/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/properjs-controller/Controller.js":
/*!********************************************************!*\
  !*** ./node_modules/properjs-controller/Controller.js ***!
  \********************************************************/
/***/ ((module, exports) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n *\n * Event / Animation cycle manager\n *\n * @Controller\n * @author: kitajchuk\n *\n *\n */\n(function (factory) {\n  if (( false ? 0 : _typeof(exports)) === \"object\" && \"object\" !== \"undefined\") {\n    module.exports = factory();\n  } else if (typeof window !== \"undefined\") {\n    window.Controller = factory();\n  }\n})(function () {\n  // Private animation functions\n  var raf = window.requestAnimationFrame,\n    caf = window.cancelAnimationFrame,\n    /**\n     *\n     * Event / Animation cycle manager\n     * @constructor Controller\n     * @requires raf\n     * @memberof! <global>\n     *\n     */\n    Controller = function Controller() {\n      return this.init.apply(this, arguments);\n    };\n  Controller.prototype = {\n    constructor: Controller,\n    /**\n     *\n     * Controller constructor method\n     * @memberof Controller\n     * @method Controller.init\n     *\n     */\n    init: function init() {\n      /**\n       *\n       * Controller event handlers object\n       * @memberof Controller\n       * @member _handlers\n       * @private\n       *\n       */\n      this._handlers = {};\n\n      /**\n       *\n       * Controller unique ID\n       * @memberof Controller\n       * @member _uid\n       * @private\n       *\n       */\n      this._uid = 0;\n\n      /**\n       *\n       * Started iteration flag\n       * @memberof Controller\n       * @member _started\n       * @private\n       *\n       */\n      this._started = false;\n\n      /**\n       *\n       * Paused flag\n       * @memberof Controller\n       * @member _paused\n       * @private\n       *\n       */\n      this._paused = false;\n\n      /**\n       *\n       * Timeout reference\n       * @memberof Controller\n       * @member _cycle\n       * @private\n       *\n       */\n      this._cycle = null;\n    },\n    /**\n     *\n     * Controller go method to start frames\n     * @memberof Controller\n     * @method go\n     *\n     */\n    go: function go(fn) {\n      if (this._started && this._cycle) {\n        return this;\n      }\n      this._started = true;\n      var self = this,\n        anim = function anim(t) {\n          self._cycle = raf(anim);\n          if (self._started) {\n            if (typeof fn === \"function\") {\n              fn(t);\n            }\n          }\n        };\n      anim();\n    },\n    /**\n     *\n     * Pause the cycle\n     * @memberof Controller\n     * @method pause\n     *\n     */\n    pause: function pause() {\n      this._paused = true;\n      return this;\n    },\n    /**\n     *\n     * Play the cycle\n     * @memberof Controller\n     * @method play\n     *\n     */\n    play: function play() {\n      this._paused = false;\n      return this;\n    },\n    /**\n     *\n     * Stop the cycle\n     * @memberof Controller\n     * @method stop\n     *\n     */\n    stop: function stop() {\n      caf(this._cycle);\n      this._paused = false;\n      this._started = false;\n      this._cycle = null;\n      return this;\n    },\n    /**\n     *\n     * Controller add event handler\n     * @memberof Controller\n     * @method on\n     * @param {string} event the event to listen for\n     * @param {function} handler the handler to call\n     *\n     */\n    on: function on(event, handler) {\n      var events = event.split(\" \");\n\n      // One unique ID per handler\n      handler._jsControllerID = this.getUID();\n      for (var i = events.length; i--;) {\n        if (typeof handler === \"function\") {\n          if (!this._handlers[events[i]]) {\n            this._handlers[events[i]] = [];\n          }\n\n          // Handler can be stored with multiple events\n          this._handlers[events[i]].push(handler);\n        }\n      }\n      return this;\n    },\n    /**\n     *\n     * Controller remove event handler\n     * @memberof Controller\n     * @method off\n     * @param {string} event the event to remove handler for\n     * @param {function} handler the handler to remove\n     *\n     */\n    off: function off(event, handler) {\n      if (!this._handlers[event]) {\n        return this;\n      }\n\n      // Remove a single handler\n      if (handler) {\n        this._off(event, handler);\n\n        // Remove all handlers for event\n      } else {\n        this._offed(event);\n      }\n      return this;\n    },\n    /**\n     *\n     * Controller fire an event\n     * @memberof Controller\n     * @method fire\n     * @param {string} event the event to fire\n     *\n     */\n    fire: function fire(event) {\n      if (!this._handlers[event]) {\n        return this;\n      }\n      var args = [].slice.call(arguments, 1);\n      for (var i = this._handlers[event].length; i--;) {\n        this._handlers[event][i].apply(this, args);\n      }\n      return this;\n    },\n    /**\n     *\n     * Get a unique ID\n     * @memberof Controller\n     * @method getUID\n     * @returns number\n     *\n     */\n    getUID: function getUID() {\n      this._uid = this._uid  1;\n      return this._uid;\n    },\n    /**\n     *\n     * Controller internal off method assumes event AND handler are good\n     * @memberof Controller\n     * @method _off\n     * @param {string} event the event to remove handler for\n     * @param {function} handler the handler to remove\n     * @private\n     *\n     */\n    _off: function _off(event, handler) {\n      for (var i = 0, len = this._handlers[event].length; i < len; i) {\n        if (handler._jsControllerID === this._handlers[event][i]._jsControllerID) {\n          this._handlers[event].splice(i, 1);\n          break;\n        }\n      }\n    },\n    /**\n     *\n     * Controller completely remove all handlers and an event type\n     * @memberof Controller\n     * @method _offed\n     * @param {string} event the event to remove handler for\n     * @private\n     *\n     */\n    _offed: function _offed(event) {\n      for (var i = this._handlers[event].length; i--;) {\n        this._handlers[event][i] = null;\n      }\n      delete this._handlers[event];\n    }\n  };\n  return Controller;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtY29udHJvbGxlci9Db250cm9sbGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVdBLE9BQU8sRUFBRztFQUVsQixJQUFLLE9BQWMsT0FBQUUsT0FBQSxDQUFQRCxPQUFPLE9BQUssUUFBUSxJQUFJLFFBQWEsS0FBSyxXQUFXLEVBQUc7SUFDaEVFLE1BQU0sQ0FBQ0YsT0FBTyxHQUFHRCxPQUFPLENBQUMsQ0FBQztFQUU5QixDQUFDLE1BQU0sSUFBSyxPQUFPSSxNQUFNLEtBQUssV0FBVyxFQUFHO0lBQ3hDQSxNQUFNLENBQUNDLFVBQVUsR0FBR0wsT0FBTyxDQUFDLENBQUM7RUFDakM7QUFFSixDQUFDLEVBQUUsWUFBWTtFQUNYO0VBQ0EsSUFBSU0sR0FBRyxHQUFHRixNQUFNLENBQUNHLHFCQUFxQjtJQUNsQ0MsR0FBRyxHQUFHSixNQUFNLENBQUNLLG9CQUFvQjtJQUdyQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ0lKLFVBQVUsR0FBRyxTQUFiQSxVQUFVQSxDQUFBLEVBQWU7TUFDckIsT0FBTyxJQUFJLENBQUNLLElBQUksQ0FBQ0MsS0FBSyxDQUFFLElBQUksRUFBRUMsU0FBVSxDQUFDO0lBQzdDLENBQUM7RUFFRFAsVUFBVSxDQUFDUSxTQUFTLEdBQUc7SUFDbkJDLFdBQVcsRUFBRVQsVUFBVTtJQUV2QjtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNRSyxJQUFJLEVBQUUsU0FBQUEsS0FBQSxFQUFZO01BQ2Q7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtNQUNZLElBQUksQ0FBQ0ssU0FBUyxHQUFHLENBQUMsQ0FBQzs7TUFFbkI7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtNQUNZLElBQUksQ0FBQ0MsSUFBSSxHQUFHLENBQUM7O01BRWI7QUFD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QTtBQUNBO0FBQ0E7SUFDUXVCLElBQUksRUFBRSxTQUFBQSxLQUFXVixLQUFLLEVBQUVDLE9BQU8sRUFBRztNQUM5QixLQUFNLElBQUlLLENBQUMsR0FBRyxDQUFDLEVBQUVVLEdBQUcsR0FBRyxJQUFJLENBQUM5QixTQUFTLENBQUVjLEtBQUssQ0FBRSxDQUFDTyxNQUFNLEVBQUVELENBQUMsR0FBR1UsR0FBRyxFQUFFVixDQUFDLEVBQUUsRUFBRztRQUNsRSxJQUFLTCxPQUFPLENBQUNHLGVBQWUsS0FBSyxJQUFJLENBQUNsQixTQUFTLENBQUVjLEtBQUssQ0FBRSxDQUFFTSxDQUFDLENBQUUsQ0FBQ0YsZUFBZSxFQUFHO1VBQzVFLElBQUksQ0FBQ2xCLFNBQVMsQ0FBRWMsS0FBSyxDQUFFLENBQUNpQixNQUFNLENBQUVYLENBQUMsRUFBRSxDQUFFLENBQUM7VUFFdEM7UUFDSjtNQUNKO0lBQ0osQ0FBQztJQUVEO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNRSyxNQUFNLEVBQUUsU0FBQUEsT0FBV1gsS0FBSyxFQUFHO01BQ3ZCLEtBQU0sSUFBSU0sQ0FBQyxHQUFHLElBQUksQ0FBQ3BCLFNBQVMsQ0FBRWMsS0FBSyxDQUFFLENBQUNPLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEdBQUk7UUFDakQsSUFBSSxDQUFDcEIsU0FBUyxDQUFFYyxLQUFLLENBQUUsQ0FBRU0sQ0FBQyxDQUFFLEdBQUcsSUFBSTtNQUN2QztNQUVBLE9BQU8sSUFBSSxDQUFDcEIsU0FBUyxDQUFFYyxLQUFLLENBQUU7SUFDbEM7RUFDSixDQUFDO0VBRUQsT0FBT3hCLFVBQVU7QUFDckIsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWNvbnRyb2xsZXIvQ29udHJvbGxlci5qcz9kNDA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqIEV2ZW50IC8gQW5pbWF0aW9uIGN5Y2xlIG1hbmFnZXJcbiAqXG4gKiBAQ29udHJvbGxlclxuICogQGF1dGhvcjoga2l0YWpjaHVrXG4gKlxuICpcbiAqL1xuKGZ1bmN0aW9uICggZmFjdG9yeSApIHtcblxuICAgIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cbiAgICB9IGVsc2UgaWYgKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICB3aW5kb3cuQ29udHJvbGxlciA9IGZhY3RvcnkoKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBQcml2YXRlIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgY2FmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEV2ZW50IC8gQW5pbWF0aW9uIGN5Y2xlIG1hbmFnZXJcbiAgICAgKiBAY29uc3RydWN0b3IgQ29udHJvbGxlclxuICAgICAqIEByZXF1aXJlcyByYWZcbiAgICAgKiBAbWVtYmVyb2YhIDxnbG9iYWwXG4gICAgICpcbiAgICAgKi9cbiAgICBDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBDb250cm9sbGVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb250cm9sbGVyIGNvbnN0cnVjdG9yIG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29udHJvbGxlclxuICAgICAgICAgKiBAbWV0aG9kIENvbnRyb2xsZXIuaW5pdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQ29udHJvbGxlciBldmVudCBoYW5kbGVycyBvYmplY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDb250cm9sbGVyXG4gICAgICAgICAgICAgKiBAbWVtYmVyIF9oYW5kbGVyc1xuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIENvbnRyb2xsZXIgdW5pcXVlIElEXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ29udHJvbGxlclxuICAgICAgICAgICAgICogQG1lbWJlciBfdWlkXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fdWlkID0gMDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU3RhcnRlZCBpdGVyYXRpb24gZmxhZ1xuICAgICAgICAgICAgICogQG1lbWJlcm9mIENvbnRyb2xsZXJcbiAgICAgICAgICAgICAqIEBtZW1iZXIgX3N0YXJ0ZWRcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFBhdXNlZCBmbGFnXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ29udHJvbGxlclxuICAgICAgICAgICAgICogQG1lbWJlciBfcGF1c2VkXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRpbWVvdXQgcmVmZXJlbmNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ29udHJvbGxlclxuICAgICAgICAgICAgICogQG1lbWJlciBfY3ljbGVcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9jeWNsZSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnRyb2xsZXIgZ28gbWV0aG9kIHRvIHN0YXJ0IGZyYW1lc1xuICAgICAgICAgKiBAbWVtYmVyb2YgQ29udHJvbGxlclxuICAgICAgICAgKiBAbWV0aG9kIGdvXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBnbzogZnVuY3Rpb24gKCBmbiApIHtcbiAgICAgICAgICAgIGlmICggdGhpcy5fc3RhcnRlZCAmJiB0aGlzLl9jeWNsZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhbmltID0gZnVuY3Rpb24gKCB0ICkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jeWNsZSA9IHJhZiggYW5pbSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VsZi5fc3RhcnRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4oIHQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFuaW0oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogUGF1c2UgdGhlIGN5Y2xlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb250cm9sbGVyXG4gICAgICAgICAqIEBtZXRob2QgcGF1c2VcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogUGxheSB0aGUgY3ljbGVcbiAgICAgICAgICogQG1lbWJlcm9mIENvbnRyb2xsZXJcbiAgICAgICAgICogQG1ldGhvZCBwbGF5XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwbGF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFN0b3AgdGhlIGN5Y2xlXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb250cm9sbGVyXG4gICAgICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FmKCB0aGlzLl9jeWNsZSApO1xuXG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlID0gbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnRyb2xsZXIgYWRkIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICogQG1lbWJlcm9mIENvbnRyb2xsZXJcbiAgICAgICAgICogQG1ldGhvZCBvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciB0aGUgaGFuZGxlciB0byBjYWxsXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24gKCBldmVudCwgaGFuZGxlciApIHtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSBldmVudC5zcGxpdCggXCIgXCIgKTtcblxuICAgICAgICAgICAgLy8gT25lIHVuaXF1ZSBJRCBwZXIgaGFuZGxlclxuICAgICAgICAgICAgaGFuZGxlci5fanNDb250cm9sbGVySUQgPSB0aGlzLmdldFVJRCgpO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IGV2ZW50cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICF0aGlzLl9oYW5kbGVyc1sgZXZlbnRzWyBpIF0gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzWyBldmVudHNbIGkgXSBdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGVyIGNhbiBiZSBzdG9yZWQgd2l0aCBtdWx0aXBsZSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbIGV2ZW50c1sgaSBdIF0ucHVzaCggaGFuZGxlciApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnRyb2xsZXIgcmVtb3ZlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICogQG1lbWJlcm9mIENvbnRyb2xsZXJcbiAgICAgICAgICogQG1ldGhvZCBvZmZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IHRoZSBldmVudCB0byByZW1vdmUgaGFuZGxlciBmb3JcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciB0aGUgaGFuZGxlciB0byByZW1vdmVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIG9mZjogZnVuY3Rpb24gKCBldmVudCwgaGFuZGxlciApIHtcbiAgICAgICAgICAgIGlmICggIXRoaXMuX2hhbmRsZXJzWyBldmVudCBdICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYSBzaW5nbGUgaGFuZGxlclxuICAgICAgICAgICAgaWYgKCBoYW5kbGVyICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZiggZXZlbnQsIGhhbmRsZXIgKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBoYW5kbGVycyBmb3IgZXZlbnRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2ZmZWQoIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb250cm9sbGVyIGZpcmUgYW4gZXZlbnRcbiAgICAgICAgICogQG1lbWJlcm9mIENvbnRyb2xsZXJcbiAgICAgICAgICogQG1ldGhvZCBmaXJlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCB0aGUgZXZlbnQgdG8gZmlyZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZmlyZTogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgICAgIGlmICggIXRoaXMuX2hhbmRsZXJzWyBldmVudCBdICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHRoaXMuX2hhbmRsZXJzWyBldmVudCBdLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXVsgaSBdLmFwcGx5KCB0aGlzLCBhcmdzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXQgYSB1bmlxdWUgSURcbiAgICAgICAgICogQG1lbWJlcm9mIENvbnRyb2xsZXJcbiAgICAgICAgICogQG1ldGhvZCBnZXRVSURcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRVSUQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VpZCA9ICh0aGlzLl91aWQgKyAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VpZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQ29udHJvbGxlciBpbnRlcm5hbCBvZmYgbWV0aG9kIGFzc3VtZXMgZXZlbnQgQU5EIGhhbmRsZXIgYXJlIGdvb2RcbiAgICAgICAgICogQG1lbWJlcm9mIENvbnRyb2xsZXJcbiAgICAgICAgICogQG1ldGhvZCBfb2ZmXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCB0aGUgZXZlbnQgdG8gcmVtb3ZlIGhhbmRsZXIgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgdGhlIGhhbmRsZXIgdG8gcmVtb3ZlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBfb2ZmOiBmdW5jdGlvbiAoIGV2ZW50LCBoYW5kbGVyICkge1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXS5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZXIuX2pzQ29udHJvbGxlcklEID09PSB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXVsgaSBdLl9qc0NvbnRyb2xsZXJJRCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbIGV2ZW50IF0uc3BsaWNlKCBpLCAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb250cm9sbGVyIGNvbXBsZXRlbHkgcmVtb3ZlIGFsbCBoYW5kbGVycyBhbmQgYW4gZXZlbnQgdHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29udHJvbGxlclxuICAgICAgICAgKiBAbWV0aG9kIF9vZmZlZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgdGhlIGV2ZW50IHRvIHJlbW92ZSBoYW5kbGVyIGZvclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgX29mZmVkOiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXS5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbIGV2ZW50IF1bIGkgXSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ29udHJvbGxlcjtcbn0pO1xuIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJleHBvcnRzIiwiX3R5cGVvZiIsIm1vZHVsZSIsIndpbmRvdyIsIkNvbnRyb2xsZXIiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYWYiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImluaXQiLCJhcHBseSIsImFyZ3VtZW50cyIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwiX2hhbmRsZXJzIiwiX3VpZCIsIl9zdGFydGVkIiwiX3BhdXNlZCIsIl9jeWNsZSIsImdvIiwiZm4iLCJzZWxmIiwiYW5pbSIsInQiLCJwYXVzZSIsInBsYXkiLCJzdG9wIiwib24iLCJldmVudCIsImhhbmRsZXIiLCJldmVudHMiLCJzcGxpdCIsIl9qc0NvbnRyb2xsZXJJRCIsImdldFVJRCIsImkiLCJsZW5ndGgiLCJwdXNoIiwib2ZmIiwiX29mZiIsIl9vZmZlZCIsImZpcmUiLCJhcmdzIiwic2xpY2UiLCJjYWxsIiwibGVuIiwic3BsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-controller/Controller.js\n");

/***/ }),

/***/ "./node_modules/properjs-debounce/debounce.js":
/*!****************************************************!*\
  !*** ./node_modules/properjs-debounce/debounce.js ***!
  \****************************************************/
/***/ ((module, exports) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n *\n * Debounce methods\n * Sourced from here:\n * http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n *\n * @debounce\n * @author: kitajchuk\n *\n */\n(function (factory) {\n  if (( false ? 0 : _typeof(exports)) === \"object\" && \"object\" !== \"undefined\") {\n    module.exports = factory();\n  } else if (typeof window !== \"undefined\") {\n    window.debounce = factory();\n  }\n})(function () {\n  /**\n   *\n   * Limit method calls\n   * @memberof! <global>\n   * @method debounce\n   * @param {function} callback The method handler\n   * @param {number} threshold The timeout delay in ms\n   * @param {boolean} execAsap Call function at beginning or end of detection period\n   *\n   */\n  var debounce = function debounce(callback, threshold, execAsap) {\n    var timeout = null;\n    return function debounced() {\n      var args = arguments,\n        context = this;\n      function delayed() {\n        if (!execAsap) {\n          callback.apply(context, args);\n        }\n        timeout = null;\n      }\n      if (timeout) {\n        clearTimeout(timeout);\n      } else if (execAsap) {\n        callback.apply(context, args);\n      }\n      timeout = setTimeout(delayed, threshold || 100);\n    };\n  };\n  return debounce;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtZGVib3VuY2UvZGVib3VuY2UuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxVQUFXQSxPQUFPLEVBQUc7RUFFbEIsSUFBSyxPQUFjLE9BQUFFLE9BQUEsQ0FBUEQsT0FBTyxPQUFLLFFBQVEsSUFBSSxRQUFhLEtBQUssV0FBVyxFQUFHO0lBQ2hFRSxNQUFNLENBQUNGLE9BQU8sR0FBR0QsT0FBTyxDQUFDLENBQUM7RUFFOUIsQ0FBQyxNQUFNLElBQUssT0FBT0ksTUFBTSxLQUFLLFdBQVcsRUFBRztJQUN4Q0EsTUFBTSxDQUFDQyxRQUFRLEdBQUdMLE9BQU8sQ0FBQyxDQUFDO0VBQy9CO0FBRUosQ0FBQyxFQUFFLFlBQVk7RUFHWDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLElBQUlLLFFBQVEsR0FBRyxTQUFYQSxRQUFRQSxDQUFjQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUFHO0lBQ3RELElBQUlDLE9BQU8sR0FBRyxJQUFJO0lBRWxCLE9BQU8sU0FBU0MsU0FBU0EsQ0FBQSxFQUFHO01BQ3hCLElBQUlDLElBQUksR0FBR0MsU0FBUztRQUNoQkMsT0FBTyxHQUFHLElBQUk7TUFFbEIsU0FBU0MsT0FBT0EsQ0FBQSxFQUFHO1FBQ2YsSUFBSyxDQUFDTixRQUFRLEVBQUc7VUFDYkYsUUFBUSxDQUFDUyxLQUFLLENBQUVGLE9BQU8sRUFBRUYsSUFBSyxDQUFDO1FBQ25DO1FBRUFGLE9BQU8sR0FBRyxJQUFJO01BQ2xCO01BRUEsSUFBS0EsT0FBTyxFQUFHO1FBQ1hPLFlBQVksQ0FBRVAsT0FBUSxDQUFDO01BRTNCLENBQUMsTUFBTSxJQUFLRCxRQUFRLEVBQUc7UUFDbkJGLFFBQVEsQ0FBQ1MsS0FBSyxDQUFFRixPQUFPLEVBQUVGLElBQUssQ0FBQztNQUNuQztNQUVBRixPQUFPLEdBQUdRLFVBQVUsQ0FBRUgsT0FBTyxFQUFHUCxTQUFTLElBQUksR0FBSyxDQUFDO0lBQ3ZELENBQUM7RUFDTCxDQUFDO0VBR0QsT0FBT0YsUUFBUTtBQUduQixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtZGVib3VuY2UvZGVib3VuY2UuanM/ZTlmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqXG4gKiBEZWJvdW5jZSBtZXRob2RzXG4gKiBTb3VyY2VkIGZyb20gaGVyZTpcbiAqIGh0dHA6Ly91bnNjcmlwdGFibGUuY29tLzIwMDkvMDMvMjAvZGVib3VuY2luZy1qYXZhc2NyaXB0LW1ldGhvZHMvXG4gKlxuICogQGRlYm91bmNlXG4gKiBAYXV0aG9yOiBraXRhamNodWtcbiAqXG4gKi9cbihmdW5jdGlvbiAoIGZhY3RvcnkgKSB7XG4gICAgXG4gICAgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblxuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgIHdpbmRvdy5kZWJvdW5jZSA9IGZhY3RvcnkoKTtcbiAgICB9XG4gICAgXG59KShmdW5jdGlvbiAoKSB7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTGltaXQgbWV0aG9kIGNhbGxzXG4gICAgICogQG1lbWJlcm9mISA8Z2xvYmFsPlxuICAgICAqIEBtZXRob2QgZGVib3VuY2VcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgbWV0aG9kIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIFRoZSB0aW1lb3V0IGRlbGF5IGluIG1zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBleGVjQXNhcCBDYWxsIGZ1bmN0aW9uIGF0IGJlZ2lubmluZyBvciBlbmQgb2YgZGV0ZWN0aW9uIHBlcmlvZFxuICAgICAqXG4gICAgICovXG4gICAgdmFyIGRlYm91bmNlID0gZnVuY3Rpb24gKCBjYWxsYmFjaywgdGhyZXNob2xkLCBleGVjQXNhcCApIHtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBkZWxheWVkKCkge1xuICAgICAgICAgICAgICAgIGlmICggIWV4ZWNBc2FwICkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSggY29udGV4dCwgYXJncyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCB0aW1lb3V0ICkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGltZW91dCApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmICggZXhlY0FzYXAgKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoIGNvbnRleHQsIGFyZ3MgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoIGRlbGF5ZWQsICh0aHJlc2hvbGQgfHwgMTAwKSApO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgXG4gICAgXG4gICAgcmV0dXJuIGRlYm91bmNlO1xuXG5cbn0pOyJdLCJuYW1lcyI6WyJmYWN0b3J5IiwiZXhwb3J0cyIsIl90eXBlb2YiLCJtb2R1bGUiLCJ3aW5kb3ciLCJkZWJvdW5jZSIsImNhbGxiYWNrIiwidGhyZXNob2xkIiwiZXhlY0FzYXAiLCJ0aW1lb3V0IiwiZGVib3VuY2VkIiwiYXJncyIsImFyZ3VtZW50cyIsImNvbnRleHQiLCJkZWxheWVkIiwiYXBwbHkiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-debounce/debounce.js\n");

/***/ }),

/***/ "./node_modules/properjs-easing/Easing.js":
/*!************************************************!*\
  !*** ./node_modules/properjs-easing/Easing.js ***!
  \************************************************/
/***/ ((module, exports) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n *\n * A base set of easing methods\n * Most of which were found here:\n * https://gist.github.com/gre/1650294\n *\n * @Easing\n * @author: kitajchuk\n *\n */\n(function (factory) {\n  if (( false ? 0 : _typeof(exports)) === \"object\" && \"object\" !== \"undefined\") {\n    module.exports = factory();\n  } else if (typeof window !== \"undefined\") {\n    window.Easing = factory();\n  }\n})(function () {\n  /**\n   *\n   * Easing functions\n   * @namespace Easing\n   * @memberof! <global>\n   *\n   */\n  var Easing = {\n    /**\n     *\n     * Produce a linear ease\n     * @method linear\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    linear: function linear(t) {\n      return t;\n    },\n    /**\n     *\n     * Produce a swing ease like in jQuery\n     * @method swing\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    swing: function swing(t) {\n      return (1 - Math.cos(t * Math.PI)) / 2;\n    },\n    /**\n     *\n     * Accelerating from zero velocity\n     * @method easeInQuad\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeInQuad: function easeInQuad(t) {\n      return t * t;\n    },\n    /**\n     *\n     * Decelerating to zero velocity\n     * @method easeOutQuad\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeOutQuad: function easeOutQuad(t) {\n      return t * (2 - t);\n    },\n    /**\n     *\n     * Acceleration until halfway, then deceleration\n     * @method easeInOutQuad\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeInOutQuad: function easeInOutQuad(t) {\n      return t < 0.5 ? 2 * t * t : -1  (4 - 2 * t) * t;\n    },\n    /**\n     *\n     * Accelerating from zero velocity\n     * @method easeInCubic\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeInCubic: function easeInCubic(t) {\n      return t * t * t;\n    },\n    /**\n     *\n     * Decelerating to zero velocity\n     * @method easeOutCubic\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeOutCubic: function easeOutCubic(t) {\n      return --t * t * t  1;\n    },\n    /**\n     *\n     * Acceleration until halfway, then deceleration\n     * @method easeInOutCubic\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeInOutCubic: function easeInOutCubic(t) {\n      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2)  1;\n    },\n    /**\n     *\n     * Accelerating from zero velocity\n     * @method easeInQuart\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeInQuart: function easeInQuart(t) {\n      return t * t * t * t;\n    },\n    /**\n     *\n     * Decelerating to zero velocity\n     * @method easeOutQuart\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeOutQuart: function easeOutQuart(t) {\n      return 1 - --t * t * t * t;\n    },\n    /**\n     *\n     * Acceleration until halfway, then deceleration\n     * @method easeInOutQuart\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeInOutQuart: function easeInOutQuart(t) {\n      return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n    },\n    /**\n     *\n     * Accelerating from zero velocity\n     * @method easeInQuint\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeInQuint: function easeInQuint(t) {\n      return t * t * t * t * t;\n    },\n    /**\n     *\n     * Decelerating to zero velocity\n     * @method easeOutQuint\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeOutQuint: function easeOutQuint(t) {\n      return 1  --t * t * t * t * t;\n    },\n    /**\n     *\n     * Acceleration until halfway, then deceleration\n     * @method easeInOutQuint\n     * @param {number} t Difference in time\n     * @memberof Easing\n     * @returns a new t value\n     *\n     */\n    easeInOutQuint: function easeInOutQuint(t) {\n      return t < 0.5 ? 16 * t * t * t * t * t : 1  16 * --t * t * t * t * t;\n    }\n  };\n  return Easing;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtZWFzaW5nL0Vhc2luZy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVdBLE9BQU8sRUFBRztFQUVsQixJQUFLLE9BQWMsT0FBQUUsT0FBQSxDQUFQRCxPQUFPLE9BQUssUUFBUSxJQUFJLFFBQWEsS0FBSyxXQUFXLEVBQUc7SUFDaEVFLE1BQU0sQ0FBQ0YsT0FBTyxHQUFHRCxPQUFPLENBQUMsQ0FBQztFQUU5QixDQUFDLE1BQU0sSUFBSyxPQUFPSSxNQUFNLEtBQUssV0FBVyxFQUFHO0lBQ3hDQSxNQUFNLENBQUNDLE1BQU0sR0FBR0wsT0FBTyxDQUFDLENBQUM7RUFDN0I7QUFFSixDQUFDLEVBQUUsWUFBWTtFQUVYO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSUssTUFBTSxHQUFHO0lBQ1Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ1FDLE1BQU0sRUFBRSxTQUFBQSxPQUFXQyxDQUFDLEVBQUc7TUFBRSxPQUFPQSxDQUFDO0lBQUUsQ0FBQztJQUVwQztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDUUMsS0FBSyxFQUFFLFNBQUFBLE1BQVdELENBQUMsRUFBRztNQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUNFLElBQUksQ0FBQ0MsR0FBRyxDQUFFSCxDQUFDLEdBQUNFLElBQUksQ0FBQ0UsRUFBRyxDQUFDLElBQUUsQ0FBQztJQUFFLENBQUM7SUFFN0Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ1FDLFVBQVUsRUFBRSxTQUFBQSxXQUFXTCxDQUFDLEVBQUc7TUFBRSxPQUFPQSxDQUFDLEdBQUNBLENBQUM7SUFBRSxDQUFDO0lBRTFDO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDLEVBQUc7TUFBRSxPQUFPQSxDQUFDLEdBQUMsR0FBRyxHQUFHLEVBQUUsR0FBQ0EsQ0FBQyxHQUFDQSxDQUFDLEdBQUNBLENBQUMsR0FBQ0EsQ0FBQyxHQUFDQSxDQUFDLEdBQUcsQ0FBQyxHQUFDLEVBQUUsR0FBRSxFQUFFQSxDQUFFLEdBQUNBLENBQUMsR0FBQ0EsQ0FBQyxHQUFDQSxDQUFDLEdBQUNBLENBQUM7SUFBRTtFQUN2RixDQUFDO0VBR0QsT0FBT0YsTUFBTTtBQUdqQixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtZWFzaW5nL0Vhc2luZy5qcz9hM2EwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqIEEgYmFzZSBzZXQgb2YgZWFzaW5nIG1ldGhvZHNcbiAqIE1vc3Qgb2Ygd2hpY2ggd2VyZSBmb3VuZCBoZXJlOlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcbiAqXG4gKiBARWFzaW5nXG4gKiBAYXV0aG9yOiBraXRhamNodWtcbiAqXG4gKi9cbihmdW5jdGlvbiAoIGZhY3RvcnkgKSB7XG4gICAgXG4gICAgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblxuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgIHdpbmRvdy5FYXNpbmcgPSBmYWN0b3J5KCk7XG4gICAgfVxuICAgIFxufSkoZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFYXNpbmcgZnVuY3Rpb25zXG4gICAgICogQG5hbWVzcGFjZSBFYXNpbmdcbiAgICAgKiBAbWVtYmVyb2YhIDxnbG9iYWwXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgRWFzaW5nID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogUHJvZHVjZSBhIGxpbmVhciBlYXNlXG4gICAgICAgICAqIEBtZXRob2QgbGluZWFyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAgICAgKiBAbWVtYmVyb2YgRWFzaW5nXG4gICAgICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKCB0ICkgeyByZXR1cm4gdDsgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBQcm9kdWNlIGEgc3dpbmcgZWFzZSBsaWtlIGluIGpRdWVyeVxuICAgICAgICAgKiBAbWV0aG9kIHN3aW5nXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAgICAgKiBAbWVtYmVyb2YgRWFzaW5nXG4gICAgICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHN3aW5nOiBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiAoMS1NYXRoLmNvcyggdCpNYXRoLlBJICkpLzI7IH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAgICAgKiBAbWV0aG9kIGVhc2VJblF1YWRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBFYXNpbmdcbiAgICAgICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZWFzZUluUXVhZDogZnVuY3Rpb24gKCB0ICkgeyByZXR1cm4gdCp0OyB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIERlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgICAqIEBtZXRob2QgZWFzZU91dFF1YWRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBFYXNpbmdcbiAgICAgICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICggdCApIHsgcmV0dXJuIHQqKDItdCk7IH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICAgICAqIEBtZXRob2QgZWFzZUluT3V0UXVhZFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgICAgICogQG1lbWJlcm9mIEVhc2luZ1xuICAgICAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiB0PDAuNSA/IDIqdCp0IDogLTErKDQtMip0KSp0OyB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICAgICAgICogQG1ldGhvZCBlYXNlSW5DdWJpY1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgICAgICogQG1lbWJlcm9mIEVhc2luZ1xuICAgICAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gKCB0ICkgeyByZXR1cm4gdCp0KnQ7IH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogRGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgICAgICogQG1ldGhvZCBlYXNlT3V0Q3ViaWNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBFYXNpbmdcbiAgICAgICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiAoLS10KSp0KnQrMTsgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBBY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgICAgICogQG1ldGhvZCBlYXNlSW5PdXRDdWJpY1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgICAgICogQG1lbWJlcm9mIEVhc2luZ1xuICAgICAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gKCB0ICkgeyByZXR1cm4gdDwwLjUgPyA0KnQqdCp0IDogKHQtMSkqKDIqdC0yKSooMip0LTIpKzE7IH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAgICAgKiBAbWV0aG9kIGVhc2VJblF1YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAgICAgKiBAbWVtYmVyb2YgRWFzaW5nXG4gICAgICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiB0KnQqdCp0OyB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIERlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgICAqIEBtZXRob2QgZWFzZU91dFF1YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAgICAgKiBAbWVtYmVyb2YgRWFzaW5nXG4gICAgICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKCB0ICkgeyByZXR1cm4gMS0oLS10KSp0KnQqdDsgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBBY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgICAgICogQG1ldGhvZCBlYXNlSW5PdXRRdWFydFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgICAgICogQG1lbWJlcm9mIEVhc2luZ1xuICAgICAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKCB0ICkgeyByZXR1cm4gdDwwLjUgPyA4KnQqdCp0KnQgOiAxLTgqKC0tdCkqdCp0KnQ7IH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAgICAgKiBAbWV0aG9kIGVhc2VJblF1aW50XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAgICAgKiBAbWVtYmVyb2YgRWFzaW5nXG4gICAgICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGVhc2VJblF1aW50OiBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiB0KnQqdCp0KnQ7IH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogRGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgICAgICogQG1ldGhvZCBlYXNlT3V0UXVpbnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBFYXNpbmdcbiAgICAgICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZWFzZU91dFF1aW50OiBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiAxKygtLXQpKnQqdCp0KnQ7IH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICAgICAqIEBtZXRob2QgZWFzZUluT3V0UXVpbnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBFYXNpbmdcbiAgICAgICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICggdCApIHsgcmV0dXJuIHQ8MC41ID8gMTYqdCp0KnQqdCp0IDogMSsxNiooLS10KSp0KnQqdCp0OyB9XG4gICAgfTtcbiAgICBcbiAgICBcbiAgICByZXR1cm4gRWFzaW5nO1xuXG5cbn0pOyJdLCJuYW1lcyI6WyJmYWN0b3J5IiwiZXhwb3J0cyIsIl90eXBlb2YiLCJtb2R1bGUiLCJ3aW5kb3ciLCJFYXNpbmciLCJsaW5lYXIiLCJ0Iiwic3dpbmciLCJNYXRoIiwiY29zIiwiUEkiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-easing/Easing.js\n");

/***/ }),

/***/ "./node_modules/properjs-historia/Historia.js":
/*!****************************************************!*\
  !*** ./node_modules/properjs-historia/Historia.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Historia)\n/* harmony export */ });\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-historia/node_modules/properjs-controller/Controller.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar pushable = \"history\" in window && \"pushState\" in window.history;\nvar hashable = (\"onhashchange\" in window);\nvar Historia = /*#__PURE__*/function (_Controller) {\n  _inherits(Historia, _Controller);\n  var _super = _createSuper(Historia);\n  function Historia(options) {\n    var _this;\n    _classCallCheck(this, Historia);\n    _this = _super.call(this);\n    _this._initUrl = window.location.href.replace(window.location.hash, \"\");\n    _this._options = options || {};\n    _this._enabled = false;\n    _this._ishashpushed = false;\n    _this._states = {};\n    _this._callbacks = {};\n    _this._states[_this._initUrl] = {\n      uid: _this.uid() // Controller method\n    };\n\n    _this._stateEnable();\n    return _this;\n  }\n  _createClass(Historia, [{\n    key: \"push\",\n    value: function push(url) {\n      if (url === window.location.href) {\n        return;\n      }\n      this._push(url);\n      this._states[url] = {\n        uid: this.uid()\n      };\n    }\n  }, {\n    key: \"goBack\",\n    value: function goBack() {\n      window.history.back();\n      this.fire(\"backstate\");\n    }\n  }, {\n    key: \"goForward\",\n    value: function goForward() {\n      window.history.forward();\n      this.fire(\"forwardstate\");\n    }\n  }, {\n    key: \"_push\",\n    value: function _push(url) {\n      if (pushable && !this._options.forceHash) {\n        window.history.pushState(this._states[url], \"\", url);\n      } else {\n        // This replace ensures we get the following:\n        // \"/\":         root\n        // \"/foo/bar/\": uri path\n        var hashUri = url.replace(window.location.origin, \"\");\n\n        // Fix for root hash uri.\n        // Ensure we dont get the following:\n        // \"/foo/bar/#/foo/bar/\"\n        // Rather we would get the following:\n        // \"/foo/bar/#/\"\n        if (hashUri === window.location.pathname) {\n          hashUri = \"/\";\n        }\n        this._ishashpushed = true;\n        window.location.hash = hashUri;\n      }\n    }\n  }, {\n    key: \"_stateEnable\",\n    value: function _stateEnable() {\n      var _this2 = this;\n      if (this._enabled) {\n        return this;\n      }\n      this._enabled = true;\n      var handler = function handler() {\n        var url = window.location.href;\n        var roots = [\"#/\", \"#\", \"\"];\n\n        // Ensure we clean out the hash for Router\n        // Example:\n        // Start:  http://localhost/foo/#/bar/\n        // Result: http://localhost/foo/bar/\n        if (_this2._options.forceHash) {\n          // Shave the hash from the end of the URL\n          url = url.replace(window.location.hash, \"\");\n\n          // Shave the hash root from the end of the URL\n          url = url.replace(window.location.pathname, \"\");\n\n          // Empty hash means we have gone back to root\n          if (roots.indexOf(window.location.hash) !== -1) {\n            // Append the hash root to the URL\n            url = url  window.location.pathname;\n          } else {\n            // Append the applied hash pathname to the URL\n            url = url  window.location.hash.replace(\"#\", \"\");\n          }\n        }\n        _this2.fire(\"popstate\", url, _this2._states[url]);\n      };\n      if (pushable && !this._options.forceHash) {\n        window.addEventListener(\"popstate\", function () {\n          handler();\n        }, false);\n      } else if (hashable) {\n        // For hashstate we should apply initial hash on page load\n        this._push(this._initUrl);\n        window.addEventListener(\"hashchange\", function () {\n          if (!_this2._ishashpushed) {\n            handler();\n          } else {\n            _this2._ishashpushed = false;\n          }\n        }, false);\n      }\n    }\n  }]);\n  return Historia;\n}(properjs_controller__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaGlzdG9yaWEvSGlzdG9yaWEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBSTdDLElBQU1DLFFBQVEsR0FBSSxTQUFTLElBQUlDLE1BQU0sSUFBSSxXQUFXLElBQUlBLE1BQU0sQ0FBQ0MsT0FBUTtBQUN2RSxJQUFNQyxRQUFRLElBQUksY0FBYyxJQUFJRixNQUFNLENBQUM7QUFBQyxJQUl2QkcsUUFBUSwwQkFBQUMsV0FBQTtFQUFBQyxTQUFBLENBQUFGLFFBQUEsRUFBQUMsV0FBQTtFQUFBLElBQUFFLE1BQUEsR0FBQUMsWUFBQSxDQUFBSixRQUFBO0VBQ3pCLFNBQUFBLFNBQWNLLE9BQU8sRUFBRztJQUFBLElBQUFDLEtBQUE7SUFBQUMsZUFBQSxPQUFBUCxRQUFBO0lBQ3BCTSxLQUFBLEdBQUFILE1BQUEsQ0FBQUssSUFBQTtJQUVBRixLQUFBLENBQUtHLFFBQVEsR0FBR1osTUFBTSxDQUFDYSxRQUFRLENBQUNDLElBQUksQ0FBQ0MsT0FBTyxDQUFFZixNQUFNLENBQUNhLFFBQVEsQ0FBQ0csSUFBSSxFQUFFLEVBQUcsQ0FBQztJQUN4RVAsS0FBQSxDQUFLUSxRQUFRLEdBQUlULE9BQU8sSUFBSSxDQUFDLENBQUU7SUFDL0JDLEtBQUEsQ0FBS1MsUUFBUSxHQUFHLEtBQUs7SUFDckJULEtBQUEsQ0FBS1UsYUFBYSxHQUFHLEtBQUs7SUFDMUJWLEtBQUEsQ0FBS1csT0FBTyxHQUFHLENBQUMsQ0FBQztJQUNqQlgsS0FBQSxDQUFLWSxVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBQ3BCWixLQUFBLENBQUtXLE9BQU8sQ0FBRVgsS0FBQSxDQUFLRyxRQUFRLENBQUUsR0FBRztNQUM1QlUsR0FBRyxFQUFFYixLQUFBLENBQUthLEdBQUcsQ0FBQyxDQUFDLENBQUU7SUFDckIsQ0FBQzs7SUFFRGIsS0FBQSxDQUFLYyxZQUFZLENBQUMsQ0FBQztJQUFDLE9BQUFkLEtBQUE7RUFDeEI7RUFBQ2UsWUFB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R0FBRyxHQUFJQSxHQUFHLEdBQUc1QixNQUFNLENBQUNhLFFBQVEsQ0FBQ0csSUFBSSxDQUFDRCxPQUFPLENBQUUsR0FBRyxFQUFFLEVBQUcsQ0FBRTtVQUN6RDtRQUNKO1FBRUF5QixNQUFJLENBQUNSLElBQUksQ0FBRSxVQUFVLEVBQUVKLEdBQUcsRUFBRVksTUFBSSxDQUFDcEIsT0FBTyxDQUFFUSxHQUFHLENBQUcsQ0FBQztNQUNyRCxDQUFDO01BRUQsSUFBSzdCLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQ2tCLFFBQVEsQ0FBQ2tCLFNBQVMsRUFBRztRQUN4Q25DLE1BQU0sQ0FBQzRDLGdCQUFnQixDQUFFLFVBQVUsRUFBRSxZQUFNO1VBQ3ZDSCxPQUFPLENBQUMsQ0FBQztRQUViLENBQUMsRUFBRSxLQUFNLENBQUM7TUFFZCxDQUFDLE1BQU0sSUFBS3ZDLFFBQVEsRUFBRztRQUNuQjtRQUNBLElBQUksQ0FBQzJCLEtBQUssQ0FBRSxJQUFJLENBQUNqQixRQUFTLENBQUM7UUFFM0JaLE1BQU0sQ0FBQzRDLGdCQUFnQixDQUFFLFlBQVksRUFBRSxZQUFNO1VBQ3pDLElBQUssQ0FBQ0osTUFBSSxDQUFDckIsYUFBYSxFQUFHO1lBQ3ZCc0IsT0FBTyxDQUFDLENBQUM7VUFFYixDQUFDLE1BQU07WUFDSEQsTUFBSSxDQUFDckIsYUFBYSxHQUFHLEtBQUs7VUFDOUI7UUFFSixDQUFDLEVBQUUsS0FBTSxDQUFDO01BQ2Q7SUFDSjtFQUFDO0VBQUEsT0FBQWhCLFFBQUE7QUFBQSxFQS9IaUNMLDJEQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWhpc3RvcmlhL0hpc3RvcmlhLmpzPzkyNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbnRyb2xsZXIgZnJvbSBcInByb3BlcmpzLWNvbnRyb2xsZXJcIjtcblxuXG5cbmNvbnN0IHB1c2hhYmxlID0gKFwiaGlzdG9yeVwiIGluIHdpbmRvdyAmJiBcInB1c2hTdGF0ZVwiIGluIHdpbmRvdy5oaXN0b3J5KTtcbmNvbnN0IGhhc2hhYmxlID0gKFwib25oYXNoY2hhbmdlXCIgaW4gd2luZG93KTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpc3RvcmlhIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IgKCBvcHRpb25zICkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX2luaXRVcmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5yZXBsYWNlKCB3aW5kb3cubG9jYXRpb24uaGFzaCwgXCJcIiApO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gKG9wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzaGFzaHB1c2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgICAgIHRoaXMuX3N0YXRlc1sgdGhpcy5faW5pdFVybCBdID0ge1xuICAgICAgICAgICAgdWlkOiB0aGlzLnVpZCgpLCAvLyBDb250cm9sbGVyIG1ldGhvZFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3N0YXRlRW5hYmxlKCk7XG4gICAgfVxuXG5cbiAgICBwdXNoICggdXJsICkge1xuICAgICAgICBpZiAoIHVybCA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wdXNoKCB1cmwgKTtcblxuICAgICAgICB0aGlzLl9zdGF0ZXNbIHVybCBdID0ge1xuICAgICAgICAgICAgdWlkOiB0aGlzLnVpZCgpLFxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZ29CYWNrICgpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuXG4gICAgICAgIHRoaXMuZmlyZSggXCJiYWNrc3RhdGVcIiApO1xuICAgIH1cblxuXG4gICAgZ29Gb3J3YXJkICgpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpO1xuXG4gICAgICAgIHRoaXMuZmlyZSggXCJmb3J3YXJkc3RhdGVcIiApO1xuICAgIH1cblxuXG4gICAgX3B1c2ggKCB1cmwgKSB7XG4gICAgICAgIGlmICggcHVzaGFibGUgJiYgIXRoaXMuX29wdGlvbnMuZm9yY2VIYXNoICkge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKCB0aGlzLl9zdGF0ZXNbIHVybCBdLCBcIlwiLCB1cmwgKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyByZXBsYWNlIGVuc3VyZXMgd2UgZ2V0IHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICAvLyBcIi9cIjogICAgICAgICByb290XG4gICAgICAgICAgICAvLyBcIi9mb28vYmFyL1wiOiB1cmkgcGF0aFxuICAgICAgICAgICAgbGV0IGhhc2hVcmkgPSB1cmwucmVwbGFjZSggd2luZG93LmxvY2F0aW9uLm9yaWdpbiwgXCJcIiApO1xuXG4gICAgICAgICAgICAvLyBGaXggZm9yIHJvb3QgaGFzaCB1cmkuXG4gICAgICAgICAgICAvLyBFbnN1cmUgd2UgZG9udCBnZXQgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICAgIC8vIFwiL2Zvby9iYXIvIy9mb28vYmFyL1wiXG4gICAgICAgICAgICAvLyBSYXRoZXIgd2Ugd291bGQgZ2V0IHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICAvLyBcIi9mb28vYmFyLyMvXCJcbiAgICAgICAgICAgIGlmICggaGFzaFVyaSA9PT0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICkge1xuICAgICAgICAgICAgICAgIGhhc2hVcmkgPSBcIi9cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faXNoYXNocHVzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoVXJpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBfc3RhdGVFbmFibGUgKCkge1xuICAgICAgICBpZiAoIHRoaXMuX2VuYWJsZWQgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgICAgICBjb25zdCByb290cyA9IFtcIiMvXCIsIFwiI1wiLCBcIlwiXTtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGNsZWFuIG91dCB0aGUgaGFzaCBmb3IgUm91dGVyXG4gICAgICAgICAgICAvLyBFeGFtcGxlOlxuICAgICAgICAgICAgLy8gU3RhcnQ6ICBodHRwOi8vbG9jYWxob3N0L2Zvby8jL2Jhci9cbiAgICAgICAgICAgIC8vIFJlc3VsdDogaHR0cDovL2xvY2FsaG9zdC9mb28vYmFyL1xuICAgICAgICAgICAgaWYgKCB0aGlzLl9vcHRpb25zLmZvcmNlSGFzaCApIHtcbiAgICAgICAgICAgICAgICAvLyBTaGF2ZSB0aGUgaGFzaCBmcm9tIHRoZSBlbmQgb2YgdGhlIFVSTFxuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCB3aW5kb3cubG9jYXRpb24uaGFzaCwgXCJcIiApO1xuXG4gICAgICAgICAgICAgICAgLy8gU2hhdmUgdGhlIGhhc2ggcm9vdCBmcm9tIHRoZSBlbmQgb2YgdGhlIFVSTFxuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIFwiXCIgKTtcblxuICAgICAgICAgICAgICAgIC8vIEVtcHR5IGhhc2ggbWVhbnMgd2UgaGF2ZSBnb25lIGJhY2sgdG8gcm9vdFxuICAgICAgICAgICAgICAgIGlmICggcm9vdHMuaW5kZXhPZiggd2luZG93LmxvY2F0aW9uLmhhc2ggKSAhPT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgaGFzaCByb290IHRvIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKHVybCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGFwcGxpZWQgaGFzaCBwYXRobmFtZSB0byB0aGUgVVJMXG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICh1cmwgKyB3aW5kb3cubG9jYXRpb24uaGFzaC5yZXBsYWNlKCBcIiNcIiwgXCJcIiApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSggXCJwb3BzdGF0ZVwiLCB1cmwsIHRoaXMuX3N0YXRlc1sgdXJsIF0gKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIHB1c2hhYmxlICYmICF0aGlzLl9vcHRpb25zLmZvcmNlSGFzaCApIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInBvcHN0YXRlXCIsICgpID0IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG5cbiAgICAgICAgICAgIH0sIGZhbHNlICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggaGFzaGFibGUgKSB7XG4gICAgICAgICAgICAvLyBGb3IgaGFzaHN0YXRlIHdlIHNob3VsZCBhcHBseSBpbml0aWFsIGhhc2ggb24gcGFnZSBsb2FkXG4gICAgICAgICAgICB0aGlzLl9wdXNoKCB0aGlzLl9pbml0VXJsICk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImhhc2hjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICggIXRoaXMuX2lzaGFzaHB1c2hlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNoYXNocHVzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCBmYWxzZSApO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkNvbnRyb2xsZXIiLCJwdXNoYWJsZSIsIndpbmRvdyIsImhpc3RvcnkiLCJoYXNoYWJsZSIsIkhpc3RvcmlhIiwiX0NvbnRyb2xsZXIiLCJfaW5oZXJpdHMiLCJfc3VwZXIiLCJfY3JlYXRlU3VwZXIiLCJvcHRpb25zIiwiX3RoaXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJjYWxsIiwiX2luaXRVcmwiLCJsb2NhdGlvbiIsImhyZWYiLCJyZXBsYWNlIiwiaGFzaCIsIl9vcHRpb25zIiwiX2VuYWJsZWQiLCJfaXNoYXNocHVzaGVkIiwiX3N0YXRlcyIsIl9jYWxsYmFja3MiLCJ1aWQiLCJfc3RhdGVFbmFibGUiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsInB1c2giLCJ1cmwiLCJfcHVzaCIsImdvQmFjayIsImJhY2siLCJmaXJlIiwiZ29Gb3J3YXJkIiwiZm9yd2FyZCIsImZvcmNlSGFzaCIsInB1c2hTdGF0ZSIsImhhc2hVcmkiLCJvcmlnaW4iLCJwYXRobmFtZSIsIl90aGlzMiIsImhhbmRsZXIiLCJyb290cyIsImluZGV4T2YiLCJhZGRFdmVudExpc3RlbmVyIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-historia/Historia.js\n");

/***/ }),

/***/ "./node_modules/properjs-historia/node_modules/properjs-controller/Controller.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/properjs-historia/node_modules/properjs-controller/Controller.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Controller)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar raf = window.requestAnimationFrame;\nvar caf = window.cancelAnimationFrame;\n\n/**\n *\n * Easing functions\n * @namespace Easing\n * @memberof! <global>\n *\n */\nvar ease = {\n  /**\n   *\n   * Produce a linear ease\n   * @method linear\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  linear: function linear(t) {\n    return t;\n  },\n  /**\n   *\n   * Produce a swing ease like in jQuery\n   * @method swing\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  swing: function swing(t) {\n    return (1 - Math.cos(t * Math.PI)) / 2;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInQuad\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutQuad\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutQuad: function easeOutQuad(t) {\n    return t * (2 - t);\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutQuad\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutQuad: function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1  (4 - 2 * t) * t;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInCubic\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutCubic\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutCubic: function easeOutCubic(t) {\n    return --t * t * t  1;\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutCubic\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutCubic: function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2)  1;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInQuart\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutQuart\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutQuart: function easeOutQuart(t) {\n    return 1 - --t * t * t * t;\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutQuart\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutQuart: function easeInOutQuart(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInQuint\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutQuint\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutQuint: function easeOutQuint(t) {\n    return 1  --t * t * t * t * t;\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutQuint\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutQuint: function easeInOutQuint(t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1  16 * --t * t * t * t * t;\n  }\n};\nvar defs = {\n  ease: ease.swing,\n  duration: 500,\n  from: 0,\n  to: 500,\n  update: function update() {},\n  complete: function complete() {}\n};\nvar Controller = /*#__PURE__*/function () {\n  function Controller() {\n    _classCallCheck(this, Controller);\n    // Unique event IDs\n    this._uid = 0;\n    this._uprop = \"properjsUID\";\n\n    // Store for event handlers\n    this._handlers = {};\n\n    // RAF manager props\n    this._started = false;\n    this._paused = false;\n    this._cycle = null;\n  }\n  _createClass(Controller, [{\n    key: \"uid\",\n    value: function uid() {\n      this._uid = this._uid  1;\n      return this._uid;\n    }\n  }, {\n    key: \"go\",\n    value: function go(callback) {\n      var _this = this;\n      if (this._started) {\n        return this;\n      }\n      this._started = true;\n      this._anim = function (elapsed) {\n        _this._cycle = raf(_this._anim);\n        if (typeof callback === \"function\") {\n          callback(elapsed);\n        }\n      };\n      this._cycle = raf(this._anim);\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._paused = true;\n      return this;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      this._paused = false;\n      return this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      caf(this._cycle);\n      this._paused = false;\n      this._started = false;\n      this._cycle = null;\n      return this;\n    }\n  }, {\n    key: \"tween\",\n    value: function tween(opts) {\n      var _this2 = this;\n      for (var i in defs) {\n        if (opts[i] === undefined) {\n          opts[i] = defs[i];\n        }\n      }\n      var startTime = null;\n      var tweenDiff = opts.to - opts.from;\n      this.stop().go(function (elapsed) {\n        if (startTime === null) {\n          startTime = elapsed;\n        }\n        var diff = elapsed - startTime;\n        var tweenTo = tweenDiff * opts.ease(diff / opts.duration)  opts.from;\n        opts.update(tweenTo);\n        if (diff > opts.duration) {\n          opts.complete(opts.to);\n          _this2.stop();\n        }\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, handler) {\n      var events = event.split(\" \");\n      handler[this._uprop] = this.uid();\n      for (var i = events.length; i--;) {\n        if (typeof handler === \"function\") {\n          if (!this._handlers[events[i]]) {\n            this._handlers[events[i]] = [];\n          }\n          this._handlers[events[i]].push(handler);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      if (!this._handlers[event]) {\n        return this;\n      }\n      if (handler) {\n        this._offOne(event, handler);\n      } else {\n        this._offAll(event);\n      }\n      return this;\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(event) {\n      if (!this._handlers[event]) {\n        return this;\n      }\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key) {\n        args[_key - 1] = arguments[_key];\n      }\n      for (var i = this._handlers[event].length; i--;) {\n        this._handlers[event][i].apply(this, args);\n      }\n      return this;\n    }\n  }, {\n    key: \"_offOne\",\n    value: function _offOne(event, handler) {\n      for (var i = 0, len = this._handlers[event].length; i < len; i) {\n        if (handler[this._uprop] === this._handlers[event][i][this._uprop]) {\n          this._handlers[event].splice(i, 1);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"_offAll\",\n    value: function _offAll(event) {\n      for (var i = this._handlers[event].length; i--;) {\n        this._handlers[event][i] = null;\n      }\n      delete this._handlers[event];\n    }\n  }]);\n  return Controller;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaGlzdG9yaWEvbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWNvbnRyb2xsZXIvQ29udHJvbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsSUFBTUEsR0FBRyxHQUFHQyxNQUFNLENBQUNDLHFCQUFxQjtBQUN4QyxJQUFNQyxHQUFHLEdBQUdGLE1BQU0sQ0FBQ0csb0JBQW9COztBQUl2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1DLElBQUksR0FBRztFQUNUO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsTUFBTSxXQUFBQSxPQUFHQyxDQUFDLEVBQUc7SUFBRSxPQUFPQSxDQUFDO0VBQUUsQ0FBQztFQUUxQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLEtBQUssV0FBQUEsTUFBR0QsQ0FBQyxFQUFHO0lBQUUsT0FBTyxDQUFDLENBQUMsR0FBQ0UsSUFBSSxDQUFDQyxHQUFHLENBQUVILENBQUMsR0FBQ0UsSUFBSSxDQUFDRSxFQUFHLENBQUMsSUFBRSxDQUFDO0VBQUUsQ0FBQztFQUVuRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLFVBQVUsV0FBQUEsV0FBR0wsQ0FBQyxFQUFHO0lBQUUsT0FBT0EsQ0FBQyxHQUFDQSxDQUFDO0VBQUUsQ0FBQztFQUVoQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lNLFdBQVcsV0FBQUEsWUFBR04sQ0FBQyxFQUFHO0lBQUUsT0FBT0EsQ0FBQyxJQUFFLENBQUMsR0FBQ0EsQ0FBQyxDQUFDO0VBQUUsQ0FBQztFQUVyQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lPLGFBQWEsV0FBQUEsY0FBR1AsQ0FBQyxFQUFHO0lBQUUsT0FBT0EsQ0FBQyxHQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUNBLENBQUMsR0FBQ0Es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QUFJLENBQUMxQyxTQUFTLENBQUUwQixLQUFLLENBQUUsQ0FBQ0ksTUFBTSxFQUFFWCxDQUFDLEdBQUd1QixHQUFHLEVBQUV2QixDQUFDLEVBQUUsRUFBRztRQUNsRSxJQUFLUSxPQUFPLENBQUUsSUFBSSxDQUFDNUIsTUFBTSxDQUFFLEtBQUssSUFBSSxDQUFDQyxTQUFTLENBQUUwQixLQUFLLENBQUUsQ0FBRVAsQ0FBQyxDQUFFLENBQUUsSUFBSSxDQUFDcEIsTUFBTSxDQUFFLEVBQUc7VUFDMUUsSUFBSSxDQUFDQyxTQUFTLENBQUUwQixLQUFLLENBQUUsQ0FBQ2lCLE1BQU0sQ0FBRXhCLENBQUMsRUFBRSxDQUFFLENBQUM7VUFFdEM7UUFDSjtNQUNKO0lBQ0o7RUFBQztJQUFBZCxHQUFBO0lBQUFDLEtBQUEsRUFHRCxTQUFBNEIsUUFBVVIsS0FBSyxFQUFHO01BQ2QsS0FBTSxJQUFJUCxDQUFDLEdBQUcsSUFBSSxDQUFDbkIsU0FBUyxDQUFFMEIsS0FBSyxDQUFFLENBQUNJLE1BQU0sRUFBRVgsQ0FBQyxFQUFFLEdBQUk7UUFDakQsSUFBSSxDQUFDbkIsU0FBUyxDQUFFMEIsS0FBSyxDQUFFLENBQUVQLENBQUMsQ0FBRSxHQUFHLElBQUk7TUFDdkM7TUFFQSxPQUFPLElBQUksQ0FBQ25CLFNBQVMsQ0FBRTBCLEtBQUssQ0FBRTtJQUNsQztFQUFDO0VBQUEsT0FBQTlCLFVBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1oaXN0b3JpYS9ub2RlX21vZHVsZXMvcHJvcGVyanMtY29udHJvbGxlci9Db250cm9sbGVyLmpzPzQ0NWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbmNvbnN0IGNhZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZTtcblxuXG5cbi8qKlxuICpcbiAqIEVhc2luZyBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgRWFzaW5nXG4gKiBAbWVtYmVyb2YhIDxnbG9iYWwXG4gKlxuICovXG5jb25zdCBlYXNlID0ge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJvZHVjZSBhIGxpbmVhciBlYXNlXG4gICAgICogQG1ldGhvZCBsaW5lYXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBsaW5lYXIgKCB0ICkgeyByZXR1cm4gdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJvZHVjZSBhIHN3aW5nIGVhc2UgbGlrZSBpbiBqUXVlcnlcbiAgICAgKiBAbWV0aG9kIHN3aW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgc3dpbmcgKCB0ICkgeyByZXR1cm4gKDEtTWF0aC5jb3MoIHQqTWF0aC5QSSApKS8yOyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlSW5RdWFkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgZWFzZUluUXVhZCAoIHQgKSB7IHJldHVybiB0KnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlT3V0UXVhZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VPdXRRdWFkICggdCApIHsgcmV0dXJuIHQqKDItdCk7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAqIEBtZXRob2QgZWFzZUluT3V0UXVhZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJbk91dFF1YWQgKCB0ICkgeyByZXR1cm4gdDwwLjUgPyAyKnQqdCA6IC0xKyg0LTIqdCkqdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAqIEBtZXRob2QgZWFzZUluQ3ViaWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlSW5DdWJpYyAoIHQgKSB7IHJldHVybiB0KnQqdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgKiBAbWV0aG9kIGVhc2VPdXRDdWJpY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VPdXRDdWJpYyAoIHQgKSB7IHJldHVybiAoLS10KSp0KnQrMTsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICogQG1ldGhvZCBlYXNlSW5PdXRDdWJpY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJbk91dEN1YmljICggdCApIHsgcmV0dXJuIHQ8MC41ID8gNCp0KnQqdCA6ICh0LTEpKigyKnQtMikqKDIqdC0yKSsxOyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlSW5RdWFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJblF1YXJ0ICggdCApIHsgcmV0dXJuIHQqdCp0KnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlT3V0UXVhcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVhcnQgKCB0ICkgeyByZXR1cm4gMS0oLS10KSp0KnQqdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICogQG1ldGhvZCBlYXNlSW5PdXRRdWFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJbk91dFF1YXJ0ICggdCApIHsgcmV0dXJuIHQ8MC41ID8gOCp0KnQqdCp0IDogMS04KigtLXQpKnQqdCp0OyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlSW5RdWludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJblF1aW50ICggdCApIHsgcmV0dXJuIHQqdCp0KnQqdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgKiBAbWV0aG9kIGVhc2VPdXRRdWludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VPdXRRdWludCAoIHQgKSB7IHJldHVybiAxKygtLXQpKnQqdCp0KnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAqIEBtZXRob2QgZWFzZUluT3V0UXVpbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWludCAoIHQgKSB7IHJldHVybiB0PDAuNSA/IDE2KnQqdCp0KnQqdCA6IDErMTYqKC0tdCkqdCp0KnQqdDsgfVxufTtcblxuXG5cbmNvbnN0IGRlZnMgPSB7XG4gICAgZWFzZTogZWFzZS5zd2luZyxcbiAgICBkdXJhdGlvbjogNTAwLFxuICAgIGZyb206IDAsXG4gICAgdG86IDUwMCxcbiAgICB1cGRhdGU6ICgpID0IHt9LFxuICAgIGNvbXBsZXRlOiAoKSA9PiB7fSxcbn07XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIC8vIFVuaXF1ZSBldmVudCBJRHNcbiAgICAgICAgdGhpcy5fdWlkID0gMDtcbiAgICAgICAgdGhpcy5fdXByb3AgPSBcInByb3BlcmpzVUlEXCI7XG5cbiAgICAgICAgLy8gU3RvcmUgZm9yIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG5cbiAgICAgICAgLy8gUkFGIG1hbmFnZXIgcHJvcHNcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3ljbGUgPSBudWxsO1xuICAgIH1cblxuXG4gICAgdWlkICgpIHtcbiAgICAgICAgdGhpcy5fdWlkID0gKHRoaXMuX3VpZCArIDEpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl91aWQ7XG4gICAgfVxuXG5cbiAgICBnbyAoIGNhbGxiYWNrICkge1xuICAgICAgICBpZiAoIHRoaXMuX3N0YXJ0ZWQgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hbmltID0gKCBlbGFwc2VkICkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUgPSByYWYoIHRoaXMuX2FuaW0gKTtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayggZWxhcHNlZCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jeWNsZSA9IHJhZiggdGhpcy5fYW5pbSApO1xuICAgIH1cblxuXG4gICAgcGF1c2UgKCkge1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgcGxheSAoKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgc3RvcCAoKSB7XG4gICAgICAgIGNhZiggdGhpcy5fY3ljbGUgKTtcblxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jeWNsZSA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICB0d2VlbiAoIG9wdHMgKSB7XG4gICAgICAgIGZvciAoIGxldCBpIGluIGRlZnMgKSB7XG4gICAgICAgICAgICBpZiAoIG9wdHNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIG9wdHNbIGkgXSA9IGRlZnNbIGkgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGFydFRpbWUgPSBudWxsO1xuICAgICAgICBjb25zdCB0d2VlbkRpZmYgPSAob3B0cy50byAtIG9wdHMuZnJvbSk7XG5cbiAgICAgICAgdGhpcy5zdG9wKCkuZ28oKCBlbGFwc2VkICkgPT4ge1xuICAgICAgICAgICAgaWYgKCBzdGFydFRpbWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gZWxhcHNlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGVsYXBzZWQgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zdCB0d2VlblRvID0gKHR3ZWVuRGlmZiAqIG9wdHMuZWFzZSggZGlmZiAvIG9wdHMuZHVyYXRpb24gKSkgKyBvcHRzLmZyb207XG5cbiAgICAgICAgICAgIG9wdHMudXBkYXRlKCB0d2VlblRvICk7XG5cbiAgICAgICAgICAgIGlmICggZGlmZiAIG9wdHMuZHVyYXRpb24gKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5jb21wbGV0ZSggb3B0cy50byApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgb24gKCBldmVudCwgaGFuZGxlciApIHtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gZXZlbnQuc3BsaXQoIFwiIFwiICk7XG5cbiAgICAgICAgaGFuZGxlclsgdGhpcy5fdXByb3AgXSA9IHRoaXMudWlkKCk7XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSBldmVudHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgIGlmICggIXRoaXMuX2hhbmRsZXJzWyBldmVudHNbIGkgXSBdICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1sgZXZlbnRzWyBpIF0gXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzWyBldmVudHNbIGkgXSBdLnB1c2goIGhhbmRsZXIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgb2ZmICggZXZlbnQsIGhhbmRsZXIgKSB7XG4gICAgICAgIGlmICggIXRoaXMuX2hhbmRsZXJzWyBldmVudCBdICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGhhbmRsZXIgKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZPbmUoIGV2ZW50LCBoYW5kbGVyICk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29mZkFsbCggZXZlbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgZmlyZSAoIGV2ZW50LCAuLi5hcmdzICkge1xuICAgICAgICBpZiAoICF0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXS5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXVsgaSBdLmFwcGx5KCB0aGlzLCBhcmdzICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIF9vZmZPbmUgKCBldmVudCwgaGFuZGxlciApIHtcbiAgICAgICAgZm9yICggbGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXS5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggaGFuZGxlclsgdGhpcy5fdXByb3AgXSA9PT0gdGhpcy5faGFuZGxlcnNbIGV2ZW50IF1bIGkgXVsgdGhpcy5fdXByb3AgXSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXS5zcGxpY2UoIGksIDEgKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBfb2ZmQWxsICggZXZlbnQgKSB7XG4gICAgICAgIGZvciAoIGxldCBpID0gdGhpcy5faGFuZGxlcnNbIGV2ZW50IF0ubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbIGV2ZW50IF1bIGkgXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNbIGV2ZW50IF07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInJhZiIsIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhZiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZWFzZSIsImxpbmVhciIsInQiLCJzd2luZyIsIk1hdGgiLCJjb3MiLCJQSSIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJkZWZzIiwiZHVyYXRpb24iLCJmcm9tIiwidG8iLCJ1cGRhdGUiLCJjb21wbGV0ZSIsIkNvbnRyb2xsZXIiLCJfY2xhc3NDYWxsQ2hlY2siLCJfdWlkIiwiX3Vwcm9wIiwiX2hhbmRsZXJzIiwiX3N0YXJ0ZWQiLCJfcGF1c2VkIiwiX2N5Y2xlIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJ1aWQiLCJnbyIsImNhbGxiYWNrIiwiX3RoaXMiLCJfYW5pbSIsImVsYXBzZWQiLCJwYXVzZSIsInBsYXkiLCJzdG9wIiwidHdlZW4iLCJvcHRzIiwiX3RoaXMyIiwiaSIsInVuZGVmaW5lZCIsInN0YXJ0VGltZSIsInR3ZWVuRGlmZiIsImRpZmYiLCJ0d2VlblRvIiwib24iLCJldmVudCIsImhhbmRsZXIiLCJldmVudHMiLCJzcGxpdCIsImxlbmd0aCIsInB1c2giLCJvZmYiLCJfb2ZmT25lIiwiX29mZkFsbCIsImZpcmUiLCJfbGVuIiwiYXJndW1lbnRzIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImFwcGx5IiwibGVuIiwic3BsaWNlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-historia/node_modules/properjs-controller/Controller.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/dist/hobo.build.js":
/*!*******************************************************!*\
  !*** ./node_modules/properjs-hobo/dist/hobo.build.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n *\n *\n * Hobo\n * A very small, modular DOM utility for modern web apps.\n * @hobo-dist npm run build -- is eq not one next prev attr last first index parent filter detach append remove trigger prepend closest children removeAttr toggleClass\n *\n * @links\n * https://developer.mozilla.org/en-US/docs/Web/API/Node\n * https://developer.mozilla.org/en-US/docs/Web/API/Element\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n * https://github.com/jakearchibald/es6-promise\n * http://www.html5rocks.com/en/tutorials/es6/promises/\n *\n *\n */\n(function (factory) {\n  if (( false ? 0 : _typeof(exports)) === \"object\" && \"object\" !== \"undefined\") {\n    module.exports = factory();\n  } else if (typeof window !== \"undefined\") {\n    window.hobo = factory();\n  }\n})(function () {\n  var Hobo = __webpack_require__(/*! ../lib/Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n    utils = __webpack_require__(/*! ../lib/utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n  // Core Hobo methods:\n  Hobo.prototype.on = __webpack_require__(/*! ../lib/core/on */ \"./node_modules/properjs-hobo/lib/core/on.js\");\n  Hobo.prototype.off = __webpack_require__(/*! ../lib/core/off */ \"./node_modules/properjs-hobo/lib/core/off.js\");\n  Hobo.prototype.data = __webpack_require__(/*! ../lib/core/data */ \"./node_modules/properjs-hobo/lib/core/data.js\");\n  Hobo.prototype.find = __webpack_require__(/*! ../lib/core/find */ \"./node_modules/properjs-hobo/lib/core/find.js\");\n  Hobo.prototype.addClass = __webpack_require__(/*! ../lib/core/addClass */ \"./node_modules/properjs-hobo/lib/core/addClass.js\");\n  Hobo.prototype.removeClass = __webpack_require__(/*! ../lib/core/removeClass */ \"./node_modules/properjs-hobo/lib/core/removeClass.js\");\n\n  // Extended Hobo methods:\n  Hobo.prototype.is = __webpack_require__(/*! ../lib/extended/is */ \"./node_modules/properjs-hobo/lib/extended/is.js\");\n  Hobo.prototype.eq = __webpack_require__(/*! ../lib/extended/eq */ \"./node_modules/properjs-hobo/lib/extended/eq.js\");\n  Hobo.prototype.not = __webpack_require__(/*! ../lib/extended/not */ \"./node_modules/properjs-hobo/lib/extended/not.js\");\n  Hobo.prototype.one = __webpack_require__(/*! ../lib/extended/one */ \"./node_modules/properjs-hobo/lib/extended/one.js\");\n  Hobo.prototype.next = __webpack_require__(/*! ../lib/extended/next */ \"./node_modules/properjs-hobo/lib/extended/next.js\");\n  Hobo.prototype.prev = __webpack_require__(/*! ../lib/extended/prev */ \"./node_modules/properjs-hobo/lib/extended/prev.js\");\n  Hobo.prototype.attr = __webpack_require__(/*! ../lib/extended/attr */ \"./node_modules/properjs-hobo/lib/extended/attr.js\");\n  Hobo.prototype.last = __webpack_require__(/*! ../lib/extended/last */ \"./node_modules/properjs-hobo/lib/extended/last.js\");\n  Hobo.prototype.first = __webpack_require__(/*! ../lib/extended/first */ \"./node_modules/properjs-hobo/lib/extended/first.js\");\n  Hobo.prototype.index = __webpack_require__(/*! ../lib/extended/index */ \"./node_modules/properjs-hobo/lib/extended/index.js\");\n  Hobo.prototype.parent = __webpack_require__(/*! ../lib/extended/parent */ \"./node_modules/properjs-hobo/lib/extended/parent.js\");\n  Hobo.prototype.filter = __webpack_require__(/*! ../lib/extended/filter */ \"./node_modules/properjs-hobo/lib/extended/filter.js\");\n  Hobo.prototype.detach = __webpack_require__(/*! ../lib/extended/detach */ \"./node_modules/properjs-hobo/lib/extended/detach.js\");\n  Hobo.prototype.append = __webpack_require__(/*! ../lib/extended/append */ \"./node_modules/properjs-hobo/lib/extended/append.js\");\n  Hobo.prototype.remove = __webpack_require__(/*! ../lib/extended/remove */ \"./node_modules/properjs-hobo/lib/extended/remove.js\");\n  Hobo.prototype.trigger = __webpack_require__(/*! ../lib/extended/trigger */ \"./node_modules/properjs-hobo/lib/extended/trigger.js\");\n  Hobo.prototype.prepend = __webpack_require__(/*! ../lib/extended/prepend */ \"./node_modules/properjs-hobo/lib/extended/prepend.js\");\n  Hobo.prototype.closest = __webpack_require__(/*! ../lib/extended/closest */ \"./node_modules/properjs-hobo/lib/extended/closest.js\");\n  Hobo.prototype.children = __webpack_require__(/*! ../lib/extended/children */ \"./node_modules/properjs-hobo/lib/extended/children.js\");\n  Hobo.prototype.removeAttr = __webpack_require__(/*! ../lib/extended/removeAttr */ \"./node_modules/properjs-hobo/lib/extended/removeAttr.js\");\n  Hobo.prototype.toggleClass = __webpack_require__(/*! ../lib/extended/toggleClass */ \"./node_modules/properjs-hobo/lib/extended/toggleClass.js\");\n\n  /**\n   *\n   * @global\n   * @public\n   * @method hobo\n   * @description Wrapper for `Hobo` instances.\n   * @param {string} selector The parameter passed to `querySelectorAll`\n   * @param {element} context The Element used to call `querySelectorAll`\n   * @returns {Hobo}\n   *\n   */\n  hobo = function hobo(selector, context) {\n    return new Hobo(selector, context);\n  };\n\n  // Attach Hobo utilities to `wrapper` method\n  hobo.ajax = __webpack_require__(/*! ../lib/core/ajax */ \"./node_modules/properjs-hobo/lib/core/ajax.js\");\n\n  // Attach Hobo internal utils to `wrapper` method\n  hobo.utils = utils;\n  return hobo;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9kaXN0L2hvYm8uYnVpbGQuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVdBLE9BQU8sRUFBRztFQUVsQixJQUFLLE9BQWMsT0FBQUUsT0FBQSxDQUFQRCxPQUFPLE9BQUssUUFBUSxJQUFJLFFBQWEsS0FBSyxXQUFXLEVBQUc7SUFDaEVFLE1BQU0sQ0FBQ0YsT0FBTyxHQUFHRCxPQUFPLENBQUMsQ0FBQztFQUU5QixDQUFDLE1BQU0sSUFBSyxPQUFPSSxNQUFNLEtBQUssV0FBVyxFQUFHO0lBQ3hDQSxNQUFNLENBQUNDLElBQUksR0FBR0wsT0FBTyxDQUFDLENBQUM7RUFDM0I7QUFFSixDQUFDLEVBQUUsWUFBWTtFQUVYLElBQUlNLElBQUksR0FBR0MsbUJBQU8sQ0FBRSw2REFBYyxDQUFDO0lBQy9CQyxLQUFLLEdBQUdELG1CQUFPLENBQUUsK0RBQWUsQ0FBQzs7RUFHckM7RUFDQUQsSUFBSSxDQUFDRyxTQUFTLENBQUNDLEVBQUUsR0FBR0gsbUJBQU8sQ0FBRSxtRUFBaUIsQ0FBQztFQUMvQ0QsSUFBSSxDQUFDRyxTQUFTLENBQUNFLEdBQUcsR0FBR0osbUJBQU8sQ0FBRSxxRUFBa0IsQ0FBQztFQUNqREQsSUFBSSxDQUFDRyxTQUFTLENBQUNHLElBQUksR0FBR0wsbUJBQU8sQ0FBRSx1RUFBbUIsQ0FBQztFQUNuREQsSUFBSSxDQUFDRyxTQUFTLENBQUNJLElBQUksR0FBR04sbUJBQU8sQ0FBRSx1RUFBbUIsQ0FBQztFQUNuREQsSUFBSSxDQUFDRyxTQUFTLENBQUNLLFFBQVEsR0FBR1AsbUJBQU8sQ0FBRSwrRUFBdUIsQ0FBQztFQUMzREQsSUFBSSxDQUFDRyxTQUFTLENBQUNNLFdBQVcsR0FBR1IsbUJBQU8sQ0FBRSxxRkFBMEIsQ0FBQzs7RUFHakU7RUFDQUQsSUFBSSxDQUFDRyxTQUFTLENBQUNPLEVBQUUsR0FBR1QsbUJBQU8sQ0FBRSwyRUFBcUIsQ0FBQztFQUNuREQsSUFBSSxDQUFDRyxTQUFTLENBQUNRLEVBQUUsR0FBR1YsbUJBQU8sQ0FBRSwyRUFBcUIsQ0FBQztFQUNuREQsSUFBSSxDQUFDRyxTQUFTLENBQUNTLEdBQUcsR0FBR1gsbUJBQU8sQ0FBRSw2RUFBc0IsQ0FBQztFQUNyREQsSUFBSSxDQUFDRyxTQUFTLENBQUNVLEdBQUcsR0FBR1osbUJBQU8sQ0FBRSw2RUFBc0IsQ0FBQztFQUNyREQsSUFBSSxDQUFDRyxTQUFTLENBQUNXLElBQUksR0FBR2IsbUJBQU8sQ0FBRSwrRUFBdUIsQ0FBQztFQUN2REQsSUFBSSxDQUFDRyxTQUFTLENBQUNZLElBQUksR0FBR2QsbUJBQU8sQ0FBRSwrRUFBdUIsQ0FBQztFQUN2REQsSUFBSSxDQUFDRyxTQUFTLENBQUNhLElBQUksR0FBR2YsbUJBQU8sQ0FBRSwrRUFBdUIsQ0FBQztFQUN2REQsSUFBSSxDQUFDRyxTQUFTLENBQUNjLElBQUksR0FBR2hCLG1CQUFPLENBQUUsK0VBQXVCLENBQUM7RUFDdkRELElBQUksQ0FBQ0csU0FBUyxDQUFDZSxLQUFLLEdBQUdqQixtQkFBTyxDQUFFLGlGQUF3QixDQUFDO0VBQ3pERCxJQUFJLENBQUNHLFNBQVMsQ0FBQ2dCLEtBQUssR0FBR2xCLG1CQUFPLENBQUUsaUZBQXdCLENBQUM7RUFDekRELElBQUksQ0FBQ0csU0FBUyxDQUFDaUIsTUFBTSxHQUFHbkIsbUJBQU8sQ0FBRSxtRkFBeUIsQ0FBQztFQUMzREQsSUFBSSxDQUFDRyxTQUFTLENBQUNrQixNQUFNLEdBQUdwQixtQkFBTyxDQUFFLG1GQUF5QixDQUFDO0VBQzNERCxJQUFJLENBQUNHLFNBQVMsQ0FBQ21CLE1BQU0sR0FBR3JCLG1CQUFPLENBQUUsbUZBQXlCLENBQUM7RUFDM0RELElBQUksQ0FBQ0csU0FBUyxDQUFDb0IsTUFBTSxHQUFHdEIsbUJBQU8sQ0FBRSxtRkFBeUIsQ0FBQztFQUMzREQsSUFBSSxDQUFDRyxTQUFTLENBQUNxQixNQUFNLEdBQUd2QixtQkFBTyxDQUFFLG1GQUF5QixDQUFDO0VBQzNERCxJQUFJLENBQUNHLFNBQVMsQ0FBQ3NCLE9BQU8sR0FBR3hCLG1CQUFPLENBQUUscUZBQTBCLENBQUM7RUFDN0RELElBQUksQ0FBQ0csU0FBUyxDQUFDdUIsT0FBTyxHQUFHekIsbUJBQU8sQ0FBRSxxRkFBMEIsQ0FBQztFQUM3REQsSUFBSSxDQUFDRyxTQUFTLENBQUN3QixPQUFPLEdBQUcxQixtQkFBTyxDQUFFLHFGQUEwQixDQUFDO0VBQzdERCxJQUFJLENBQUNHLFNBQVMsQ0FBQ3lCLFFBQVEsR0FBRzNCLG1CQUFPLENBQUUsdUZBQTJCLENBQUM7RUFDL0RELElBQUksQ0FBQ0csU0FBUyxDQUFDMEIsVUFBVSxHQUFHNUIsbUJBQU8sQ0FBRSwyRkFBNkIsQ0FBQztFQUNuRUQsSUFBSSxDQUFDRyxTQUFTLENBQUMyQixXQUFXLEdBQUc3QixtQkFBTyxDQUFFLDZGQUE4QixDQUFDOztFQUdyRTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lGLElBQUksR0FBRyxTQUFBQSxLQUFXZ0MsUUFBUSxFQUFFQyxPQUFPLEVBQUc7SUFDbEMsT0FBTyxJQUFJaEMsSUFBSSxDQUFFK0IsUUFBUSxFQUFFQyxPQUFRLENBQUM7RUFDeEMsQ0FBQzs7RUFHRDtFQUNBakMsSUFBSSxDQUFDa0MsSUFBSSxHQUFHaEMsbUJBQU8sQ0FBRSx1RUFBbUIsQ0FBQzs7RUFFekM7RUFDQUYsSUFBSSxDQUFDRyxLQUFLLEdBQUdBLEtBQUs7RUFHbEIsT0FBT0gsSUFBSTtBQUVmLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2Rpc3QvaG9iby5idWlsZC5qcz9iMTI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqXG4gKiBIb2JvXG4gKiBBIHZlcnkgc21hbGwsIG1vZHVsYXIgRE9NIHV0aWxpdHkgZm9yIG1vZGVybiB3ZWIgYXBwcy5cbiAqIEBob2JvLWRpc3QgbnBtIHJ1biBidWlsZCAtLSBpcyBlcSBub3Qgb25lIG5leHQgcHJldiBhdHRyIGxhc3QgZmlyc3QgaW5kZXggcGFyZW50IGZpbHRlciBkZXRhY2ggYXBwZW5kIHJlbW92ZSB0cmlnZ2VyIHByZXBlbmQgY2xvc2VzdCBjaGlsZHJlbiByZW1vdmVBdHRyIHRvZ2dsZUNsYXNzXG4gKlxuICogQGxpbmtzXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnRcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9xdWVyeVNlbGVjdG9yQWxsXG4gKlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0XG4gKlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2pha2VhcmNoaWJhbGQvZXM2LXByb21pc2VcbiAqIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2VzNi9wcm9taXNlcy9cbiAqXG4gKlxuICovXG4oZnVuY3Rpb24gKCBmYWN0b3J5ICkge1xuXG4gICAgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblxuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgIHdpbmRvdy5ob2JvID0gZmFjdG9yeSgpO1xuICAgIH1cblxufSkoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIEhvYm8gPSByZXF1aXJlKCBcIi4uL2xpYi9Ib2JvXCIgKSxcbiAgICAgICAgdXRpbHMgPSByZXF1aXJlKCBcIi4uL2xpYi91dGlsc1wiICk7XG5cblxuICAgIC8vIENvcmUgSG9ibyBtZXRob2RzOlxuICAgIEhvYm8ucHJvdG90eXBlLm9uID0gcmVxdWlyZSggXCIuLi9saWIvY29yZS9vblwiICk7XG4gICAgSG9iby5wcm90b3R5cGUub2ZmID0gcmVxdWlyZSggXCIuLi9saWIvY29yZS9vZmZcIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLmRhdGEgPSByZXF1aXJlKCBcIi4uL2xpYi9jb3JlL2RhdGFcIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLmZpbmQgPSByZXF1aXJlKCBcIi4uL2xpYi9jb3JlL2ZpbmRcIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLmFkZENsYXNzID0gcmVxdWlyZSggXCIuLi9saWIvY29yZS9hZGRDbGFzc1wiICk7XG4gICAgSG9iby5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSByZXF1aXJlKCBcIi4uL2xpYi9jb3JlL3JlbW92ZUNsYXNzXCIgKTtcblxuXG4gICAgLy8gRXh0ZW5kZWQgSG9ibyBtZXRob2RzOlxuICAgIEhvYm8ucHJvdG90eXBlLmlzID0gcmVxdWlyZSggXCIuLi9saWIvZXh0ZW5kZWQvaXNcIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLmVxID0gcmVxdWlyZSggXCIuLi9saWIvZXh0ZW5kZWQvZXFcIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLm5vdCA9IHJlcXVpcmUoIFwiLi4vbGliL2V4dGVuZGVkL25vdFwiICk7XG4gICAgSG9iby5wcm90b3R5cGUub25lID0gcmVxdWlyZSggXCIuLi9saWIvZXh0ZW5kZWQvb25lXCIgKTtcbiAgICBIb2JvLnByb3RvdHlwZS5uZXh0ID0gcmVxdWlyZSggXCIuLi9saWIvZXh0ZW5kZWQvbmV4dFwiICk7XG4gICAgSG9iby5wcm90b3R5cGUucHJldiA9IHJlcXVpcmUoIFwiLi4vbGliL2V4dGVuZGVkL3ByZXZcIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLmF0dHIgPSByZXF1aXJlKCBcIi4uL2xpYi9leHRlbmRlZC9hdHRyXCIgKTtcbiAgICBIb2JvLnByb3RvdHlwZS5sYXN0ID0gcmVxdWlyZSggXCIuLi9saWIvZXh0ZW5kZWQvbGFzdFwiICk7XG4gICAgSG9iby5wcm90b3R5cGUuZmlyc3QgPSByZXF1aXJlKCBcIi4uL2xpYi9leHRlbmRlZC9maXJzdFwiICk7XG4gICAgSG9iby5wcm90b3R5cGUuaW5kZXggPSByZXF1aXJlKCBcIi4uL2xpYi9leHRlbmRlZC9pbmRleFwiICk7XG4gICAgSG9iby5wcm90b3R5cGUucGFyZW50ID0gcmVxdWlyZSggXCIuLi9saWIvZXh0ZW5kZWQvcGFyZW50XCIgKTtcbiAgICBIb2JvLnByb3RvdHlwZS5maWx0ZXIgPSByZXF1aXJlKCBcIi4uL2xpYi9leHRlbmRlZC9maWx0ZXJcIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLmRldGFjaCA9IHJlcXVpcmUoIFwiLi4vbGliL2V4dGVuZGVkL2RldGFjaFwiICk7XG4gICAgSG9iby5wcm90b3R5cGUuYXBwZW5kID0gcmVxdWlyZSggXCIuLi9saWIvZXh0ZW5kZWQvYXBwZW5kXCIgKTtcbiAgICBIb2JvLnByb3RvdHlwZS5yZW1vdmUgPSByZXF1aXJlKCBcIi4uL2xpYi9leHRlbmRlZC9yZW1vdmVcIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLnRyaWdnZXIgPSByZXF1aXJlKCBcIi4uL2xpYi9leHRlbmRlZC90cmlnZ2VyXCIgKTtcbiAgICBIb2JvLnByb3RvdHlwZS5wcmVwZW5kID0gcmVxdWlyZSggXCIuLi9saWIvZXh0ZW5kZWQvcHJlcGVuZFwiICk7XG4gICAgSG9iby5wcm90b3R5cGUuY2xvc2VzdCA9IHJlcXVpcmUoIFwiLi4vbGliL2V4dGVuZGVkL2Nsb3Nlc3RcIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLmNoaWxkcmVuID0gcmVxdWlyZSggXCIuLi9saWIvZXh0ZW5kZWQvY2hpbGRyZW5cIiApO1xuICAgIEhvYm8ucHJvdG90eXBlLnJlbW92ZUF0dHIgPSByZXF1aXJlKCBcIi4uL2xpYi9leHRlbmRlZC9yZW1vdmVBdHRyXCIgKTtcbiAgICBIb2JvLnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IHJlcXVpcmUoIFwiLi4vbGliL2V4dGVuZGVkL3RvZ2dsZUNsYXNzXCIgKTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZ2xvYmFsXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZXRob2QgaG9ib1xuICAgICAqIEBkZXNjcmlwdGlvbiBXcmFwcGVyIGZvciBgSG9ib2AgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgcGFyYW1ldGVyIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvckFsbGBcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGNvbnRleHQgVGhlIEVsZW1lbnQgdXNlZCB0byBjYWxsIGBxdWVyeVNlbGVjdG9yQWxsYFxuICAgICAqIEByZXR1cm5zIHtIb2JvfVxuICAgICAqXG4gICAgICovXG4gICAgaG9ibyA9IGZ1bmN0aW9uICggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG4gICAgICAgIHJldHVybiBuZXcgSG9ibyggc2VsZWN0b3IsIGNvbnRleHQgKTtcbiAgICB9O1xuXG5cbiAgICAvLyBBdHRhY2ggSG9ibyB1dGlsaXRpZXMgdG8gYHdyYXBwZXJgIG1ldGhvZFxuICAgIGhvYm8uYWpheCA9IHJlcXVpcmUoIFwiLi4vbGliL2NvcmUvYWpheFwiICk7XG5cbiAgICAvLyBBdHRhY2ggSG9ibyBpbnRlcm5hbCB1dGlscyB0byBgd3JhcHBlcmAgbWV0aG9kXG4gICAgaG9iby51dGlscyA9IHV0aWxzO1xuXG5cbiAgICByZXR1cm4gaG9ibztcblxufSk7XG4iXSwibmFtZXMiOlsiZmFjdG9yeSIsImV4cG9ydHMiLCJfdHlwZW9mIiwibW9kdWxlIiwid2luZG93IiwiaG9ibyIsIkhvYm8iLCJyZXF1aXJlIiwidXRpbHMiLCJwcm90b3R5cGUiLCJvbiIsIm9mZiIsImRhdGEiLCJmaW5kIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsImlzIiwiZXEiLCJub3QiLCJvbmUiLCJuZXh0IiwicHJldiIsImF0dHIiLCJsYXN0IiwiZmlyc3QiLCJpbmRleCIsInBhcmVudCIsImZpbHRlciIsImRldGFjaCIsImFwcGVuZCIsInJlbW92ZSIsInRyaWdnZXIiLCJwcmVwZW5kIiwiY2xvc2VzdCIsImNoaWxkcmVuIiwicmVtb3ZlQXR0ciIsInRvZ2dsZUNsYXNzIiwic2VsZWN0b3IiLCJjb250ZXh0IiwiYWpheCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/dist/hobo.build.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/Hobo.js":
/*!************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/Hobo.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var utils = __webpack_require__(/*! ./utils */ \"./node_modules/properjs-hobo/lib/utils.js\"),\n  array = [];\n\n/**\n *\n * @class Hobo\n * @constructor\n * @classdesc A very small, modular DOM utility for modern web apps.\n * @param {string} selector The goods - String, Element, Collection.\n * @param {element} context The Element used to call `querySelectorAll`\n *\n */\nvar Hobo = function Hobo(selector, context) {\n  // Hobo version?\n  this._hobo = utils.version;\n\n  // Hobo context\n  this._context = context && context.nodeType && context.nodeType === 1 ? context : document;\n\n  // Hobo selector / elements\n  // Hobo supports a mixed selector argument\n\n  // Handle Window\n  // Handle Document\n  // Handle DOMElement\n  if (selector === window || selector === document || selector.nodeType && selector.nodeType === 1) {\n    this._selector = \"\";\n    selector = [selector];\n\n    // Handle String\n  } else if (typeof selector === \"string\") {\n    // Trim trailing whitespace from the string\n    selector = utils.trimString(selector);\n\n    // Handle string html => Element creation\n    if (utils.rTag.test(selector)) {\n      // Then remove the doctype - `<!DOCTYPE html>`\n      selector = selector.replace(utils.rDocType, \"\");\n\n      // Create a dummy `hobo` element\n      // Dump the HTML payload in the `hobo` element\n      // Extract the elements from the `hobo` element\n      var el = document.createElement(\"hobo\");\n      el.innerHTML = selector;\n\n      // Format elements as a true Array\n      selector = utils.makeArray(el.children);\n      el = null;\n\n      // Handle string selector\n    } else {\n      this._selector = selector;\n      selector = utils.makeArray(this._context.querySelectorAll(selector));\n    }\n\n    // Handle Collection: NodeList, HTMLCollection, Array\n  } else if (selector.length !== undefined) {\n    this._selector = \"\";\n    selector = utils.makeArray(selector);\n  }\n\n  // Hobo events?\n  this._events = {};\n\n  // Hobo length?\n  this.length = selector.length;\n\n  // Hobo elements?\n  for (var i = this.length; i--;) {\n    this[i] = selector[i];\n  }\n\n  // Initial mapping of each nodes data.\n  // Transfer {DOMStringMap} => {hoboDataMap}\n  this.forEach(utils.makeData);\n};\n\n// Shim Array-like presentation in console\nHobo.prototype.splice = array.splice;\n\n/**\n *\n * @instance\n * @method each\n * @param {function} callback The method called on each iteration\n * @memberof Hobo\n * @description Make sure Hobo is iterable like an Array\n *\n */\nHobo.prototype.each = array.forEach;\n\n/**\n *\n * @instance\n * @method forEach\n * @param {function} callback The method called on each iteration\n * @memberof Hobo\n * @description Make sure Hobo is iterable like an Array\n *\n */\nHobo.prototype.forEach = array.forEach;\n\n/**\n *\n * @instance\n * @method push\n * @param {?} element element1, ..., elementN\n * @memberof Hobo\n * @description Make sure Hobo is pushable like an Array\n *\n */\nHobo.prototype.push = array.push;\n\n/**\n *\n * @instance\n * @method map\n * @param {function} callback The method called for each element\n * @memberof Hobo\n * @description Make sure Hobo is mappable like an Array\n *\n */\nHobo.prototype.map = array.map;\n\n// Export the main Hobo Class :D\nmodule.exports = Hobo;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvSG9iby5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxLQUFLLEdBQUdDLG1CQUFPLENBQUUsMERBQVUsQ0FBQztFQUM1QkMsS0FBSyxHQUFHLEVBQUU7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsSUFBSSxHQUFHLFNBQVBBLElBQUlBLENBQWNDLFFBQVEsRUFBRUMsT0FBTyxFQUFHO0VBQ3RDO0VBQ0EsSUFBSSxDQUFDQyxLQUFLLEdBQUdOLEtBQUssQ0FBQ08sT0FBTzs7RUFFMUI7RUFDQSxJQUFJLENBQUNDLFFBQVEsR0FBSUgsT0FBTyxJQUFJQSxPQUFPLENBQUNJLFFBQVEsSUFBSUosT0FBTyxDQUFDSSxRQUFRLEtBQUssQ0FBQyxHQUFHSixPQUFPLEdBQUdLLFFBQVM7O0VBRTVGO0VBQ0E7O0VBRUE7RUFDQTtFQUNBO0VBQ0EsSUFBS04sUUFBUSxLQUFLTyxNQUFNLElBQUlQLFFBQVEsS0FBS00sUUFBUSxJQUFLTixRQUFRLENBQUNLLFFBQVEsSUFBSUwsUUFBUSxDQUFDSyxRQUFRLEtBQUssQ0FBRSxFQUFHO0lBQ2xHLElBQUksQ0FBQ0csU0FBUyxHQUFHLEVBQUU7SUFDbkJSLFFBQVEsR0FBRyxDQUFFQSxRQUFRLENBQUU7O0lBRTNCO0VBQ0EsQ0FBQyxNQUFNLElBQUssT0FBT0EsUUFBUSxLQUFLLFFBQVEsRUFBRztJQUN2QztJQUNBQSxRQUFRLEdBQUdKLEtBQUssQ0FBQ2EsVUFBVSxDQUFFVCxRQUFTLENBQUM7O0lBRXZDO0lBQ0EsSUFBS0osS0FBSyxDQUFDYyxJQUFJLENBQUNDLElBQUksQ0FBRVgsUUFBUyxDQUFDLEVBQUc7TUFDL0I7TUFDQUEsUUFBUSxHQUFHQSxRQUFRLENBQUNZLE9BQU8sQ0FBRWhCLEtBQUssQ0FBQ2lCLFFBQVEsRUFBRSxFQUFHLENBQUM7O01BRWpEO01BQ0E7TUFDQTtNQUNBLElBQUlDLEVBQUUsR0FBR1IsUUFBUSxDQUFDUyxhQUFhLENBQUUsTUFBTyxDQUFDO01BQ3JDRCxFQUFFLENBQUNFLFNBQVMsR0FBR2hCLFFBQVE7O01BRTNCO01BQ0FBLFFBQVEsR0FBR0osS0FBSyxDQUFDcUIsU0FBUyxDQUFFSCxFQUFFLENBQUNJLFFBQVMsQ0FBQztNQUV6Q0osRUFBRSxHQUFHLElBQUk7O01BRWI7SUFDQSxDQUFDLE1BQU07TUFDSCxJQUFJLENBQUNOLFNBQVMsR0FBR1IsUUFBUTtNQUN6QkEsUUFBUSxHQUFHSixLQUFLLENBQUNxQixTQUFTLENBQUUsSUFBSSxDQUFDYixRQUFRLENBQUNlLGdCQUFnQixDQUFFbkIsUUFBUyxDQUFFLENBQUM7SUFDNUU7O0lBRUo7RUFDQSxDQUFDLE1BQU0sSUFBS0EsUUFBUSxDQUFDb0IsTUFBTSxLQUFLQyxTQUFTLEVBQUc7SUFDeEMsSUFBSSxDQUFDYixTQUFTLEdBQUcsRUFBRTtJQUNuQlIsUUFBUSxHQUFHSixLQUFLLENBQUNxQixTQUFTLENBQUVqQixRQUFTLENBQUM7RUFDMUM7O0VBRUE7RUFDQSxJQUFJLENBQUNzQixPQUFPLEdBQUcsQ0FBQyxDQUFDOztFQUVqQjtFQUNBLElBQUksQ0FBQ0YsTUFBTSxHQUFHcEIsUUFBUSxDQUFDb0IsTUFBTTs7RUFFN0I7RUFDQSxLQUFNLElBQUlHLENBQUMsR0FBRyxJQUFJLENBQUNILE1BQU0sRUFBRUcsQ0FBQyxFQUFFLEdBQUk7SUFDOUIsSUFBSSxDQUFFQSxDQUFDLENBQUUsR0FBR3ZCLFFBQVEsQ0FBRXVCLENBQUMsQ0FBRTtFQUM3Qjs7RUFFQTtFQUNBO0VBQ0EsSUFBSSxDQUFDQyxPQUFPLENBQUU1QixLQUFLLENBQUM2QixRQUFTLENBQUM7QUFDbEMsQ0FBQzs7QUFHRDtBQUNBMUIsSUFBSSxDQUFDMkIsU0FBUyxDQUFDQyxNQUFNLEdBQUc3QixLQUFLLENBQUM2QixNQUFNOztBQUdwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTVCLElBQUksQ0FBQzJCLFNBQVMsQ0FBQ0UsSUFBSSxHQUFHOUIsS0FBSyxDQUFDMEIsT0FBTzs7QUFHbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0F6QixJQUFJLENBQUMyQixTQUFTLENBQUNGLE9BQU8sR0FBRzFCLEtBQUssQ0FBQzBCLE9BQU87O0FBR3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBekIsSUFBSSxDQUFDMkIsU0FBUyxDQUFDRyxJQUFJLEdBQUcvQixLQUFLLENBQUMrQixJQUFJOztBQUdoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTlCLElBQUksQ0FBQzJCLFNBQVMsQ0FBQ0ksR0FBRyxHQUFHaEMsS0FBSyxDQUFDZ0MsR0FBRzs7QUFHOUI7QUFDQUMsTUFBTSxDQUFDQyxPQUFPLEdBQUdqQyxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWhvYm8vbGliL0hvYm8uanM/NTQ0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbHMgPSByZXF1aXJlKCBcIi4vdXRpbHNcIiApLFxuICAgIGFycmF5ID0gW107XG5cblxuLyoqXG4gKlxuICogQGNsYXNzIEhvYm9cbiAqIEBjb25zdHJ1Y3RvclxuICogQGNsYXNzZGVzYyBBIHZlcnkgc21hbGwsIG1vZHVsYXIgRE9NIHV0aWxpdHkgZm9yIG1vZGVybiB3ZWIgYXBwcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgZ29vZHMgLSBTdHJpbmcsIEVsZW1lbnQsIENvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2VsZW1lbnR9IGNvbnRleHQgVGhlIEVsZW1lbnQgdXNlZCB0byBjYWxsIGBxdWVyeVNlbGVjdG9yQWxsYFxuICpcbiAqL1xudmFyIEhvYm8gPSBmdW5jdGlvbiAoIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuICAgIC8vIEhvYm8gdmVyc2lvbj9cbiAgICB0aGlzLl9ob2JvID0gdXRpbHMudmVyc2lvbjtcblxuICAgIC8vIEhvYm8gY29udGV4dFxuICAgIHRoaXMuX2NvbnRleHQgPSAoY29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDEgPyBjb250ZXh0IDogZG9jdW1lbnQpO1xuXG4gICAgLy8gSG9ibyBzZWxlY3RvciAvIGVsZW1lbnRzXG4gICAgLy8gSG9ibyBzdXBwb3J0cyBhIG1peGVkIHNlbGVjdG9yIGFyZ3VtZW50XG5cbiAgICAvLyBIYW5kbGUgV2luZG93XG4gICAgLy8gSGFuZGxlIERvY3VtZW50XG4gICAgLy8gSGFuZGxlIERPTUVsZW1lbnRcbiAgICBpZiAoIHNlbGVjdG9yID09PSB3aW5kb3cgfHwgc2VsZWN0b3IgPT09IGRvY3VtZW50IHx8IChzZWxlY3Rvci5ub2RlVHlwZSAmJiBzZWxlY3Rvci5ub2RlVHlwZSA9PT0gMSkgKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgc2VsZWN0b3IgPSBbIHNlbGVjdG9yIF07XG5cbiAgICAvLyBIYW5kbGUgU3RyaW5nXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgc3RyaW5nXG4gICAgICAgIHNlbGVjdG9yID0gdXRpbHMudHJpbVN0cmluZyggc2VsZWN0b3IgKTtcblxuICAgICAgICAvLyBIYW5kbGUgc3RyaW5nIGh0bWwgPT4gRWxlbWVudCBjcmVhdGlvblxuICAgICAgICBpZiAoIHV0aWxzLnJUYWcudGVzdCggc2VsZWN0b3IgKSApIHtcbiAgICAgICAgICAgIC8vIFRoZW4gcmVtb3ZlIHRoZSBkb2N0eXBlIC0gYDwhRE9DVFlQRSBodG1sPmBcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSggdXRpbHMuckRvY1R5cGUsIFwiXCIgKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgYGhvYm9gIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIER1bXAgdGhlIEhUTUwgcGF5bG9hZCBpbiB0aGUgYGhvYm9gIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGVsZW1lbnRzIGZyb20gdGhlIGBob2JvYCBlbGVtZW50XG4gICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImhvYm9cIiApO1xuICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHNlbGVjdG9yO1xuXG4gICAgICAgICAgICAvLyBGb3JtYXQgZWxlbWVudHMgYXMgYSB0cnVlIEFycmF5XG4gICAgICAgICAgICBzZWxlY3RvciA9IHV0aWxzLm1ha2VBcnJheSggZWwuY2hpbGRyZW4gKTtcblxuICAgICAgICAgICAgZWwgPSBudWxsO1xuXG4gICAgICAgIC8vIEhhbmRsZSBzdHJpbmcgc2VsZWN0b3JcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHV0aWxzLm1ha2VBcnJheSggdGhpcy5fY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApICk7XG4gICAgICAgIH1cblxuICAgIC8vIEhhbmRsZSBDb2xsZWN0aW9uOiBOb2RlTGlzdCwgSFRNTENvbGxlY3Rpb24sIEFycmF5XG4gICAgfSBlbHNlIGlmICggc2VsZWN0b3IubGVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgc2VsZWN0b3IgPSB1dGlscy5tYWtlQXJyYXkoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgLy8gSG9ibyBldmVudHM/XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgICAvLyBIb2JvIGxlbmd0aD9cbiAgICB0aGlzLmxlbmd0aCA9IHNlbGVjdG9yLmxlbmd0aDtcblxuICAgIC8vIEhvYm8gZWxlbWVudHM/XG4gICAgZm9yICggdmFyIGkgPSB0aGlzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgdGhpc1sgaSBdID0gc2VsZWN0b3JbIGkgXTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsIG1hcHBpbmcgb2YgZWFjaCBub2RlcyBkYXRhLlxuICAgIC8vIFRyYW5zZmVyIHtET01TdHJpbmdNYXB9ID0IHtob2JvRGF0YU1hcH1cbiAgICB0aGlzLmZvckVhY2goIHV0aWxzLm1ha2VEYXRhICk7XG59O1xuXG5cbi8vIFNoaW0gQXJyYXktbGlrZSBwcmVzZW50YXRpb24gaW4gY29uc29sZVxuSG9iby5wcm90b3R5cGUuc3BsaWNlID0gYXJyYXkuc3BsaWNlO1xuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1ldGhvZCBlYWNoXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgbWV0aG9kIGNhbGxlZCBvbiBlYWNoIGl0ZXJhdGlvblxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBkZXNjcmlwdGlvbiBNYWtlIHN1cmUgSG9ibyBpcyBpdGVyYWJsZSBsaWtlIGFuIEFycmF5XG4gKlxuICovXG5Ib2JvLnByb3RvdHlwZS5lYWNoID0gYXJyYXkuZm9yRWFjaDtcblxuXG4vKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgZm9yRWFjaFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIG1ldGhvZCBjYWxsZWQgb24gZWFjaCBpdGVyYXRpb25cbiAqIEBtZW1iZXJvZiBIb2JvXG4gKiBAZGVzY3JpcHRpb24gTWFrZSBzdXJlIEhvYm8gaXMgaXRlcmFibGUgbGlrZSBhbiBBcnJheVxuICpcbiAqL1xuSG9iby5wcm90b3R5cGUuZm9yRWFjaCA9IGFycmF5LmZvckVhY2g7XG5cblxuLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kIHB1c2hcbiAqIEBwYXJhbSB7P30gZWxlbWVudCBlbGVtZW50MSwgLi4uLCBlbGVtZW50TlxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBkZXNjcmlwdGlvbiBNYWtlIHN1cmUgSG9ibyBpcyBwdXNoYWJsZSBsaWtlIGFuIEFycmF5XG4gKlxuICovXG5Ib2JvLnByb3RvdHlwZS5wdXNoID0gYXJyYXkucHVzaDtcblxuXG4vKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgbWFwXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgbWV0aG9kIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50XG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQGRlc2NyaXB0aW9uIE1ha2Ugc3VyZSBIb2JvIGlzIG1hcHBhYmxlIGxpa2UgYW4gQXJyYXlcbiAqXG4gKi9cbkhvYm8ucHJvdG90eXBlLm1hcCA9IGFycmF5Lm1hcDtcblxuXG4vLyBFeHBvcnQgdGhlIG1haW4gSG9ibyBDbGFzcyA6RFxubW9kdWxlLmV4cG9ydHMgPSBIb2JvO1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsImFycmF5IiwiSG9ibyIsInNlbGVjdG9yIiwiY29udGV4dCIsIl9ob2JvIiwidmVyc2lvbiIsIl9jb250ZXh0Iiwibm9kZVR5cGUiLCJkb2N1bWVudCIsIndpbmRvdyIsIl9zZWxlY3RvciIsInRyaW1TdHJpbmciLCJyVGFnIiwidGVzdCIsInJlcGxhY2UiLCJyRG9jVHlwZSIsImVsIiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsIm1ha2VBcnJheSIsImNoaWxkcmVuIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsInVuZGVmaW5lZCIsIl9ldmVudHMiLCJpIiwiZm9yRWFjaCIsIm1ha2VEYXRhIiwicHJvdG90eXBlIiwic3BsaWNlIiwiZWFjaCIsInB1c2giLCJtYXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/Hobo.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/core/addClass.js":
/*!*********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/core/addClass.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method addClass\n * @description Add one or more classNames to the nodes.\n * @param {string} classes The space-separated classNames\n * @returns {Hobo}\n *\n */\nmodule.exports = function (classes) {\n  this.forEach(function (element) {\n    var newClass = classes.split(\" \"),\n      elsClass = utils.getClass(element).split(\" \");\n    newClass.forEach(function (klass) {\n      if (elsClass.indexOf(klass) === -1) {\n        elsClass.push(klass);\n      }\n    });\n    utils.setClass(element, utils.trimString(elsClass.join(\" \")));\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9hZGRDbGFzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxLQUFLLEdBQUdDLG1CQUFPLENBQUUsMkRBQVcsQ0FBQzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUMsTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBV0MsT0FBTyxFQUFHO0VBQ2xDLElBQUksQ0FBQ0MsT0FBTyxDQUFDLFVBQVdDLE9BQU8sRUFBRztJQUM5QixJQUFJQyxRQUFRLEdBQUdILE9BQU8sQ0FBQ0ksS0FBSyxDQUFFLEdBQUksQ0FBQztNQUMvQkMsUUFBUSxHQUFHVCxLQUFLLENBQUNVLFFBQVEsQ0FBRUosT0FBUSxDQUFDLENBQUNFLEtBQUssQ0FBRSxHQUFJLENBQUM7SUFFckRELFFBQVEsQ0FBQ0YsT0FBTyxDQUFDLFVBQVdNLEtBQUssRUFBRztNQUNoQyxJQUFLRixRQUFRLENBQUNHLE9BQU8sQ0FBRUQsS0FBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUc7UUFDcENGLFFBQVEsQ0FBQ0ksSUFBSSxDQUFFRixLQUFNLENBQUM7TUFDMUI7SUFDSixDQUFDLENBQUM7SUFFRlgsS0FBSyxDQUFDYyxRQUFRLENBQUVSLE9BQU8sRUFBRU4sS0FBSyxDQUFDZSxVQUFVLENBQUVOLFFBQVEsQ0FBQ08sSUFBSSxDQUFFLEdBQUksQ0FBRSxDQUFFLENBQUM7RUFDdkUsQ0FBQyxDQUFDO0VBRUYsT0FBTyxJQUFJO0FBQ2YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9jb3JlL2FkZENsYXNzLmpzPzM1MGIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWxzID0gcmVxdWlyZSggXCIuLi91dGlsc1wiICk7XG5cblxuLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBhZGRDbGFzc1xuICogQGRlc2NyaXB0aW9uIEFkZCBvbmUgb3IgbW9yZSBjbGFzc05hbWVzIHRvIHRoZSBub2Rlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc2VzIFRoZSBzcGFjZS1zZXBhcmF0ZWQgY2xhc3NOYW1lc1xuICogQHJldHVybnMge0hvYm99XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggY2xhc3NlcyApIHtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuICAgICAgICB2YXIgbmV3Q2xhc3MgPSBjbGFzc2VzLnNwbGl0KCBcIiBcIiApLFxuICAgICAgICAgICAgZWxzQ2xhc3MgPSB1dGlscy5nZXRDbGFzcyggZWxlbWVudCApLnNwbGl0KCBcIiBcIiApO1xuXG4gICAgICAgIG5ld0NsYXNzLmZvckVhY2goZnVuY3Rpb24gKCBrbGFzcyApIHtcbiAgICAgICAgICAgIGlmICggZWxzQ2xhc3MuaW5kZXhPZigga2xhc3MgKSA9PT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgZWxzQ2xhc3MucHVzaCgga2xhc3MgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdXRpbHMuc2V0Q2xhc3MoIGVsZW1lbnQsIHV0aWxzLnRyaW1TdHJpbmcoIGVsc0NsYXNzLmpvaW4oIFwiIFwiICkgKSApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJjbGFzc2VzIiwiZm9yRWFjaCIsImVsZW1lbnQiLCJuZXdDbGFzcyIsInNwbGl0IiwiZWxzQ2xhc3MiLCJnZXRDbGFzcyIsImtsYXNzIiwiaW5kZXhPZiIsInB1c2giLCJzZXRDbGFzcyIsInRyaW1TdHJpbmciLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/core/addClass.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/core/ajax.js":
/*!*****************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/core/ajax.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\nvar AjaxPromise = function AjaxPromise() {\n  var self = this;\n  this._promise = new Promise(function (resolve, reject) {\n    self._resolve = resolve;\n    self._reject = reject;\n  });\n};\nAjaxPromise.prototype.then = function (fn) {\n  this._then = fn;\n  return this;\n};\nAjaxPromise.prototype[\"catch\"] = function (fn) {\n  this._catch = fn;\n  return this;\n};\nAjaxPromise.prototype.resolve = function (arg) {\n  if (this._then) {\n    this._then(arg);\n    this._resolve(arg);\n  }\n  return this;\n};\nAjaxPromise.prototype.reject = function (err) {\n  if (this._catch) {\n    this._catch(err);\n    this._reject(err);\n  }\n  return this;\n};\nAjaxPromise.prototype.abort = function () {\n  if (this._xhr) {\n    this._reject(\"Rejecting on XMLHttpRequest.abort()\");\n    this._xhr.abort();\n  }\n  return this;\n};\n\n/**\n *\n * @static\n * @memberof Hobo\n * @method ajax\n * @description Perform standar XHR with a native Promise.\n *              dataType can be `html`, `json`, `jsonp`.\n * @param {object} config The ajax config object\n *                        url       => string, default: window.location.href\n *                        data      => object, default: null\n *                        dataType  => string, default: \"html\"\n *                        method    => string, default: \"GET\"\n *                        jsonp     => string, default: \"callback\"\n *                        headers   => object, default: null\n * @returns {Promise}\n *\n */\nmodule.exports = function (config) {\n  var params = config.data || null,\n    dataType = config.dataType || \"html\",\n    method = (config.method || \"GET\").toUpperCase(),\n    url = config.url || window.location.href,\n    headers = config.headers || null,\n    payload = config.payload || null,\n    ajaxPromise = new AjaxPromise();\n\n  // Handle params\n  // Params will be one of the following:\n  // Serialized querystring\n  // Instanceof FormData\n  // Null\n  if (params && !(FormData && params instanceof FormData)) {\n    params = utils.serializeData(config.data);\n  }\n\n  // Handle JSON payloads\n  if (payload && typeof payload !== \"string\") {\n    payload = JSON.stringify(payload);\n  }\n\n  // Handle params in GET URL\n  if (method === \"GET\" && params) {\n    url = \"?\"  params;\n  }\n\n  // Normalize response handling\n  var handleResponse = function handleResponse(response) {\n    if (dataType === \"json\") {\n      try {\n        response = JSON.parse(response);\n      } catch (error) {\n        // ajaxPromise.reject( (\"Rejecting on JSON.parse error : \"  error) );\n        ajaxPromise.reject(response);\n      }\n    }\n    ajaxPromise.resolve(response);\n  };\n\n  // JSONP\n  if (dataType === \"jsonp\") {\n    var jsonpCallbackValue = utils.makeId()  \"JSONP\",\n      jsonpCallbackKey = config.jsonp || \"callback\",\n      jsonpScript = document.createElement(\"script\");\n    jsonpScript.src = url  (/\\?/.test(url) ? \"&\" : \"?\")  jsonpCallbackKey  \"=\"  jsonpCallbackValue;\n    window[jsonpCallbackValue] = function (response) {\n      document.getElementsByTagName(\"head\")[0].removeChild(jsonpScript);\n      jsonpScript = null;\n      delete window[jsonpCallbackValue];\n      handleResponse(response);\n    };\n    document.getElementsByTagName(\"head\")[0].appendChild(jsonpScript);\n\n    // XHR\n  } else {\n    var xhr = new XMLHttpRequest();\n    xhr.open(method, url, true);\n    if (headers) {\n      for (var header in headers) {\n        if (headers.hasOwnProperty(header)) {\n          xhr.setRequestHeader(header, headers[header]);\n        }\n      }\n    }\n    xhr.onreadystatechange = function (e) {\n      if (this.readyState === 4) {\n        // Two-Hundo's are A-Okay with Hobo\n        if (/^20/.test(this.status)) {\n          handleResponse(this.responseText);\n        } else {\n          // ajaxPromise.reject( (\"Rejecting on server status code : \"  this.status) );\n          ajaxPromise.reject(this.responseText);\n        }\n      }\n    };\n    xhr.send(params || payload);\n    ajaxPromise._xhr = xhr;\n  }\n  return ajaxPromise;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9hamF4LmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLEtBQUssR0FBR0MsbUJBQU8sQ0FBRSwyREFBVyxDQUFDO0FBQ2pDLElBQUlDLFdBQVcsR0FBRyxTQUFkQSxXQUFXQSxDQUFBLEVBQWU7RUFDMUIsSUFBSUMsSUFBSSxHQUFHLElBQUk7RUFFZixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJQyxPQUFPLENBQUMsVUFBV0MsT0FBTyxFQUFFQyxNQUFNLEVBQUc7SUFDckRKLElBQUksQ0FBQ0ssUUFBUSxHQUFHRixPQUFPO0lBQ3ZCSCxJQUFJLENBQUNNLE9BQU8sR0FBR0YsTUFBTTtFQUN6QixDQUFDLENBQUM7QUFDTixDQUFDO0FBQ0RMLFdBQVcsQ0FBQ1EsU0FBUyxDQUFDQyxJQUFJLEdBQUcsVUFBV0MsRUFBRSxFQUFHO0VBQ3pDLElBQUksQ0FBQ0MsS0FBSyxHQUFHRCxFQUFFO0VBQ2YsT0FBTyxJQUFJO0FBQ2YsQ0FBQztBQUNEVixXQUFXLENBQUNRLFNBQVMsU0FBTSxHQUFHLFVBQVdFLEVBQUUsRUFBRztFQUMxQyxJQUFJLENBQUNFLE1BQU0sR0FBR0YsRUFBRTtFQUNoQixPQUFPLElBQUk7QUFDZixDQUFDO0FBQ0RWLFdBQVcsQ0FBQ1EsU0FBUyxDQUFDSixPQUFPLEdBQUcsVUFBV1MsR0FBRyxFQUFHO0VBQzdDLElBQUssSUFBSSxDQUFDRixLQUFLLEVBQUc7SUFDZCxJQUFJLENBQUNBLEtBQUssQ0FBRUUsR0FBSSxDQUFDO0lBQ2pCLElBQUksQ0FBQ1AsUUFBUSxDQUFFTyxHQUFJLENBQUM7RUFDeEI7RUFFQSxPQUFPLElBQUk7QUFDZixDQUFDO0FBQ0RiLFdBQVcsQ0FBQ1EsU0FBUyxDQUFDSCxNQUFNLEdBQUcsVUFBV1MsR0FBRyxFQUFHO0VBQzVDLElBQUssSUFBSSxDQUFDRixNQUFNLEVBQUc7SUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBRUUsR0FBSSxDQUFDO0lBQ2xCLElB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SSxHQUFHb0MsR0FBRztFQUMxQjtFQUVBLE9BQU9yQixXQUFXO0FBQ3RCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9hamF4LmpzPzFmZTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWxzID0gcmVxdWlyZSggXCIuLi91dGlsc1wiICk7XG52YXIgQWpheFByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uICggcmVzb2x2ZSwgcmVqZWN0ICkge1xuICAgICAgICBzZWxmLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgc2VsZi5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xufTtcbkFqYXhQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKCBmbiApIHtcbiAgICB0aGlzLl90aGVuID0gZm47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuQWpheFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKCBmbiApIHtcbiAgICB0aGlzLl9jYXRjaCA9IGZuO1xuICAgIHJldHVybiB0aGlzO1xufTtcbkFqYXhQcm9taXNlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKCBhcmcgKSB7XG4gICAgaWYgKCB0aGlzLl90aGVuICkge1xuICAgICAgICB0aGlzLl90aGVuKCBhcmcgKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSggYXJnICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuQWpheFByb21pc2UucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uICggZXJyICkge1xuICAgIGlmICggdGhpcy5fY2F0Y2ggKSB7XG4gICAgICAgIHRoaXMuX2NhdGNoKCBlcnIgKTtcbiAgICAgICAgdGhpcy5fcmVqZWN0KCBlcnIgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5BamF4UHJvbWlzZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCB0aGlzLl94aHIgKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdCggXCJSZWplY3Rpbmcgb24gWE1MSHR0cFJlcXVlc3QuYWJvcnQoKVwiICk7XG4gICAgICAgIHRoaXMuX3hoci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBhamF4XG4gKiBAZGVzY3JpcHRpb24gUGVyZm9ybSBzdGFuZGFyIFhIUiB3aXRoIGEgbmF0aXZlIFByb21pc2UuXG4gKiAgICAgICAgICAgICAgZGF0YVR5cGUgY2FuIGJlIGBodG1sYCwgYGpzb25gLCBganNvbnBgLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgYWpheCBjb25maWcgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHVybCAgICAgICA9PiBzdHJpbmcsIGRlZmF1bHQ6IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgICAgICA9PiBvYmplY3QsIGRlZmF1bHQ6IG51bGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGUgID0IHN0cmluZywgZGVmYXVsdDogXCJodG1sXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kICAgID0IHN0cmluZywgZGVmYXVsdDogXCJHRVRcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBqc29ucCAgICAgPT4gc3RyaW5nLCBkZWZhdWx0OiBcImNhbGxiYWNrXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyAgID0IG9iamVjdCwgZGVmYXVsdDogbnVsbFxuICogQHJldHVybnMge1Byb21pc2V9XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggY29uZmlnICkge1xuICAgIHZhciBwYXJhbXMgPSAoY29uZmlnLmRhdGEgfHwgbnVsbCksXG4gICAgICAgIGRhdGFUeXBlID0gKGNvbmZpZy5kYXRhVHlwZSB8fCBcImh0bWxcIiksXG4gICAgICAgIG1ldGhvZCA9IChjb25maWcubWV0aG9kIHx8IFwiR0VUXCIpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIHVybCA9IChjb25maWcudXJsIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxcbiAgICAgICAgaGVhZGVycyA9IChjb25maWcuaGVhZGVycyB8fCBudWxsKSxcbiAgICAgICAgcGF5bG9hZCA9IChjb25maWcucGF5bG9hZCB8fCBudWxsKSxcbiAgICAgICAgYWpheFByb21pc2UgPSBuZXcgQWpheFByb21pc2UoKTtcblxuICAgIC8vIEhhbmRsZSBwYXJhbXNcbiAgICAvLyBQYXJhbXMgd2lsbCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAvLyBTZXJpYWxpemVkIHF1ZXJ5c3RyaW5nXG4gICAgLy8gSW5zdGFuY2VvZiBGb3JtRGF0YVxuICAgIC8vIE51bGxcbiAgICBpZiAoIHBhcmFtcyAmJiAhKEZvcm1EYXRhICYmIHBhcmFtcyBpbnN0YW5jZW9mIEZvcm1EYXRhKSApIHtcbiAgICAgICAgcGFyYW1zID0gdXRpbHMuc2VyaWFsaXplRGF0YSggY29uZmlnLmRhdGEgKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgSlNPTiBwYXlsb2Fkc1xuICAgIGlmICggcGF5bG9hZCAmJiB0eXBlb2YgcGF5bG9hZCAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KCBwYXlsb2FkICk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHBhcmFtcyBpbiBHRVQgVVJMXG4gICAgaWYgKCBtZXRob2QgPT09IFwiR0VUXCIgJiYgcGFyYW1zICkge1xuICAgICAgICB1cmwgKz0gKFwiP1wiICsgcGFyYW1zKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgcmVzcG9uc2UgaGFuZGxpbmdcbiAgICB2YXIgaGFuZGxlUmVzcG9uc2UgPSBmdW5jdGlvbiAoIHJlc3BvbnNlICkge1xuICAgICAgICBpZiAoIGRhdGFUeXBlID09PSBcImpzb25cIiApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKCByZXNwb25zZSApO1xuXG4gICAgICAgICAgICB9IGNhdGNoICggZXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgLy8gYWpheFByb21pc2UucmVqZWN0KCAoXCJSZWplY3Rpbmcgb24gSlNPTi5wYXJzZSBlcnJvciA6IFwiICsgZXJyb3IpICk7XG4gICAgICAgICAgICAgICAgYWpheFByb21pc2UucmVqZWN0KCByZXNwb25zZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWpheFByb21pc2UucmVzb2x2ZSggcmVzcG9uc2UgKTtcbiAgICB9O1xuXG4gICAgLy8gSlNPTlBcbiAgICBpZiAoIGRhdGFUeXBlID09PSBcImpzb25wXCIgKSB7XG4gICAgICAgIHZhciBqc29ucENhbGxiYWNrVmFsdWUgPSAodXRpbHMubWFrZUlkKCkgKyBcIkpTT05QXCIpLFxuICAgICAgICAgICAganNvbnBDYWxsYmFja0tleSA9IChjb25maWcuanNvbnAgfHwgXCJjYWxsYmFja1wiKSxcbiAgICAgICAgICAgIGpzb25wU2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG4gICAgICAgIGpzb25wU2NyaXB0LnNyYyA9ICh1cmwgKyAoL1xcPy8udGVzdCggdXJsICkgPyBcIiZcIiA6IFwiP1wiKSArIGpzb25wQ2FsbGJhY2tLZXkgKyBcIj1cIiArIGpzb25wQ2FsbGJhY2tWYWx1ZSk7XG5cbiAgICAgICAgd2luZG93WyBqc29ucENhbGxiYWNrVmFsdWUgXSA9IGZ1bmN0aW9uICggcmVzcG9uc2UgKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJoZWFkXCIgKVsgMCBdLnJlbW92ZUNoaWxkKCBqc29ucFNjcmlwdCApO1xuICAgICAgICAgICAganNvbnBTY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlIHdpbmRvd1sganNvbnBDYWxsYmFja1ZhbHVlIF07XG5cbiAgICAgICAgICAgIGhhbmRsZVJlc3BvbnNlKCByZXNwb25zZSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImhlYWRcIiApWyAwIF0uYXBwZW5kQ2hpbGQoIGpzb25wU2NyaXB0ICk7XG5cbiAgICAvLyBYSFJcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgeGhyLm9wZW4oIG1ldGhvZCwgdXJsLCB0cnVlICk7XG5cbiAgICAgICAgaWYgKCBoZWFkZXJzICkge1xuICAgICAgICAgICAgZm9yICggdmFyIGhlYWRlciBpbiBoZWFkZXJzICkge1xuICAgICAgICAgICAgICAgIGlmICggaGVhZGVycy5oYXNPd25Qcm9wZXJ0eSggaGVhZGVyICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBoZWFkZXIsIGhlYWRlcnNbIGhlYWRlciBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICggZSApIHtcbiAgICAgICAgICAgIGlmICggdGhpcy5yZWFkeVN0YXRlID09PSA0ICkge1xuICAgICAgICAgICAgICAgIC8vIFR3by1IdW5kbydzIGFyZSBBLU9rYXkgd2l0aCBIb2JvXG4gICAgICAgICAgICAgICAgaWYgKCAvXjIwLy50ZXN0KCB0aGlzLnN0YXR1cyApICkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZXNwb25zZSggdGhpcy5yZXNwb25zZVRleHQgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFqYXhQcm9taXNlLnJlamVjdCggKFwiUmVqZWN0aW5nIG9uIHNlcnZlciBzdGF0dXMgY29kZSA6IFwiICsgdGhpcy5zdGF0dXMpICk7XG4gICAgICAgICAgICAgICAgICAgIGFqYXhQcm9taXNlLnJlamVjdCggdGhpcy5yZXNwb25zZVRleHQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgeGhyLnNlbmQoIChwYXJhbXMgfHwgcGF5bG9hZCkgKTtcblxuICAgICAgICBhamF4UHJvbWlzZS5feGhyID0geGhyO1xuICAgIH1cblxuICAgIHJldHVybiBhamF4UHJvbWlzZTtcbn07XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiQWpheFByb21pc2UiLCJzZWxmIiwiX3Byb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIl9yZXNvbHZlIiwiX3JlamVjdCIsInByb3RvdHlwZSIsInRoZW4iLCJmbiIsIl90aGVuIiwiX2NhdGNoIiwiYXJnIiwiZXJyIiwiYWJvcnQiLCJfeGhyIiwibW9kdWxlIiwiZXhwb3J0cyIsImNvbmZpZyIsInBhcmFtcyIsImRhdGEiLCJkYXRhVHlwZSIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwidXJsIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiaGVhZGVycyIsInBheWxvYWQiLCJhamF4UHJvbWlzZSIsIkZvcm1EYXRhIiwic2VyaWFsaXplRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYW5kbGVSZXNwb25zZSIsInJlc3BvbnNlIiwicGFyc2UiLCJlcnJvciIsImpzb25wQ2FsbGJhY2tWYWx1ZSIsIm1ha2VJZCIsImpzb25wQ2FsbGJhY2tLZXkiLCJqc29ucCIsImpzb25wU2NyaXB0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwidGVzdCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsImhlYWRlciIsImhhc093blByb3BlcnR5Iiwic2V0UmVxdWVzdEhlYWRlciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImUiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0Iiwic2VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/core/ajax.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/core/data.js":
/*!*****************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/core/data.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method data\n * @description Get / set data values with nodes.\n * @param {string} key The access key\n * @param {string} value The value to be stored\n * @returns {mixed}\n *\n */\nmodule.exports = function (key, value) {\n  // Any `non-unique` data keys resolve to the first unique occurrence\n  // Exactly how jQuery handles `.data( ... )` on multi-node collections\n\n  var ret = this,\n    obj = null;\n\n  // Storing data from an Object\n  if (_typeof(key) === \"object\") {\n    obj = key;\n    this.forEach(function (node) {\n      utils.storeData(obj, node);\n    });\n\n    // Storing data as a `key:value` pair\n  } else if (value) {\n    obj = {};\n    obj[key] = value;\n    this.forEach(function (node) {\n      utils.storeData(obj, node);\n    });\n\n    // Accessing data by `key`\n  } else if (key) {\n    this.forEach(function (node) {\n      if (obj !== null) {\n        return;\n      }\n      obj = utils.retrieveData(key, node);\n    });\n    ret = obj;\n\n    // Accessing all data\n    // Merges all `unique` data for a Hobo set\n  } else {\n    obj = {};\n\n    // Object is mutated here by `mergeData`\n    this.forEach(function (node) {\n      utils.mergeData(obj, node);\n    });\n    ret = obj;\n  }\n  return ret;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9kYXRhLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQSxLQUFLLEdBQUdDLG1CQUFPLENBQUUsMkRBQVcsQ0FBQzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxNQUFNLENBQUNDLE9BQU8sR0FBRyxVQUFXQyxHQUFHLEVBQUVDLEtBQUssRUFBRztFQUNyQztFQUNBOztFQUVBLElBQUlDLEdBQUcsR0FBRyxJQUFJO0lBQ1ZDLEdBQUcsR0FBRyxJQUFJOztFQUVkO0VBQ0EsSUFBS0MsT0FBQSxDQUFPSixHQUFHLE1BQUssUUFBUSxFQUFHO0lBQzNCRyxHQUFHLEdBQUdILEdBQUc7SUFFVCxJQUFJLENBQUNLLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7TUFDM0JWLEtBQUssQ0FBQ1csU0FBUyxDQUFFSixHQUFHLEVBQUVHLElBQUssQ0FBQztJQUNoQyxDQUFDLENBQUM7O0lBRU47RUFDQSxDQUFDLE1BQU0sSUFBS0wsS0FBSyxFQUFHO0lBQ2hCRSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ1JBLEdBQUcsQ0FBRUgsR0FBRyxDQUFFLEdBQUdDLEtBQUs7SUFFbEIsSUFBSSxDQUFDSSxPQUFPLENBQUMsVUFBV0MsSUFBSSxFQUFHO01BQzNCVixLQUFLLENBQUNXLFNBQVMsQ0FBRUosR0FBRyxFQUFFRyxJQUFLLENBQUM7SUFDaEMsQ0FBQyxDQUFDOztJQUVOO0VBQ0EsQ0FBQyxNQUFNLElBQUtOLEdBQUcsRUFBRztJQUNkLElBQUksQ0FBQ0ssT0FBTyxDQUFDLFVBQVdDLElBQUksRUFBRztNQUMzQixJQUFLSCxHQUFHLEtBQUssSUFBSSxFQUFHO1FBQ2hCO01BQ0o7TUFFQUEsR0FBRyxHQUFHUCxLQUFLLENBQUNZLFlBQVksQ0FBRVIsR0FBRyxFQUFFTSxJQUFLLENBQUM7SUFFekMsQ0FBQyxDQUFDO0lBRUZKLEdBQUcsR0FBR0MsR0FBRzs7SUFFYjtJQUNBO0VBQ0EsQ0FBQyxNQUFNO0lBQ0hBLEdBQUcsR0FBRyxDQUFDLENBQUM7O0lBRVI7SUFDQSxJQUFJLENBQUNFLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7TUFDM0JWLEtBQUssQ0FBQ2EsU0FBUyxDQUFFTixHQUFHLEVBQUVHLElBQUssQ0FBQztJQUNoQyxDQUFDLENBQUM7SUFFRkosR0FBRyxHQUFHQyxHQUFHO0VBQ2I7RUFFQSxPQUFPRCxHQUFHO0FBQ2QsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9jb3JlL2RhdGEuanM/Y2Y4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbHMgPSByZXF1aXJlKCBcIi4uL3V0aWxzXCIgKTtcblxuXG4vKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBIb2JvXG4gKiBAbWV0aG9kIGRhdGFcbiAqIEBkZXNjcmlwdGlvbiBHZXQgLyBzZXQgZGF0YSB2YWx1ZXMgd2l0aCBub2Rlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGFjY2VzcyBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgc3RvcmVkXG4gKiBAcmV0dXJucyB7bWl4ZWR9XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgga2V5LCB2YWx1ZSApIHtcbiAgICAvLyBBbnkgYG5vbi11bmlxdWVgIGRhdGEga2V5cyByZXNvbHZlIHRvIHRoZSBmaXJzdCB1bmlxdWUgb2NjdXJyZW5jZVxuICAgIC8vIEV4YWN0bHkgaG93IGpRdWVyeSBoYW5kbGVzIGAuZGF0YSggLi4uIClgIG9uIG11bHRpLW5vZGUgY29sbGVjdGlvbnNcblxuICAgIHZhciByZXQgPSB0aGlzLFxuICAgICAgICBvYmogPSBudWxsO1xuXG4gICAgLy8gU3RvcmluZyBkYXRhIGZyb20gYW4gT2JqZWN0XG4gICAgaWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICBvYmogPSBrZXk7XG5cbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICggbm9kZSApIHtcbiAgICAgICAgICAgIHV0aWxzLnN0b3JlRGF0YSggb2JqLCBub2RlICk7XG4gICAgICAgIH0pO1xuXG4gICAgLy8gU3RvcmluZyBkYXRhIGFzIGEgYGtleTp2YWx1ZWAgcGFpclxuICAgIH0gZWxzZSBpZiAoIHZhbHVlICkge1xuICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgb2JqWyBrZXkgXSA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgICAgICB1dGlscy5zdG9yZURhdGEoIG9iaiwgbm9kZSApO1xuICAgICAgICB9KTtcblxuICAgIC8vIEFjY2Vzc2luZyBkYXRhIGJ5IGBrZXlgXG4gICAgfSBlbHNlIGlmICgga2V5ICkge1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICAgICAgaWYgKCBvYmogIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmogPSB1dGlscy5yZXRyaWV2ZURhdGEoIGtleSwgbm9kZSApO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldCA9IG9iajtcblxuICAgIC8vIEFjY2Vzc2luZyBhbGwgZGF0YVxuICAgIC8vIE1lcmdlcyBhbGwgYHVuaXF1ZWAgZGF0YSBmb3IgYSBIb2JvIHNldFxuICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHt9O1xuXG4gICAgICAgIC8vIE9iamVjdCBpcyBtdXRhdGVkIGhlcmUgYnkgYG1lcmdlRGF0YWBcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICggbm9kZSApIHtcbiAgICAgICAgICAgIHV0aWxzLm1lcmdlRGF0YSggb2JqLCBub2RlICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldCA9IG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTsiXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImtleSIsInZhbHVlIiwicmV0Iiwib2JqIiwiX3R5cGVvZiIsImZvckVhY2giLCJub2RlIiwic3RvcmVEYXRhIiwicmV0cmlldmVEYXRhIiwibWVyZ2VEYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/core/data.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/core/find.js":
/*!*****************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/core/find.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n  utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method find\n * @description Query into a Hobo instance for new nodes.\n * @param {string} selector The selector to query for\n * @returns {Hobo}\n *\n */\nmodule.exports = function (selector) {\n  var ret = this;\n\n  // If we are `finding` within a multi-node collection...\n  // Here its probably faster to grab the nodes within each Node\n  // and then just let the context be the document for the new instance. \n  if (this.length > 1) {\n    ret = [];\n    this.forEach(function (node) {\n      ret = ret.concat(utils.makeArray(node.querySelectorAll(selector)));\n    });\n    ret = new Hobo(ret, null);\n\n    // Single node collection\n    // Empty node collection\n  } else {\n    ret = new Hobo(this.length ? selector : [], this.length ? this[0] : null);\n  }\n  return ret;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9maW5kLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLElBQUksR0FBR0MsbUJBQU8sQ0FBRSx5REFBVSxDQUFDO0VBQzNCQyxLQUFLLEdBQUdELG1CQUFPLENBQUUsMkRBQVcsQ0FBQzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUUsTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBV0MsUUFBUSxFQUFHO0VBQ25DLElBQUlDLEdBQUcsR0FBRyxJQUFJOztFQUVkO0VBQ0E7RUFDQTtFQUNBLElBQUssSUFBSSxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxFQUFHO0lBQ25CRCxHQUFHLEdBQUcsRUFBRTtJQUVSLElBQUksQ0FBQ0UsT0FBTyxDQUFDLFVBQVdDLElBQUksRUFBRztNQUMzQkgsR0FBRyxHQUFHQSxHQUFHLENBQUNJLE1BQU0sQ0FBRVIsS0FBSyxDQUFDUyxTQUFTLENBQUVGLElBQUksQ0FBQ0csZ0JBQWdCLENBQUVQLFFBQVMsQ0FBRSxDQUFFLENBQUM7SUFDNUUsQ0FBQyxDQUFDO0lBRUZDLEdBQUcsR0FBRyxJQUFJTixJQUFJLENBQUVNLEdBQUcsRUFBRSxJQUFLLENBQUM7O0lBRS9CO0lBQ0E7RUFDQSxDQUFDLE1BQU07SUFDSEEsR0FBRyxHQUFHLElBQUlOLElBQUksQ0FBRyxJQUFJLENBQUNPLE1BQU0sR0FBR0YsUUFBUSxHQUFHLEVBQUUsRUFBSSxJQUFJLENBQUNFLE1BQU0sR0FBRyxJQUFJLENBQUUsQ0FBQyxDQUFFLEdBQUcsSUFBTSxDQUFDO0VBQ3JGO0VBRUEsT0FBT0QsR0FBRztBQUNkLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9maW5kLmpzPzZiZmEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEhvYm8gPSByZXF1aXJlKCBcIi4uL0hvYm9cIiApLFxuICAgIHV0aWxzID0gcmVxdWlyZSggXCIuLi91dGlsc1wiICk7XG5cblxuLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBmaW5kXG4gKiBAZGVzY3JpcHRpb24gUXVlcnkgaW50byBhIEhvYm8gaW5zdGFuY2UgZm9yIG5ldyBub2Rlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgdG8gcXVlcnkgZm9yXG4gKiBAcmV0dXJucyB7SG9ib31cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcbiAgICB2YXIgcmV0ID0gdGhpcztcblxuICAgIC8vIElmIHdlIGFyZSBgZmluZGluZ2Agd2l0aGluIGEgbXVsdGktbm9kZSBjb2xsZWN0aW9uLi4uXG4gICAgLy8gSGVyZSBpdHMgcHJvYmFibHkgZmFzdGVyIHRvIGdyYWIgdGhlIG5vZGVzIHdpdGhpbiBlYWNoIE5vZGVcbiAgICAvLyBhbmQgdGhlbiBqdXN0IGxldCB0aGUgY29udGV4dCBiZSB0aGUgZG9jdW1lbnQgZm9yIHRoZSBuZXcgaW5zdGFuY2UuIFxuICAgIGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuICAgICAgICByZXQgPSBbXTtcblxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdCggdXRpbHMubWFrZUFycmF5KCBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoIHNlbGVjdG9yICkgKSApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXQgPSBuZXcgSG9ibyggcmV0LCBudWxsICk7XG5cbiAgICAvLyBTaW5nbGUgbm9kZSBjb2xsZWN0aW9uXG4gICAgLy8gRW1wdHkgbm9kZSBjb2xsZWN0aW9uXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IEhvYm8oICh0aGlzLmxlbmd0aCA/IHNlbGVjdG9yIDogW10pLCAodGhpcy5sZW5ndGggPyB0aGlzWyAwIF0gOiBudWxsKSApO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59OyJdLCJuYW1lcyI6WyJIb2JvIiwicmVxdWlyZSIsInV0aWxzIiwibW9kdWxlIiwiZXhwb3J0cyIsInNlbGVjdG9yIiwicmV0IiwibGVuZ3RoIiwiZm9yRWFjaCIsIm5vZGUiLCJjb25jYXQiLCJtYWtlQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/core/find.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/core/off.js":
/*!****************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/core/off.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n *\n * @private\n * @method unbind\n * @description Unbind a standard DOM Event.\n * @param {element} node\n * @param {string} event\n * @param {function} callback\n * @this {Hobo}\n *\n */\nvar unbind = function unbind(node, event, callback) {\n  var type, evo, id;\n\n  // Remove a single handler for an event type\n  if (callback) {\n    for (id in this._events[event]) {\n      if (this._events[event].hasOwnProperty(id)) {\n        evo = this._events[event][id];\n\n        // Match the nodes, Match the callback\n        if (evo.node === node && evo.callback === callback) {\n          node.removeEventListener(evo.type, evo.handler, false);\n          delete this._events[event][id];\n        }\n      }\n    }\n\n    // Remove all handlers for an event type\n  } else {\n    for (id in this._events[event]) {\n      if (this._events[event].hasOwnProperty(id)) {\n        evo = this._events[event][id];\n\n        // Match the nodes\n        if (evo.node === node) {\n          node.removeEventListener(evo.type, evo.handler, false);\n          delete this._events[event][id];\n        }\n      }\n    }\n  }\n};\n\n/**\n *\n * @private\n * @method teardown\n * @description Unbind all events for instance.\n * @param {element} node\n * @this {Hobo}\n *\n */\nvar teardown = function teardown(node) {\n  var type, evo, id;\n  for (type in this._events) {\n    if (this._events.hasOwnProperty(type)) {\n      for (id in this._events[type]) {\n        if (this._events[type].hasOwnProperty(id)) {\n          evo = this._events[type][id];\n\n          // Match the nodes\n          if (evo.node === node) {\n            node.removeEventListener(evo.type, evo.handler, false);\n            delete this._events[type][id];\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method off\n * @description Un-Bind a standard DOM Event.\n * @param {string} events The event type\n * @param {function} callback The supplied callback\n * @returns {Hobo}\n *\n */\nmodule.exports = function (events, callback) {\n  var self = this;\n\n  // Iterate over event(s)\n  // Space separated event list is supported\n  // Example: \"DOMMouseScroll mousewheel\"\n  // off() can be called with no args, account for this and remove ALL events\n  (events ? events.split(\" \") : [null]).forEach(function (event) {\n    self.forEach(function (node) {\n      // Explicit `null` check for teardown\n      if (event === null) {\n        teardown.call(self, node);\n      } else {\n        unbind.call(self, node, event, callback);\n      }\n    });\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9vZmYuanMiLCJuYW1lcyI6WyJ1bmJpbmQiLCJub2RlIiwiZXZlbnQiLCJjYWxsYmFjayIsInR5cGUiLCJldm8iLCJpZCIsIl9ldmVudHMiLCJoYXNPd25Qcm9wZXJ0eSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVyIiwidGVhcmRvd24iLCJtb2R1bGUiLCJleHBvcnRzIiwiZXZlbnRzIiwic2VsZiIsInNwbGl0IiwiZm9yRWFjaCIsImNhbGwiXSwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9jb3JlL29mZi5qcz80MzRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHVuYmluZFxuICogQGRlc2NyaXB0aW9uIFVuYmluZCBhIHN0YW5kYXJkIERPTSBFdmVudC5cbiAqIEBwYXJhbSB7ZWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHRoaXMge0hvYm99XG4gKlxuICovXG52YXIgdW5iaW5kID0gZnVuY3Rpb24gKCBub2RlLCBldmVudCwgY2FsbGJhY2sgKSB7XG4gICAgdmFyIHR5cGUsXG4gICAgICAgIGV2byxcbiAgICAgICAgaWQ7XG5cbiAgICAvLyBSZW1vdmUgYSBzaW5nbGUgaGFuZGxlciBmb3IgYW4gZXZlbnQgdHlwZVxuICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgIGZvciAoIGlkIGluIHRoaXMuX2V2ZW50c1sgZXZlbnQgXSApIHtcbiAgICAgICAgICAgIGlmICggdGhpcy5fZXZlbnRzWyBldmVudCBdLmhhc093blByb3BlcnR5KCBpZCApICkge1xuICAgICAgICAgICAgICAgIGV2byA9IHRoaXMuX2V2ZW50c1sgZXZlbnQgXVsgaWQgXTtcblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIHRoZSBub2RlcywgTWF0Y2ggdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKCBldm8ubm9kZSA9PT0gbm9kZSAmJiBldm8uY2FsbGJhY2sgPT09IGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGV2by50eXBlLCBldm8uaGFuZGxlciwgZmFsc2UgKTtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzWyBldmVudCBdWyBpZCBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBoYW5kbGVycyBmb3IgYW4gZXZlbnQgdHlwZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoIGlkIGluIHRoaXMuX2V2ZW50c1sgZXZlbnQgXSApIHtcbiAgICAgICAgICAgIGlmICggdGhpcy5fZXZlbnRzWyBldmVudCBdLmhhc093blByb3BlcnR5KCBpZCApICkge1xuICAgICAgICAgICAgICAgIGV2byA9IHRoaXMuX2V2ZW50c1sgZXZlbnQgXVsgaWQgXTtcblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIHRoZSBub2Rlc1xuICAgICAgICAgICAgICAgIGlmICggZXZvLm5vZGUgPT09IG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggZXZvLnR5cGUsIGV2by5oYW5kbGVyLCBmYWxzZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbIGV2ZW50IF1bIGlkIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCB0ZWFyZG93blxuICogQGRlc2NyaXB0aW9uIFVuYmluZCBhbGwgZXZlbnRzIGZvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7ZWxlbWVudH0gbm9kZVxuICogQHRoaXMge0hvYm99XG4gKlxuICovXG52YXIgdGVhcmRvd24gPSBmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgdmFyIHR5cGUsXG4gICAgICAgIGV2byxcbiAgICAgICAgaWQ7XG5cbiAgICBmb3IgKCB0eXBlIGluIHRoaXMuX2V2ZW50cyApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoIHR5cGUgKSApIHtcbiAgICAgICAgICAgIGZvciAoIGlkIGluIHRoaXMuX2V2ZW50c1sgdHlwZSBdICkge1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5fZXZlbnRzWyB0eXBlIF0uaGFzT3duUHJvcGVydHkoIGlkICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2byA9IHRoaXMuX2V2ZW50c1sgdHlwZSBdWyBpZCBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIHRoZSBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGV2by5ub2RlID09PSBub2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCBldm8udHlwZSwgZXZvLmhhbmRsZXIsIGZhbHNlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbIHR5cGUgXVsgaWQgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBvZmZcbiAqIEBkZXNjcmlwdGlvbiBVbi1CaW5kIGEgc3RhbmRhcmQgRE9NIEV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50cyBUaGUgZXZlbnQgdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIHN1cHBsaWVkIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7SG9ib31cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBldmVudHMsIGNhbGxiYWNrICkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVudChzKVxuICAgIC8vIFNwYWNlIHNlcGFyYXRlZCBldmVudCBsaXN0IGlzIHN1cHBvcnRlZFxuICAgIC8vIEV4YW1wbGU6IFwiRE9NTW91c2VTY3JvbGwgbW91c2V3aGVlbFwiXG4gICAgLy8gb2ZmKCkgY2FuIGJlIGNhbGxlZCB3aXRoIG5vIGFyZ3MsIGFjY291bnQgZm9yIHRoaXMgYW5kIHJlbW92ZSBBTEwgZXZlbnRzXG4gICAgKGV2ZW50cyA/IGV2ZW50cy5zcGxpdCggXCIgXCIgKSA6IFtudWxsXSkuZm9yRWFjaChmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICBzZWxmLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXQgYG51bGxgIGNoZWNrIGZvciB0ZWFyZG93blxuICAgICAgICAgICAgaWYgKCBldmVudCA9PT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICB0ZWFyZG93bi5jYWxsKCBzZWxmLCBub2RlICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5iaW5kLmNhbGwoIHNlbGYsIG5vZGUsIGV2ZW50LCBjYWxsYmFjayApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJQSxNQUFNLEdBQUcsU0FBVEEsTUFBTUEsQ0FBY0MsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRztFQUM1QyxJQUFJQyxJQUFJLEVBQ0pD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\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/core/off.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/core/on.js":
/*!***************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/core/on.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\"),\n  utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n/**\n *\n * @private\n * @method bind\n * @description Bind a standard DOM Event.\n * @param {element} node\n * @param {string} event\n * @param {string} selector\n * @param {function} callback\n * @this {Hobo}\n *\n */\nvar bind = function bind(node, event, selector, callback) {\n  // Unique ID for each node event\n  var eventId = utils.makeId()  \"EVENT\",\n    // The true event name\n    eventType = event,\n    // Normalize event handler with a small wrapper function\n    eventHandler = function eventHandler(e) {\n      // Default context is `this` element\n      var context = selector ? matchElement(e.target, selector, true) : this;\n\n      // Handle `mouseenter` and `mouseleave`\n      if (event === \"mouseenter\" || event === \"mouseleave\") {\n        var relatedElement = event === \"mouseenter\" ? e.fromElement : e.toElement;\n        if (context && relatedElement !== context && !context.contains(relatedElement)) {\n          callback.call(context, e);\n        }\n\n        // Fire callback if context element\n      } else if (context) {\n        callback.call(context, e);\n      }\n    };\n\n  // Support `mouseenter` and `mouseleave`\n  if (event === \"mouseenter\") {\n    eventType = \"mouseover\";\n  } else if (event === \"mouseleave\") {\n    eventType = \"mouseout\";\n  }\n\n  // Each handler/callback pair gets stored in an `events` index\n  this._events[event][eventId] = {\n    id: eventId,\n    type: eventType,\n    node: node,\n    handler: eventHandler,\n    callback: callback\n  };\n  node.addEventListener(eventType, eventHandler, false);\n};\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method on\n * @description Bind a standard DOM Event. Honor delegation as a primary.\n * @param {string} events \n * @param {string} selector \n * @param {function} callback\n * @returns {Hobo}\n *\n */\nmodule.exports = function (events, selector, callback) {\n  var self = this;\n\n  // Normalize `selector` and `callback`\n  if (!callback) {\n    callback = selector;\n    selector = this._selector;\n  }\n\n  // Iterate over event(s)\n  // Space separated event list is supported\n  // Example: \"DOMMouseScroll mousewheel\"\n  events.split(\" \").forEach(function (event) {\n    // Does this event type have an index yet\n    if (!self._events[event]) {\n      self._events[event] = {};\n    }\n    self.forEach(function (node) {\n      bind.call(self, node, event, selector, callback);\n    });\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9vbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxZQUFZLEdBQUdDLG1CQUFPLENBQUUsOEdBQXdCLENBQUM7RUFDakRDLEtBQUssR0FBR0QsbUJBQU8sQ0FBRSwyREFBVyxDQUFDOztBQUdqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJRSxJQUFJLEdBQUcsU0FBUEEsSUFBSUEsQ0FBY0MsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFHO0VBQ3BEO0VBQ0EsSUFBSUMsT0FBTyxHQUFJTixLQUFLLENBQUNPLE1BQU0sQ0FBQyxDQUFDLEdBQUcsT0FBUTtJQUVwQztJQUNBQyxTQUFTLEdBQUdMLEtBQUs7SUFFakI7SUFDQU0sWUFBWSxHQUFHLFNBQWZBLFlBQVlBLENBQWNDLENBQUMsRUFBRztNQUMxQjtNQUNBLElBQUlDLE9BQU8sR0FBSVAsUUFBUSxHQUFHTixZQUFZLENBQUVZLENBQUMsQ0FBQ0UsTUFBTSxFQUFFUixRQUFRLEVBQUUsSUFBSyxDQUFDLEdBQUcsSUFBSzs7TUFFMUU7TUFDQSxJQUFLRCxLQUFLLEtBQUssWUFBWSxJQUFJQSxLQUFLLEtBQUssWUFBWSxFQUFHO1FBQ3BELElBQUlVLGNBQWMsR0FBSVYsS0FBSyxLQUFLLFlBQVksR0FBR08sQ0FBQyxDQUFDSSxXQUFXLEdBQUdKLENBQUMsQ0FBQ0ssU0FBVTtRQUUzRSxJQUFLSixPQUFPLElBQU1FLGNBQWMsS0FBS0YsT0FBTyxJQUFJLENBQUNBLE9BQU8sQ0FBQ0ssUUFBUSxDQUFFSCxjQUFlLENBQUcsRUFBRztVQUNwRlIsUUFBUSxDQUFDWSxJQUFJLENBQUVOLE9BQU8sRUFBRUQsQ0FBRSxDQUFDO1FBQy9COztRQUVKO01BQ0EsQ0FBQyxNQUFNLElBQUtDLE9BQU8sRUFBRztRQUNsQk4sUUFBUSxDQUFDWSxJQUFJLENBQUVOLE9BQU8sRUFBRUQsQ0FBRSxDQUFDO01BQy9CO0lBQ0osQ0FBQzs7RUFFTDtFQUNBLElBQUtQLEtBQUssS0FBSyxZQUFZLEVBQUc7SUFDMUJLLFNBQVMsR0FBRyxXQUFXO0VBRTNCLENBQUMsTUFBTSxJQUFLTCxLQUFLLEtBQUssWUFBWSxFQUFHO0lBQ2pDSyxTQUFTLEdBQUcsVUFBVTtFQUMxQjs7RUFFQTtFQUNBLElBQUksQ0FBQ1UsT0FBTyxDQUFFZixLQUFLLENBQUUsQ0FBRUcsT0FBTyxDQUFFLEdBQUc7SUFDL0JhLEVBQUUsRUFBRWIsT0FBTztJQUNYYyxJQUFJLEVBQUVaLFNBQVM7SUFDZk4sSUFBSSxFQUFFQSxJQUFJO0lBQ1ZtQixPQUFPLEVBQUVaLFlBQVk7SUFDckJKLFFBQVEsRUFBRUE7RUFDZCxDQUFDO0VBRURILElBQUksQ0FBQ29CLGdCQUFnQixDQUFFZCxTQUFTLEVBQUVDLFlBQVksRUFBRSxLQUFNLENBQUM7QUFDM0QsQ0FBQzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQWMsTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBV0MsTUFBTSxFQUFFckIsUUFBUSxFQUFFQyxRQUFRLEVBQUc7RUFDckQsSUFBSXFCLElBQUksR0FBRyxJQUFJOztFQUVmO0VBQ0EsSUFBSyxDQUFDckIsUUFBUSxFQUFHO0lBQ2JBLFFBQVEsR0FBR0QsUUFBUTtJQUNuQkEsUUFBUSxHQUFHLElBQUksQ0FBQ3VCLFNBQVM7RUFDN0I7O0VBRUE7RUFDQTtFQUNBO0VBQ0FGLE1BQU0sQ0FBQ0csS0FBSyxDQUFFLEdBQUksQ0FBQyxDQUFDQyxPQUFPLENBQUMsVUFBVzFCLEtBQUssRUFBRztJQUMzQztJQUNBLElBQUssQ0FBQ3VCLElBQUksQ0FBQ1IsT0FBTyxDQUFFZixLQUFLLENBQUUsRUFBRztNQUMxQnVCLElBQUksQ0FBQ1IsT0FBTyxDQUFFZixLQUFLLENBQUUsR0FBRyxDQUFDLENBQUM7SUFDOUI7SUFFQXVCLElBQUksQ0FBQ0csT0FBTyxDQUFDLFVBQVczQixJQUFJLEVBQUc7TUFDM0JELElBQUksQ0FBQ2dCLElBQUksQ0FBRVMsSUFBSSxFQUFFeEIsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsUUFBUyxDQUFDO0lBQ3RELENBQUMsQ0FBQztFQUNOLENBQUMsQ0FBQztFQUVGLE9BQU8sSUFBSTtBQUNmLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9vbi5qcz80YmFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBtYXRjaEVsZW1lbnQgPSByZXF1aXJlKCBcInByb3BlcmpzLW1hdGNoZWxlbWVudFwiICksXG4gICAgdXRpbHMgPSByZXF1aXJlKCBcIi4uL3V0aWxzXCIgKTtcblxuXG4vKipcbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBiaW5kXG4gKiBAZGVzY3JpcHRpb24gQmluZCBhIHN0YW5kYXJkIERPTSBFdmVudC5cbiAqIEBwYXJhbSB7ZWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAdGhpcyB7SG9ib31cbiAqXG4gKi9cbnZhciBiaW5kID0gZnVuY3Rpb24gKCBub2RlLCBldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrICkge1xuICAgIC8vIFVuaXF1ZSBJRCBmb3IgZWFjaCBub2RlIGV2ZW50XG4gICAgdmFyIGV2ZW50SWQgPSAodXRpbHMubWFrZUlkKCkgKyBcIkVWRU5UXCIpLFxuXG4gICAgICAgIC8vIFRoZSB0cnVlIGV2ZW50IG5hbWVcbiAgICAgICAgZXZlbnRUeXBlID0gZXZlbnQsXG5cbiAgICAgICAgLy8gTm9ybWFsaXplIGV2ZW50IGhhbmRsZXIgd2l0aCBhIHNtYWxsIHdyYXBwZXIgZnVuY3Rpb25cbiAgICAgICAgZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKCBlICkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBjb250ZXh0IGlzIGB0aGlzYCBlbGVtZW50XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IChzZWxlY3RvciA/IG1hdGNoRWxlbWVudCggZS50YXJnZXQsIHNlbGVjdG9yLCB0cnVlICkgOiB0aGlzKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIGBtb3VzZWVudGVyYCBhbmQgYG1vdXNlbGVhdmVgXG4gICAgICAgICAgICBpZiAoIGV2ZW50ID09PSBcIm1vdXNlZW50ZXJcIiB8fCBldmVudCA9PT0gXCJtb3VzZWxlYXZlXCIgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0ZWRFbGVtZW50ID0gKGV2ZW50ID09PSBcIm1vdXNlZW50ZXJcIiA/IGUuZnJvbUVsZW1lbnQgOiBlLnRvRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGNvbnRleHQgJiYgKCByZWxhdGVkRWxlbWVudCAhPT0gY29udGV4dCAmJiAhY29udGV4dC5jb250YWlucyggcmVsYXRlZEVsZW1lbnQgKSApICkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKCBjb250ZXh0LCBlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlIGNhbGxiYWNrIGlmIGNvbnRleHQgZWxlbWVudFxuICAgICAgICAgICAgfSBlbHNlIGlmICggY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKCBjb250ZXh0LCBlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAvLyBTdXBwb3J0IGBtb3VzZWVudGVyYCBhbmQgYG1vdXNlbGVhdmVgXG4gICAgaWYgKCBldmVudCA9PT0gXCJtb3VzZWVudGVyXCIgKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9IFwibW91c2VvdmVyXCI7XG5cbiAgICB9IGVsc2UgaWYgKCBldmVudCA9PT0gXCJtb3VzZWxlYXZlXCIgKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9IFwibW91c2VvdXRcIjtcbiAgICB9XG5cbiAgICAvLyBFYWNoIGhhbmRsZXIvY2FsbGJhY2sgcGFpciBnZXRzIHN0b3JlZCBpbiBhbiBgZXZlbnRzYCBpbmRleFxuICAgIHRoaXMuX2V2ZW50c1sgZXZlbnQgXVsgZXZlbnRJZCBdID0ge1xuICAgICAgICBpZDogZXZlbnRJZCxcbiAgICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBoYW5kbGVyOiBldmVudEhhbmRsZXIsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgIH07XG5cbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50VHlwZSwgZXZlbnRIYW5kbGVyLCBmYWxzZSApO1xufTtcblxuXG4vKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBIb2JvXG4gKiBAbWV0aG9kIG9uXG4gKiBAZGVzY3JpcHRpb24gQmluZCBhIHN0YW5kYXJkIERPTSBFdmVudC4gSG9ub3IgZGVsZWdhdGlvbiBhcyBhIHByaW1hcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRzIFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrICkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIE5vcm1hbGl6ZSBgc2VsZWN0b3JgIGFuZCBgY2FsbGJhY2tgXG4gICAgaWYgKCAhY2FsbGJhY2sgKSB7XG4gICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gdGhpcy5fc2VsZWN0b3I7XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZW50KHMpXG4gICAgLy8gU3BhY2Ugc2VwYXJhdGVkIGV2ZW50IGxpc3QgaXMgc3VwcG9ydGVkXG4gICAgLy8gRXhhbXBsZTogXCJET01Nb3VzZVNjcm9sbCBtb3VzZXdoZWVsXCJcbiAgICBldmVudHMuc3BsaXQoIFwiIFwiICkuZm9yRWFjaChmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICAvLyBEb2VzIHRoaXMgZXZlbnQgdHlwZSBoYXZlIGFuIGluZGV4IHlldFxuICAgICAgICBpZiAoICFzZWxmLl9ldmVudHNbIGV2ZW50IF0gKSB7XG4gICAgICAgICAgICBzZWxmLl9ldmVudHNbIGV2ZW50IF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZm9yRWFjaChmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgICAgICBiaW5kLmNhbGwoIHNlbGYsIG5vZGUsIGV2ZW50LCBzZWxlY3RvciwgY2FsbGJhY2sgKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07Il0sIm5hbWVzIjpbIm1hdGNoRWxlbWVudCIsInJlcXVpcmUiLCJ1dGlscyIsImJpbmQiLCJub2RlIiwiZXZlbnQiLCJzZWxlY3RvciIsImNhbGxiYWNrIiwiZXZlbnRJZCIsIm1ha2VJZCIsImV2ZW50VHlwZSIsImV2ZW50SGFuZGxlciIsImUiLCJjb250ZXh0IiwidGFyZ2V0IiwicmVsYXRlZEVsZW1lbnQiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsImNvbnRhaW5zIiwiY2FsbCIsIl9ldmVudHMiLCJpZCIsInR5cGUiLCJoYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJldmVudHMiLCJzZWxmIiwiX3NlbGVjdG9yIiwic3BsaXQiLCJmb3JFYWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/core/on.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/core/removeClass.js":
/*!************************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/core/removeClass.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method removeClass\n * @description Remove one or more classNames from the nodes.\n * @param {string} classes The space-separated classNames\n * @returns {Hobo}\n *\n */\nmodule.exports = function (classes) {\n  this.forEach(function (element) {\n    // Explicit check for `undefined`\n    // Using `!classes` would be bad in this case\n    // Calling `removeClass( \"\" )` should not wipe the entire className\n    if (classes === undefined) {\n      utils.setClass(element, \"\");\n    } else {\n      var oldClass = classes.split(\" \"),\n        elsClass = utils.getClass(element).split(\" \");\n      oldClass.forEach(function (klass) {\n        if (elsClass.indexOf(klass) !== -1) {\n          elsClass.splice(elsClass.indexOf(klass), 1);\n        }\n      });\n      utils.setClass(element, utils.trimString(elsClass.join(\" \")));\n    }\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvY29yZS9yZW1vdmVDbGFzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxLQUFLLEdBQUdDLG1CQUFPLENBQUUsMkRBQVcsQ0FBQzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUMsTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBV0MsT0FBTyxFQUFHO0VBQ2xDLElBQUksQ0FBQ0MsT0FBTyxDQUFDLFVBQVdDLE9BQU8sRUFBRztJQUM5QjtJQUNBO0lBQ0E7SUFDQSxJQUFLRixPQUFPLEtBQUtHLFNBQVMsRUFBRztNQUN6QlAsS0FBSyxDQUFDUSxRQUFRLENBQUVGLE9BQU8sRUFBRSxFQUFHLENBQUM7SUFFakMsQ0FBQyxNQUFNO01BQ0gsSUFBSUcsUUFBUSxHQUFHTCxPQUFPLENBQUNNLEtBQUssQ0FBRSxHQUFJLENBQUM7UUFDL0JDLFFBQVEsR0FBR1gsS0FBSyxDQUFDWSxRQUFRLENBQUVOLE9BQVEsQ0FBQyxDQUFDSSxLQUFLLENBQUUsR0FBSSxDQUFDO01BRXJERCxRQUFRLENBQUNKLE9BQU8sQ0FBQyxVQUFXUSxLQUFLLEVBQUc7UUFDaEMsSUFBS0YsUUFBUSxDQUFDRyxPQUFPLENBQUVELEtBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFHO1VBQ3BDRixRQUFRLENBQUNJLE1BQU0sQ0FBRUosUUFBUSxDQUFDRyxPQUFPLENBQUVELEtBQU0sQ0FBQyxFQUFFLENBQUUsQ0FBQztRQUNuRDtNQUNKLENBQUMsQ0FBQztNQUVGYixLQUFLLENBQUNRLFFBQVEsQ0FBRUYsT0FBTyxFQUFFTixLQUFLLENBQUNnQixVQUFVLENBQUVMLFFBQVEsQ0FBQ00sSUFBSSxDQUFFLEdBQUksQ0FBRSxDQUFFLENBQUM7SUFDdkU7RUFDSixDQUFDLENBQUM7RUFFRixPQUFPLElBQUk7QUFDZixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWhvYm8vbGliL2NvcmUvcmVtb3ZlQ2xhc3MuanM/ODJlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbHMgPSByZXF1aXJlKCBcIi4uL3V0aWxzXCIgKTtcblxuXG4vKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBIb2JvXG4gKiBAbWV0aG9kIHJlbW92ZUNsYXNzXG4gKiBAZGVzY3JpcHRpb24gUmVtb3ZlIG9uZSBvciBtb3JlIGNsYXNzTmFtZXMgZnJvbSB0aGUgbm9kZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBUaGUgc3BhY2Utc2VwYXJhdGVkIGNsYXNzTmFtZXNcbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIGNsYXNzZXMgKSB7XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICggZWxlbWVudCApIHtcbiAgICAgICAgLy8gRXhwbGljaXQgY2hlY2sgZm9yIGB1bmRlZmluZWRgXG4gICAgICAgIC8vIFVzaW5nIGAhY2xhc3Nlc2Agd291bGQgYmUgYmFkIGluIHRoaXMgY2FzZVxuICAgICAgICAvLyBDYWxsaW5nIGByZW1vdmVDbGFzcyggXCJcIiApYCBzaG91bGQgbm90IHdpcGUgdGhlIGVudGlyZSBjbGFzc05hbWVcbiAgICAgICAgaWYgKCBjbGFzc2VzID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICB1dGlscy5zZXRDbGFzcyggZWxlbWVudCwgXCJcIiApO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb2xkQ2xhc3MgPSBjbGFzc2VzLnNwbGl0KCBcIiBcIiApLFxuICAgICAgICAgICAgICAgIGVsc0NsYXNzID0gdXRpbHMuZ2V0Q2xhc3MoIGVsZW1lbnQgKS5zcGxpdCggXCIgXCIgKTtcblxuICAgICAgICAgICAgb2xkQ2xhc3MuZm9yRWFjaChmdW5jdGlvbiAoIGtsYXNzICkge1xuICAgICAgICAgICAgICAgIGlmICggZWxzQ2xhc3MuaW5kZXhPZigga2xhc3MgKSAhPT0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsc0NsYXNzLnNwbGljZSggZWxzQ2xhc3MuaW5kZXhPZigga2xhc3MgKSwgMSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB1dGlscy5zZXRDbGFzcyggZWxlbWVudCwgdXRpbHMudHJpbVN0cmluZyggZWxzQ2xhc3Muam9pbiggXCIgXCIgKSApICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2xhc3NlcyIsImZvckVhY2giLCJlbGVtZW50IiwidW5kZWZpbmVkIiwic2V0Q2xhc3MiLCJvbGRDbGFzcyIsInNwbGl0IiwiZWxzQ2xhc3MiLCJnZXRDbGFzcyIsImtsYXNzIiwiaW5kZXhPZiIsInNwbGljZSIsInRyaW1TdHJpbmciLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/core/removeClass.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/append.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method append\n * @param {mixed} appendage What to append? Hobo, Element...\n * @description Append the nodes to the DOM\n * @returns {Hobo}\n *\n */\nmodule.exports = function (appendage) {\n  // Selector string, wrap in new Hobo instance\n  if (typeof appendage === \"string\") {\n    appendage = new Hobo(appendage);\n  }\n  this.forEach(function (node) {\n    // Hobo instance OR Array OR Array-like object with forEach\n    if (appendage instanceof Hobo || appendage.length && typeof appendage.forEach === \"function\") {\n      appendage.forEach(function (append) {\n        if (append.nodeType && append.nodeType === 1) {\n          node.appendChild(append);\n        }\n      });\n    } else if (appendage.nodeType) {\n      node.appendChild(appendage);\n    }\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvYXBwZW5kLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLElBQUksR0FBR0MsbUJBQU8sQ0FBRSx5REFBVSxDQUFDOztBQUcvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxNQUFNLENBQUNDLE9BQU8sR0FBRyxVQUFXQyxTQUFTLEVBQUc7RUFDcEM7RUFDQSxJQUFLLE9BQU9BLFNBQVMsS0FBSyxRQUFRLEVBQUc7SUFDakNBLFNBQVMsR0FBRyxJQUFJSixJQUFJLENBQUVJLFNBQVUsQ0FBQztFQUNyQztFQUVBLElBQUksQ0FBQ0MsT0FBTyxDQUFDLFVBQVdDLElBQUksRUFBRztJQUMzQjtJQUNBLElBQUtGLFNBQVMsWUFBWUosSUFBSSxJQUFLSSxTQUFTLENBQUNHLE1BQU0sSUFBSSxPQUFPSCxTQUFTLENBQUNDLE9BQU8sS0FBSyxVQUFXLEVBQUc7TUFDOUZELFNBQVMsQ0FBQ0MsT0FBTyxDQUFDLFVBQVdHLE1BQU0sRUFBRztRQUNsQyxJQUFLQSxNQUFNLENBQUNDLFFBQVEsSUFBSUQsTUFBTSxDQUFDQyxRQUFRLEtBQUssQ0FBQyxFQUFHO1VBQzVDSCxJQUFJLENBQUNJLFdBQVcsQ0FBRUYsTUFBTyxDQUFDO1FBQzlCO01BQ0osQ0FBQyxDQUFDO0lBRU4sQ0FBQyxNQUFNLElBQUtKLFNBQVMsQ0FBQ0ssUUFBUSxFQUFHO01BQzdCSCxJQUFJLENBQUNJLFdBQVcsQ0FBRU4sU0FBVSxDQUFDO0lBQ2pDO0VBQ0osQ0FBQyxDQUFDO0VBRUYsT0FBTyxJQUFJO0FBQ2YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC9hcHBlbmQuanM/OTAzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSG9ibyA9IHJlcXVpcmUoIFwiLi4vSG9ib1wiICk7XG5cblxuLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBhcHBlbmRcbiAqIEBwYXJhbSB7bWl4ZWR9IGFwcGVuZGFnZSBXaGF0IHRvIGFwcGVuZD8gSG9ibywgRWxlbWVudC4uLlxuICogQGRlc2NyaXB0aW9uIEFwcGVuZCB0aGUgbm9kZXMgdG8gdGhlIERPTVxuICogQHJldHVybnMge0hvYm99XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggYXBwZW5kYWdlICkge1xuICAgIC8vIFNlbGVjdG9yIHN0cmluZywgd3JhcCBpbiBuZXcgSG9ibyBpbnN0YW5jZVxuICAgIGlmICggdHlwZW9mIGFwcGVuZGFnZSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgYXBwZW5kYWdlID0gbmV3IEhvYm8oIGFwcGVuZGFnZSApO1xuICAgIH1cblxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgIC8vIEhvYm8gaW5zdGFuY2UgT1IgQXJyYXkgT1IgQXJyYXktbGlrZSBvYmplY3Qgd2l0aCBmb3JFYWNoXG4gICAgICAgIGlmICggYXBwZW5kYWdlIGluc3RhbmNlb2YgSG9ibyB8fCAoYXBwZW5kYWdlLmxlbmd0aCAmJiB0eXBlb2YgYXBwZW5kYWdlLmZvckVhY2ggPT09IFwiZnVuY3Rpb25cIikgKSB7XG4gICAgICAgICAgICBhcHBlbmRhZ2UuZm9yRWFjaChmdW5jdGlvbiAoIGFwcGVuZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGFwcGVuZC5ub2RlVHlwZSAmJiBhcHBlbmQubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoIGFwcGVuZCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIGFwcGVuZGFnZS5ub2RlVHlwZSApIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoIGFwcGVuZGFnZSApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG4iXSwibmFtZXMiOlsiSG9ibyIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiYXBwZW5kYWdlIiwiZm9yRWFjaCIsIm5vZGUiLCJsZW5ndGgiLCJhcHBlbmQiLCJub2RlVHlwZSIsImFwcGVuZENoaWxkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/append.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/attr.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method addAttr\n * @param {element} node The element to set attribute on\n * @param {string} key The attribute\n * @param {mixed} value The value to set\n * @description Get or Set an attribute(s) on a DOM node\n * @returns {string}\n *\n */\nvar addAttr = function addAttr(node, key, value) {\n  node.setAttribute(key, value);\n\n  // Apply data()?\n  if (utils.rData.test(key)) {\n    // storeData expects a {data object}\n    var obj = {};\n    obj[key.replace(utils.rData, \"\")] = value;\n    utils.storeData(obj, node);\n  }\n};\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method attr\n * @param {string} key The attribute\n * @param {mixed} value The value to set\n * @description Get or Set an attribute(s) on a DOM node\n * @returns {string}\n *\n */\nmodule.exports = function (key, value) {\n  var ret = this;\n\n  // Value can be an {object}\n  if (_typeof(key) === \"object\") {\n    for (var i in key) {\n      this.forEach(function (node) {\n        addAttr(node, i, key[i]);\n      });\n    }\n\n    // Value could possibly be \"\" or 0\n  } else if (value !== undefined) {\n    this.forEach(function (node) {\n      addAttr(node, key, value);\n    });\n  } else {\n    ret = this[0].getAttribute(key);\n  }\n  return ret;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvYXR0ci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsSUFBSUEsS0FBSyxHQUFHQyxtQkFBTyxDQUFFLDJEQUFXLENBQUM7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLE9BQU8sR0FBRyxTQUFWQSxPQUFPQSxDQUFjQyxJQUFJLEVBQUVDLEdBQUcsRUFBRUMsS0FBSyxFQUFHO0VBQ3hDRixJQUFJLENBQUNHLFlBQVksQ0FBRUYsR0FBRyxFQUFFQyxLQUFNLENBQUM7O0VBRS9CO0VBQ0EsSUFBS0wsS0FBSyxDQUFDTyxLQUFLLENBQUNDLElBQUksQ0FBRUosR0FBSSxDQUFDLEVBQUc7SUFDM0I7SUFDQSxJQUFJSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBRVpBLEdBQUcsQ0FBRUwsR0FBRyxDQUFDTSxPQUFPLENBQUVWLEtBQUssQ0FBQ08sS0FBSyxFQUFFLEVBQUcsQ0FBQyxDQUFFLEdBQUdGLEtBQUs7SUFFN0NMLEtBQUssQ0FBQ1csU0FBUyxDQUFFRixHQUFHLEVBQUVOLElBQUssQ0FBQztFQUNoQztBQUNKLENBQUM7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBUyxNQUFNLENBQUNDLE9BQU8sR0FBRyxVQUFXVCxHQUFHLEVBQUVDLEtBQUssRUFBRztFQUNyQyxJQUFJUyxHQUFHLEdBQUcsSUFBSTs7RUFFZDtFQUNBLElBQUtDLE9BQUEsQ0FBT1gsR0FBRyxNQUFLLFFBQVEsRUFBRztJQUMzQixLQUFNLElBQUlZLENBQUMsSUFBSVosR0FBRyxFQUFHO01BQ2pCLElBQUksQ0FBQ2EsT0FBTyxDQUFDLFVBQVdkLElBQUksRUFBRztRQUMzQkQsT0FBTyxDQUFFQyxJQUFJLEVBQUVhLENBQUMsRUFBRVosR0FBRyxDQUFFWSxDQUFDLENBQUcsQ0FBQztNQUNoQyxDQUFDLENBQUM7SUFDTjs7SUFFSjtFQUNBLENBQUMsTUFBTSxJQUFLWCxLQUFLLEtBQUthLFNBQVMsRUFBRztJQUM5QixJQUFJLENBQUNELE9BQU8sQ0FBQyxVQUFXZCxJQUFJLEVBQUc7TUFDM0JELE9BQU8sQ0FBRUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLEtBQU0sQ0FBQztJQUMvQixDQUFDLENBQUM7RUFFTixDQUFDLE1BQU07SUFDSFMsR0FBRyxHQUFHLElBQUksQ0FBRSxDQUFDLENBQUUsQ0FBQ0ssWUFBWSxDQUFFZixHQUFJLENBQUM7RUFDdkM7RUFFQSxPQUFPVSxHQUFHO0FBQ2QsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC9hdHRyLmpzPzFhNjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWxzID0gcmVxdWlyZSggXCIuLi91dGlsc1wiICk7XG5cblxuLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBhZGRBdHRyXG4gKiBAcGFyYW0ge2VsZW1lbnR9IG5vZGUgVGhlIGVsZW1lbnQgdG8gc2V0IGF0dHJpYnV0ZSBvblxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgYXR0cmlidXRlXG4gKiBAcGFyYW0ge21peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0XG4gKiBAZGVzY3JpcHRpb24gR2V0IG9yIFNldCBhbiBhdHRyaWJ1dGUocykgb24gYSBET00gbm9kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqXG4gKi9cbnZhciBhZGRBdHRyID0gZnVuY3Rpb24gKCBub2RlLCBrZXksIHZhbHVlICkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCBrZXksIHZhbHVlICk7XG5cbiAgICAvLyBBcHBseSBkYXRhKCk/XG4gICAgaWYgKCB1dGlscy5yRGF0YS50ZXN0KCBrZXkgKSApIHtcbiAgICAgICAgLy8gc3RvcmVEYXRhIGV4cGVjdHMgYSB7ZGF0YSBvYmplY3R9XG4gICAgICAgIHZhciBvYmogPSB7fTtcblxuICAgICAgICBvYmpbIGtleS5yZXBsYWNlKCB1dGlscy5yRGF0YSwgXCJcIiApIF0gPSB2YWx1ZTtcblxuICAgICAgICB1dGlscy5zdG9yZURhdGEoIG9iaiwgbm9kZSApO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBhdHRyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXRcbiAqIEBkZXNjcmlwdGlvbiBHZXQgb3IgU2V0IGFuIGF0dHJpYnV0ZShzKSBvbiBhIERPTSBub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIGtleSwgdmFsdWUgKSB7XG4gICAgdmFyIHJldCA9IHRoaXM7XG5cbiAgICAvLyBWYWx1ZSBjYW4gYmUgYW4ge29iamVjdH1cbiAgICBpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgIGZvciAoIHZhciBpIGluIGtleSApIHtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgYWRkQXR0ciggbm9kZSwgaSwga2V5WyBpIF0gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAvLyBWYWx1ZSBjb3VsZCBwb3NzaWJseSBiZSBcIlwiIG9yIDBcbiAgICB9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICAgICAgYWRkQXR0ciggbm9kZSwga2V5LCB2YWx1ZSApO1xuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IHRoaXNbIDAgXS5nZXRBdHRyaWJ1dGUoIGtleSApO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59OyJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJhZGRBdHRyIiwibm9kZSIsImtleSIsInZhbHVlIiwic2V0QXR0cmlidXRlIiwickRhdGEiLCJ0ZXN0Iiwib2JqIiwicmVwbGFjZSIsInN0b3JlRGF0YSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXQiLCJfdHlwZW9mIiwiaSIsImZvckVhY2giLCJ1bmRlZmluZWQiLCJnZXRBdHRyaWJ1dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/attr.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/children.js":
/*!*************************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/children.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n  utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method children\n * @description Gather all child nodes that are NOT text nodes\n * @returns {Hobo}\n *\n */\nmodule.exports = function () {\n  var children = [],\n    len,\n    i;\n  this.forEach(function (node) {\n    i = 0;\n    len = node.children.length;\n    for (i; i < len; i) {\n      children.push(node.children[i]);\n    }\n  });\n  return new Hobo(children, this._context);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvY2hpbGRyZW4uanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsSUFBSSxHQUFHQyxtQkFBTyxDQUFFLHlEQUFVLENBQUM7RUFDM0JDLEtBQUssR0FBR0QsbUJBQU8sQ0FBRSwyREFBVyxDQUFDOztBQUlqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUUsTUFBTSxDQUFDQyxPQUFPLEdBQUcsWUFBWTtFQUN6QixJQUFJQyxRQUFRLEdBQUcsRUFBRTtJQUNiQyxHQUFHO0lBQ0hDLENBQUM7RUFFTCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0JGLENBQUMsR0FBRyxDQUFDO0lBQ0xELEdBQUcsR0FBR0csSUFBSSxDQUFDSixRQUFRLENBQUNLLE1BQU07SUFFMUIsS0FBTUgsQ0FBQyxFQUFFQSxDQUFDLEdBQUdELEdBQUcsRUFBRUMsQ0FBQyxFQUFFLEVBQUc7TUFDcEJGLFFBQVEsQ0FBQ00sSUFBSSxDQUFFRixJQUFJLENBQUNKLFFBQVEsQ0FBRUUsQ0FBQyxDQUFHLENBQUM7SUFDdkM7RUFDSixDQUFDLENBQUM7RUFFRixPQUFPLElBQUlQLElBQUksQ0FBRUssUUFBUSxFQUFFLElBQUksQ0FBQ08sUUFBUyxDQUFDO0FBQzlDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvY2hpbGRyZW4uanM/ZjE2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSG9ibyA9IHJlcXVpcmUoIFwiLi4vSG9ib1wiICksXG4gICAgdXRpbHMgPSByZXF1aXJlKCBcIi4uL3V0aWxzXCIgKTtcblxuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2QgY2hpbGRyZW5cbiAqIEBkZXNjcmlwdGlvbiBHYXRoZXIgYWxsIGNoaWxkIG5vZGVzIHRoYXQgYXJlIE5PVCB0ZXh0IG5vZGVzXG4gKiBAcmV0dXJucyB7SG9ib31cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IFtdLFxuICAgICAgICBsZW4sXG4gICAgICAgIGk7XG5cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggaTsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCggbm9kZS5jaGlsZHJlblsgaSBdICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgSG9ibyggY2hpbGRyZW4sIHRoaXMuX2NvbnRleHQgKTtcbn07Il0sIm5hbWVzIjpbIkhvYm8iLCJyZXF1aXJlIiwidXRpbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2hpbGRyZW4iLCJsZW4iLCJpIiwiZm9yRWFjaCIsIm5vZGUiLCJsZW5ndGgiLCJwdXNoIiwiX2NvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/children.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/closest.js":
/*!************************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/closest.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n  matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method closest\n * @param {string} selector The selector to try and match\n * @description Find the first ancestor element with this selector\n * @returns {Hobo}\n *\n */\nmodule.exports = function (selector) {\n  var closest = [];\n  this.forEach(function (node) {\n    var match = matchElement(node, selector, true);\n    if (match) {\n      closest.push(match);\n    }\n  });\n  return new Hobo(closest, null);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvY2xvc2VzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxJQUFJLEdBQUdDLG1CQUFPLENBQUUseURBQVUsQ0FBQztFQUMzQkMsWUFBWSxHQUFHRCxtQkFBTyxDQUFFLDhHQUF3QixDQUFDOztBQUdyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBRSxNQUFNLENBQUNDLE9BQU8sR0FBRyxVQUFXQyxRQUFRLEVBQUc7RUFDbkMsSUFBSUMsT0FBTyxHQUFHLEVBQUU7RUFFaEIsSUFBSSxDQUFDQyxPQUFPLENBQUMsVUFBV0MsSUFBSSxFQUFHO0lBQzNCLElBQUlDLEtBQUssR0FBR1AsWUFBWSxDQUFFTSxJQUFJLEVBQUVILFFBQVEsRUFBRSxJQUFLLENBQUM7SUFFaEQsSUFBS0ksS0FBSyxFQUFHO01BQ1RILE9BQU8sQ0FBQ0ksSUFBSSxDQUFFRCxLQUFNLENBQUM7SUFDekI7RUFDSixDQUFDLENBQUM7RUFFRixPQUFPLElBQUlULElBQUksQ0FBRU0sT0FBTyxFQUFFLElBQUssQ0FBQztBQUNwQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWhvYm8vbGliL2V4dGVuZGVkL2Nsb3Nlc3QuanM/YzVlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSG9ibyA9IHJlcXVpcmUoIFwiLi4vSG9ib1wiICksXG4gICAgbWF0Y2hFbGVtZW50ID0gcmVxdWlyZSggXCJwcm9wZXJqcy1tYXRjaGVsZW1lbnRcIiApO1xuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2QgY2xvc2VzdFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBzZWxlY3RvciB0byB0cnkgYW5kIG1hdGNoXG4gKiBAZGVzY3JpcHRpb24gRmluZCB0aGUgZmlyc3QgYW5jZXN0b3IgZWxlbWVudCB3aXRoIHRoaXMgc2VsZWN0b3JcbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuICAgIHZhciBjbG9zZXN0ID0gW107XG5cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBtYXRjaEVsZW1lbnQoIG5vZGUsIHNlbGVjdG9yLCB0cnVlICk7XG5cbiAgICAgICAgaWYgKCBtYXRjaCApIHtcbiAgICAgICAgICAgIGNsb3Nlc3QucHVzaCggbWF0Y2ggKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBIb2JvKCBjbG9zZXN0LCBudWxsICk7XG59OyJdLCJuYW1lcyI6WyJIb2JvIiwicmVxdWlyZSIsIm1hdGNoRWxlbWVudCIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZWxlY3RvciIsImNsb3Nlc3QiLCJmb3JFYWNoIiwibm9kZSIsIm1hdGNoIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/closest.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/detach.js":
/*!***********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/detach.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("/**\n *\n * @instance\n * @memberof Hobo\n * @method detach\n * @description Detach the nodes from the DOM\n *              This method does NOT remove events or data.\n * @returns {Hobo}\n *\n */\nmodule.exports = function () {\n  this.forEach(function (node) {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvZGV0YWNoLmpzIiwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImZvckVhY2giLCJub2RlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIl0sInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvZGV0YWNoLmpzP2FiODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBkZXRhY2hcbiAqIEBkZXNjcmlwdGlvbiBEZXRhY2ggdGhlIG5vZGVzIGZyb20gdGhlIERPTVxuICogICAgICAgICAgICAgIFRoaXMgbWV0aG9kIGRvZXMgTk9UIHJlbW92ZSBldmVudHMgb3IgZGF0YS5cbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICggbm9kZSApIHtcbiAgICAgICAgaWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsTUFBTSxDQUFDQyxPQUFPLEdBQUcsWUFBWTtFQUN6QixJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0IsSUFBS0EsSUFBSSxDQUFDQyxVQUFVLEVBQUc7TUFDbkJELElBQUksQ0FBQ0MsVUFBVSxDQUFDQyxXQUFXLENBQUVGLElBQUssQ0FBQztJQUN2QztFQUNKLENBQUMsQ0FBQztFQUVGLE9BQU8sSUFBSTtBQUNmLENBQUMifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/detach.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/eq.js":
/*!*******************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/eq.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method eq\n * @param {number} i The indexOf the element\n * @description Get the element at the index as a Hobo instance.\n * @returns {Hobo}\n *\n */\nmodule.exports = function (i) {\n  return i < this.length ? new Hobo(this[i], this._context) : this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvZXEuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsSUFBSSxHQUFHQyxtQkFBTyxDQUFFLHlEQUFVLENBQUM7O0FBRy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFVBQVdDLENBQUMsRUFBRztFQUM1QixPQUFPQSxDQUFDLEdBQUcsSUFBSSxDQUFDQyxNQUFNLEdBQ1osSUFBSUwsSUFBSSxDQUNOLElBQUksQ0FBRUksQ0FBQyxDQUFFLEVBQ1QsSUFBSSxDQUFDRSxRQUNULENBQUMsR0FDQyxJQUFJO0FBQ2xCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvZXEuanM/Y2M3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSG9ibyA9IHJlcXVpcmUoIFwiLi4vSG9ib1wiICk7XG5cblxuLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBlcVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4T2YgdGhlIGVsZW1lbnRcbiAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIGluZGV4IGFzIGEgSG9ibyBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgcmV0dXJuIGkgPCB0aGlzLmxlbmd0aCBcbiAgICAgICAgICAgID8gbmV3IEhvYm8oXG4gICAgICAgICAgICAgICAgdGhpc1sgaSBdLFxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRcbiAgICAgICAgICAgICkgXG4gICAgICAgICAgICA6IHRoaXM7XG59OyJdLCJuYW1lcyI6WyJIb2JvIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJpIiwibGVuZ3RoIiwiX2NvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/eq.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/filter.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n  matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method filter\n * @param {string} selector The selector to match elements against\n * @description Filter out the elements that match the selector.\n * @returns {Hobo}\n *\n */\nmodule.exports = function (selector) {\n  var filtered = [];\n  this.forEach(function (node) {\n    if (matchElement(node, selector)) {\n      filtered.push(node);\n    }\n  });\n  return new Hobo(filtered, null);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLElBQUksR0FBR0MsbUJBQU8sQ0FBRSx5REFBVSxDQUFDO0VBQzNCQyxZQUFZLEdBQUdELG1CQUFPLENBQUUsOEdBQXdCLENBQUM7O0FBR3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FFLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFVBQVdDLFFBQVEsRUFBRztFQUNuQyxJQUFJQyxRQUFRLEdBQUcsRUFBRTtFQUVqQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0IsSUFBS04sWUFBWSxDQUFFTSxJQUFJLEVBQUVILFFBQVMsQ0FBQyxFQUFHO01BQ2xDQyxRQUFRLENBQUNHLElBQUksQ0FBRUQsSUFBSyxDQUFDO0lBQ3pCO0VBQ0osQ0FBQyxDQUFDO0VBRUYsT0FBTyxJQUFJUixJQUFJLENBQUVNLFFBQVEsRUFBRSxJQUFLLENBQUM7QUFDckMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC9maWx0ZXIuanM/MjRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSG9ibyA9IHJlcXVpcmUoIFwiLi4vSG9ib1wiICksXG4gICAgbWF0Y2hFbGVtZW50ID0gcmVxdWlyZSggXCJwcm9wZXJqcy1tYXRjaGVsZW1lbnRcIiApO1xuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2QgZmlsdGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHRvIG1hdGNoIGVsZW1lbnRzIGFnYWluc3RcbiAqIEBkZXNjcmlwdGlvbiBGaWx0ZXIgb3V0IHRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBzZWxlY3Rvci5cbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuICAgIHZhciBmaWx0ZXJlZCA9IFtdO1xuXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICggbm9kZSApIHtcbiAgICAgICAgaWYgKCBtYXRjaEVsZW1lbnQoIG5vZGUsIHNlbGVjdG9yICkgKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKCBub2RlICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgSG9ibyggZmlsdGVyZWQsIG51bGwgKTtcbn07Il0sIm5hbWVzIjpbIkhvYm8iLCJyZXF1aXJlIiwibWF0Y2hFbGVtZW50IiwibW9kdWxlIiwiZXhwb3J0cyIsInNlbGVjdG9yIiwiZmlsdGVyZWQiLCJmb3JFYWNoIiwibm9kZSIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/filter.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/first.js":
/*!**********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/first.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method first\n * @description Get hobo instance of the first element.\n * @returns {Hobo}\n *\n */\nmodule.exports = function () {\n  return new Hobo(this[0], this._context);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvZmlyc3QuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsSUFBSSxHQUFHQyxtQkFBTyxDQUFFLHlEQUFVLENBQUM7O0FBRy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxNQUFNLENBQUNDLE9BQU8sR0FBRyxZQUFZO0VBQ3pCLE9BQU8sSUFBSUgsSUFBSSxDQUFFLElBQUksQ0FBRSxDQUFDLENBQUUsRUFBRSxJQUFJLENBQUNJLFFBQVMsQ0FBQztBQUMvQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWhvYm8vbGliL2V4dGVuZGVkL2ZpcnN0LmpzP2Q1MzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEhvYm8gPSByZXF1aXJlKCBcIi4uL0hvYm9cIiApO1xuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2QgZmlyc3RcbiAqIEBkZXNjcmlwdGlvbiBHZXQgaG9ibyBpbnN0YW5jZSBvZiB0aGUgZmlyc3QgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBIb2JvKCB0aGlzWyAwIF0sIHRoaXMuX2NvbnRleHQgKTtcbn07Il0sIm5hbWVzIjpbIkhvYm8iLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9jb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/first.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/index.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("/**\n *\n * @instance\n * @memberof Hobo\n * @method index\n * @description Get the nodes index compared to its DOM siblings.\n *              Possibly this should be its index in the Hobo set?\n * @returns {number}\n *\n */\nmodule.exports = function () {\n  return [].indexOf.call(this[0].parentNode.children, this[0]);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvaW5kZXguanMiLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiaW5kZXhPZiIsImNhbGwiLCJwYXJlbnROb2RlIiwiY2hpbGRyZW4iXSwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC9pbmRleC5qcz9iNTc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2QgaW5kZXhcbiAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIG5vZGVzIGluZGV4IGNvbXBhcmVkIHRvIGl0cyBET00gc2libGluZ3MuXG4gKiAgICAgICAgICAgICAgUG9zc2libHkgdGhpcyBzaG91bGQgYmUgaXRzIGluZGV4IGluIHRoZSBIb2JvIHNldD9cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW10uaW5kZXhPZi5jYWxsKFxuICAgICAgICB0aGlzWyAwIF0ucGFyZW50Tm9kZS5jaGlsZHJlbixcbiAgICAgICAgdGhpc1sgMCBdXG4gICAgKTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxNQUFNLENBQUNDLE9BQU8sR0FBRyxZQUFZO0VBQ3pCLE9BQU8sRUFBRSxDQUFDQyxPQUFPLENBQUNDLElBQUksQ0FDbEIsSUFBSSxDQUFFLENBQUMsQ0FBRSxDQUFDQyxVQUFVLENBQUNDLFFBQVEsRUFDN0IsSUFBSSxDQUFFLENBQUMsQ0FDWCxDQUFDO0FBQ0wsQ0FBQyJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/index.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/is.js":
/*!*******************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/is.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n  matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method is\n * @param {string} selector The selector to match elements against\n * @description Determine if a node set is this selector.\n * @returns {boolean}\n *\n */\nmodule.exports = function (selector) {\n  return matchElement(this[0], selector) ? true : false;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvaXMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsSUFBSSxHQUFHQyxtQkFBTyxDQUFFLHlEQUFVLENBQUM7RUFDM0JDLFlBQVksR0FBR0QsbUJBQU8sQ0FBRSw4R0FBd0IsQ0FBQzs7QUFHckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUUsTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBV0MsUUFBUSxFQUFHO0VBQ25DLE9BQVFILFlBQVksQ0FBRSxJQUFJLENBQUUsQ0FBQyxDQUFFLEVBQUVHLFFBQVMsQ0FBQyxHQUFHLElBQUksR0FBRyxLQUFLO0FBQzlELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvaXMuanM/ZDU4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSG9ibyA9IHJlcXVpcmUoIFwiLi4vSG9ib1wiICksXG4gICAgbWF0Y2hFbGVtZW50ID0gcmVxdWlyZSggXCJwcm9wZXJqcy1tYXRjaGVsZW1lbnRcIiApO1xuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2QgaXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgdG8gbWF0Y2ggZWxlbWVudHMgYWdhaW5zdFxuICogQGRlc2NyaXB0aW9uIERldGVybWluZSBpZiBhIG5vZGUgc2V0IGlzIHRoaXMgc2VsZWN0b3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcbiAgICByZXR1cm4gKG1hdGNoRWxlbWVudCggdGhpc1sgMCBdLCBzZWxlY3RvciApID8gdHJ1ZSA6IGZhbHNlKTtcbn07Il0sIm5hbWVzIjpbIkhvYm8iLCJyZXF1aXJlIiwibWF0Y2hFbGVtZW50IiwibW9kdWxlIiwiZXhwb3J0cyIsInNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/is.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/last.js":
/*!*********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/last.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method last\n * @description Get hobo instance of the last element.\n * @returns {Hobo}\n *\n */\nmodule.exports = function () {\n  return new Hobo(this[this.length - 1], this._context);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvbGFzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxJQUFJLEdBQUdDLG1CQUFPLENBQUUseURBQVUsQ0FBQzs7QUFHL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFlBQVk7RUFDekIsT0FBTyxJQUFJSCxJQUFJLENBQUUsSUFBSSxDQUFHLElBQUksQ0FBQ0ksTUFBTSxHQUFHLENBQUMsQ0FBRyxFQUFFLElBQUksQ0FBQ0MsUUFBUyxDQUFDO0FBQy9ELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvbGFzdC5qcz85MzUwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBIb2JvID0gcmVxdWlyZSggXCIuLi9Ib2JvXCIgKTtcblxuXG4vKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBIb2JvXG4gKiBAbWV0aG9kIGxhc3RcbiAqIEBkZXNjcmlwdGlvbiBHZXQgaG9ibyBpbnN0YW5jZSBvZiB0aGUgbGFzdCBlbGVtZW50LlxuICogQHJldHVybnMge0hvYm99XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEhvYm8oIHRoaXNbICh0aGlzLmxlbmd0aCAtIDEpIF0sIHRoaXMuX2NvbnRleHQgKTtcbn07Il0sIm5hbWVzIjpbIkhvYm8iLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImxlbmd0aCIsIl9jb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/last.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/next.js":
/*!*********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/next.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n  matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method next\n * @param {string} selector Optional selector to match\n * @description Get the next sibling, test against selector\n * @returns {Hobo}\n *\n */\nmodule.exports = function (selector) {\n  var ret = [];\n  this.forEach(function (node) {\n    var nextNode = node.nextSibling;\n    while (nextNode && nextNode.nodeType !== 1) {\n      nextNode = nextNode.nextSibling;\n    }\n    if (nextNode && (!selector || selector && matchElement(nextNode, selector))) {\n      ret.push(nextNode);\n    }\n  });\n  return new Hobo(ret, this._context);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvbmV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxJQUFJLEdBQUdDLG1CQUFPLENBQUUseURBQVUsQ0FBQztFQUMzQkMsWUFBWSxHQUFHRCxtQkFBTyxDQUFFLDhHQUF3QixDQUFDOztBQUlyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBRSxNQUFNLENBQUNDLE9BQU8sR0FBRyxVQUFXQyxRQUFRLEVBQUc7RUFDbkMsSUFBSUMsR0FBRyxHQUFHLEVBQUU7RUFFWixJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0IsSUFBSUMsUUFBUSxHQUFHRCxJQUFJLENBQUNFLFdBQVc7SUFFL0IsT0FBUUQsUUFBUSxJQUFJQSxRQUFRLENBQUNFLFFBQVEsS0FBSyxDQUFDLEVBQUc7TUFDMUNGLFFBQVEsR0FBR0EsUUFBUSxDQUFDQyxXQUFXO0lBQ25DO0lBRUEsSUFBS0QsUUFBUSxLQUFLLENBQUNKLFFBQVEsSUFBS0EsUUFBUSxJQUFJSCxZQUFZLENBQUVPLFFBQVEsRUFBRUosUUFBUyxDQUFFLENBQUMsRUFBRztNQUMvRUMsR0FBRyxDQUFDTSxJQUFJLENBQUVILFFBQVMsQ0FBQztJQUN4QjtFQUNKLENBQUMsQ0FBQztFQUVGLE9BQU8sSUFBSVQsSUFBSSxDQUFFTSxHQUFHLEVBQUUsSUFBSSxDQUFDTyxRQUFTLENBQUM7QUFDekMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC9uZXh0LmpzP2VkM2YiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEhvYm8gPSByZXF1aXJlKCBcIi4uL0hvYm9cIiApLFxuICAgIG1hdGNoRWxlbWVudCA9IHJlcXVpcmUoIFwicHJvcGVyanMtbWF0Y2hlbGVtZW50XCIgKTtcblxuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2QgbmV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIE9wdGlvbmFsIHNlbGVjdG9yIHRvIG1hdGNoXG4gKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBuZXh0IHNpYmxpbmcsIHRlc3QgYWdhaW5zdCBzZWxlY3RvclxuICogQHJldHVybnMge0hvYm99XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICggbm9kZSApIHtcbiAgICAgICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcblxuICAgICAgICB3aGlsZSAoIG5leHROb2RlICYmIG5leHROb2RlLm5vZGVUeXBlICE9PSAxICkge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0Tm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbmV4dE5vZGUgJiYgKCFzZWxlY3RvciB8fCAoc2VsZWN0b3IgJiYgbWF0Y2hFbGVtZW50KCBuZXh0Tm9kZSwgc2VsZWN0b3IgKSkpICkge1xuICAgICAgICAgICAgcmV0LnB1c2goIG5leHROb2RlICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgSG9ibyggcmV0LCB0aGlzLl9jb250ZXh0ICk7XG59OyJdLCJuYW1lcyI6WyJIb2JvIiwicmVxdWlyZSIsIm1hdGNoRWxlbWVudCIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZWxlY3RvciIsInJldCIsImZvckVhY2giLCJub2RlIiwibmV4dE5vZGUiLCJuZXh0U2libGluZyIsIm5vZGVUeXBlIiwicHVzaCIsIl9jb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/next.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/not.js":
/*!********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/not.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\"),\n  Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method not\n * @param {string} selector The selector to filter out elements\n * @description Filter out elements that are NOT this selector\n * @returns {Hobo}\n *\n */\nmodule.exports = function (selector) {\n  var keepers = new Hobo([], this._context);\n\n  // Hobo instance\n  if (selector instanceof Hobo) {\n    this.forEach(function (node) {\n      var pushNode = true;\n      selector.forEach(function (elem) {\n        if (node === elem) {\n          pushNode = false;\n        }\n      });\n      if (pushNode) {\n        keepers.push(node);\n      }\n    });\n  } else {\n    this.forEach(function (node, i) {\n      if (typeof selector === \"function\") {\n        if (selector(i, node)) {\n          keepers.push(node);\n        }\n      } else if (!matchElement(node, selector)) {\n        keepers.push(node);\n      }\n    });\n  }\n  return keepers;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvbm90LmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFlBQVksR0FBR0MsbUJBQU8sQ0FBRSw4R0FBd0IsQ0FBQztFQUNqREMsSUFBSSxHQUFHRCxtQkFBTyxDQUFFLHlEQUFVLENBQUM7O0FBRy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FFLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFVBQVdDLFFBQVEsRUFBRztFQUNuQyxJQUFJQyxPQUFPLEdBQUcsSUFBSUosSUFBSSxDQUFFLEVBQUUsRUFBRSxJQUFJLENBQUNLLFFBQVMsQ0FBQzs7RUFFM0M7RUFDQSxJQUFLRixRQUFRLFlBQVlILElBQUksRUFBRztJQUM1QixJQUFJLENBQUNNLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7TUFDM0IsSUFBSUMsUUFBUSxHQUFHLElBQUk7TUFFbkJMLFFBQVEsQ0FBQ0csT0FBTyxDQUFDLFVBQVdHLElBQUksRUFBRztRQUMvQixJQUFLRixJQUFJLEtBQUtFLElBQUksRUFBRztVQUNqQkQsUUFBUSxHQUFHLEtBQUs7UUFDcEI7TUFDSixDQUFDLENBQUM7TUFFRixJQUFLQSxRQUFRLEVBQUc7UUFDWkosT0FBTyxDQUFDTSxJQUFJLENBQUVILElBQUssQ0FBQztNQUN4QjtJQUNKLENBQUMsQ0FBQztFQUVOLENBQUMsTUFBTTtJQUNILElBQUksQ0FBQ0QsT0FBTyxDQUFDLFVBQVdDLElBQUksRUFBRUksQ0FBQyxFQUFHO01BQzlCLElBQUssT0FBT1IsUUFBUSxLQUFLLFVBQVUsRUFBRztRQUNsQyxJQUFLQSxRQUFRLENBQUVRLENBQUMsRUFBRUosSUFBSyxDQUFDLEVBQUc7VUFDdkJILE9BQU8sQ0FBQ00sSUFBSSxDQUFFSCxJQUFLLENBQUM7UUFDeEI7TUFFSixDQUFDLE1BQU0sSUFBSyxDQUFDVCxZQUFZLENBQUVTLElBQUksRUFBRUosUUFBUyxDQUFDLEVBQUc7UUFDMUNDLE9BQU8sQ0FBQ00sSUFBSSxDQUFFSCxJQUFLLENBQUM7TUFDeEI7SUFDSixDQUFDLENBQUM7RUFDTjtFQUVBLE9BQU9ILE9BQU87QUFDbEIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC9ub3QuanM/ODdhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWF0Y2hFbGVtZW50ID0gcmVxdWlyZSggXCJwcm9wZXJqcy1tYXRjaGVsZW1lbnRcIiApLFxuICAgIEhvYm8gPSByZXF1aXJlKCBcIi4uL0hvYm9cIiApO1xuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2Qgbm90XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHRvIGZpbHRlciBvdXQgZWxlbWVudHNcbiAqIEBkZXNjcmlwdGlvbiBGaWx0ZXIgb3V0IGVsZW1lbnRzIHRoYXQgYXJlIE5PVCB0aGlzIHNlbGVjdG9yXG4gKiBAcmV0dXJucyB7SG9ib31cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcbiAgICB2YXIga2VlcGVycyA9IG5ldyBIb2JvKCBbXSwgdGhpcy5fY29udGV4dCApO1xuXG4gICAgLy8gSG9ibyBpbnN0YW5jZVxuICAgIGlmICggc2VsZWN0b3IgaW5zdGFuY2VvZiBIb2JvICkge1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICAgICAgdmFyIHB1c2hOb2RlID0gdHJ1ZTtcblxuICAgICAgICAgICAgc2VsZWN0b3IuZm9yRWFjaChmdW5jdGlvbiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBub2RlID09PSBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoTm9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIHB1c2hOb2RlICkge1xuICAgICAgICAgICAgICAgIGtlZXBlcnMucHVzaCggbm9kZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoIG5vZGUsIGkgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgIGlmICggc2VsZWN0b3IoIGksIG5vZGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAga2VlcGVycy5wdXNoKCBub2RlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAhbWF0Y2hFbGVtZW50KCBub2RlLCBzZWxlY3RvciApICkge1xuICAgICAgICAgICAgICAgIGtlZXBlcnMucHVzaCggbm9kZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2VlcGVycztcbn07Il0sIm5hbWVzIjpbIm1hdGNoRWxlbWVudCIsInJlcXVpcmUiLCJIb2JvIiwibW9kdWxlIiwiZXhwb3J0cyIsInNlbGVjdG9yIiwia2VlcGVycyIsIl9jb250ZXh0IiwiZm9yRWFjaCIsIm5vZGUiLCJwdXNoTm9kZSIsImVsZW0iLCJwdXNoIiwiaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/not.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/one.js":
/*!********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/one.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\"),\n  utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method one\n * @description Bind a standard DOM Event only ONE time.\n * @param {string} event \n * @param {string} selector \n * @param {function} callback\n * @returns {Hobo}\n *\n */\nmodule.exports = function (event, selector, callback) {\n  var self = this;\n  if (!callback) {\n    callback = selector;\n    selector = this._selector;\n  }\n  return this.on(event, selector, function once(e) {\n    // Apply `this` - which is the Element context\n    callback.call(this, e);\n    self.off(event, once);\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvb25lLmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFlBQVksR0FBR0MsbUJBQU8sQ0FBRSw4R0FBd0IsQ0FBQztFQUNqREMsS0FBSyxHQUFHRCxtQkFBTyxDQUFFLDJEQUFXLENBQUM7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBRSxNQUFNLENBQUNDLE9BQU8sR0FBRyxVQUFXQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFHO0VBQ3BELElBQUlDLElBQUksR0FBRyxJQUFJO0VBRWYsSUFBSyxDQUFDRCxRQUFRLEVBQUc7SUFDYkEsUUFBUSxHQUFHRCxRQUFRO0lBQ25CQSxRQUFRLEdBQUcsSUFBSSxDQUFDRyxTQUFTO0VBQzdCO0VBRUEsT0FBTyxJQUFJLENBQUNDLEVBQUUsQ0FBRUwsS0FBSyxFQUFFQyxRQUFRLEVBQUUsU0FBU0ssSUFBSUEsQ0FBR0MsQ0FBQyxFQUFHO0lBQ2pEO0lBQ0FMLFFBQVEsQ0FBQ00sSUFBSSxDQUFFLElBQUksRUFBRUQsQ0FBRSxDQUFDO0lBRXhCSixJQUFJLENBQUNNLEdBQUcsQ0FBRVQsS0FBSyxFQUFFTSxJQUFLLENBQUM7RUFDM0IsQ0FBQyxDQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC9vbmUuanM/ZTFiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWF0Y2hFbGVtZW50ID0gcmVxdWlyZSggXCJwcm9wZXJqcy1tYXRjaGVsZW1lbnRcIiApLFxuICAgIHV0aWxzID0gcmVxdWlyZSggXCIuLi91dGlsc1wiICk7XG5cblxuLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCBvbmVcbiAqIEBkZXNjcmlwdGlvbiBCaW5kIGEgc3RhbmRhcmQgRE9NIEV2ZW50IG9ubHkgT05FIHRpbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0hvYm99XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggZXZlbnQsIHNlbGVjdG9yLCBjYWxsYmFjayApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoICFjYWxsYmFjayApIHtcbiAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3IgPSB0aGlzLl9zZWxlY3RvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5vbiggZXZlbnQsIHNlbGVjdG9yLCBmdW5jdGlvbiBvbmNlICggZSApIHtcbiAgICAgICAgLy8gQXBwbHkgYHRoaXNgIC0gd2hpY2ggaXMgdGhlIEVsZW1lbnQgY29udGV4dFxuICAgICAgICBjYWxsYmFjay5jYWxsKCB0aGlzLCBlICk7XG5cbiAgICAgICAgc2VsZi5vZmYoIGV2ZW50LCBvbmNlICk7XG4gICAgfSk7XG59OyJdLCJuYW1lcyI6WyJtYXRjaEVsZW1lbnQiLCJyZXF1aXJlIiwidXRpbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXZlbnQiLCJzZWxlY3RvciIsImNhbGxiYWNrIiwic2VsZiIsIl9zZWxlY3RvciIsIm9uIiwib25jZSIsImUiLCJjYWxsIiwib2ZmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/one.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/parent.js":
/*!***********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/parent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n  matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method parent\n * @param {string} selector Optional selector to match\n * @description Get a Hobo instance of the parent node of this instance.\n * @returns {Hobo}\n *\n */\nmodule.exports = function (selector) {\n  var parents = [];\n  this.forEach(function (node) {\n    if (!selector || selector && matchElement(node.parentNode, selector)) {\n      parents.push(node.parentNode);\n    }\n  });\n  return new Hobo(parents, null);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvcGFyZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLElBQUksR0FBR0MsbUJBQU8sQ0FBRSx5REFBVSxDQUFDO0VBQzNCQyxZQUFZLEdBQUdELG1CQUFPLENBQUUsOEdBQXdCLENBQUM7O0FBR3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FFLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFVBQVdDLFFBQVEsRUFBRztFQUNuQyxJQUFJQyxPQUFPLEdBQUcsRUFBRTtFQUVoQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0IsSUFBSyxDQUFDSCxRQUFRLElBQUtBLFFBQVEsSUFBSUgsWUFBWSxDQUFFTSxJQUFJLENBQUNDLFVBQVUsRUFBRUosUUFBUyxDQUFFLEVBQUc7TUFDeEVDLE9BQU8sQ0FBQ0ksSUFBSSxDQUFFRixJQUFJLENBQUNDLFVBQVcsQ0FBQztJQUNuQztFQUNKLENBQUMsQ0FBQztFQUVGLE9BQU8sSUFBSVQsSUFBSSxDQUFFTSxPQUFPLEVBQUUsSUFBSyxDQUFDO0FBQ3BDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvcGFyZW50LmpzP2Y0ZjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEhvYm8gPSByZXF1aXJlKCBcIi4uL0hvYm9cIiApLFxuICAgIG1hdGNoRWxlbWVudCA9IHJlcXVpcmUoIFwicHJvcGVyanMtbWF0Y2hlbGVtZW50XCIgKTtcblxuXG4vKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBIb2JvXG4gKiBAbWV0aG9kIHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIE9wdGlvbmFsIHNlbGVjdG9yIHRvIG1hdGNoXG4gKiBAZGVzY3JpcHRpb24gR2V0IGEgSG9ibyBpbnN0YW5jZSBvZiB0aGUgcGFyZW50IG5vZGUgb2YgdGhpcyBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuICAgIHZhciBwYXJlbnRzID0gW107XG5cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICBpZiAoICFzZWxlY3RvciB8fCAoc2VsZWN0b3IgJiYgbWF0Y2hFbGVtZW50KCBub2RlLnBhcmVudE5vZGUsIHNlbGVjdG9yICkpICkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKCBub2RlLnBhcmVudE5vZGUgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBIb2JvKCBwYXJlbnRzLCBudWxsICk7XG59OyJdLCJuYW1lcyI6WyJIb2JvIiwicmVxdWlyZSIsIm1hdGNoRWxlbWVudCIsIm1vZHVsZSIsImV4cG9ydHMiLCJzZWxlY3RvciIsInBhcmVudHMiLCJmb3JFYWNoIiwibm9kZSIsInBhcmVudE5vZGUiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/parent.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/prepend.js":
/*!************************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/prepend.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method prepend\n * @param {mixed} prependage What to prepend? Hobo, Element...\n * @description Append the nodes to the DOM\n * @returns {Hobo}\n *\n */\nmodule.exports = function (prependage) {\n  // Selector string, wrap in new Hobo instance\n  if (typeof prependage === \"string\") {\n    prependage = new Hobo(prependage);\n  }\n  this.forEach(function (node) {\n    // Hobo instance OR Array OR Array-like object with forEach\n    if (prependage instanceof Hobo || prependage.length && typeof prependage.forEach === \"function\") {\n      prependage.forEach(function (prepend) {\n        if (prepend.nodeType && prepend.nodeType === 1) {\n          // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n          // Context node inserts first element BEFORE second element\n          node.insertBefore(prepend, node.firstChild);\n        }\n      });\n    } else if (prependage.nodeType) {\n      node.insertBefore(prependage, node.firstChild);\n    }\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvcHJlcGVuZC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxJQUFJLEdBQUdDLG1CQUFPLENBQUUseURBQVUsQ0FBQzs7QUFHL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUMsTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBV0MsVUFBVSxFQUFHO0VBQ3JDO0VBQ0EsSUFBSyxPQUFPQSxVQUFVLEtBQUssUUFBUSxFQUFHO0lBQ2xDQSxVQUFVLEdBQUcsSUFBSUosSUFBSSxDQUFFSSxVQUFXLENBQUM7RUFDdkM7RUFFQSxJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0I7SUFDQSxJQUFLRixVQUFVLFlBQVlKLElBQUksSUFBS0ksVUFBVSxDQUFDRyxNQUFNLElBQUksT0FBT0gsVUFBVSxDQUFDQyxPQUFPLEtBQUssVUFBVyxFQUFHO01BQ2pHRCxVQUFVLENBQUNDLE9BQU8sQ0FBQyxVQUFXRyxPQUFPLEVBQUc7UUFDcEMsSUFBS0EsT0FBTyxDQUFDQyxRQUFRLElBQUlELE9BQU8sQ0FBQ0MsUUFBUSxLQUFLLENBQUMsRUFBRztVQUM5QztVQUNBO1VBQ0FILElBQUksQ0FBQ0ksWUFBWSxDQUFFRixPQUFPLEVBQUVGLElBQUksQ0FBQ0ssVUFBVyxDQUFDO1FBQ2pEO01BQ0osQ0FBQyxDQUFDO0lBRU4sQ0FBQyxNQUFNLElBQUtQLFVBQVUsQ0FBQ0ssUUFBUSxFQUFHO01BQzlCSCxJQUFJLENBQUNJLFlBQVksQ0FBRU4sVUFBVSxFQUFFRSxJQUFJLENBQUNLLFVBQVcsQ0FBQztJQUNwRDtFQUNKLENBQUMsQ0FBQztFQUVGLE9BQU8sSUFBSTtBQUNmLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvcHJlcGVuZC5qcz9mNTNlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBIb2JvID0gcmVxdWlyZSggXCIuLi9Ib2JvXCIgKTtcblxuXG4vKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBIb2JvXG4gKiBAbWV0aG9kIHByZXBlbmRcbiAqIEBwYXJhbSB7bWl4ZWR9IHByZXBlbmRhZ2UgV2hhdCB0byBwcmVwZW5kPyBIb2JvLCBFbGVtZW50Li4uXG4gKiBAZGVzY3JpcHRpb24gQXBwZW5kIHRoZSBub2RlcyB0byB0aGUgRE9NXG4gKiBAcmV0dXJucyB7SG9ib31cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBwcmVwZW5kYWdlICkge1xuICAgIC8vIFNlbGVjdG9yIHN0cmluZywgd3JhcCBpbiBuZXcgSG9ibyBpbnN0YW5jZVxuICAgIGlmICggdHlwZW9mIHByZXBlbmRhZ2UgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgIHByZXBlbmRhZ2UgPSBuZXcgSG9ibyggcHJlcGVuZGFnZSApO1xuICAgIH1cblxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgIC8vIEhvYm8gaW5zdGFuY2UgT1IgQXJyYXkgT1IgQXJyYXktbGlrZSBvYmplY3Qgd2l0aCBmb3JFYWNoXG4gICAgICAgIGlmICggcHJlcGVuZGFnZSBpbnN0YW5jZW9mIEhvYm8gfHwgKHByZXBlbmRhZ2UubGVuZ3RoICYmIHR5cGVvZiBwcmVwZW5kYWdlLmZvckVhY2ggPT09IFwiZnVuY3Rpb25cIikgKSB7XG4gICAgICAgICAgICBwcmVwZW5kYWdlLmZvckVhY2goZnVuY3Rpb24gKCBwcmVwZW5kICkge1xuICAgICAgICAgICAgICAgIGlmICggcHJlcGVuZC5ub2RlVHlwZSAmJiBwcmVwZW5kLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9pbnNlcnRCZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGV4dCBub2RlIGluc2VydHMgZmlyc3QgZWxlbWVudCBCRUZPUkUgc2Vjb25kIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoIHByZXBlbmQsIG5vZGUuZmlyc3RDaGlsZCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIHByZXBlbmRhZ2Uubm9kZVR5cGUgKSB7XG4gICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZSggcHJlcGVuZGFnZSwgbm9kZS5maXJzdENoaWxkICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTsiXSwibmFtZXMiOlsiSG9ibyIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicHJlcGVuZGFnZSIsImZvckVhY2giLCJub2RlIiwibGVuZ3RoIiwicHJlcGVuZCIsIm5vZGVUeXBlIiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/prepend.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/prev.js":
/*!*********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/prev.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n  matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method prev\n * @param {string} selector Optional selector to match\n * @description Get the previous sibling, test against selector\n * @returns {Hobo}\n *\n */\nmodule.exports = function (selector) {\n  var ret = [];\n  this.forEach(function (node) {\n    var prevNode = node.previousSibling;\n    while (prevNode && prevNode.nodeType !== 1) {\n      prevNode = prevNode.previousSibling;\n    }\n    if (prevNode && (!selector || selector && matchElement(prevNode, selector))) {\n      ret.push(prevNode);\n    }\n  });\n  return new Hobo(ret, this._context);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvcHJldi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxJQUFJLEdBQUdDLG1CQUFPLENBQUUseURBQVUsQ0FBQztFQUMzQkMsWUFBWSxHQUFHRCxtQkFBTyxDQUFFLDhHQUF3QixDQUFDOztBQUlyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBRSxNQUFNLENBQUNDLE9BQU8sR0FBRyxVQUFXQyxRQUFRLEVBQUc7RUFDbkMsSUFBSUMsR0FBRyxHQUFHLEVBQUU7RUFFWixJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0IsSUFBSUMsUUFBUSxHQUFHRCxJQUFJLENBQUNFLGVBQWU7SUFFbkMsT0FBUUQsUUFBUSxJQUFJQSxRQUFRLENBQUNFLFFBQVEsS0FBSyxDQUFDLEVBQUc7TUFDMUNGLFFBQVEsR0FBR0EsUUFBUSxDQUFDQyxlQUFlO0lBQ3ZDO0lBRUEsSUFBS0QsUUFBUSxLQUFLLENBQUNKLFFBQVEsSUFBS0EsUUFBUSxJQUFJSCxZQUFZLENBQUVPLFFBQVEsRUFBRUosUUFBUyxDQUFFLENBQUMsRUFBRztNQUMvRUMsR0FBRyxDQUFDTSxJQUFJLENBQUVILFFBQVMsQ0FBQztJQUN4QjtFQUNKLENBQUMsQ0FBQztFQUVGLE9BQU8sSUFBSVQsSUFBSSxDQUFFTSxHQUFHLEVBQUUsSUFBSSxDQUFDTyxRQUFTLENBQUM7QUFDekMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC9wcmV2LmpzP2JlMDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEhvYm8gPSByZXF1aXJlKCBcIi4uL0hvYm9cIiApLFxuICAgIG1hdGNoRWxlbWVudCA9IHJlcXVpcmUoIFwicHJvcGVyanMtbWF0Y2hlbGVtZW50XCIgKTtcblxuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2QgcHJldlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIE9wdGlvbmFsIHNlbGVjdG9yIHRvIG1hdGNoXG4gKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBwcmV2aW91cyBzaWJsaW5nLCB0ZXN0IGFnYWluc3Qgc2VsZWN0b3JcbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgIHZhciBwcmV2Tm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuXG4gICAgICAgIHdoaWxlICggcHJldk5vZGUgJiYgcHJldk5vZGUubm9kZVR5cGUgIT09IDEgKSB7XG4gICAgICAgICAgICBwcmV2Tm9kZSA9IHByZXZOb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcHJldk5vZGUgJiYgKCFzZWxlY3RvciB8fCAoc2VsZWN0b3IgJiYgbWF0Y2hFbGVtZW50KCBwcmV2Tm9kZSwgc2VsZWN0b3IgKSkpICkge1xuICAgICAgICAgICAgcmV0LnB1c2goIHByZXZOb2RlICk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgSG9ibyggcmV0LCB0aGlzLl9jb250ZXh0ICk7XG59O1xuIl0sIm5hbWVzIjpbIkhvYm8iLCJyZXF1aXJlIiwibWF0Y2hFbGVtZW50IiwibW9kdWxlIiwiZXhwb3J0cyIsInNlbGVjdG9yIiwicmV0IiwiZm9yRWFjaCIsIm5vZGUiLCJwcmV2Tm9kZSIsInByZXZpb3VzU2libGluZyIsIm5vZGVUeXBlIiwicHVzaCIsIl9jb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/prev.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/remove.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("/**\n *\n * @instance\n * @memberof Hobo\n * @method remove\n * @description Remove the nodes from the DOM\n *              This method will remove events and data.\n * @returns {Hobo}\n *\n */\nmodule.exports = function () {\n  // Remove Events\n  this.off();\n  this.forEach(function (node) {\n    // Remove Data\n    // Could this cause issues ?\n    delete node.hoboDataMap;\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvcmVtb3ZlLmpzIiwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIm9mZiIsImZvckVhY2giLCJub2RlIiwiaG9ib0RhdGFNYXAiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiXSwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC9yZW1vdmUuanM/YTc4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBIb2JvXG4gKiBAbWV0aG9kIHJlbW92ZVxuICogQGRlc2NyaXB0aW9uIFJlbW92ZSB0aGUgbm9kZXMgZnJvbSB0aGUgRE9NXG4gKiAgICAgICAgICAgICAgVGhpcyBtZXRob2Qgd2lsbCByZW1vdmUgZXZlbnRzIGFuZCBkYXRhLlxuICogQHJldHVybnMge0hvYm99XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZW1vdmUgRXZlbnRzXG4gICAgdGhpcy5vZmYoKTtcblxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgIC8vIFJlbW92ZSBEYXRhXG4gICAgICAgIC8vIENvdWxkIHRoaXMgY2F1c2UgaXNzdWVzID9cbiAgICAgICAgZGVsZXRlIG5vZGUuaG9ib0RhdGFNYXA7XG5cbiAgICAgICAgaWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsTUFBTSxDQUFDQyxPQUFPLEdBQUcsWUFBWTtFQUN6QjtFQUNBLElBQUksQ0FBQ0MsR0FBRyxDQUFDLENBQUM7RUFFVixJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0I7SUFDQTtJQUNBLE9BQU9BLElBQUksQ0FBQ0MsV0FBVztJQUV2QixJQUFLRCxJQUFJLENBQUNFLFVBQVUsRUFBRztNQUNuQkYsSUFBSSxDQUFDRSxVQUFVLENBQUNDLFdBQVcsQ0FBRUgsSUFBSyxDQUFDO0lBQ3ZDO0VBQ0osQ0FBQyxDQUFDO0VBRUYsT0FBTyxJQUFJO0FBQ2YsQ0FBQyJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/remove.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/removeAttr.js":
/*!***************************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/removeAttr.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var utils = __webpack_require__(/*! ../utils */ \"./node_modules/properjs-hobo/lib/utils.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method removeAttr\n * @param {string} attr The attribute to remove\n * @description Remove the specified attribute from each node in the set.\n * @returns {Hobo}\n *\n * @note This method needs to update data() in case we remove data-attr's\n *\n */\nmodule.exports = function (attr) {\n  this.forEach(function (node) {\n    node.removeAttribute(attr);\n\n    // Remove data()?\n    if (utils.rData.test(attr)) {\n      utils.removeData(attr.replace(utils.rData, \"\"), node);\n    }\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvcmVtb3ZlQXR0ci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxLQUFLLEdBQUdDLG1CQUFPLENBQUUsMkRBQVcsQ0FBQzs7QUFHakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFVBQVdDLElBQUksRUFBRztFQUMvQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0JBLElBQUksQ0FBQ0MsZUFBZSxDQUFFSCxJQUFLLENBQUM7O0lBRTVCO0lBQ0EsSUFBS0osS0FBSyxDQUFDUSxLQUFLLENBQUNDLElBQUksQ0FBRUwsSUFBSyxDQUFDLEVBQUc7TUFDNUJKLEtBQUssQ0FBQ1UsVUFBVSxDQUFFTixJQUFJLENBQUNPLE9BQU8sQ0FBRVgsS0FBSyxDQUFDUSxLQUFLLEVBQUUsRUFBRyxDQUFDLEVBQUVGLElBQUssQ0FBQztJQUM3RDtFQUNKLENBQUMsQ0FBQztFQUVGLE9BQU8sSUFBSTtBQUNmLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvcmVtb3ZlQXR0ci5qcz82MGI1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlscyA9IHJlcXVpcmUoIFwiLi4vdXRpbHNcIiApO1xuXG5cbi8qKlxuICpcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZXRob2QgcmVtb3ZlQXR0clxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgVGhlIGF0dHJpYnV0ZSB0byByZW1vdmVcbiAqIEBkZXNjcmlwdGlvbiBSZW1vdmUgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGUgZnJvbSBlYWNoIG5vZGUgaW4gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqIEBub3RlIFRoaXMgbWV0aG9kIG5lZWRzIHRvIHVwZGF0ZSBkYXRhKCkgaW4gY2FzZSB3ZSByZW1vdmUgZGF0YS1hdHRyJ3NcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBhdHRyICkge1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCBhdHRyICk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGRhdGEoKT9cbiAgICAgICAgaWYgKCB1dGlscy5yRGF0YS50ZXN0KCBhdHRyICkgKSB7XG4gICAgICAgICAgICB1dGlscy5yZW1vdmVEYXRhKCBhdHRyLnJlcGxhY2UoIHV0aWxzLnJEYXRhLCBcIlwiICksIG5vZGUgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJhdHRyIiwiZm9yRWFjaCIsIm5vZGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyRGF0YSIsInRlc3QiLCJyZW1vdmVEYXRhIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/removeAttr.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/toggleClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/toggleClass.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hobo = __webpack_require__(/*! ../Hobo */ \"./node_modules/properjs-hobo/lib/Hobo.js\"),\n  matchElement = __webpack_require__(/*! properjs-matchelement */ \"./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\");\n\n/**\n *\n * @instance\n * @memberof Hobo\n * @method toggleClass\n * @description Add or remove the specified classNames.\n * @param {string} classes The space-separated classNames\n * @returns {Hobo}\n *\n */\nmodule.exports = function (classes) {\n  classes = classes.split(\" \");\n  this.forEach(function (node) {\n    classes.forEach(function (klass) {\n      if (matchElement(node, \".\"  klass)) {\n        new Hobo(node, null).removeClass(klass);\n      } else {\n        new Hobo(node, null).addClass(klass);\n      }\n    });\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvdG9nZ2xlQ2xhc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsSUFBSSxHQUFHQyxtQkFBTyxDQUFFLHlEQUFVLENBQUM7RUFDM0JDLFlBQVksR0FBR0QsbUJBQU8sQ0FBRSw4R0FBd0IsQ0FBQzs7QUFHckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUUsTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBV0MsT0FBTyxFQUFHO0VBQ2xDQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0MsS0FBSyxDQUFFLEdBQUksQ0FBQztFQUU5QixJQUFJLENBQUNDLE9BQU8sQ0FBQyxVQUFXQyxJQUFJLEVBQUc7SUFDM0JILE9BQU8sQ0FBQ0UsT0FBTyxDQUFDLFVBQVdFLEtBQUssRUFBRztNQUMvQixJQUFLUCxZQUFZLENBQUVNLElBQUksRUFBRyxHQUFHLEdBQUdDLEtBQU8sQ0FBQyxFQUFHO1FBQ3ZDLElBQUlULElBQUksQ0FBRVEsSUFBSSxFQUFFLElBQUssQ0FBQyxDQUFDRSxXQUFXLENBQUVELEtBQU0sQ0FBQztNQUUvQyxDQUFDLE1BQU07UUFDSCxJQUFJVCxJQUFJLENBQUVRLElBQUksRUFBRSxJQUFLLENBQUMsQ0FBQ0csUUFBUSxDQUFFRixLQUFNLENBQUM7TUFDNUM7SUFDSixDQUFDLENBQUM7RUFDTixDQUFDLENBQUM7RUFFRixPQUFPLElBQUk7QUFDZixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWhvYm8vbGliL2V4dGVuZGVkL3RvZ2dsZUNsYXNzLmpzPzY2ZjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEhvYm8gPSByZXF1aXJlKCBcIi4uL0hvYm9cIiApLFxuICAgIG1hdGNoRWxlbWVudCA9IHJlcXVpcmUoIFwicHJvcGVyanMtbWF0Y2hlbGVtZW50XCIgKTtcblxuXG4vKipcbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBIb2JvXG4gKiBAbWV0aG9kIHRvZ2dsZUNsYXNzXG4gKiBAZGVzY3JpcHRpb24gQWRkIG9yIHJlbW92ZSB0aGUgc3BlY2lmaWVkIGNsYXNzTmFtZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBUaGUgc3BhY2Utc2VwYXJhdGVkIGNsYXNzTmFtZXNcbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoIGNsYXNzZXMgKSB7XG4gICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoIFwiIFwiICk7XG5cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKCBrbGFzcyApIHtcbiAgICAgICAgICAgIGlmICggbWF0Y2hFbGVtZW50KCBub2RlLCAoXCIuXCIgKyBrbGFzcykgKSApIHtcbiAgICAgICAgICAgICAgICBuZXcgSG9ibyggbm9kZSwgbnVsbCApLnJlbW92ZUNsYXNzKCBrbGFzcyApO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ldyBIb2JvKCBub2RlLCBudWxsICkuYWRkQ2xhc3MoIGtsYXNzICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59OyJdLCJuYW1lcyI6WyJIb2JvIiwicmVxdWlyZSIsIm1hdGNoRWxlbWVudCIsIm1vZHVsZSIsImV4cG9ydHMiLCJjbGFzc2VzIiwic3BsaXQiLCJmb3JFYWNoIiwibm9kZSIsImtsYXNzIiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/toggleClass.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/extended/trigger.js":
/*!************************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/extended/trigger.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/**\n *\n * @instance\n * @memberof Hobo\n * @method trigger\n * @description Dispatch a simulated event.\n * @param {string} event The event to dispatch\n * @returns {Hobo}\n *\n */\nmodule.exports = function (event) {\n  var self = this,\n    evo,\n    id;\n  this.forEach(function (node) {\n    for (id in self._events[event]) {\n      if (self._events[event].hasOwnProperty(id)) {\n        evo = self._events[event][id];\n\n        // Match the nodes\n        if (evo.node === node) {\n          evo = document.createEvent(\"Events\");\n          evo.initEvent(event, true, false);\n          node.dispatchEvent(evo);\n        }\n      }\n    }\n  });\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvZXh0ZW5kZWQvdHJpZ2dlci5qcyIsIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJldmVudCIsInNlbGYiLCJldm8iLCJpZCIsImZvckVhY2giLCJub2RlIiwiX2V2ZW50cyIsImhhc093blByb3BlcnR5IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiXSwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1ob2JvL2xpYi9leHRlbmRlZC90cmlnZ2VyLmpzP2JmOGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgSG9ib1xuICogQG1ldGhvZCB0cmlnZ2VyXG4gKiBAZGVzY3JpcHRpb24gRGlzcGF0Y2ggYSBzaW11bGF0ZWQgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHRvIGRpc3BhdGNoXG4gKiBAcmV0dXJucyB7SG9ib31cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGV2byxcbiAgICAgICAgaWQ7XG5cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICBmb3IgKCBpZCBpbiBzZWxmLl9ldmVudHNbIGV2ZW50IF0gKSB7XG4gICAgICAgICAgICBpZiAoIHNlbGYuX2V2ZW50c1sgZXZlbnQgXS5oYXNPd25Qcm9wZXJ0eSggaWQgKSApIHtcbiAgICAgICAgICAgICAgICBldm8gPSBzZWxmLl9ldmVudHNbIGV2ZW50IF1bIGlkIF07XG5cbiAgICAgICAgICAgICAgICAvLyBNYXRjaCB0aGUgbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoIGV2by5ub2RlID09PSBub2RlICkge1xuICAgICAgICAgICAgICAgICAgICBldm8gPSBkb2N1bWVudC5jcmVhdGVFdmVudCggXCJFdmVudHNcIiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGV2by5pbml0RXZlbnQoIGV2ZW50LCB0cnVlLCBmYWxzZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudCggZXZvICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxNQUFNLENBQUNDLE9BQU8sR0FBRyxVQUFXQyxLQUFLLEVBQUc7RUFDaEMsSUFBSUMsSUFBSSxHQUFHLElBQUk7SUFDWEMsR0FBRztJQUNIQyxFQUFFO0VBRU4sSUFBSSxDQUFDQyxPQUFPLENBQUMsVUFBV0MsSUFBSSxFQUFHO0lBQzNCLEtBQU1GLEVBQUUsSUFBSUYsSUFBSSxDQUFDSyxPQUFPLENBQUVOLEtBQUssQ0FBRSxFQUFHO01BQ2hDLElBQUtDLElBQUksQ0FBQ0ssT0FBTyxDQUFFTixLQUFLLENBQUUsQ0FBQ08sY0FBYyxDQUFFSixFQUFHLENBQUMsRUFBRztRQUM5Q0QsR0FBRyxHQUFHRCxJQUFJLENBQUNLLE9BQU8sQ0FBRU4sS0FBSyxDQUFFLENBQUVHLEVBQUUsQ0FBRTs7UUFFakM7UUFDQSxJQUFLRCxHQUFHLENBQUNHLElBQUksS0FBS0EsSUFBSSxFQUFHO1VBQ3JCSCxHQUFHLEdBQUdNLFFBQVEsQ0FBQ0MsV0FBVyxDQUFFLFFBQVMsQ0FBQztVQUV0Q1AsR0FBRyxDQUFDUSxTQUFTLENBQUVWLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBTSxDQUFDO1VBRW5DSyxJQUFJLENBQUNNLGFBQWEsQ0FBRVQsR0FBSSxDQUFDO1FBQzdCO01BQ0o7SUFDSjtFQUNKLENBQUMsQ0FBQztFQUVGLE9BQU8sSUFBSTtBQUNmLENBQUMifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/extended/trigger.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/properjs-hobo/lib/utils.js ***!
  \*************************************************/
/***/ ((module) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/**\n *\n * @static\n * @memberof Hobo\n * @member utils\n * @description Utility methods used internally by Hobo\n *\n */\nvar version = \"0.3.15\",\n  rData = /^data-/,\n  rDigit = /\\D/g,\n  rDashAlpha = /-([\\da-z])/gi,\n  rTag = /^</,\n  rJson = /^\\[|\\{/,\n  rDocType = /^<\\!DOCTYPE\\shtml>/i,\n  rFront2Back = /^\\s|\\s$/g,\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method trimString\n   * @description Trim leading and trailing whitespace\n   * @param {string} str The string to trim\n   * @returns {string}\n   *\n   */\n  trimString = function trimString(str) {\n    return str.replace(rFront2Back, \"\");\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method camelCase\n   * @description Camel case a string\n   * @param {string} str The string to camel case\n   * @returns {string}\n   *\n   */\n  camelCase = function camelCase(str) {\n    return str.replace(rDashAlpha, function (all, letter) {\n      return letter.toUpperCase();\n    });\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method makeId\n   * @description Make a unique hobo ID string\n   * @returns {string}\n   *\n   */\n  makeId = function makeId() {\n    return \"hobo\"  (version  Math.random()).replace(rDigit, \"\");\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method makeArray\n   * @description Convert elements to a native Array\n   * @param {elements} nodes The nodes to make into an array\n   * @returns {array}\n   *\n   */\n  makeArray = function makeArray(nodes) {\n    return [].slice.call(nodes);\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method makeData\n   * @description Establish the hoboDataMap for a node\n   * @param {element} node The node to map data on\n   *\n   */\n  makeData = function makeData(node) {\n    if (!node.hoboDataMap) {\n      node.hoboDataMap = {};\n    }\n    if (node.dataset) {\n      _mapDataset(node);\n    } else if (node.attributes) {\n      _mapAttributes(node);\n    }\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method storeData\n   * @description Store data in the hoboDataMap\n   * @param {object} data The data to store\n   * @param {element} node The node to store data with\n   *\n   */\n  storeData = function storeData(data, node) {\n    var id, i;\n    for (i in data) {\n      if (data.hasOwnProperty(i)) {\n        id = camelCase(i);\n        node.hoboDataMap[id] = data[i];\n      }\n    }\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method mergeData\n   * @description Merge\n   * @param {object} data The data to mutate\n   * @param {element} node The node to pull data from\n   *\n   */\n  mergeData = function mergeData(data, node) {\n    for (var i in node.hoboDataMap) {\n      if (node.hoboDataMap.hasOwnProperty(i) && !data[i]) {\n        data[i] = node.hoboDataMap[i];\n      }\n    }\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method retrieveData\n   * @description Get data from a node\n   * @param {string} key The reference point for a data entry\n   * @param {element} node The node to pull a data value from\n   * @returns {mixed}\n   *\n   */\n  retrieveData = function retrieveData(key, node) {\n    var ret = null;\n\n    // All data mapped into Hobo will be camel-cased\n    key = camelCase(key);\n    if (node.hoboDataMap && node.hoboDataMap[key]) {\n      ret = node.hoboDataMap[key];\n    }\n    return ret;\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method removeData\n   * @description Delete data from a nodes hoboDataMap\n   * @param {string} key The reference point for a data entry\n   * @param {element} node The node to delete a data value from\n   *\n   */\n  removeData = function removeData(key, node) {\n    // All data mapped into Hobo will be camel-cased\n    key = camelCase(key);\n    if (node.hoboDataMap && node.hoboDataMap[key]) {\n      delete node.hoboDataMap[key];\n    }\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method serializeData\n   * @description Convert data into AJAXable querystring\n   * @param {object} data The data to convert\n   * @param {string} prefix The current iterations property name\n   * @returns {string}\n   *\n   */\n  serializeData = function serializeData(data, prefix) {\n    var str = [],\n      key,\n      val,\n      i;\n    for (i in data) {\n      if (data.hasOwnProperty(i)) {\n        key = prefix ? prefix  \"[\"  i  \"]\" : i;\n        val = data[i];\n        if (Array.isArray(val)) {\n          val.forEach(function (v) {\n            str.push(encodeURIComponent(key)  \"[]\"  \"=\"  encodeURIComponent(v));\n          });\n        } else if (_typeof(val) === \"object\") {\n          str.push(serializeData(val, key));\n        } else {\n          str.push(encodeURIComponent(key)  \"=\"  encodeURIComponent(val));\n        }\n      }\n    }\n    return str.join(\"&\");\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method getClass\n   * @description Get the class string from a node\n   * @param {Element} node The node to get `class` for\n   * @returns {string}\n   *\n   */\n  getClass = function getClass(node) {\n    return node.getAttribute(\"class\") || \"\";\n  },\n  /**\n   *\n   * @public\n   * @memberof utils\n   * @method setClass\n   * @description Set the class string for a node\n   * @param {Element} node The node to set `class` on\n   * @param {string} klass The class string to be applied\n   *\n   */\n  setClass = function setClass(node, klass) {\n    node.setAttribute(\"class\", klass);\n  },\n  // DOMStringMap camel-cases data- attributes.\n  // NamedNodeMap is a fallback which supports IE 10.\n  // Data mapped through Hobo must camel-case as well.\n\n  /**\n   *\n   * @private\n   * @memberof utils\n   * @method _getDataValue\n   * @description Normalized parsing of JSON string into Object\n   * @param {object} data The data to parse\n   * @returns {object}\n   *\n   */\n  _getDataValue = function _getDataValue(data) {\n    if (rJson.test(data)) {\n      try {\n        data = JSON.parse(data);\n      } catch (error) {\n        throw error;\n      }\n    }\n    return data;\n  },\n  /**\n   *\n   * @private\n   * @memberof utils\n   * @method _mapAttributes\n   * @description Migrate existing NamedNodeMap to a nodes hoboDataMap\n   * @param {element} node The data to parse\n   *\n   */\n  _mapAttributes = function _mapAttributes(node) {\n    var i = node.attributes.length;\n    for (i; i--;) {\n      if (rData.test(node.attributes[i].name)) {\n        var key = camelCase(node.attributes[i].name.replace(rData, \"\"));\n        node.hoboDataMap[key] = _getDataValue(node.attributes[i].value);\n      }\n    }\n  },\n  /**\n   *\n   * @private\n   * @memberof utils\n   * @method _mapDataset\n   * @description Migrate existing DOMStringMap to a nodes hoboDataMap\n   * @param {element} node The data to parse\n   *\n   */\n  _mapDataset = function _mapDataset(node) {\n    for (var i in node.dataset) {\n      if (node.dataset.hasOwnProperty(i)) {\n        node.hoboDataMap[i] = _getDataValue(node.dataset[i]);\n      }\n    }\n  };\nmodule.exports = {\n  version: version,\n  rData: rData,\n  rDigit: rDigit,\n  rTag: rTag,\n  rJson: rJson,\n  rDocType: rDocType,\n  rFront2Back: rFront2Back,\n  trimString: trimString,\n  camelCase: camelCase,\n  makeId: makeId,\n  makeArray: makeArray,\n  makeData: makeData,\n  storeData: storeData,\n  retrieveData: retrieveData,\n  mergeData: mergeData,\n  removeData: removeData,\n  serializeData: serializeData,\n  getClass: getClass,\n  setClass: setClass\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9saWIvdXRpbHMuanMiLCJuYW1lcyI6WyJ2ZXJzaW9uIiwickRhdGEiLCJyRGlnaXQiLCJyRGFzaEFscGhhIiwiclRhZyIsInJKc29uIiwickRvY1R5cGUiLCJyRnJvbnQyQmFjayIsInRyaW1TdHJpbmciLCJzdHIiLCJyZXBsYWNlIiwiY2FtZWxDYXNlIiwiYWxsIiwibGV0dGVyIiwidG9VcHBlckNhc2UiLCJtYWtlSWQiLCJNYXRoIiwicmFuZG9tIiwibWFrZUFycmF5Iiwibm9kZXMiLCJzbGljZSIsImNhbGwiLCJtYWtlRGF0YSIsIm5vZGUiLCJob2JvRGF0YU1hcCIsImRhdGFzZXQiLCJfbWFwRGF0YXNldCIsImF0dHJpYnV0ZXMiLCJfbWFwQXR0cmlidXRlcyIsInN0b3JlRGF0YSIsImRhdGEiLCJpZCIsImkiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlRGF0YSIsInJldHJpZXZlRGF0YSIsImtleSIsInJldCIsInJlbW92ZURhdGEiLCJzZXJpYWxpemVEYXRhIiwicHJlZml4IiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInYiLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiX3R5cGVvZiIsImpvaW4iLCJnZXRDbGFzcyIsImdldEF0dHJpYnV0ZSIsInNldENsYXNzIiwia2xhc3MiLCJzZXRBdHRyaWJ1dGUiLCJfZ2V0RGF0YVZhbHVlIiwidGVzdCIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwibGVuZ3RoIiwibmFtZSIsInZhbHVlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWhvYm8vbGliL3V0aWxzLmpzPzJkNzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIEhvYm9cbiAqIEBtZW1iZXIgdXRpbHNcbiAqIEBkZXNjcmlwdGlvbiBVdGlsaXR5IG1ldGhvZHMgdXNlZCBpbnRlcm5hbGx5IGJ5IEhvYm9cbiAqXG4gKi9cbnZhciB2ZXJzaW9uID0gXCIwLjMuMTVcIixcblxuXG4gICAgckRhdGEgPSAvXmRhdGEtLyxcblxuXG4gICAgckRpZ2l0ID0gL1xcRC9nLFxuXG5cbiAgICByRGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cbiAgICByVGFnID0gL148LyxcblxuXG4gICAgckpzb24gPSAvXlxcW3xcXHsvLFxuXG5cbiAgICByRG9jVHlwZSA9IC9ePFxcIURPQ1RZUEVcXHNodG1sPi9pLFxuXG5cbiAgICByRnJvbnQyQmFjayA9IC9eXFxzK3xcXHMrJC9nLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWVtYmVyb2YgdXRpbHNcbiAgICAgKiBAbWV0aG9kIHRyaW1TdHJpbmdcbiAgICAgKiBAZGVzY3JpcHRpb24gVHJpbSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHRyaW1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqXG4gICAgICovXG4gICAgdHJpbVN0cmluZyA9IGZ1bmN0aW9uICggc3RyICkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoIHJGcm9udDJCYWNrLCBcIlwiICk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlcm9mIHV0aWxzXG4gICAgICogQG1ldGhvZCBjYW1lbENhc2VcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FtZWwgY2FzZSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjYW1lbCBjYXNlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKlxuICAgICAqL1xuICAgIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uICggc3RyICkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoIHJEYXNoQWxwaGEsIGZ1bmN0aW9uICggYWxsLCBsZXR0ZXIgKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXJvZiB1dGlsc1xuICAgICAqIEBtZXRob2QgbWFrZUlkXG4gICAgICogQGRlc2NyaXB0aW9uIE1ha2UgYSB1bmlxdWUgaG9ibyBJRCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqXG4gICAgICovXG4gICAgbWFrZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFwiaG9ib1wiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIHJEaWdpdCwgXCJcIiApKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWVtYmVyb2YgdXRpbHNcbiAgICAgKiBAbWV0aG9kIG1ha2VBcnJheVxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0IGVsZW1lbnRzIHRvIGEgbmF0aXZlIEFycmF5XG4gICAgICogQHBhcmFtIHtlbGVtZW50c30gbm9kZXMgVGhlIG5vZGVzIHRvIG1ha2UgaW50byBhbiBhcnJheVxuICAgICAqIEByZXR1cm5zIHthcnJheX1cbiAgICAgKlxuICAgICAqL1xuICAgIG1ha2VBcnJheSA9IGZ1bmN0aW9uICggbm9kZXMgKSB7XG4gICAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKCBub2RlcyApO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXJvZiB1dGlsc1xuICAgICAqIEBtZXRob2QgbWFrZURhdGFcbiAgICAgKiBAZGVzY3JpcHRpb24gRXN0YWJsaXNoIHRoZSBob2JvRGF0YU1hcCBmb3IgYSBub2RlXG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBub2RlIFRoZSBub2RlIHRvIG1hcCBkYXRhIG9uXG4gICAgICpcbiAgICAgKi9cbiAgICBtYWtlRGF0YSA9IGZ1bmN0aW9uICggbm9kZSApIHtcbiAgICAgICAgaWYgKCAhbm9kZS5ob2JvRGF0YU1hcCApIHtcbiAgICAgICAgICAgIG5vZGUuaG9ib0RhdGFNYXAgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbm9kZS5kYXRhc2V0ICkge1xuICAgICAgICAgICAgX21hcERhdGFzZXQoIG5vZGUgKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCBub2RlLmF0dHJpYnV0ZXMgKSB7XG4gICAgICAgICAgICBfbWFwQXR0cmlidXRlcyggbm9kZSApO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlcm9mIHV0aWxzXG4gICAgICogQG1ldGhvZCBzdG9yZURhdGFcbiAgICAgKiBAZGVzY3JpcHRpb24gU3RvcmUgZGF0YSBpbiB0aGUgaG9ib0RhdGFNYXBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBzdG9yZVxuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gbm9kZSBUaGUgbm9kZSB0byBzdG9yZSBkYXRhIHdpdGhcbiAgICAgKlxuICAgICAqL1xuICAgIHN0b3JlRGF0YSA9IGZ1bmN0aW9uICggZGF0YSwgbm9kZSApIHtcbiAgICAgICAgdmFyIGlkLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKCBpIGluIGRhdGEgKSB7XG4gICAgICAgICAgICBpZiAoIGRhdGEuaGFzT3duUHJvcGVydHkoIGkgKSApIHtcbiAgICAgICAgICAgICAgICBpZCA9IGNhbWVsQ2FzZSggaSApO1xuXG4gICAgICAgICAgICAgICAgbm9kZS5ob2JvRGF0YU1hcFsgaWQgXSA9IGRhdGFbIGkgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXJvZiB1dGlsc1xuICAgICAqIEBtZXRob2QgbWVyZ2VEYXRhXG4gICAgICogQGRlc2NyaXB0aW9uIE1lcmdlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gbXV0YXRlXG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBub2RlIFRoZSBub2RlIHRvIHB1bGwgZGF0YSBmcm9tXG4gICAgICpcbiAgICAgKi9cbiAgICBtZXJnZURhdGEgPSBmdW5jdGlvbiAoIGRhdGEsIG5vZGUgKSB7XG4gICAgICAgIGZvciAoIHZhciBpIGluIG5vZGUuaG9ib0RhdGFNYXAgKSB7XG4gICAgICAgICAgICBpZiAoIG5vZGUuaG9ib0RhdGFNYXAuaGFzT3duUHJvcGVydHkoIGkgKSAmJiAhZGF0YVsgaSBdICkge1xuICAgICAgICAgICAgICAgIGRhdGFbIGkgXSA9IG5vZGUuaG9ib0RhdGFNYXBbIGkgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXJvZiB1dGlsc1xuICAgICAqIEBtZXRob2QgcmV0cmlldmVEYXRhXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCBkYXRhIGZyb20gYSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIHBvaW50IGZvciBhIGRhdGEgZW50cnlcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IG5vZGUgVGhlIG5vZGUgdG8gcHVsbCBhIGRhdGEgdmFsdWUgZnJvbVxuICAgICAqIEByZXR1cm5zIHttaXhlZH1cbiAgICAgKlxuICAgICAqL1xuICAgIHJldHJpZXZlRGF0YSA9IGZ1bmN0aW9uICgga2V5LCBub2RlICkge1xuICAgICAgICB2YXIgcmV0ID0gbnVsbDtcblxuICAgICAgICAvLyBBbGwgZGF0YSBtYXBwZWQgaW50byBIb2JvIHdpbGwgYmUgY2FtZWwtY2FzZWRcbiAgICAgICAga2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuICAgICAgICBpZiAoIG5vZGUuaG9ib0RhdGFNYXAgJiYgbm9kZS5ob2JvRGF0YU1hcFsga2V5IF0gKSB7XG4gICAgICAgICAgICByZXQgPSBub2RlLmhvYm9EYXRhTWFwWyBrZXkgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlcm9mIHV0aWxzXG4gICAgICogQG1ldGhvZCByZW1vdmVEYXRhXG4gICAgICogQGRlc2NyaXB0aW9uIERlbGV0ZSBkYXRhIGZyb20gYSBub2RlcyBob2JvRGF0YU1hcFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBwb2ludCBmb3IgYSBkYXRhIGVudHJ5XG4gICAgICogQHBhcmFtIHtlbGVtZW50fSBub2RlIFRoZSBub2RlIHRvIGRlbGV0ZSBhIGRhdGEgdmFsdWUgZnJvbVxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlRGF0YSA9IGZ1bmN0aW9uICgga2V5LCBub2RlICkge1xuICAgICAgICAvLyBBbGwgZGF0YSBtYXBwZWQgaW50byBIb2JvIHdpbGwgYmUgY2FtZWwtY2FzZWRcbiAgICAgICAga2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuICAgICAgICBpZiAoIG5vZGUuaG9ib0RhdGFNYXAgJiYgbm9kZS5ob2JvRGF0YU1hcFsga2V5IF0gKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZS5ob2JvRGF0YU1hcFsga2V5IF07XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWVtYmVyb2YgdXRpbHNcbiAgICAgKiBAbWV0aG9kIHNlcmlhbGl6ZURhdGFcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVydCBkYXRhIGludG8gQUpBWGFibGUgcXVlcnlzdHJpbmdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBUaGUgY3VycmVudCBpdGVyYXRpb25zIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqXG4gICAgICovXG4gICAgc2VyaWFsaXplRGF0YSA9IGZ1bmN0aW9uICggZGF0YSwgcHJlZml4ICkge1xuICAgICAgICB2YXIgc3RyID0gW10sXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoIGkgaW4gZGF0YSApIHtcbiAgICAgICAgICAgIGlmICggZGF0YS5oYXNPd25Qcm9wZXJ0eSggaSApICkge1xuICAgICAgICAgICAgICAgIGtleSA9IHByZWZpeCA/IChwcmVmaXggKyBcIltcIiArIGkgKyBcIl1cIikgOiBpO1xuICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFbIGkgXTtcblxuICAgICAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICggdiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKCAoZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiW11cIiArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2ICkpICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goIHNlcmlhbGl6ZURhdGEoIHZhbCwga2V5ICkgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKCAoZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWwgKSkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLmpvaW4oIFwiJlwiICk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlcm9mIHV0aWxzXG4gICAgICogQG1ldGhvZCBnZXRDbGFzc1xuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGNsYXNzIHN0cmluZyBmcm9tIGEgbm9kZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgbm9kZSB0byBnZXQgYGNsYXNzYCBmb3JcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCIpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXJvZiB1dGlsc1xuICAgICAqIEBtZXRob2Qgc2V0Q2xhc3NcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBjbGFzcyBzdHJpbmcgZm9yIGEgbm9kZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgbm9kZSB0byBzZXQgYGNsYXNzYCBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrbGFzcyBUaGUgY2xhc3Mgc3RyaW5nIHRvIGJlIGFwcGxpZWRcbiAgICAgKlxuICAgICAqL1xuICAgIHNldENsYXNzID0gZnVuY3Rpb24gKCBub2RlLCBrbGFzcyApIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwga2xhc3MgKTtcbiAgICB9LFxuXG5cbiAgICAvLyBET01TdHJpbmdNYXAgY2FtZWwtY2FzZXMgZGF0YS0gYXR0cmlidXRlcy5cbiAgICAvLyBOYW1lZE5vZGVNYXAgaXMgYSBmYWxsYmFjayB3aGljaCBzdXBwb3J0cyBJRSAxMC5cbiAgICAvLyBEYXRhIG1hcHBlZCB0aHJvdWdoIEhvYm8gbXVzdCBjYW1lbC1jYXNlIGFzIHdlbGwuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyb2YgdXRpbHNcbiAgICAgKiBAbWV0aG9kIF9nZXREYXRhVmFsdWVcbiAgICAgKiBAZGVzY3JpcHRpb24gTm9ybWFsaXplZCBwYXJzaW5nIG9mIEpTT04gc3RyaW5nIGludG8gT2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqXG4gICAgICovXG4gICAgX2dldERhdGFWYWx1ZSA9IGZ1bmN0aW9uICggZGF0YSApIHtcbiAgICAgICAgaWYgKCBySnNvbi50ZXN0KCBkYXRhICkgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKCBkYXRhICk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyb2YgdXRpbHNcbiAgICAgKiBAbWV0aG9kIF9tYXBBdHRyaWJ1dGVzXG4gICAgICogQGRlc2NyaXB0aW9uIE1pZ3JhdGUgZXhpc3RpbmcgTmFtZWROb2RlTWFwIHRvIGEgbm9kZXMgaG9ib0RhdGFNYXBcbiAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IG5vZGUgVGhlIGRhdGEgdG8gcGFyc2VcbiAgICAgKlxuICAgICAqL1xuICAgIF9tYXBBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCBub2RlICkge1xuICAgICAgICB2YXIgaSA9IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggaTsgaS0tOyApIHtcbiAgICAgICAgICAgIGlmICggckRhdGEudGVzdCggbm9kZS5hdHRyaWJ1dGVzWyBpIF0ubmFtZSApICkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjYW1lbENhc2UoIG5vZGUuYXR0cmlidXRlc1sgaSBdLm5hbWUucmVwbGFjZSggckRhdGEsIFwiXCIgKSApO1xuXG4gICAgICAgICAgICAgICAgbm9kZS5ob2JvRGF0YU1hcFsga2V5IF0gPSBfZ2V0RGF0YVZhbHVlKCBub2RlLmF0dHJpYnV0ZXNbIGkgXS52YWx1ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJvZiB1dGlsc1xuICAgICAqIEBtZXRob2QgX21hcERhdGFzZXRcbiAgICAgKiBAZGVzY3JpcHRpb24gTWlncmF0ZSBleGlzdGluZyBET01TdHJpbmdNYXAgdG8gYSBub2RlcyBob2JvRGF0YU1hcFxuICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gbm9kZSBUaGUgZGF0YSB0byBwYXJzZVxuICAgICAqXG4gICAgICovXG4gICAgX21hcERhdGFzZXQgPSBmdW5jdGlvbiAoIG5vZGUgKSB7XG4gICAgICAgIGZvciAoIHZhciBpIGluIG5vZGUuZGF0YXNldCApIHtcbiAgICAgICAgICAgIGlmICggbm9kZS5kYXRhc2V0Lmhhc093blByb3BlcnR5KCBpICkgKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5ob2JvRGF0YU1hcFsgaSBdID0gX2dldERhdGFWYWx1ZSggbm9kZS5kYXRhc2V0WyBpIF0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICByRGF0YTogckRhdGEsXG4gICAgckRpZ2l0OiByRGlnaXQsXG4gICAgclRhZzogclRhZyxcbiAgICBySnNvbjogckpzb24sXG4gICAgckRvY1R5cGU6IHJEb2NUeXBlLFxuICAgIHJGcm9udDJCYWNrOiByRnJvbnQyQmFjayxcbiAgICB0cmltU3RyaW5nOiB0cmltU3RyaW5nLFxuICAgIGNhbWVsQ2FzZTogY2FtZWxDYXNlLFxuICAgIG1ha2VJZDogbWFrZUlkLFxuICAgIG1ha2VBcnJheTogbWFrZUFycmF5LFxuICAgIG1ha2VEYXRhOiBtYWtlRGF0YSxcbiAgICBzdG9yZURhdGE6IHN0b3JlRGF0YSxcbiAgICByZXRyaWV2ZURhdGE6IHJldHJpZXZlRGF0YSxcbiAgICBtZXJnZURhdGE6IG1lcmdlRGF0YSxcbiAgICByZW1vdmVEYXRhOiByZW1vdmVEYXRhLFxuICAgIHNlcmlhbGl6ZURhdGE6IHNlcmlhbGl6ZURhdGEsXG4gICAgZ2V0Q2xhc3M6IGdldENsYXNzLFxuICAgIHNldENsYXNzOiBzZXRDbGFzc1xufTtcbiJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJQSxPQUFPLEdBQUcsUUFBUTtFQUdsQkMsS0FBSyxHQUFHLFFBQVE7RUFHaEJDLE1BQU0sR0FBRyxLQUFLO0VBR2RDLFVBQVUsR0FBRyxjQUFjO0VBRzNCQyxJQUFJLEdBQUcsSUFBSTtFQUdYQyxLQUFLLEdBQUcsUUFBUTtFQUdoQkMsUUFBUSxHQUFHLHFCQUFxQjtFQUdoQ0MsV0FBVyxHQUFHLFlBQVk7RUFHMUI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsVUFBVSxHQUFHLFNBQWJBLFVBQVVBLENBQWNDLEdBQUcsRUFBRztJQUMxQixPQUFPQSxHQUFHLENBQUNDLE9BQU8sQ0FBRUgsV0FBVyxFQUFFLEVBQUcsQ0FBQztFQUN6QyxDQUFDO0VBR0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUksU0FBUyxHQUFHLFNBQVpBLFNBQVNBLENBQWNGLEdBQUcsRUFBRztJQUN6QixPQUFPQSxHQUFHLENBQUNDLE9BQU8sQ0FBRVAsVUFBVSxFQUFFLFVBQVdTLEdBQUcsRUFBRUMsTUFBTSxFQUFHO01BQ3JELE9BQU9BLE1BQU0sQ0FBQ0MsV0FBVyxDQUFDLENBQUM7SUFDL0IsQ0FBQyxDQUFDO0VBQ04sQ0FBQztFQUdEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxNQUFNLEdBQUcsU0FBVEEsTUFBTUEsQ0FBQSxFQUFlO0lBQ2pCLE9BQVEsTUFBTSxHQUFHLENBQUVmLE9BQU8sR0FBR2dCLElBQUksQ0FBQ0MsTUFBTSxDQUFDLENBQUMsRUFBR1AsT0FBTyxDQUFFUixNQUFNLEVBQUUsRUFBRyxDQUFDO0VBQ3RFLENBQUM7RUFHRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJZ0IsU0FBUyxHQUFHLFNBQVpBLFNBQVNBLENBQWNDLEtBQUssRUFBRztJQUMzQixPQUFPLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUVGLEtBQU0sQ0FBQztFQUNqQyxDQUFDO0VBR0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lHLFFBQVEsR0FBRyxTQUFYQSxRQUFRQSxDQUFjQyxJQUFJLEVBQUc7SUFDekIsSUFBSyxDQUFDQSxJQUFJLENBQUNDLFdBQVcsRUFBRztNQUNyQkQsSUFBSSxDQUFDQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0lBQ3pCO0lBRUEsSUFBS0QsSUFBSSxDQUFDRSxPQUFPLEVBQUc7TUFDaEJDLFdBQVcsQ0FBRUgsSUFBSyxDQUFDO0lBRXZCLENBQUMsTUFBTSxJQUFLQSxJQUFJLENBQUNJLFVBQVUsRUFBRztNQUMxQkMsY0FBYyxDQUFFTCxJQUFLLENBQUM7SUFDMUI7RUFDSixDQUFDO0VBR0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSU0sU0FBUyxHQUFHLFNBQVpBLFNBQVNBLENBQWNDLElBQUksRUFBRVAsSUFBSSxFQUFHO0lBQ2hDLElBQUlRLEVBQUUsRUFDRkMsQ0FBQztJQUVMLEtBQU1BLENBQUMsSUFBSUYsSUFBSSxFQUFHO01BQ2QsSUFBS0EsSUFBSSxDQUFDRyxjQUFjLENBQUVELENBQUUsQ0FBQyxFQUFHO1FBQzVCRCxFQUFFLEdBQUdwQixTQUFTLENBQUVxQixDQUFFLENBQUM7UUFFbkJULElBQUksQ0FBQ0MsV0FBVyxDQUFFTyxFQUFFLENBQUUsR0FBR0QsSUFBSSxDQUFFRSxDQUFDLENBQUU7TUFDdEM7SUFDSjtFQUNKLENBQUM7RUFHRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJRSxTQUFTLEdBQUcsU0FBWkEsU0FBU0EsQ0FBY0osSUFBSSxFQUFFUCxJQUFJLEVBQUc7SUFDaEMsS0FBTSxJQUFJUyxDQUFDLElBQUlULElBQUksQ0FBQ0MsV0FBVyxFQUFHO01BQzlCLElBQUtELElBQUksQ0FBQ0MsV0FBVyxDQUFDUyxjQUFjLENBQUVELENBQUUsQ0FBQyxJQUFJLENBQUNGLElBQUksQ0FBRUUsQ0FBQyxDQUFFLEVBQUc7UUFDdERGLElBQUksQ0FBRUUsQ0FBQyxDQUFFLEdBQUdULElBQUksQ0FBQ0MsV0FBVyxDQUFFUSxDQUFDLENBQUU7TUFDckM7SUFDSjtFQUNKLENBQUM7RUFHRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lHLFlBQVksR0FBRyxTQUFmQSxZQUFZQSxDQUFjQyxHQUFHLEVBQUViLElBQUksRUFBRztJQUNsQyxJQUFJYyxHQUFHLEdBQUcsSUFBSTs7SUFFZDtJQUNBRCxHQUFHLEdBQUd6QixTQUFTLENBQUV5QixHQUFJLENBQUM7SUFFdEIsSUFBS2IsSUFBSSxDQUFDQyxXQUFXLElBQUlELElBQUksQ0FBQ0MsV0FBVyxDQUFFWSxHQUFHLENBQUUsRUFBRztNQUMvQ0MsR0FBRyxHQUFHZCxJQUFJLENBQUNDLFdBQVcsQ0FBRVksR0FBRyxDQUFFO0lBQ2pDO0lBRUEsT0FBT0MsR0FBRztFQUNkLENBQUM7RUFHRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxVQUFVLEdBQUcsU0FBYkEsVUFBVUEsQ0FBY0YsR0FBRyxFQUFFYixJQUFJLEVBQUc7SUFDaEM7SUFDQWEsR0FBRyxHQUFHekIsU0FBUyxDQUFFeUIsR0FBSSxDQUFDO0lBRXRCLElBQUtiLElBQUksQ0FBQ0MsV0FBVyxJQUFJRCxJQUFJLENBQUNDLFdBQVcsQ0FBRVksR0FBRyxDQUFFLEVBQUc7TUFDL0MsT0FBT2IsSUFBSSxDQUFDQyxXQUFXLENBQUVZLEdBQUcsQ0FBRTtJQUNsQztFQUNKLENBQUM7RUFHRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lHLGFBQWEsR0FBRyxTQUFoQkEsYUFBYUEsQ0FBY1QsSUFBSSxFQUFFVSxNQUFNLEVBQUc7SUFDdEMsSUFBSS9CLEdBQUcsR0FBRyxFQUFFO01BQ1IyQixHQUFHO01BQ0hLLEdBQUc7TUFDSFQsQ0FBQztJQUVMLEtBQU1BLENBQUMsSUFBSUYsSUFBSSxFQUFHO01BQ2QsSUFBS0EsSUFBSSxDQUFDRyxjQUFjLENBQUVELENBQUUsQ0FBQyxFQUFHO1FBQzVCSSxHQUFHLEdBQUdJLE1BQU0sR0FBSUEsTUFBTSxHQUFHLEdBQUcsR0FBR1IsQ0FBQyxHQUFHLEdBQUcsR0FBSUEsQ0FBQztRQUMzQ1MsR0FBRyxHQUFHWCxJQUFJLENBQUVFLENBQUMsQ0FBRTtRQUVmLElBQUtVLEtBQUssQ0FBQ0MsT0FBTyxDQUFFRixHQUFJLENBQUMsRUFBRztVQUN4QkEsR0FBRyxDQUFDRyxPQUFPLENBQUMsVUFBV0MsQ0FBQyxFQUFHO1lBQ3ZCcEMsR0FBRyxDQUFDcUMsSUFBSSxDQUFHQyxrQkFBa0IsQ0FBRVgsR0FBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBR1csa0JBQWtCLENBQUVGLENBQUUsQ0FBRyxDQUFDO1VBQ2xGLENBQUMsQ0FBQztRQUVOLENBQUMsTUFBTSxJQUFLRyxPQUFBLENBQU9QLEdBQUcsTUFBSyxRQUFRLEVBQUc7VUFDbENoQyxHQUFHLENBQUNxQyxJQUFJLENBQUVQLGFBQWEsQ0FBRUUsR0FBRyxFQUFFTCxHQUFJLENBQUUsQ0FBQztRQUV6QyxDQUFDLE1BQU07VUFDSDNCLEdBQUcsQ0FBQ3FDLElBQUksQ0FBR0Msa0JBQWtCLENBQUVYLEdBQUksQ0FBQyxHQUFHLEdBQUcsR0FBR1csa0JBQWtCLENBQUVOLEdBQUksQ0FBRyxDQUFDO1FBQzdFO01BQ0o7SUFDSjtJQUVBLE9BQU9oQyxHQUFHLENBQUN3QyxJQUFJLENBQUUsR0FBSSxDQUFDO0VBQzFCLENBQUM7RUFHRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxRQUFRLEdBQUcsU0FBWEEsUUFBUUEsQ0FBYzNCLElBQUksRUFBRztJQUN6QixPQUFRQSxJQUFJLENBQUM0QixZQUFZLENBQUUsT0FBUSxDQUFDLElBQUksRUFBRTtFQUM5QyxDQUFDO0VBR0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsUUFBUSxHQUFHLFNBQVhBLFFBQVFBLENBQWM3QixJQUFJLEVBQUU4QixLQUFLLEVBQUc7SUFDaEM5QixJQUFJLENBQUMrQixZQUFZLENBQUUsT0FBTyxFQUFFRCxLQUFNLENBQUM7RUFDdkMsQ0FBQztFQUdEO0VBQ0E7RUFDQTs7RUFHQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJRSxhQUFhLEdBQUcsU0FBaEJBLGFBQWFBLENBQWN6QixJQUFJLEVBQUc7SUFDOUIsSUFBS3pCLEtBQUssQ0FBQ21ELElBQUksQ0FBRTFCLElBQUssQ0FBQyxFQUFHO01BQ3RCLElBQUk7UUFDQUEsSUFBSSxHQUFHMkIsSUFBSSxDQUFDQyxLQUFLLENBQUU1QixJQUFLLENBQUM7TUFFN0IsQ0FBQyxDQUFDLE9BQVE2QixLQUFLLEVBQUc7UUFDZCxNQUFNQSxLQUFLO01BQ2Y7SUFDSjtJQUVBLE9BQU83QixJQUFJO0VBQ2YsQ0FBQztFQUdEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJRixjQUFjLEdBQUcsU0FBakJBLGNBQWNBLENBQWNMLElBQUksRUFBRztJQUMvQixJQUFJUyxDQUFDLEdBQUdULElBQUksQ0FBQ0ksVUFBVSxDQUFDaUMsTUFBTTtJQUU5QixLQUFNNUIsQ0FBQyxFQUFFQSxDQUFDLEVBQUUsR0FBSTtNQUNaLElBQUsvQixLQUFLLENBQUN1RCxJQUFJLENBQUVqQyxJQUFJLENBQUNJLFVBQVUsQ0FBRUssQ0FBQyxDQUFFLENBQUM2QixJQUFLLENBQUMsRUFBRztRQUMzQyxJQUFJekIsR0FBRyxHQUFHekIsU0FBUyxDQUFFWSxJQUFJLENBQUNJLFVBQVUsQ0FBRUssQ0FBQyxDQUFFLENBQUM2QixJQUFJLENBQUNuRCxPQUFPLENBQUVULEtBQUssRUFBRSxFQUFHLENBQUUsQ0FBQztRQUVyRXNCLElBQUksQ0FBQ0MsV0FBVyxDQUFFWSxHQUFHLENBQUUsR0FBR21CLGFBQWEsQ0FBRWhDLElBQUksQ0FBQ0ksVUFBVSxDQUFFSyxDQUFDLENBQUUsQ0FBQzhCLEtBQU0sQ0FBQztNQUN6RTtJQUNKO0VBQ0osQ0FBQztFQUdEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJcEMsV0FBVyxHQUFHLFNBQWRBLFdBQVdBLENBQWNILElBQUksRUFBRztJQUM1QixLQUFNLElBQUlTLENBQUMsSUFBSVQsSUFBSSxDQUFDRSxPQUFPLEVBQUc7TUFDMUIsSUFBS0YsSUFBSSxDQUFDRSxPQUFPLENBQUNRLGNBQWMsQ0FBRUQsQ0FBRSxDQUFDLEVBQUc7UUFDcENULElBQUksQ0FBQ0MsV0FBVyxDQUFFUSxDQUFDLENBQUUsR0FBR3VCLGFBQWEsQ0FBRWhDLElBQUksQ0FBQ0UsT0FBTyxDQUFFTyxDQUFDLENBQUcsQ0FBQztNQUM5RDtJQUNKO0VBQ0osQ0FBQztBQUdMK0IsTUFBTSxDQUFDQyxPQUFPLEdBQUc7RUFDYmhFLE9BQU8sRUFBRUEsT0FBTztFQUNoQkMsS0FBSyxFQUFFQSxLQUFLO0VBQ1pDLE1BQU0sRUFBRUEsTUFBTTtFQUNkRSxJQUFJLEVBQUVBLElBQUk7RUFDVkMsS0FBSyxFQUFFQSxLQUFLO0VBQ1pDLFFBQVEsRUFBRUEsUUFBUTtFQUNsQkMsV0FBVyxFQUFFQSxXQUFXO0VBQ3hCQyxVQUFVLEVBQUVBLFVBQVU7RUFDdEJHLFNBQVMsRUFBRUEsU0FBUztFQUNwQkksTUFBTSxFQUFFQSxNQUFNO0VBQ2RHLFNBQVMsRUFBRUEsU0FBUztFQUNwQkksUUFBUSxFQUFFQSxRQUFRO0VBQ2xCTyxTQUFTLEVBQUVBLFNBQVM7RUFDcEJNLFlBQVksRUFBRUEsWUFBWTtFQUMxQkQsU0FBUyxFQUFFQSxTQUFTO0VBQ3BCSSxVQUFVLEVBQUVBLFVBQVU7RUFDdEJDLGFBQWEsRUFBRUEsYUFBYTtFQUM1QlcsUUFBUSxFQUFFQSxRQUFRO0VBQ2xCRSxRQUFRLEVBQUVBO0FBQ2QsQ0FBQyJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/lib/utils.js\n");

/***/ }),

/***/ "./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js ***!
  \***************************************************************************************/
/***/ ((module, exports) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n *\n * Use native element selector matching\n *\n * @matchElement\n * @author: kitajchuk\n *\n */\n(function (factory) {\n  if (( false ? 0 : _typeof(exports)) === \"object\" && \"object\" !== \"undefined\") {\n    module.exports = factory();\n  } else if (typeof window !== \"undefined\") {\n    window.matchElement = factory();\n  }\n})(function () {\n  /**\n   *\n   * Use native element selector matching\n   * @memberof! <global>\n   * @method matchElement\n   * @param {object} el the element\n   * @param {string} selector the selector to match\n   * @param {boolean} walk should we walk the tree if el is not a match?\n   * @returns element OR null\n   *\n   */\n  var matchElement = function matchElement(el, selector, walk) {\n    var method = el.matches ? \"matches\" : el.webkitMatchesSelector ? \"webkitMatchesSelector\" : el.mozMatchesSelector ? \"mozMatchesSelector\" : el.msMatchesSelector ? \"msMatchesSelector\" : el.oMatchesSelector ? \"oMatchesSelector\" : null;\n\n    // Try testing the element against the selector\n    // 0.1 => Method is not undefined\n    // 0.2 => Element passes method call\n    if (method && el[method].call(el, selector)) {\n      return el;\n\n      // Keep walking up the DOM if we can - only if `walk` flag is `true`\n    } else if (walk && el !== document.documentElement && el.parentNode) {\n      return matchElement(el.parentNode, selector, walk);\n\n      // Otherwise we should not execute an event\n    } else {\n      return null;\n    }\n  };\n  return matchElement;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9ub2RlX21vZHVsZXMvcHJvcGVyanMtbWF0Y2hlbGVtZW50L21hdGNoRWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsVUFBV0EsT0FBTyxFQUFHO0VBRWxCLElBQUssT0FBYyxPQUFBRSxPQUFBLENBQVBELE9BQU8sT0FBSyxRQUFRLElBQUksUUFBYSxLQUFLLFdBQVcsRUFBRztJQUNoRUUsTUFBTSxDQUFDRixPQUFPLEdBQUdELE9BQU8sQ0FBQyxDQUFDO0VBRTlCLENBQUMsTUFBTSxJQUFLLE9BQU9JLE1BQU0sS0FBSyxXQUFXLEVBQUc7SUFDeENBLE1BQU0sQ0FBQ0MsWUFBWSxHQUFHTCxPQUFPLENBQUMsQ0FBQztFQUNuQztBQUVKLENBQUMsRUFBRSxZQUFZO0VBRVg7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLElBQUlLLFlBQVksR0FBRyxTQUFmQSxZQUFZQSxDQUFjQyxFQUFFLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFHO0lBQy9DLElBQUlDLE1BQU0sR0FBS0gsRUFBRSxDQUFDSSxPQUFPLEdBQUssU0FBUyxHQUFLSixFQUFFLENBQUNLLHFCQUFxQixHQUN0Qyx1QkFBdUIsR0FBS0wsRUFBRSxDQUFDTSxrQkFBa0IsR0FDakQsb0JBQW9CLEdBQUtOLEVBQUUsQ0FBQ08saUJBQWlCLEdBQzdDLG1CQUFtQixHQUFLUCxFQUFFLENBQUNRLGdCQUFnQixHQUMzQyxrQkFBa0IsR0FBRyxJQUFJOztJQUV2RDtJQUNBO0lBQ0E7SUFDQSxJQUFLTCxNQUFNLElBQUlILEVBQUUsQ0FBRUcsTUFBTSxDQUFFLENBQUNNLElBQUksQ0FBRVQsRUFBRSxFQUFFQyxRQUFTLENBQUMsRUFBRztNQUMvQyxPQUFPRCxFQUFFOztNQUViO0lBQ0EsQ0FBQyxNQUFNLElBQUtFLElBQUksSUFBSUYsRUFBRSxLQUFLVSxRQUFRLENBQUNDLGVBQWUsSUFBSVgsRUFBRSxDQUFDWSxVQUFVLEVBQUc7TUFDbkUsT0FBT2IsWUFBWSxDQUFFQyxFQUFFLENBQUNZLFVBQVUsRUFBRVgsUUFBUSxFQUFFQyxJQUFLLENBQUM7O01BRXhEO0lBQ0EsQ0FBQyxNQUFNO01BQ0gsT0FBTyxJQUFJO0lBQ2Y7RUFDSixDQUFDO0VBR0QsT0FBT0gsWUFBWTtBQUV2QixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaG9iby9ub2RlX21vZHVsZXMvcHJvcGVyanMtbWF0Y2hlbGVtZW50L21hdGNoRWxlbWVudC5qcz9lM2RlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqIFVzZSBuYXRpdmUgZWxlbWVudCBzZWxlY3RvciBtYXRjaGluZ1xuICpcbiAqIEBtYXRjaEVsZW1lbnRcbiAqIEBhdXRob3I6IGtpdGFqY2h1a1xuICpcbiAqL1xuKGZ1bmN0aW9uICggZmFjdG9yeSApIHtcbiAgICBcbiAgICBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgd2luZG93Lm1hdGNoRWxlbWVudCA9IGZhY3RvcnkoKTtcbiAgICB9XG4gICAgXG59KShmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZSBuYXRpdmUgZWxlbWVudCBzZWxlY3RvciBtYXRjaGluZ1xuICAgICAqIEBtZW1iZXJvZiEgPGdsb2JhbD5cbiAgICAgKiBAbWV0aG9kIG1hdGNoRWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbCB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciB0aGUgc2VsZWN0b3IgdG8gbWF0Y2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdhbGsgc2hvdWxkIHdlIHdhbGsgdGhlIHRyZWUgaWYgZWwgaXMgbm90IGEgbWF0Y2g/XG4gICAgICogQHJldHVybnMgZWxlbWVudCBPUiBudWxsXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgbWF0Y2hFbGVtZW50ID0gZnVuY3Rpb24gKCBlbCwgc2VsZWN0b3IsIHdhbGsgKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSAoIGVsLm1hdGNoZXMgKSA/IFwibWF0Y2hlc1wiIDogKCBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgKSA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndlYmtpdE1hdGNoZXNTZWxlY3RvclwiIDogKCBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgKSA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1vek1hdGNoZXNTZWxlY3RvclwiIDogKCBlbC5tc01hdGNoZXNTZWxlY3RvciApID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibXNNYXRjaGVzU2VsZWN0b3JcIiA6ICggZWwub01hdGNoZXNTZWxlY3RvciApID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib01hdGNoZXNTZWxlY3RvclwiIDogbnVsbDtcblxuICAgICAgICAvLyBUcnkgdGVzdGluZyB0aGUgZWxlbWVudCBhZ2FpbnN0IHRoZSBzZWxlY3RvclxuICAgICAgICAvLyAwLjEgPT4gTWV0aG9kIGlzIG5vdCB1bmRlZmluZWRcbiAgICAgICAgLy8gMC4yID0IEVsZW1lbnQgcGFzc2VzIG1ldGhvZCBjYWxsXG4gICAgICAgIGlmICggbWV0aG9kICYmIGVsWyBtZXRob2QgXS5jYWxsKCBlbCwgc2VsZWN0b3IgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcblxuICAgICAgICAvLyBLZWVwIHdhbGtpbmcgdXAgdGhlIERPTSBpZiB3ZSBjYW4gLSBvbmx5IGlmIGB3YWxrYCBmbGFnIGlzIGB0cnVlYFxuICAgICAgICB9IGVsc2UgaWYgKCB3YWxrICYmIGVsICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZWwucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaEVsZW1lbnQoIGVsLnBhcmVudE5vZGUsIHNlbGVjdG9yLCB3YWxrICk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIHNob3VsZCBub3QgZXhlY3V0ZSBhbiBldmVudFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICByZXR1cm4gbWF0Y2hFbGVtZW50O1xuXG59KTsiXSwibmFtZXMiOlsiZmFjdG9yeSIsImV4cG9ydHMiLCJfdHlwZW9mIiwibW9kdWxlIiwid2luZG93IiwibWF0Y2hFbGVtZW50IiwiZWwiLCJzZWxlY3RvciIsIndhbGsiLCJtZXRob2QiLCJtYXRjaGVzIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwiY2FsbCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwicGFyZW50Tm9kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-hobo/node_modules/properjs-matchelement/matchElement.js\n");

/***/ }),

/***/ "./node_modules/properjs-imageloader/ImageLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/properjs-imageloader/ImageLoader.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n *\n * Handle lazy-loading images with contextual load conditions.\n *\n * @ImageLoader\n * @author: kitajchuk\n *\n *\n */\n(function (factory) {\n  if (( false ? 0 : _typeof(exports)) === \"object\" && \"object\" !== \"undefined\") {\n    module.exports = factory();\n  } else if (typeof window !== \"undefined\") {\n    window.ImageLoader = factory();\n  }\n})(function () {\n  var Controller = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-controller/Controller.js\");\n\n  /**\n   *\n   * Handle lazy-loading images with unique callback conditions\n   * @memberof! <global>\n   * @requires raf\n   * @constructor ImageLoader\n   * @param {object} options Controller settings\n   * <ul>\n   * <li>elements - The collection of elements to load against</li>\n   * <li>property - The property to pull the image source from</li>\n   * <li>transitionDelay - The timeout before transition starts</li>\n   * <li>transitionDuration - The length of the animation</li>\n   * </ul>\n   *\n   */\n  var ImageLoader = function ImageLoader(options) {\n    var self = this;\n    if (!options) {\n      throw new Error(\"ImageLoader Class requires options to be passed\");\n    }\n\n    // Up, up and away...\n    Controller.call(this);\n\n    /**\n     *\n     * The method to determine if an image should load itself\n     * @memberof ImageLoader\n     * @member _executor\n     * @private\n     *\n     */\n    this._executor = options.executor || function (elem) {\n      return elem;\n    };\n\n    /**\n     *\n     * The Collection to load against\n     * @memberof ImageLoader\n     * @member _elements\n     * @private\n     *\n     */\n    this._elements = options.elements;\n\n    /**\n     *\n     * The property to get image source from\n     * @memberof ImageLoader\n     * @member _property\n     * @private\n     *\n     */\n    this._property = options.property || \"data-src\";\n\n    /**\n     *\n     * The way to load, async or sync\n     * Using \"sync\" loading requires calling .start() on the instance\n     * and the \"handle\" event will not be utilized, rather each image\n     * will be loaded in succession as the previous finishes loading\n     * @memberof ImageLoader\n     * @member _loadType\n     * @private\n     *\n     */\n    this._loadType = options.loadType || \"async\";\n\n    /**\n     *\n     * The current amount of elements lazy loaded\n     * @memberof ImageLoader\n     * @member _numLoaded\n     * @private\n     *\n     */\n    this._numLoaded = 0;\n\n    /**\n     *\n     * The total amount of elements to lazy load\n     * @memberof ImageLoader\n     * @member _num2Load\n     * @private\n     *\n     */\n    this._num2Load = this._elements ? this._elements.length : 0;\n\n    /**\n     *\n     * The delay to execute lazy loading on an element in ms\n     * @memberof ImageLoader\n     * @member _transitionDelay\n     * @default 100\n     * @private\n     *\n     */\n    this._transitionDelay = options.transitionDelay || 0;\n\n    /**\n     *\n     * The duration on a lazy loaded elements fade in in ms\n     * @memberof ImageLoader\n     * @member _transitionDuration\n     * @default 600\n     * @private\n     *\n     */\n    this._transitionDuration = options.transitionDuration || 400;\n\n    /**\n     *\n     * This flags that all elements have been loaded\n     * @memberof ImageLoader\n     * @member _resolved\n     * @private\n     *\n     */\n    this._resolved = false;\n\n    // Break out if no elements in collection\n    if (!this._elements.length) {\n      return this;\n    }\n\n    // Only run animation frame for async loading\n    if (this._loadType === \"async\") {\n      this.initAsync();\n    } else {\n      this.initSync();\n    }\n  };\n\n  /**\n   *\n   * @extends Controller\n   *\n   */\n  ImageLoader.prototype = Object.create(Controller.prototype);\n\n  /**\n   *\n   * Support asynchronous loading of a set of images\n   * @memberof ImageLoader\n   * @method initAsync\n   *\n   */\n  ImageLoader.prototype.initAsync = function () {\n    var self = this;\n    this.go(function () {\n      if (self._resolved) {\n        self.stop();\n      } else {\n        self.handle();\n      }\n    });\n  };\n\n  /**\n   *\n   * Support batch synchronous loading of a set of images\n   * @memberof ImageLoader\n   * @method initSync\n   *\n   */\n  ImageLoader.prototype.initSync = function () {\n    var self = this;\n    function syncLoad() {\n      var elem = self._elements[self._numLoaded];\n      self._numLoaded;\n      self.load(elem, function (error) {\n        if (!error && !self._resolved) {\n          syncLoad();\n        }\n      });\n    }\n    syncLoad();\n  };\n\n  /**\n   *\n   * Perform the image loading and set correct values on element\n   * @method load\n   * @memberof ImageLoader\n   * @param {object} $elem element object\n   * @param {function} callback optional callback for each load\n   * @fires done\n   *\n   */\n  ImageLoader.prototype.load = function (element, callback) {\n    var self = this,\n      image = null,\n      timeout = null,\n      isImage = element.nodeName === \"IMG\",\n      source = element.getAttribute(this._property);\n    element.setAttribute(\"data-imageloader\", true);\n    if (isImage) {\n      image = element;\n    } else {\n      image = new Image();\n    }\n    timeout = setTimeout(function () {\n      clearTimeout(timeout);\n      image.onload = function () {\n        self.fire(\"load\", element);\n        if (!isImage) {\n          element.style.backgroundImage = \"url(\"  source  \")\";\n          image = null;\n        }\n        timeout = setTimeout(function () {\n          clearTimeout(timeout);\n          if (self._numLoaded === self._num2Load && !self._resolved) {\n            self._resolve(true);\n          } else if (typeof callback === \"function\") {\n            // Errors first\n            callback(false);\n          }\n        }, self._transitionDuration);\n      };\n      image.onerror = function () {\n        self.fire(\"error\", element);\n        if (self._numLoaded === self._num2Load && !self._resolved) {\n          self._resolve(true);\n        } else if (typeof callback === \"function\") {\n          // Errors first\n          callback(true);\n        }\n      };\n      image.src = source;\n    }, this._transitionDelay);\n    return this;\n  };\n\n  /**\n   *\n   * Handles element iterations and loading based on callbacks\n   * @memberof ImageLoader\n   * @method handle\n   *\n   */\n  ImageLoader.prototype.handle = function () {\n    var elems = this.getNotLoaded(),\n      self = this;\n    for (var i = 0, len = elems.length; i < len; i) {\n      if (self._executor(elems[i])) {\n        self._numLoaded;\n        self.load(elems[i]);\n      }\n    }\n  };\n\n  /**\n   *\n   * Get all images in the set that have yet to be loaded\n   * @memberof ImageLoader\n   * @method getNotLoaded\n   *\n   */\n  ImageLoader.prototype.getNotLoaded = function () {\n    var elems = [];\n    for (var i = 0, len = this._elements.length; i < len; i) {\n      if (!this._elements[i].getAttribute(\"data-imageloader\")) {\n        elems.push(this._elements[i]);\n      }\n    }\n    return elems;\n  };\n\n  /**\n   *\n   * Resolve an instance and remove it from the stack\n   * @memberof ImageLoader\n   * @method _resolve\n   *\n   */\n  ImageLoader.prototype._resolve = function () {\n    // Resolved state\n    this._resolved = true;\n\n    // Fires the predefined \"done\" event\n    this.fire(\"done\");\n  };\n  return ImageLoader;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtaW1hZ2Vsb2FkZXIvSW1hZ2VMb2FkZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsVUFBV0EsT0FBTyxFQUFHO0VBRWxCLElBQUssT0FBYyxPQUFBRSxPQUFBLENBQVBELE9BQU8sT0FBSyxRQUFRLElBQUksUUFBYSxLQUFLLFdBQVcsRUFBRztJQUNoRUUsTUFBTSxDQUFDRixPQUFPLEdBQUdELE9BQU8sQ0FBQyxDQUFDO0VBRTlCLENBQUMsTUFBTSxJQUFLLE9BQU9JLE1BQU0sS0FBSyxXQUFXLEVBQUc7SUFDeENBLE1BQU0sQ0FBQ0MsV0FBVyxHQUFHTCxPQUFPLENBQUMsQ0FBQztFQUNsQztBQUVKLENBQUMsRUFBRSxZQUFZO0VBRVgsSUFBSU0sVUFBVSxHQUFHQyxtQkFBTyxDQUFFLDZFQUFzQixDQUFDOztFQUdqRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJRixXQUFXLEdBQUcsU0FBZEEsV0FBV0EsQ0FBY0csT0FBTyxFQUFHO0lBQ25DLElBQUlDLElBQUksR0FBRyxJQUFJO0lBRWYsSUFBSyxDQUFDRCxPQUFPLEVBQUc7TUFDWixNQUFNLElBQUlFLEtBQUssQ0FBRSxpREFBa0QsQ0FBQztJQUN4RTs7SUFFQTtJQUNBSixVQUFVLENBQUNLLElBQUksQ0FBRSxJQUFLLENBQUM7O0lBRXZCO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDUSxJQUFJLENBQUNDLFNBQVMsR0FBSUosT0FBTyxDQUFDSyxRQUFRLElBQUksVUFBV0MsSUFBSSxFQUFHO01BQ3BELE9BQU9BLElBQUk7SUFDZixDQUFFOztJQUVGO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDUSxJQUFJLENBQUNDLFNBQVMsR0FB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O0VBQ0osQ0FBQzs7RUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJeEQsV0FBVyxDQUFDMEIsU0FBUyxDQUFDNkIsWUFBWSxHQUFHLFlBQVk7SUFDN0MsSUFBSUQsS0FBSyxHQUFHLEVBQUU7SUFFZCxLQUFNLElBQUlFLENBQUMsR0FBRyxDQUFDLEVBQUVDLEdBQUcsR0FBRyxJQUFJLENBQUMvQyxTQUFTLENBQUNRLE1BQU0sRUFBRXNDLENBQUMsR0FBR0MsR0FBRyxFQUFFRCxDQUFDLEVBQUUsRUFBRztNQUN6RCxJQUFLLENBQUMsSUFBSSxDQUFDOUMsU0FBUyxDQUFFOEMsQ0FBQyxDQUFFLENBQUNkLFlBQVksQ0FBRSxrQkFBbUIsQ0FBQyxFQUFHO1FBQzNEWSxLQUFLLENBQUNJLElBQUksQ0FBRSxJQUFJLENBQUNoRCxTQUFTLENBQUU4QyxDQUFDLENBQUcsQ0FBQztNQUNyQztJQUNKO0lBRUEsT0FBT0YsS0FBSztFQUNoQixDQUFDOztFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0l0RCxXQUFXLENBQUMwQixTQUFTLENBQUN5QixRQUFRLEdBQUcsWUFBWTtJQUN6QztJQUNBLElBQUksQ0FBQzVCLFNBQVMsR0FBRyxJQUFJOztJQUVyQjtJQUNBLElBQUksQ0FBQ3lCLElBQUksQ0FBRSxNQUFPLENBQUM7RUFDdkIsQ0FBQztFQUdELE9BQU9oRCxXQUFXO0FBR3RCLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1pbWFnZWxvYWRlci9JbWFnZUxvYWRlci5qcz8zYWVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqIEhhbmRsZSBsYXp5LWxvYWRpbmcgaW1hZ2VzIHdpdGggY29udGV4dHVhbCBsb2FkIGNvbmRpdGlvbnMuXG4gKlxuICogQEltYWdlTG9hZGVyXG4gKiBAYXV0aG9yOiBraXRhamNodWtcbiAqXG4gKlxuICovXG4oZnVuY3Rpb24gKCBmYWN0b3J5ICkge1xuXG4gICAgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblxuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgIHdpbmRvdy5JbWFnZUxvYWRlciA9IGZhY3RvcnkoKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBDb250cm9sbGVyID0gcmVxdWlyZSggXCJwcm9wZXJqcy1jb250cm9sbGVyXCIgKTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBIYW5kbGUgbGF6eS1sb2FkaW5nIGltYWdlcyB3aXRoIHVuaXF1ZSBjYWxsYmFjayBjb25kaXRpb25zXG4gICAgICogQG1lbWJlcm9mISA8Z2xvYmFsPlxuICAgICAqIEByZXF1aXJlcyByYWZcbiAgICAgKiBAY29uc3RydWN0b3IgSW1hZ2VMb2FkZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBDb250cm9sbGVyIHNldHRpbmdzXG4gICAgICogPHVsPlxuICAgICAqIDxsaT5lbGVtZW50cyAtIFRoZSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIHRvIGxvYWQgYWdhaW5zdDwvbGkXG4gICAgICogPGxpPnByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHRvIHB1bGwgdGhlIGltYWdlIHNvdXJjZSBmcm9tPC9saT5cbiAgICAgKiA8bGkdHJhbnNpdGlvbkRlbGF5IC0gVGhlIHRpbWVvdXQgYmVmb3JlIHRyYW5zaXRpb24gc3RhcnRzPC9saT5cbiAgICAgKiA8bGkdHJhbnNpdGlvbkR1cmF0aW9uIC0gVGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uPC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqXG4gICAgICovXG4gICAgdmFyIEltYWdlTG9hZGVyID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCAhb3B0aW9ucyApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJJbWFnZUxvYWRlciBDbGFzcyByZXF1aXJlcyBvcHRpb25zIHRvIGJlIHBhc3NlZFwiICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcCwgdXAgYW5kIGF3YXkuLi5cbiAgICAgICAgQ29udHJvbGxlci5jYWxsKCB0aGlzICk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIGFuIGltYWdlIHNob3VsZCBsb2FkIGl0c2VsZlxuICAgICAgICAgKiBAbWVtYmVyb2YgSW1hZ2VMb2FkZXJcbiAgICAgICAgICogQG1lbWJlciBfZXhlY3V0b3JcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2V4ZWN1dG9yID0gKG9wdGlvbnMuZXhlY3V0b3IgfHwgZnVuY3Rpb24gKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgQ29sbGVjdGlvbiB0byBsb2FkIGFnYWluc3RcbiAgICAgICAgICogQG1lbWJlcm9mIEltYWdlTG9hZGVyXG4gICAgICAgICAqIEBtZW1iZXIgX2VsZW1lbnRzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IG9wdGlvbnMuZWxlbWVudHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwcm9wZXJ0eSB0byBnZXQgaW1hZ2Ugc291cmNlIGZyb21cbiAgICAgICAgICogQG1lbWJlcm9mIEltYWdlTG9hZGVyXG4gICAgICAgICAqIEBtZW1iZXIgX3Byb3BlcnR5XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcm9wZXJ0eSA9IChvcHRpb25zLnByb3BlcnR5IHx8IFwiZGF0YS1zcmNcIik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB3YXkgdG8gbG9hZCwgYXN5bmMgb3Igc3luY1xuICAgICAgICAgKiBVc2luZyBcInN5bmNcIiBsb2FkaW5nIHJlcXVpcmVzIGNhbGxpbmcgLnN0YXJ0KCkgb24gdGhlIGluc3RhbmNlXG4gICAgICAgICAqIGFuZCB0aGUgXCJoYW5kbGVcIiBldmVudCB3aWxsIG5vdCBiZSB1dGlsaXplZCwgcmF0aGVyIGVhY2ggaW1hZ2VcbiAgICAgICAgICogd2lsbCBiZSBsb2FkZWQgaW4gc3VjY2Vzc2lvbiBhcyB0aGUgcHJldmlvdXMgZmluaXNoZXMgbG9hZGluZ1xuICAgICAgICAgKiBAbWVtYmVyb2YgSW1hZ2VMb2FkZXJcbiAgICAgICAgICogQG1lbWJlciBfbG9hZFR5cGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWRUeXBlID0gKG9wdGlvbnMubG9hZFR5cGUgfHwgXCJhc3luY1wiKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGN1cnJlbnQgYW1vdW50IG9mIGVsZW1lbnRzIGxhenkgbG9hZGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBJbWFnZUxvYWRlclxuICAgICAgICAgKiBAbWVtYmVyIF9udW1Mb2FkZWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX251bUxvYWRlZCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB0b3RhbCBhbW91bnQgb2YgZWxlbWVudHMgdG8gbGF6eSBsb2FkXG4gICAgICAgICAqIEBtZW1iZXJvZiBJbWFnZUxvYWRlclxuICAgICAgICAgKiBAbWVtYmVyIF9udW0yTG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbnVtMkxvYWQgPSAodGhpcy5fZWxlbWVudHMgPyB0aGlzLl9lbGVtZW50cy5sZW5ndGggOiAwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRlbGF5IHRvIGV4ZWN1dGUgbGF6eSBsb2FkaW5nIG9uIGFuIGVsZW1lbnQgaW4gbXNcbiAgICAgICAgICogQG1lbWJlcm9mIEltYWdlTG9hZGVyXG4gICAgICAgICAqIEBtZW1iZXIgX3RyYW5zaXRpb25EZWxheVxuICAgICAgICAgKiBAZGVmYXVsdCAxMDBcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25EZWxheSA9IChvcHRpb25zLnRyYW5zaXRpb25EZWxheSB8fCAwKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGR1cmF0aW9uIG9uIGEgbGF6eSBsb2FkZWQgZWxlbWVudHMgZmFkZSBpbiBpbiBtc1xuICAgICAgICAgKiBAbWVtYmVyb2YgSW1hZ2VMb2FkZXJcbiAgICAgICAgICogQG1lbWJlciBfdHJhbnNpdGlvbkR1cmF0aW9uXG4gICAgICAgICAqIEBkZWZhdWx0IDYwMFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkR1cmF0aW9uID0gKG9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uIHx8IDQwMCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZmxhZ3MgdGhhdCBhbGwgZWxlbWVudHMgaGF2ZSBiZWVuIGxvYWRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgSW1hZ2VMb2FkZXJcbiAgICAgICAgICogQG1lbWJlciBfcmVzb2x2ZWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQnJlYWsgb3V0IGlmIG5vIGVsZW1lbnRzIGluIGNvbGxlY3Rpb25cbiAgICAgICAgaWYgKCAhdGhpcy5fZWxlbWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHJ1biBhbmltYXRpb24gZnJhbWUgZm9yIGFzeW5jIGxvYWRpbmdcbiAgICAgICAgaWYgKCB0aGlzLl9sb2FkVHlwZSA9PT0gXCJhc3luY1wiICkge1xuICAgICAgICAgICAgdGhpcy5pbml0QXN5bmMoKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0U3luYygpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZXh0ZW5kcyBDb250cm9sbGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBJbWFnZUxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb250cm9sbGVyLnByb3RvdHlwZSApO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFN1cHBvcnQgYXN5bmNocm9ub3VzIGxvYWRpbmcgb2YgYSBzZXQgb2YgaW1hZ2VzXG4gICAgICogQG1lbWJlcm9mIEltYWdlTG9hZGVyXG4gICAgICogQG1ldGhvZCBpbml0QXN5bmNcbiAgICAgKlxuICAgICAqL1xuICAgIEltYWdlTG9hZGVyLnByb3RvdHlwZS5pbml0QXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLmdvKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICggc2VsZi5fcmVzb2x2ZWQgKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zdG9wKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYW5kbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU3VwcG9ydCBiYXRjaCBzeW5jaHJvbm91cyBsb2FkaW5nIG9mIGEgc2V0IG9mIGltYWdlc1xuICAgICAqIEBtZW1iZXJvZiBJbWFnZUxvYWRlclxuICAgICAqIEBtZXRob2QgaW5pdFN5bmNcbiAgICAgKlxuICAgICAqL1xuICAgIEltYWdlTG9hZGVyLnByb3RvdHlwZS5pbml0U3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGZ1bmN0aW9uIHN5bmNMb2FkKCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBzZWxmLl9lbGVtZW50c1sgc2VsZi5fbnVtTG9hZGVkIF07XG5cbiAgICAgICAgICAgIHNlbGYuX251bUxvYWRlZCsrO1xuXG4gICAgICAgICAgICBzZWxmLmxvYWQoIGVsZW0sIGZ1bmN0aW9uICggZXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhZXJyb3IgJiYgIXNlbGYuX3Jlc29sdmVkICkge1xuICAgICAgICAgICAgICAgICAgICBzeW5jTG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3luY0xvYWQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQZXJmb3JtIHRoZSBpbWFnZSBsb2FkaW5nIGFuZCBzZXQgY29ycmVjdCB2YWx1ZXMgb24gZWxlbWVudFxuICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAqIEBtZW1iZXJvZiBJbWFnZUxvYWRlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkZWxlbSBlbGVtZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIG9wdGlvbmFsIGNhbGxiYWNrIGZvciBlYWNoIGxvYWRcbiAgICAgKiBAZmlyZXMgZG9uZVxuICAgICAqXG4gICAgICovXG4gICAgSW1hZ2VMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIGVsZW1lbnQsIGNhbGxiYWNrICkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBpbWFnZSA9IG51bGwsXG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbCxcbiAgICAgICAgICAgIGlzSW1hZ2UgPSAoZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJJTUdcIiksXG4gICAgICAgICAgICBzb3VyY2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggdGhpcy5fcHJvcGVydHkgKTtcblxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSggXCJkYXRhLWltYWdlbG9hZGVyXCIsIHRydWUgKTtcblxuICAgICAgICBpZiAoIGlzSW1hZ2UgKSB7XG4gICAgICAgICAgICBpbWFnZSA9IGVsZW1lbnQ7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblxuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZSggXCJsb2FkXCIsIGVsZW1lbnQgKTtcblxuICAgICAgICAgICAgICAgIGlmICggIWlzSW1hZ2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gKFwidXJsKFwiICsgc291cmNlICsgXCIpXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKHNlbGYuX251bUxvYWRlZCA9PT0gc2VsZi5fbnVtMkxvYWQpICYmICFzZWxmLl9yZXNvbHZlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Jlc29sdmUoIHRydWUgKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9ycyBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soIGZhbHNlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0sIHNlbGYuX3RyYW5zaXRpb25EdXJhdGlvbiApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZpcmUoIFwiZXJyb3JcIiwgZWxlbWVudCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAoc2VsZi5fbnVtTG9hZGVkID09PSBzZWxmLl9udW0yTG9hZCkgJiYgIXNlbGYuX3Jlc29sdmVkICkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZXNvbHZlKCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3JzIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gc291cmNlO1xuXG4gICAgICAgIH0sIHRoaXMuX3RyYW5zaXRpb25EZWxheSApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEhhbmRsZXMgZWxlbWVudCBpdGVyYXRpb25zIGFuZCBsb2FkaW5nIGJhc2VkIG9uIGNhbGxiYWNrc1xuICAgICAqIEBtZW1iZXJvZiBJbWFnZUxvYWRlclxuICAgICAqIEBtZXRob2QgaGFuZGxlXG4gICAgICpcbiAgICAgKi9cbiAgICBJbWFnZUxvYWRlci5wcm90b3R5cGUuaGFuZGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWxlbXMgPSB0aGlzLmdldE5vdExvYWRlZCgpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggc2VsZi5fZXhlY3V0b3IoIGVsZW1zWyBpIF0gKSApIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9udW1Mb2FkZWQrKztcblxuICAgICAgICAgICAgICAgIHNlbGYubG9hZCggZWxlbXNbIGkgXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogR2V0IGFsbCBpbWFnZXMgaW4gdGhlIHNldCB0aGF0IGhhdmUgeWV0IHRvIGJlIGxvYWRlZFxuICAgICAqIEBtZW1iZXJvZiBJbWFnZUxvYWRlclxuICAgICAqIEBtZXRob2QgZ2V0Tm90TG9hZGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBJbWFnZUxvYWRlci5wcm90b3R5cGUuZ2V0Tm90TG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWxlbXMgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2VsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgaWYgKCAhdGhpcy5fZWxlbWVudHNbIGkgXS5nZXRBdHRyaWJ1dGUoIFwiZGF0YS1pbWFnZWxvYWRlclwiICkgKSB7XG4gICAgICAgICAgICAgICAgZWxlbXMucHVzaCggdGhpcy5fZWxlbWVudHNbIGkgXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJlc29sdmUgYW4gaW5zdGFuY2UgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBzdGFja1xuICAgICAqIEBtZW1iZXJvZiBJbWFnZUxvYWRlclxuICAgICAqIEBtZXRob2QgX3Jlc29sdmVcbiAgICAgKlxuICAgICAqL1xuICAgIEltYWdlTG9hZGVyLnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVzb2x2ZWQgc3RhdGVcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIEZpcmVzIHRoZSBwcmVkZWZpbmVkIFwiZG9uZVwiIGV2ZW50XG4gICAgICAgIHRoaXMuZmlyZSggXCJkb25lXCIgKTtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gSW1hZ2VMb2FkZXI7XG5cblxufSk7Il0sIm5hbWVzIjpbImZhY3RvcnkiLCJleHBvcnRzIiwiX3R5cGVvZiIsIm1vZHVsZSIsIndpbmRvdyIsIkltYWdlTG9hZGVyIiwiQ29udHJvbGxlciIsInJlcXVpcmUiLCJvcHRpb25zIiwic2VsZiIsIkVycm9yIiwiY2FsbCIsIl9leGVjdXRvciIsImV4ZWN1dG9yIiwiZWxlbSIsIl9lbGVtZW50cyIsImVsZW1lbnRzIiwiX3Byb3BlcnR5IiwicHJvcGVydHkiLCJfbG9hZFR5cGUiLCJsb2FkVHlwZSIsIl9udW1Mb2FkZWQiLCJfbnVtMkxvYWQiLCJsZW5ndGgiLCJfdHJhbnNpdGlvbkRlbGF5IiwidHJhbnNpdGlvbkRlbGF5IiwiX3RyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9yZXNvbHZlZCIsImluaXRBc3luYyIsImluaXRTeW5jIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiZ28iLCJzdG9wIiwiaGFuZGxlIiwic3luY0xvYWQiLCJsb2FkIiwiZXJyb3IiLCJlbGVtZW50IiwiY2FsbGJhY2siLCJpbWFnZSIsInRpbWVvdXQiLCJpc0ltYWdlIiwibm9kZU5hbWUiLCJzb3VyY2UiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJJbWFnZSIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJvbmxvYWQiLCJmaXJlIiwic3R5bGUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJfcmVzb2x2ZSIsIm9uZXJyb3IiLCJzcmMiLCJlbGVtcyIsImdldE5vdExvYWRlZCIsImkiLCJsZW4iLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-imageloader/ImageLoader.js\n");

/***/ }),

/***/ "./node_modules/properjs-pagecontroller/PageController.js":
/*!****************************************************************!*\
  !*** ./node_modules/properjs-pagecontroller/PageController.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PageController)\n/* harmony export */ });\n/* harmony import */ var properjs_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-router */ \"./node_modules/properjs-pagecontroller/node_modules/properjs-router/Router.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-pagecontroller/node_modules/properjs-controller/Controller.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar getRouteDataToString = function getRouteDataToString(data) {\n  var ret = data.uri,\n    i;\n  for (i in data.query) {\n    ret = \"-\".concat(i, \"-\").concat(data.query[i]);\n  }\n  for (i in data.params) {\n    ret = \"-\".concat(i, \"-\").concat(data.params[i]);\n  }\n  return ret;\n};\nvar PageController = /*#__PURE__*/function (_Controller) {\n  _inherits(PageController, _Controller);\n  var _super = _createSuper(PageController);\n  function PageController(options) {\n    var _this;\n    _classCallCheck(this, PageController);\n    _this = _super.call(this);\n    _this._options = {\n      transitionTime: 0,\n      routerOptions: {\n        historyOptions: {}\n      },\n      routes: [\"*\"]\n    };\n\n    // Normalize usage options passed in\n    options = options || {};\n\n    // Merge usage options with defaults\n    for (var i in options) {\n      _this._options[i] = options[i];\n    }\n    _this._silentMode = false;\n    _this._slientCallback = null;\n    _this._isRoutingActive = false;\n    _this._timeBefore = null;\n    _this._currentRoute = null;\n    _this._currentQuery = null;\n    _this._currentToString = \"\";\n    _this._isSamePage = false;\n    _this._isFirstRoute = true;\n    return _this;\n  }\n  _createClass(PageController, [{\n    key: \"bind\",\n    value: function bind() {\n      var _this2 = this;\n      if (this._router) {\n        return this;\n      }\n      this._router = new properjs_router__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this._options.routerOptions);\n      if (this._router._matcher.parse(window.location.href, this._options.routes).matched) {\n        this._router.bind();\n        var onPreGetRouter = this.onPreGetRouter.bind(this);\n        var onPopGetRouter = this.onPopGetRouter.bind(this);\n        var onRouterResponse = this.onRouterResponse.bind(this);\n        this._options.routes.forEach(function (route) {\n          _this2._router.get(route, onRouterResponse);\n        });\n        this._router.on(\"preget\", onPreGetRouter);\n        this._router.on(\"popget\", onPopGetRouter);\n      }\n    }\n  }, {\n    key: \"routeSilently\",\n    value: function routeSilently(uri, cb) {\n      this._silentMode = true;\n      this._silentCallback = cb;\n      this._router.trigger(uri);\n    }\n  }, {\n    key: \"onRouterResponse\",\n    value: function onRouterResponse(data) {\n      var _this3 = this;\n      if (this._isRoutingActive) {\n        return;\n      }\n      this._isRoutingActive = true;\n      this.go(function () {\n        if (Date.now() - _this3._timeBefore >= _this3._options.transitionTime) {\n          _this3.stop();\n          _this3.handleRouterResponse(data);\n        }\n      });\n    }\n  }, {\n    key: \"onPreGetRouter\",\n    value: function onPreGetRouter(data) {\n      if (this._isRoutingActive) {\n        return;\n      }\n      if (this._currentToString === getRouteDataToString(data)) {\n        this._isSamePage = true;\n        this.fire(\"samepage\", {\n          request: data\n        });\n        return;\n      }\n      this._timeBefore = Date.now();\n      if (!this._isFirstRoute) {\n        this.fire(\"transition-out\", {\n          request: data\n        });\n      }\n    }\n  }, {\n    key: \"onPopGetRouter\",\n    value: function onPopGetRouter(data) {\n      var _this4 = this;\n      if (this._isRoutingActive) {\n        return;\n      }\n      this.onPreGetRouter(data.request);\n      setTimeout(function () {\n        _this4.handleRouterResponse(data);\n      }, this._options.transitionTime);\n    }\n  }, {\n    key: \"handleRouterResponse\",\n    value: function handleRouterResponse(res) {\n      var _this5 = this;\n      if (this._isSamePage) {\n        this._isSamePage = false;\n        this._isRoutingActive = false;\n        return;\n      }\n      var data = {\n        response: res.response.responseText,\n        request: res.request,\n        status: res.status\n      };\n      this._currentRoute = data.request.uri;\n      this._currentQuery = data.request.query;\n      this._currentToString = getRouteDataToString(data.request);\n\n      // Think of this as window.onload, happens once\n      if (this._isFirstRoute) {\n        this._isFirstRoute = false;\n        this._isRoutingActive = false;\n        this.fire(\"initialized\", data);\n\n        // All other Router sequences fall here\n      } else {\n        // Allow transition duration to take place\n        setTimeout(function () {\n          // 0.1 Refresh the document content\n          _this5.fire(\"document\", data);\n\n          // 0.2 Trigger transition of content to come back in\n          _this5.fire(\"transition-in\", data);\n          _this5._isRoutingActive = false;\n\n          // 0.3 Check `silent` mode\n          if (_this5._silentMode) {\n            _this5._silentMode = false;\n            if (typeof _this5._silentCallback === \"function\") {\n              _this5._silentCallback(data);\n              _this5._silentCallback = null;\n            }\n          }\n        }, this._options.transitionTime);\n      }\n    }\n  }]);\n  return PageController;\n}(properjs_controller__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtcGFnZWNvbnRyb2xsZXIvUGFnZUNvbnRyb2xsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNRO0FBSTdDLElBQU1FLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBb0JBLENBQUtDLElBQUksRUFBTTtFQUNyQyxJQUFJQyxHQUFHLEdBQUdELElBQUksQ0FBQ0UsR0FBRztJQUNkQyxDQUFDO0VBRUwsS0FBTUEsQ0FBQyxJQUFJSCxJQUFJLENBQUNJLEtBQUssRUFBRztJQUNwQkgsR0FBRyxRQUFBSSxNQUFBLENBQVFGLENBQUMsT0FBQUUsTUFBQSxDQUFJTCxJQUFJLENBQUNJLEtBQUssQ0FBRUQsQ0FBQyxDQUFFLENBQUU7RUFDckM7RUFFQSxLQUFNQSxDQUFDLElBQUlILElBQUksQ0FBQ00sTUFBTSxFQUFHO0lBQ3JCTCxHQUFHLFFBQUFJLE1BQUEsQ0FBUUYsQ0FBQyxPQUFBRSxNQUFBLENBQUlMLElBQUksQ0FBQ00sTUFBTSxDQUFFSCxDQUFDLENBQUUsQ0FBRTtFQUN0QztFQUVBLE9BQU9GLEdBQUc7QUFDZCxDQUFDO0FBQUMsSUFJbUJNLGNBQWMsMEJBQUFDLFdBQUE7RUFBQUMsU0FBQSxDQUFBRixjQUFBLEVBQUFDLFdBQUE7RUFBQSxJQUFBRSxNQUFBLEdBQUFDLFlBQUEsQ0FBQUosY0FBQTtFQUMvQixTQUFBQSxlQUFjSyxPQUFPLEVBQUc7SUFBQSxJQUFBQyxLQUFBO0lBQUFDLGVBQUEsT0FBQVAsY0FBQTtJQUNwQk0sS0FBQSxHQUFBSCxNQUFBLENBQUFLLElBQUE7SUFFQUYsS0FBQSxDQUFLRyxRQUFRLEdBQUc7TUFDWkMsY0FBYyxFQUFFLENBQUM7TUFDakJDLGFBQWEsRUFBRTtRQUNYQyxjQUFjLEVBQUUsQ0FBQztNQUNyQixDQUFDO01BQ0RDLE1BQU0sRUFBRSxDQUFDLEdBQUc7SUFDaEIsQ0FBQzs7SUFFRDtJQUNBUixPQUFPLEdBQUlBLE9BQU8sSUFBSSxDQUFDLENB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CAgICAgICAgIGhpc3RvcnlPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb3V0ZXM6IFtcIipcIl0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHVzYWdlIG9wdGlvbnMgcGFzc2VkIGluXG4gICAgICAgIG9wdGlvbnMgPSAob3B0aW9ucyB8fCB7fSk7XG5cbiAgICAgICAgLy8gTWVyZ2UgdXNhZ2Ugb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG4gICAgICAgIGZvciAoIGxldCBpIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zWyBpIF0gPSBvcHRpb25zWyBpIF07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaWxlbnRNb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NsaWVudENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNSb3V0aW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RpbWVCZWZvcmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50Um91dGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50UXVlcnkgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9TdHJpbmcgPSBcIlwiO1xuICAgICAgICB0aGlzLl9pc1NhbWVQYWdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzRmlyc3RSb3V0ZSA9IHRydWU7XG4gICAgfVxuXG5cbiAgICBiaW5kICgpIHtcbiAgICAgICAgaWYgKCB0aGlzLl9yb3V0ZXIgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JvdXRlciA9IG5ldyBSb3V0ZXIoIHRoaXMuX29wdGlvbnMucm91dGVyT3B0aW9ucyApO1xuXG4gICAgICAgIGlmICggdGhpcy5fcm91dGVyLl9tYXRjaGVyLnBhcnNlKCB3aW5kb3cubG9jYXRpb24uaHJlZiwgdGhpcy5fb3B0aW9ucy5yb3V0ZXMgKS5tYXRjaGVkICkge1xuICAgICAgICAgICAgdGhpcy5fcm91dGVyLmJpbmQoKTtcblxuICAgICAgICAgICAgY29uc3Qgb25QcmVHZXRSb3V0ZXIgPSB0aGlzLm9uUHJlR2V0Um91dGVyLmJpbmQoIHRoaXMgKTtcbiAgICAgICAgICAgIGNvbnN0IG9uUG9wR2V0Um91dGVyID0gdGhpcy5vblBvcEdldFJvdXRlci5iaW5kKCB0aGlzICk7XG4gICAgICAgICAgICBjb25zdCBvblJvdXRlclJlc3BvbnNlID0gdGhpcy5vblJvdXRlclJlc3BvbnNlLmJpbmQoIHRoaXMgKTtcblxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5yb3V0ZXMuZm9yRWFjaCgoIHJvdXRlICkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRlci5nZXQoIHJvdXRlLCBvblJvdXRlclJlc3BvbnNlICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fcm91dGVyLm9uKCBcInByZWdldFwiLCBvblByZUdldFJvdXRlciApO1xuICAgICAgICAgICAgdGhpcy5fcm91dGVyLm9uKCBcInBvcGdldFwiLCBvblBvcEdldFJvdXRlciApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICByb3V0ZVNpbGVudGx5ICggdXJpLCBjYiApIHtcbiAgICAgICAgdGhpcy5fc2lsZW50TW9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NpbGVudENhbGxiYWNrID0gY2I7XG4gICAgICAgIHRoaXMuX3JvdXRlci50cmlnZ2VyKCB1cmkgKTtcbiAgICB9XG5cblxuICAgIG9uUm91dGVyUmVzcG9uc2UgKCBkYXRhICkge1xuICAgICAgICBpZiAoIHRoaXMuX2lzUm91dGluZ0FjdGl2ZSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lzUm91dGluZ0FjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5nbygoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIChEYXRlLm5vdygpIC0gdGhpcy5fdGltZUJlZm9yZSkgPj0gdGhpcy5fb3B0aW9ucy50cmFuc2l0aW9uVGltZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJvdXRlclJlc3BvbnNlKCBkYXRhICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgb25QcmVHZXRSb3V0ZXIgKCBkYXRhICkge1xuICAgICAgICBpZiAoIHRoaXMuX2lzUm91dGluZ0FjdGl2ZSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5fY3VycmVudFRvU3RyaW5nID09PSBnZXRSb3V0ZURhdGFUb1N0cmluZyggZGF0YSApICkge1xuICAgICAgICAgICAgdGhpcy5faXNTYW1lUGFnZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcmUoIFwic2FtZXBhZ2VcIiwge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RpbWVCZWZvcmUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIGlmICggIXRoaXMuX2lzRmlyc3RSb3V0ZSApIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSggXCJ0cmFuc2l0aW9uLW91dFwiLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBvblBvcEdldFJvdXRlciAoIGRhdGEgKSB7XG4gICAgICAgIGlmICggdGhpcy5faXNSb3V0aW5nQWN0aXZlICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblByZUdldFJvdXRlciggZGF0YS5yZXF1ZXN0ICk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJvdXRlclJlc3BvbnNlKCBkYXRhICk7XG5cbiAgICAgICAgfSwgdGhpcy5fb3B0aW9ucy50cmFuc2l0aW9uVGltZSApO1xuICAgIH1cblxuXG4gICAgaGFuZGxlUm91dGVyUmVzcG9uc2UgKCByZXMgKSB7XG4gICAgICAgIGlmICggdGhpcy5faXNTYW1lUGFnZSApIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2FtZVBhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUm91dGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXMucmVzcG9uc2UucmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgcmVxdWVzdDogcmVzLnJlcXVlc3QsXG4gICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fY3VycmVudFJvdXRlID0gZGF0YS5yZXF1ZXN0LnVyaTtcbiAgICAgICAgdGhpcy5fY3VycmVudFF1ZXJ5ID0gZGF0YS5yZXF1ZXN0LnF1ZXJ5O1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9TdHJpbmcgPSBnZXRSb3V0ZURhdGFUb1N0cmluZyggZGF0YS5yZXF1ZXN0ICk7XG5cbiAgICAgICAgLy8gVGhpbmsgb2YgdGhpcyBhcyB3aW5kb3cub25sb2FkLCBoYXBwZW5zIG9uY2VcbiAgICAgICAgaWYgKCB0aGlzLl9pc0ZpcnN0Um91dGUgKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0ZpcnN0Um91dGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lzUm91dGluZ0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoIFwiaW5pdGlhbGl6ZWRcIiwgZGF0YSApO1xuXG4gICAgICAgIC8vIEFsbCBvdGhlciBSb3V0ZXIgc2VxdWVuY2VzIGZhbGwgaGVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWxsb3cgdHJhbnNpdGlvbiBkdXJhdGlvbiB0byB0YWtlIHBsYWNlXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0IHtcbiAgICAgICAgICAgICAgICAvLyAwLjEgUmVmcmVzaCB0aGUgZG9jdW1lbnQgY29udGVudFxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSggXCJkb2N1bWVudFwiLCBkYXRhICk7XG5cbiAgICAgICAgICAgICAgICAvLyAwLjIgVHJpZ2dlciB0cmFuc2l0aW9uIG9mIGNvbnRlbnQgdG8gY29tZSBiYWNrIGluXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCBcInRyYW5zaXRpb24taW5cIiwgZGF0YSApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5faXNSb3V0aW5nQWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyAwLjMgQ2hlY2sgYHNpbGVudGAgbW9kZVxuICAgICAgICAgICAgICAgIGlmICggdGhpcy5fc2lsZW50TW9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lsZW50TW9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHRoaXMuX3NpbGVudENhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWxlbnRDYWxsYmFjayggZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lsZW50Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCB0aGlzLl9vcHRpb25zLnRyYW5zaXRpb25UaW1lICk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOlsiUm91dGVyIiwiQ29udHJvbGxlciIsImdldFJvdXRlRGF0YVRvU3RyaW5nIiwiZGF0YSIsInJldCIsInVyaSIsImkiLCJxdWVyeSIsImNvbmNhdCIsInBhcmFtcyIsIlBhZ2VDb250cm9sbGVyIiwiX0NvbnRyb2xsZXIiLCJfaW5oZXJpdHMiLCJfc3VwZXIiLCJfY3JlYXRlU3VwZXIiLCJvcHRpb25zIiwiX3RoaXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJjYWxsIiwiX29wdGlvbnMiLCJ0cmFuc2l0aW9uVGltZSIsInJvdXRlck9wdGlvbnMiLCJoaXN0b3J5T3B0aW9ucyIsInJvdXRlcyIsIl9zaWxlbnRNb2RlIiwiX3NsaWVudENhbGxiYWNrIiwiX2lzUm91dGluZ0FjdGl2ZSIsIl90aW1lQmVmb3JlIiwiX2N1cnJlbnRSb3V0ZSIsIl9jdXJyZW50UXVlcnkiLCJfY3VycmVudFRvU3RyaW5nIiwiX2lzU2FtZVBhZ2UiLCJfaXNGaXJzdFJvdXRlIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJiaW5kIiwiX3RoaXMyIiwiX3JvdXRlciIsIl9tYXRjaGVyIiwicGFyc2UiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJtYXRjaGVkIiwib25QcmVHZXRSb3V0ZXIiLCJvblBvcEdldFJvdXRlciIsIm9uUm91dGVyUmVzcG9uc2UiLCJmb3JFYWNoIiwicm91dGUiLCJnZXQiLCJvbiIsInJvdXRlU2lsZW50bHkiLCJjYiIsIl9zaWxlbnRDYWxsYmFjayIsInRyaWdnZXIiLCJfdGhpczMiLCJnbyIsIkRhdGUiLCJub3ciLCJzdG9wIiwiaGFuZGxlUm91dGVyUmVzcG9uc2UiLCJmaXJlIiwicmVxdWVzdCIsIl90aGlzNCIsInNldFRpbWVvdXQiLCJyZXMiLCJfdGhpczUiLCJyZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsInN0YXR1cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-pagecontroller/PageController.js\n");

/***/ }),

/***/ "./node_modules/properjs-pagecontroller/node_modules/paramalama/paramalama.js":
/*!************************************************************************************!*\
  !*** ./node_modules/properjs-pagecontroller/node_modules/paramalama/paramalama.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (str) {\n  var query = decodeURIComponent(str).match(/[#|?].*$/g);\n  var ret = {};\n  if (query) {\n    query = query[0].replace(/^\\?|^#|^\\/|\\/$|\\[|\\]/g, \"\");\n    query = query.split(\"&\");\n    for (var i = query.length; i--;) {\n      var pair = query[i].split(\"=\");\n      var key = pair[0];\n      var val = pair[1];\n      if (ret[key]) {\n        // #2 https://github.com/kitajchuk/paramalama/issues/2\n        // This supposedly will work as of ECMA-262\n        // This works since we are not passing objects across frame boundaries\n        // and we are not considering Array-like objects. This WILL be an Array.\n        if ({}.toString.call(ret[key]) !== \"[object Array]\") {\n          ret[key] = [ret[key]];\n        }\n        ret[key].push(val);\n      } else {\n        ret[key] = val;\n      }\n    }\n  }\n  return ret;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtcGFnZWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL3BhcmFtYWxhbWEvcGFyYW1hbGFtYS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsVUFBRUEsR0FBRyxFQUFNO0VBQ3RCLElBQUlDLEtBQUssR0FBR0Msa0JBQWtCLENBQUVGLEdBQUksQ0FBQyxDQUFDRyxLQUFLLENBQUUsV0FBWSxDQUFDO0VBQzFELElBQU1DLEdBQUcsR0FBRyxDQUFDLENBQUM7RUFFZCxJQUFLSCxLQUFLLEVBQUc7SUFDVEEsS0FBSyxHQUFHQSxLQUFLLENBQUUsQ0FBQyxDQUFFLENBQUNJLE9BQU8sQ0FBRSx1QkFBdUIsRUFBRSxFQUFHLENBQUM7SUFDekRKLEtBQUssR0FBR0EsS0FBSyxDQUFDSyxLQUFLLENBQUUsR0FBSSxDQUFDO0lBRTFCLEtBQU0sSUFBSUMsQ0FBQyxHQUFHTixLQUFLLENBQUNPLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEdBQUk7TUFDL0IsSUFBTUUsSUFBSSxHQUFHUixLQUFLLENBQUVNLENBQUMsQ0FBRSxDQUFDRCxLQUFLLENBQUUsR0FBSSxDQUFDO01BQ3BDLElBQU1JLEdBQUcsR0FBR0QsSUFBSSxDQUFFLENBQUMsQ0FBRTtNQUNyQixJQUFNRSxHQUFHLEdBQUdGLElBQUksQ0FBRSxDQUFDLENBQUU7TUFFckIsSUFBS0wsR0FBRyxDQUFFTSxHQUFHLENBQUUsRUFBRztRQUNkO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsSUFBSyxDQUFDLENBQUMsQ0FBQ0UsUUFBUSxDQUFDQyxJQUFJLENBQUVULEdBQUcsQ0FBRU0sR0FBRyxDQUFHLENBQUMsS0FBSyxnQkFBZ0IsRUFBRztVQUN2RE4sR0FBRyxDQUFFTSxHQUFHLENBQUUsR0FBRyxDQUFFTixHQUFHLENBQUVNLEdBQUcsQ0FBRSxDQUFFO1FBQy9CO1FBRUFOLEdBQUcsQ0FBRU0sR0FBRyxDQUFFLENBQUNJLElBQUksQ0FBRUgsR0FBSSxDQUFDO01BRTFCLENBQUMsTUFBTTtRQUNIUCxHQUFHLENBQUVNLEdBQUcsQ0FBRSxHQUFHQyxHQUFHO01BQ3BCO0lBQ0o7RUFDSjtFQUVBLE9BQU9QLEdBQUc7QUFDZCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLXBhZ2Vjb250cm9sbGVyL25vZGVfbW9kdWxlcy9wYXJhbWFsYW1hL3BhcmFtYWxhbWEuanM/NjE1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAoIHN0ciApID0IHtcbiAgICBsZXQgcXVlcnkgPSBkZWNvZGVVUklDb21wb25lbnQoIHN0ciApLm1hdGNoKCAvWyN8P10uKiQvZyApO1xuICAgIGNvbnN0IHJldCA9IHt9O1xuXG4gICAgaWYgKCBxdWVyeSApIHtcbiAgICAgICAgcXVlcnkgPSBxdWVyeVsgMCBdLnJlcGxhY2UoIC9eXFw/fF4jfF5cXC98XFwvJHxcXFt8XFxdL2csIFwiXCIgKTtcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5zcGxpdCggXCImXCIgKTtcblxuICAgICAgICBmb3IgKCBsZXQgaSA9IHF1ZXJ5Lmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBxdWVyeVsgaSBdLnNwbGl0KCBcIj1cIiApO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpclsgMCBdO1xuICAgICAgICAgICAgY29uc3QgdmFsID0gcGFpclsgMSBdO1xuXG4gICAgICAgICAgICBpZiAoIHJldFsga2V5IF0gKSB7XG4gICAgICAgICAgICAgICAgLy8gIzIgaHR0cHM6Ly9naXRodWIuY29tL2tpdGFqY2h1ay9wYXJhbWFsYW1hL2lzc3Vlcy8yXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzdXBwb3NlZGx5IHdpbGwgd29yayBhcyBvZiBFQ01BLTI2MlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd29ya3Mgc2luY2Ugd2UgYXJlIG5vdCBwYXNzaW5nIG9iamVjdHMgYWNyb3NzIGZyYW1lIGJvdW5kYXJpZXNcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2UgYXJlIG5vdCBjb25zaWRlcmluZyBBcnJheS1saWtlIG9iamVjdHMuIFRoaXMgV0lMTCBiZSBhbiBBcnJheS5cbiAgICAgICAgICAgICAgICBpZiAoIHt9LnRvU3RyaW5nLmNhbGwoIHJldFsga2V5IF0gKSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiICkge1xuICAgICAgICAgICAgICAgICAgICByZXRbIGtleSBdID0gWyByZXRbIGtleSBdIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0WyBrZXkgXS5wdXNoKCB2YWwgKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRbIGtleSBdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG4iXSwibmFtZXMiOlsic3RyIiwicXVlcnkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJtYXRjaCIsInJldCIsInJlcGxhY2UiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJwYWlyIiwia2V5IiwidmFsIiwidG9TdHJpbmciLCJjYWxsIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-pagecontroller/node_modules/paramalama/paramalama.js\n");

/***/ }),

/***/ "./node_modules/properjs-pagecontroller/node_modules/properjs-controller/Controller.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/properjs-pagecontroller/node_modules/properjs-controller/Controller.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Controller)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar raf = window.requestAnimationFrame;\nvar caf = window.cancelAnimationFrame;\n\n/**\n *\n * Easing functions\n * @namespace Easing\n * @memberof! <global>\n *\n */\nvar ease = {\n  /**\n   *\n   * Produce a linear ease\n   * @method linear\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  linear: function linear(t) {\n    return t;\n  },\n  /**\n   *\n   * Produce a swing ease like in jQuery\n   * @method swing\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  swing: function swing(t) {\n    return (1 - Math.cos(t * Math.PI)) / 2;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInQuad\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutQuad\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutQuad: function easeOutQuad(t) {\n    return t * (2 - t);\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutQuad\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutQuad: function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1  (4 - 2 * t) * t;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInCubic\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutCubic\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutCubic: function easeOutCubic(t) {\n    return --t * t * t  1;\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutCubic\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutCubic: function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2)  1;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInQuart\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutQuart\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutQuart: function easeOutQuart(t) {\n    return 1 - --t * t * t * t;\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutQuart\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutQuart: function easeInOutQuart(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInQuint\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutQuint\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutQuint: function easeOutQuint(t) {\n    return 1  --t * t * t * t * t;\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutQuint\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutQuint: function easeInOutQuint(t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1  16 * --t * t * t * t * t;\n  }\n};\nvar defs = {\n  ease: ease.swing,\n  duration: 500,\n  from: 0,\n  to: 500,\n  update: function update() {},\n  complete: function complete() {}\n};\nvar Controller = /*#__PURE__*/function () {\n  function Controller() {\n    _classCallCheck(this, Controller);\n    // Unique event IDs\n    this._uid = 0;\n    this._uprop = \"properjsUID\";\n\n    // Store for event handlers\n    this._handlers = {};\n\n    // RAF manager props\n    this._started = false;\n    this._paused = false;\n    this._cycle = null;\n  }\n  _createClass(Controller, [{\n    key: \"uid\",\n    value: function uid() {\n      this._uid = this._uid  1;\n      return this._uid;\n    }\n  }, {\n    key: \"go\",\n    value: function go(callback) {\n      var _this = this;\n      if (this._started) {\n        return this;\n      }\n      this._started = true;\n      this._anim = function (elapsed) {\n        _this._cycle = raf(_this._anim);\n        if (typeof callback === \"function\") {\n          callback(elapsed);\n        }\n      };\n      this._cycle = raf(this._anim);\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._paused = true;\n      return this;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      this._paused = false;\n      return this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      caf(this._cycle);\n      this._paused = false;\n      this._started = false;\n      this._cycle = null;\n      return this;\n    }\n  }, {\n    key: \"tween\",\n    value: function tween(opts) {\n      var _this2 = this;\n      for (var i in defs) {\n        if (opts[i] === undefined) {\n          opts[i] = defs[i];\n        }\n      }\n      var startTime = null;\n      var tweenDiff = opts.to - opts.from;\n      this.stop().go(function (elapsed) {\n        if (startTime === null) {\n          startTime = elapsed;\n        }\n        var diff = elapsed - startTime;\n        var tweenTo = tweenDiff * opts.ease(diff / opts.duration)  opts.from;\n        opts.update(tweenTo);\n        if (diff > opts.duration) {\n          opts.complete(opts.to);\n          _this2.stop();\n        }\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, handler) {\n      var events = event.split(\" \");\n      handler[this._uprop] = this.uid();\n      for (var i = events.length; i--;) {\n        if (typeof handler === \"function\") {\n          if (!this._handlers[events[i]]) {\n            this._handlers[events[i]] = [];\n          }\n          this._handlers[events[i]].push(handler);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      if (!this._handlers[event]) {\n        return this;\n      }\n      if (handler) {\n        this._offOne(event, handler);\n      } else {\n        this._offAll(event);\n      }\n      return this;\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(event) {\n      if (!this._handlers[event]) {\n        return this;\n      }\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key) {\n        args[_key - 1] = arguments[_key];\n      }\n      for (var i = this._handlers[event].length; i--;) {\n        this._handlers[event][i].apply(this, args);\n      }\n      return this;\n    }\n  }, {\n    key: \"_offOne\",\n    value: function _offOne(event, handler) {\n      for (var i = 0, len = this._handlers[event].length; i < len; i) {\n        if (handler[this._uprop] === this._handlers[event][i][this._uprop]) {\n          this._handlers[event].splice(i, 1);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"_offAll\",\n    value: function _offAll(event) {\n      for (var i = this._handlers[event].length; i--;) {\n        this._handlers[event][i] = null;\n      }\n      delete this._handlers[event];\n    }\n  }]);\n  return Controller;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtcGFnZWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWNvbnRyb2xsZXIvQ29udHJvbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsSUFBTUEsR0FBRyxHQUFHQyxNQUFNLENBQUNDLHFCQUFxQjtBQUN4QyxJQUFNQyxHQUFHLEdBQUdGLE1BQU0sQ0FBQ0csb0JBQW9COztBQUl2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1DLElBQUksR0FBRztFQUNUO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsTUFBTSxXQUFBQSxPQUFHQyxDQUFDLEVBQUc7SUFBRSxPQUFPQSxDQUFDO0VBQUUsQ0FBQztFQUUxQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLEtBQUssV0FBQUEsTUFBR0QsQ0FBQyxFQUFHO0lBQUUsT0FBTyxDQUFDLENBQUMsR0FBQ0UsSUFBSSxDQUFDQyxHQUFHLENBQUVILENBQUMsR0FBQ0UsSUFBSSxDQUFDRSxFQUFHLENBQUMsSUFBRSxDQUFDO0VBQUUsQ0FBQztFQUVuRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLFVBQVUsV0FBQUEsV0FBR0wsQ0FBQyxFQUFHO0lBQUUsT0FBT0EsQ0FBQyxHQUFDQSxDQUFDO0VBQUUsQ0FBQztFQUVoQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lNLFdBQVcsV0FBQUEsWUFBR04sQ0FBQyxFQUFHO0lBQUUsT0FBT0EsQ0FBQyxJQUFFLENBQUMsR0FBQ0EsQ0FBQyxDQUFDO0VBQUUsQ0FBQztFQUVyQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lPLGFBQWEsV0FBQUEsY0FBR1AsQ0FBQyxFQUFHO0lBQUUsT0FBT0EsQ0FBQyxHQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUNBLENBQUMs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R0FBRyxJQUFJLENBQUMxQyxTQUFTLENBQUUwQixLQUFLLENBQUUsQ0FBQ0ksTUFBTSxFQUFFWCxDQUFDLEdBQUd1QixHQUFHLEVBQUV2QixDQUFDLEVBQUUsRUFBRztRQUNsRSxJQUFLUSxPQUFPLENBQUUsSUFBSSxDQUFDNUIsTUFBTSxDQUFFLEtBQUssSUFBSSxDQUFDQyxTQUFTLENBQUUwQixLQUFLLENBQUUsQ0FBRVAsQ0FBQyxDQUFFLENBQUUsSUFBSSxDQUFDcEIsTUFBTSxDQUFFLEVBQUc7VUFDMUUsSUFBSSxDQUFDQyxTQUFTLENBQUUwQixLQUFLLENBQUUsQ0FBQ2lCLE1BQU0sQ0FBRXhCLENBQUMsRUFBRSxDQUFFLENBQUM7VUFFdEM7UUFDSjtNQUNKO0lBQ0o7RUFBQztJQUFBZCxHQUFBO0lBQUFDLEtBQUEsRUFHRCxTQUFBNEIsUUFBVVIsS0FBSyxFQUFHO01BQ2QsS0FBTSxJQUFJUCxDQUFDLEdBQUcsSUFBSSxDQUFDbkIsU0FBUyxDQUFFMEIsS0FBSyxDQUFFLENBQUNJLE1BQU0sRUFBRVgsQ0FBQyxFQUFFLEdBQUk7UUFDakQsSUFBSSxDQUFDbkIsU0FBUyxDQUFFMEIsS0FBSyxDQUFFLENBQUVQLENBQUMsQ0FBRSxHQUFHLElBQUk7TUFDdkM7TUFFQSxPQUFPLElBQUksQ0FBQ25CLFNBQVMsQ0FBRTBCLEtBQUssQ0FBRTtJQUNsQztFQUFDO0VBQUEsT0FBQTlCLFVBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1wYWdlY29udHJvbGxlci9ub2RlX21vZHVsZXMvcHJvcGVyanMtY29udHJvbGxlci9Db250cm9sbGVyLmpzPzNkMGQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbmNvbnN0IGNhZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZTtcblxuXG5cbi8qKlxuICpcbiAqIEVhc2luZyBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgRWFzaW5nXG4gKiBAbWVtYmVyb2YhIDxnbG9iYWwXG4gKlxuICovXG5jb25zdCBlYXNlID0ge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJvZHVjZSBhIGxpbmVhciBlYXNlXG4gICAgICogQG1ldGhvZCBsaW5lYXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBsaW5lYXIgKCB0ICkgeyByZXR1cm4gdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJvZHVjZSBhIHN3aW5nIGVhc2UgbGlrZSBpbiBqUXVlcnlcbiAgICAgKiBAbWV0aG9kIHN3aW5nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgc3dpbmcgKCB0ICkgeyByZXR1cm4gKDEtTWF0aC5jb3MoIHQqTWF0aC5QSSApKS8yOyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlSW5RdWFkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgZWFzZUluUXVhZCAoIHQgKSB7IHJldHVybiB0KnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlT3V0UXVhZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VPdXRRdWFkICggdCApIHsgcmV0dXJuIHQqKDItdCk7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAqIEBtZXRob2QgZWFzZUluT3V0UXVhZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJbk91dFF1YWQgKCB0ICkgeyByZXR1cm4gdDwwLjUgPyAyKnQqdCA6IC0xKyg0LTIqdCkqdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAqIEBtZXRob2QgZWFzZUluQ3ViaWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlSW5DdWJpYyAoIHQgKSB7IHJldHVybiB0KnQqdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgKiBAbWV0aG9kIGVhc2VPdXRDdWJpY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VPdXRDdWJpYyAoIHQgKSB7IHJldHVybiAoLS10KSp0KnQrMTsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICogQG1ldGhvZCBlYXNlSW5PdXRDdWJpY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJbk91dEN1YmljICggdCApIHsgcmV0dXJuIHQ8MC41ID8gNCp0KnQqdCA6ICh0LTEpKigyKnQtMikqKDIqdC0yKSsxOyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlSW5RdWFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJblF1YXJ0ICggdCApIHsgcmV0dXJuIHQqdCp0KnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlT3V0UXVhcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVhcnQgKCB0ICkgeyByZXR1cm4gMS0oLS10KSp0KnQqdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICogQG1ldGhvZCBlYXNlSW5PdXRRdWFydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJbk91dFF1YXJ0ICggdCApIHsgcmV0dXJuIHQ8MC41ID8gOCp0KnQqdCp0IDogMS04KigtLXQpKnQqdCp0OyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlSW5RdWludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJblF1aW50ICggdCApIHsgcmV0dXJuIHQqdCp0KnQqdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgKiBAbWV0aG9kIGVhc2VPdXRRdWludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VPdXRRdWludCAoIHQgKSB7IHJldHVybiAxKygtLXQpKnQqdCp0KnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAqIEBtZXRob2QgZWFzZUluT3V0UXVpbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWludCAoIHQgKSB7IHJldHVybiB0PDAuNSA/IDE2KnQqdCp0KnQqdCA6IDErMTYqKC0tdCkqdCp0KnQqdDsgfVxufTtcblxuXG5cbmNvbnN0IGRlZnMgPSB7XG4gICAgZWFzZTogZWFzZS5zd2luZyxcbiAgICBkdXJhdGlvbjogNTAwLFxuICAgIGZyb206IDAsXG4gICAgdG86IDUwMCxcbiAgICB1cGRhdGU6ICgpID0IHt9LFxuICAgIGNvbXBsZXRlOiAoKSA9PiB7fSxcbn07XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIC8vIFVuaXF1ZSBldmVudCBJRHNcbiAgICAgICAgdGhpcy5fdWlkID0gMDtcbiAgICAgICAgdGhpcy5fdXByb3AgPSBcInByb3BlcmpzVUlEXCI7XG5cbiAgICAgICAgLy8gU3RvcmUgZm9yIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG5cbiAgICAgICAgLy8gUkFGIG1hbmFnZXIgcHJvcHNcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3ljbGUgPSBudWxsO1xuICAgIH1cblxuXG4gICAgdWlkICgpIHtcbiAgICAgICAgdGhpcy5fdWlkID0gKHRoaXMuX3VpZCArIDEpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl91aWQ7XG4gICAgfVxuXG5cbiAgICBnbyAoIGNhbGxiYWNrICkge1xuICAgICAgICBpZiAoIHRoaXMuX3N0YXJ0ZWQgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hbmltID0gKCBlbGFwc2VkICkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUgPSByYWYoIHRoaXMuX2FuaW0gKTtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayggZWxhcHNlZCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jeWNsZSA9IHJhZiggdGhpcy5fYW5pbSApO1xuICAgIH1cblxuXG4gICAgcGF1c2UgKCkge1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgcGxheSAoKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgc3RvcCAoKSB7XG4gICAgICAgIGNhZiggdGhpcy5fY3ljbGUgKTtcblxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jeWNsZSA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICB0d2VlbiAoIG9wdHMgKSB7XG4gICAgICAgIGZvciAoIGxldCBpIGluIGRlZnMgKSB7XG4gICAgICAgICAgICBpZiAoIG9wdHNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIG9wdHNbIGkgXSA9IGRlZnNbIGkgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGFydFRpbWUgPSBudWxsO1xuICAgICAgICBjb25zdCB0d2VlbkRpZmYgPSAob3B0cy50byAtIG9wdHMuZnJvbSk7XG5cbiAgICAgICAgdGhpcy5zdG9wKCkuZ28oKCBlbGFwc2VkICkgPT4ge1xuICAgICAgICAgICAgaWYgKCBzdGFydFRpbWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gZWxhcHNlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGVsYXBzZWQgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zdCB0d2VlblRvID0gKHR3ZWVuRGlmZiAqIG9wdHMuZWFzZSggZGlmZiAvIG9wdHMuZHVyYXRpb24gKSkgKyBvcHRzLmZyb207XG5cbiAgICAgICAgICAgIG9wdHMudXBkYXRlKCB0d2VlblRvICk7XG5cbiAgICAgICAgICAgIGlmICggZGlmZiAIG9wdHMuZHVyYXRpb24gKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5jb21wbGV0ZSggb3B0cy50byApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgb24gKCBldmVudCwgaGFuZGxlciApIHtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gZXZlbnQuc3BsaXQoIFwiIFwiICk7XG5cbiAgICAgICAgaGFuZGxlclsgdGhpcy5fdXByb3AgXSA9IHRoaXMudWlkKCk7XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSBldmVudHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgIGlmICggIXRoaXMuX2hhbmRsZXJzWyBldmVudHNbIGkgXSBdICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1sgZXZlbnRzWyBpIF0gXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzWyBldmVudHNbIGkgXSBdLnB1c2goIGhhbmRsZXIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgb2ZmICggZXZlbnQsIGhhbmRsZXIgKSB7XG4gICAgICAgIGlmICggIXRoaXMuX2hhbmRsZXJzWyBldmVudCBdICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGhhbmRsZXIgKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZPbmUoIGV2ZW50LCBoYW5kbGVyICk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29mZkFsbCggZXZlbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgZmlyZSAoIGV2ZW50LCAuLi5hcmdzICkge1xuICAgICAgICBpZiAoICF0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXS5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXVsgaSBdLmFwcGx5KCB0aGlzLCBhcmdzICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIF9vZmZPbmUgKCBldmVudCwgaGFuZGxlciApIHtcbiAgICAgICAgZm9yICggbGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXS5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggaGFuZGxlclsgdGhpcy5fdXByb3AgXSA9PT0gdGhpcy5faGFuZGxlcnNbIGV2ZW50IF1bIGkgXVsgdGhpcy5fdXByb3AgXSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXS5zcGxpY2UoIGksIDEgKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBfb2ZmQWxsICggZXZlbnQgKSB7XG4gICAgICAgIGZvciAoIGxldCBpID0gdGhpcy5faGFuZGxlcnNbIGV2ZW50IF0ubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbIGV2ZW50IF1bIGkgXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNbIGV2ZW50IF07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInJhZiIsIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhZiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZWFzZSIsImxpbmVhciIsInQiLCJzd2luZyIsIk1hdGgiLCJjb3MiLCJQSSIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJkZWZzIiwiZHVyYXRpb24iLCJmcm9tIiwidG8iLCJ1cGRhdGUiLCJjb21wbGV0ZSIsIkNvbnRyb2xsZXIiLCJfY2xhc3NDYWxsQ2hlY2siLCJfdWlkIiwiX3Vwcm9wIiwiX2hhbmRsZXJzIiwiX3N0YXJ0ZWQiLCJfcGF1c2VkIiwiX2N5Y2xlIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJ1aWQiLCJnbyIsImNhbGxiYWNrIiwiX3RoaXMiLCJfYW5pbSIsImVsYXBzZWQiLCJwYXVzZSIsInBsYXkiLCJzdG9wIiwidHdlZW4iLCJvcHRzIiwiX3RoaXMyIiwiaSIsInVuZGVmaW5lZCIsInN0YXJ0VGltZSIsInR3ZWVuRGlmZiIsImRpZmYiLCJ0d2VlblRvIiwib24iLCJldmVudCIsImhhbmRsZXIiLCJldmVudHMiLCJzcGxpdCIsImxlbmd0aCIsInB1c2giLCJvZmYiLCJfb2ZmT25lIiwiX29mZkFsbCIsImZpcmUiLCJfbGVuIiwiYXJndW1lbnRzIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImFwcGx5IiwibGVuIiwic3BsaWNlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-pagecontroller/node_modules/properjs-controller/Controller.js\n");

/***/ }),

/***/ "./node_modules/properjs-pagecontroller/node_modules/properjs-matchroute/MatchRoute.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/properjs-pagecontroller/node_modules/properjs-matchroute/MatchRoute.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MatchRoute)\n/* harmony export */ });\n/* harmony import */ var paramalama__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! paramalama */ \"./node_modules/properjs-pagecontroller/node_modules/paramalama/paramalama.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar rHTTPs = /^http[s]?:\\/\\/.*?\\//;\nvar rTrails = /^\\/|\\/$/g;\nvar rHashQuery = /#.*$|\\?.*$/g;\nvar rWild = /^:/;\nvar rWilders = {\n  num: /^[0-9]$/,\n  slug: /^[A-Za-z][A-Za-z0-9-_.]*$/\n};\nvar MatchRoute = /*#__PURE__*/function () {\n  function MatchRoute(routes) {\n    _classCallCheck(this, MatchRoute);\n    this._routes = routes ? this._cleanRoutes(routes) : [];\n  }\n  _createClass(MatchRoute, [{\n    key: \"getRoutes\",\n    value: function getRoutes() {\n      return this._routes;\n    }\n  }, {\n    key: \"config\",\n    value: function config(routes) {\n      routes = typeof routes === \"string\" ? [routes] : routes;\n      this._routes = this._routes.concat(this._cleanRoutes(routes));\n      return this;\n    }\n  }, {\n    key: \"test\",\n    value: function test(url) {\n      return this.parse(url, this._routes).matched;\n    }\n  }, {\n    key: \"params\",\n    value: function params(url) {\n      return this.parse(url, this._routes).params;\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(route, url) {\n      return this.parse(url, [route]);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(url, routes) {\n      var route = this._cleanRoute(url);\n      var uris = route.split(\"/\");\n      var uLen = uris.length;\n      var iLen = routes.length;\n      var segMatches, isStar, params, match, ruris, regex, cond, ret;\n      for (var i = 0; i < iLen; i) {\n        // Flag \"*\" route\n        isStar = routes[i] === \"*\";\n\n        // Start fresh each iteration\n        // Only one matched route allowed\n        ret = {\n          matched: false,\n          route: null,\n          uri: [],\n          params: {},\n          query: (0,paramalama__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(url)\n        };\n        ruris = routes[i].split(\"/\");\n\n        // Handle route === \"/\"\n        if (route === \"/\" && routes[i] === \"/\") {\n          ret.matched = true;\n          ret.route = routes[i];\n          ret.uri = \"/\";\n          break;\n        }\n\n        // If the actual url doesn't match the route in segment length,\n        // it cannot possibly be considered for matching so just skip it\n        if (ruris.length !== uris.length && !isStar) {\n          continue;\n        }\n        segMatches = 0;\n        for (var j = 0; j < uLen; j) {\n          // Matched a variable uri segment\n          if (rWild.test(ruris[j])) {\n            // Try to split on conditions\n            params = ruris[j].split(\"!\");\n\n            // The variable segment\n            match = params[0];\n\n            // The match condition\n            cond = params[1];\n\n            // With conditions\n            if (cond) {\n              // We support this condition\n              if (rWilders[cond]) {\n                regex = rWilders[cond];\n              }\n\n              // Test against the condition\n              if (regex && regex.test(uris[j])) {\n                segMatches;\n\n                // Add the match to the config data\n                ret.params[match.replace(rWild, \"\")] = uris[j];\n                ret.uri.push(uris[j]);\n              }\n\n              // No conditions, anything goes\n            } else {\n              segMatches;\n\n              // Add the match to the config data\n              ret.params[match.replace(rWild, \"\")] = uris[j];\n              ret.uri.push(uris[j]);\n            }\n\n            // Defined segment always goes\n          } else {\n            if (uris[j] === ruris[j]) {\n              segMatches;\n              ret.uri.push(uris[j]);\n            }\n          }\n        }\n\n        // Handle a uri segment match OR \"*\" wildcard everything\n        if (segMatches === uris.length || isStar) {\n          ret.matched = true;\n          ret.route = routes[i];\n          ret.uri = isStar ? route : ret.uri.join(\"/\");\n          break;\n        }\n      }\n      return ret;\n    }\n  }, {\n    key: \"_cleanRoute\",\n    value: function _cleanRoute(route) {\n      if (route !== \"/\") {\n        route = route.replace(rHTTPs, \"\");\n        route = route.replace(rTrails, \"\");\n        route = route.replace(rHashQuery, \"\");\n        route = route.replace(rTrails, \"\");\n      }\n      if (route === \"\") {\n        route = \"/\";\n      }\n      return route;\n    }\n  }, {\n    key: \"_cleanRoutes\",\n    value: function _cleanRoutes(routes) {\n      for (var i = routes.length; i--;) {\n        routes[i] = this._cleanRoute(routes[i]);\n      }\n      return routes;\n    }\n  }]);\n  return MatchRoute;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtcGFnZWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL3Byb3BlcmpzLW1hdGNocm91dGUvTWF0Y2hSb3V0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvQztBQUlwQyxJQUFNQyxNQUFNLEdBQUcscUJBQXFCO0FBQ3BDLElBQU1DLE9BQU8sR0FBRyxVQUFVO0FBQzFCLElBQU1DLFVBQVUsR0FBRyxhQUFhO0FBQ2hDLElBQU1DLEtBQUssR0FBRyxJQUFJO0FBQ2xCLElBQU1DLFFBQVEsR0FBRztFQUNiQyxHQUFHLEVBQUUsVUFBVTtFQUNmQyxJQUFJLEVBQUU7QUFDVixDQUFDO0FBQUMsSUFJbUJDLFVBQVU7RUFDM0IsU0FBQUEsV0FBY0MsTUFBTSxFQUFHO0lBQUFDLGVBQUEsT0FBQUYsVUFBQTtJQUNuQixJQUFJLENBQUNHLE9BQU8sR0FBR0YsTUFBTSxHQUFHLElBQUksQ0FBQ0csWUFBWSxDQUFFSCxNQUFPLENBQUMsR0FBRyxFQUFFO0VBQzVEO0VBQUNJLFlBQUEsQ0FBQUwsVUFBQTtJQUFBTSxHQUFBO0lBQUFDLEtBQUEsRUFHRCxTQUFBQyxVQUFBLEVBQWE7TUFDVCxPQUFPLElBQUksQ0FBQ0wsT0FBTztJQUN2QjtFQUFDO0lBQUFHLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUFFLE9BQVNSLE1BQU0sRUFBRztNQUNkQSxNQUFNLEdBQUssT0FBT0EsTUFBTSxLQUFLLFFBQVEsR0FBSyxDQUFFQSxNQUFNLENBQUUsR0FBR0EsTUFBTTtNQUU3RCxJQUFJLENBQUNFLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sQ0FBQ08sTUFBTSxDQUFFLElBQUksQ0FBQ04sWUFBWSxDQUFFSCxNQUFPLENBQUUsQ0FBQztNQUVqRSxPQUFPLElBQUk7SUFDZjtFQUFDO0lBQUFLLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUFJLEtBQU9DLEdBQUcsRUFBRztNQUNULE9BQU8sSUFBSSxDQUFDQyxLQUFLLENBQUVELEdBQUcsRUFB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O1FBQ0o7TUFDSjtNQUVBLE9BQU9QLEdBQUc7SUFDZDtFQUFDO0lBQUF4QixHQUFBO0lBQUFDLEtBQUEsRUFHRCxTQUFBVyxZQUFjRCxLQUFLLEVBQUc7TUFDbEIsSUFBS0EsS0FBSyxLQUFLLEdBQUcsRUFBRztRQUNqQkEsS0FBSyxHQUFHQSxLQUFLLENBQUNrQixPQUFPLENBQUUxQyxNQUFNLEVBQUUsRUFBRyxDQUFDO1FBQ25Dd0IsS0FBSyxHQUFHQSxLQUFLLENBQUNrQixPQUFPLENBQUV6QyxPQUFPLEVBQUUsRUFBRyxDQUFDO1FBQ3BDdUIsS0FBSyxHQUFHQSxLQUFLLENBQUNrQixPQUFPLENBQUV4QyxVQUFVLEVBQUUsRUFBRyxDQUFDO1FBQ3ZDc0IsS0FBSyxHQUFHQSxLQUFLLENBQUNrQixPQUFPLENBQUV6QyxPQUFPLEVBQUUsRUFBRyxDQUFDO01BQ3hDO01BRUEsSUFBS3VCLEtBQUssS0FBSyxFQUFFLEVBQUc7UUFDaEJBLEtBQUssR0FBRyxHQUFHO01BQ2Y7TUFFQSxPQUFPQSxLQUFLO0lBQ2hCO0VBQUM7SUFBQVgsR0FBQTtJQUFBQyxLQUFBLEVBR0QsU0FBQUgsYUFBZUgsTUFBTSxFQUFHO01BQ3BCLEtBQU0sSUFBSThCLENBQUMsR0FBRzlCLE1BQU0sQ0FBQ3FCLE1BQU0sRUFBRVMsQ0FBQyxFQUFFLEdBQUk7UUFDaEM5QixNQUFNLENBQUU4QixDQUFDLENBQUUsR0FBRyxJQUFJLENBQUNiLFdBQVcsQ0FBRWpCLE1BQU0sQ0FBRThCLENBQUMsQ0FBRyxDQUFDO01BQ2pEO01BRUEsT0FBTzlCLE1BQU07SUFDakI7RUFBQztFQUFBLE9BQUFELFVBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1wYWdlY29udHJvbGxlci9ub2RlX21vZHVsZXMvcHJvcGVyanMtbWF0Y2hyb3V0ZS9NYXRjaFJvdXRlLmpzPzVmNzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhcmFtYWxhbWEgZnJvbSBcInBhcmFtYWxhbWFcIjtcblxuXG5cbmNvbnN0IHJIVFRQcyA9IC9eaHR0cFtzXT86XFwvXFwvLio/XFwvLztcbmNvbnN0IHJUcmFpbHMgPSAvXlxcL3xcXC8kL2c7XG5jb25zdCBySGFzaFF1ZXJ5ID0gLyMuKiR8XFw/LiokL2c7XG5jb25zdCByV2lsZCA9IC9eOi87XG5jb25zdCByV2lsZGVycyA9IHtcbiAgICBudW06IC9eWzAtOV0rJC8sXG4gICAgc2x1ZzogL15bQS1aYS16XStbQS1aYS16MC05LV8uXSokLyxcbn07XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRjaFJvdXRlIHtcbiAgICBjb25zdHJ1Y3RvciAoIHJvdXRlcyApIHtcbiAgICAgICAgdGhpcy5fcm91dGVzID0gcm91dGVzID8gdGhpcy5fY2xlYW5Sb3V0ZXMoIHJvdXRlcyApIDogW107XG4gICAgfVxuXG5cbiAgICBnZXRSb3V0ZXMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91dGVzO1xuICAgIH1cblxuXG4gICAgY29uZmlnICggcm91dGVzICkge1xuICAgICAgICByb3V0ZXMgPSAoIHR5cGVvZiByb3V0ZXMgPT09IFwic3RyaW5nXCIgKSA/IFsgcm91dGVzIF0gOiByb3V0ZXM7XG5cbiAgICAgICAgdGhpcy5fcm91dGVzID0gdGhpcy5fcm91dGVzLmNvbmNhdCggdGhpcy5fY2xlYW5Sb3V0ZXMoIHJvdXRlcyApICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICB0ZXN0ICggdXJsICkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSggdXJsLCB0aGlzLl9yb3V0ZXMgKS5tYXRjaGVkO1xuICAgIH1cblxuXG4gICAgcGFyYW1zICggdXJsICkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSggdXJsLCB0aGlzLl9yb3V0ZXMgKS5wYXJhbXM7XG4gICAgfVxuXG5cbiAgICBjb21wYXJlICggcm91dGUsIHVybCApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoIHVybCwgW3JvdXRlXSApO1xuICAgIH1cblxuXG4gICAgcGFyc2UgKCB1cmwsIHJvdXRlcyApIHtcbiAgICAgICAgY29uc3Qgcm91dGUgPSB0aGlzLl9jbGVhblJvdXRlKCB1cmwgKTtcbiAgICAgICAgY29uc3QgdXJpcyA9IHJvdXRlLnNwbGl0KCBcIi9cIiApO1xuICAgICAgICBjb25zdCB1TGVuID0gdXJpcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGlMZW4gPSByb3V0ZXMubGVuZ3RoO1xuICAgICAgICBsZXQgc2VnTWF0Y2hlcyxcbiAgICAgICAgICAgIGlzU3RhcixcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgcnVyaXMsXG4gICAgICAgICAgICByZWdleCxcbiAgICAgICAgICAgIGNvbmQsXG4gICAgICAgICAgICByZXQ7XG5cbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgaUxlbjsgaSsrICkge1xuICAgICAgICAgICAgLy8gRmxhZyBcIipcIiByb3V0ZVxuICAgICAgICAgICAgaXNTdGFyID0gKHJvdXRlc1sgaSBdID09PSBcIipcIik7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGZyZXNoIGVhY2ggaXRlcmF0aW9uXG4gICAgICAgICAgICAvLyBPbmx5IG9uZSBtYXRjaGVkIHJvdXRlIGFsbG93ZWRcbiAgICAgICAgICAgIHJldCA9IHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByb3V0ZTogbnVsbCxcbiAgICAgICAgICAgICAgICB1cmk6IFtdLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge30sXG4gICAgICAgICAgICAgICAgcXVlcnk6IHBhcmFtYWxhbWEoIHVybCApLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcnVyaXMgPSByb3V0ZXNbIGkgXS5zcGxpdCggXCIvXCIgKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHJvdXRlID09PSBcIi9cIlxuICAgICAgICAgICAgaWYgKCByb3V0ZSA9PT0gXCIvXCIgJiYgcm91dGVzWyBpIF0gPT09IFwiL1wiICkge1xuICAgICAgICAgICAgICAgIHJldC5tYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXQucm91dGUgPSByb3V0ZXNbIGkgXTtcbiAgICAgICAgICAgICAgICByZXQudXJpID0gXCIvXCI7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGFjdHVhbCB1cmwgZG9lc24ndCBtYXRjaCB0aGUgcm91dGUgaW4gc2VnbWVudCBsZW5ndGgsXG4gICAgICAgICAgICAvLyBpdCBjYW5ub3QgcG9zc2libHkgYmUgY29uc2lkZXJlZCBmb3IgbWF0Y2hpbmcgc28ganVzdCBza2lwIGl0XG4gICAgICAgICAgICBpZiAoIHJ1cmlzLmxlbmd0aCAhPT0gdXJpcy5sZW5ndGggJiYgIWlzU3RhciApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VnTWF0Y2hlcyA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIGxldCBqID0gMDsgaiA8IHVMZW47IGorKyApIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIGEgdmFyaWFibGUgdXJpIHNlZ21lbnRcbiAgICAgICAgICAgICAgICBpZiAoIHJXaWxkLnRlc3QoIHJ1cmlzWyBqIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHNwbGl0IG9uIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gcnVyaXNbIGogXS5zcGxpdCggXCIhXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdmFyaWFibGUgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHBhcmFtc1sgMCBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtYXRjaCBjb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uZCA9IHBhcmFtc1sgMSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdpdGggY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdXBwb3J0IHRoaXMgY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJXaWxkZXJzWyBjb25kIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXggPSByV2lsZGVyc1sgY29uZCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUZXN0IGFnYWluc3QgdGhlIGNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCByZWdleCAmJiByZWdleC50ZXN0KCB1cmlzWyBqIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdNYXRjaGVzKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG1hdGNoIHRvIHRoZSBjb25maWcgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wYXJhbXNbIG1hdGNoLnJlcGxhY2UoIHJXaWxkLCBcIlwiICkgXSA9IHVyaXNbIGogXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQudXJpLnB1c2goIHVyaXNbIGogXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbmRpdGlvbnMsIGFueXRoaW5nIGdvZXNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ01hdGNoZXMrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBtYXRjaCB0byB0aGUgY29uZmlnIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wYXJhbXNbIG1hdGNoLnJlcGxhY2UoIHJXaWxkLCBcIlwiICkgXSA9IHVyaXNbIGogXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC51cmkucHVzaCggdXJpc1sgaiBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERlZmluZWQgc2VnbWVudCBhbHdheXMgZ29lc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdXJpc1sgaiBdID09PSBydXJpc1sgaiBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnTWF0Y2hlcysrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQudXJpLnB1c2goIHVyaXNbIGogXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgYSB1cmkgc2VnbWVudCBtYXRjaCBPUiBcIipcIiB3aWxkY2FyZCBldmVyeXRoaW5nXG4gICAgICAgICAgICBpZiAoIHNlZ01hdGNoZXMgPT09IHVyaXMubGVuZ3RoIHx8IGlzU3RhciApIHtcbiAgICAgICAgICAgICAgICByZXQubWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0LnJvdXRlID0gcm91dGVzWyBpIF07XG4gICAgICAgICAgICAgICAgcmV0LnVyaSA9ICggaXNTdGFyICkgPyByb3V0ZSA6IHJldC51cmkuam9pbiggXCIvXCIgKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cblxuICAgIF9jbGVhblJvdXRlICggcm91dGUgKSB7XG4gICAgICAgIGlmICggcm91dGUgIT09IFwiL1wiICkge1xuICAgICAgICAgICAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKCBySFRUUHMsIFwiXCIgKTtcbiAgICAgICAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZSggclRyYWlscywgXCJcIiApO1xuICAgICAgICAgICAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKCBySGFzaFF1ZXJ5LCBcIlwiICk7XG4gICAgICAgICAgICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoIHJUcmFpbHMsIFwiXCIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcm91dGUgPT09IFwiXCIgKSB7XG4gICAgICAgICAgICByb3V0ZSA9IFwiL1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvdXRlO1xuICAgIH1cblxuXG4gICAgX2NsZWFuUm91dGVzICggcm91dGVzICkge1xuICAgICAgICBmb3IgKCBsZXQgaSA9IHJvdXRlcy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICByb3V0ZXNbIGkgXSA9IHRoaXMuX2NsZWFuUm91dGUoIHJvdXRlc1sgaSBdICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm91dGVzO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJwYXJhbWFsYW1hIiwickhUVFBzIiwiclRyYWlscyIsInJIYXNoUXVlcnkiLCJyV2lsZCIsInJXaWxkZXJzIiwibnVtIiwic2x1ZyIsIk1hdGNoUm91dGUiLCJyb3V0ZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJfcm91dGVzIiwiX2NsZWFuUm91dGVzIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJnZXRSb3V0ZXMiLCJjb25maWciLCJjb25jYXQiLCJ0ZXN0IiwidXJsIiwicGFyc2UiLCJtYXRjaGVkIiwicGFyYW1zIiwiY29tcGFyZSIsInJvdXRlIiwiX2NsZWFuUm91dGUiLCJ1cmlzIiwic3BsaXQiLCJ1TGVuIiwibGVuZ3RoIiwiaUxlbiIsInNlZ01hdGNoZXMiLCJpc1N0YXIiLCJtYXRjaCIsInJ1cmlzIiwicmVnZXgiLCJjb25kIiwicmV0IiwiaSIsInVyaSIsInF1ZXJ5IiwiaiIsInJlcGxhY2UiLCJwdXNoIiwiam9pbiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-pagecontroller/node_modules/properjs-matchroute/MatchRoute.js\n");

/***/ }),

/***/ "./node_modules/properjs-pagecontroller/node_modules/properjs-router/Router.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/properjs-pagecontroller/node_modules/properjs-router/Router.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Router)\n/* harmony export */ });\n/* harmony import */ var properjs_historia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-historia */ \"./node_modules/properjs-historia/Historia.js\");\n/* harmony import */ var properjs_matchroute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! properjs-matchroute */ \"./node_modules/properjs-pagecontroller/node_modules/properjs-matchroute/MatchRoute.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-pagecontroller/node_modules/properjs-controller/Controller.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar triggerEl;\nvar activeEl;\nvar initDelay = 200;\nvar rHTTPs = /^http[s]?:\\/\\/.*?\\//;\nvar rFiles = /\\.(jpg|jpeg|png|gif|pdf|csv|txt|md|doc|docx|xls|xlsx|webm|mp4|mp3)$/gi;\nvar rDomain = new RegExp(document.domain);\nvar Router = /*#__PURE__*/function (_Controller) {\n  _inherits(Router, _Controller);\n  var _super = _createSuper(Router);\n  function Router(options) {\n    var _this;\n    _classCallCheck(this, Router);\n    _this = _super.call(this);\n    _this._options = {\n      async: true,\n      proxy: false,\n      caching: true,\n      handle404: true,\n      handle500: true,\n      historyOptions: {}\n    };\n\n    // Normalize usage options passed in\n    options = options || {};\n\n    // Merge usage options with defaults\n    for (var i in options) {\n      _this._options[i] = options[i];\n    }\n    _this._matcher = new properjs_matchroute__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    _this._history = new properjs_historia__WEBPACK_IMPORTED_MODULE_0__[\"default\"](_this._options.historyOptions);\n    _this._callbacks = [];\n    _this._responses = {};\n    _this._ready = false;\n    _this._isRouting = false;\n    return _this;\n  }\n  _createClass(Router, [{\n    key: \"bind\",\n    value: function bind() {\n      var _this2 = this;\n      // Ensure this first cache URL is clean as a whistle\n      var url = window.location.href.replace(window.location.hash, \"\");\n\n      // Bind GET requests to links\n      document.addEventListener(\"click\", function (e) {\n        _this2._handleClick(e);\n      }, false);\n\n      // Bind popstate event for history\n      this._history.on(\"popstate\", function (url, state) {\n        _this2._handlePopstate(url, state);\n      });\n\n      // Fire first route\n      // Async this in order to allow .get() to work after instantiation\n      if (this._options.async && this._options.handle404) {\n        this._route(url, function /*response, status*/\n        () {\n          _this2._ready = true;\n        });\n\n        // Shim a little and bypass true XHR here if not handling 404s\n      } else {\n        setTimeout(function () {\n          // https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer\n          var doc = new XMLSerializer().serializeToString(document);\n          var xhr = {\n            status: 200,\n            responseText: doc\n          };\n          _this2._fire(url, xhr, xhr.status);\n          _this2._cache(url, xhr);\n          _this2._ready = true;\n        }, initDelay);\n      }\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(url) {\n      if (!triggerEl) {\n        triggerEl = document.createElement(\"a\");\n      }\n      triggerEl.href = url;\n      this._handleClick({\n        target: triggerEl\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(route, callback) {\n      // Add route to matcher\n      this._matcher.config([route]);\n\n      // Bind the route to the callback\n      if (callback._routerRoutes) {\n        callback._routerRoutes.push(route);\n      } else {\n        callback._routerRoutes = [route];\n      }\n\n      // When binding multiple routes to a single\n      // callback, we need to make sure the callbacks\n      // routes array is updated above but the callback\n      // only gets added to the list once.\n      if (callback._routerRoutes.length === 1) {\n        // this.on( \"get\", callback );\n        this._callbacks.push(callback);\n      }\n    }\n  }, {\n    key: \"getActiveEl\",\n    value: function getActiveEl() {\n      return activeEl;\n    }\n  }, {\n    key: \"getRouteForUrl\",\n    value: function getRouteForUrl(url) {\n      return this._matcher._cleanRoute(url);\n    }\n  }, {\n    key: \"getRouteDataForUrl\",\n    value: function getRouteDataForUrl(url) {\n      return this._matcher.parse(url, this._matcher.getRoutes()).params;\n    }\n  }, {\n    key: \"_preventDefault\",\n    value: function _preventDefault(e) {\n      if (e.preventDefault) {\n        e.preventDefault();\n      } else {\n        e.returnValue = false;\n      }\n    }\n  }, {\n    key: \"_handleClick\",\n    value: function _handleClick(e) {\n      var el = e.target;\n      var elem = el.matches(\"a\") ? el : el.closest(\"a\");\n      var isMatched = elem && this._matcher.test(elem.href);\n      var isDomain = elem && rDomain.test(elem.href);\n      var isProxy = elem && this._options.proxy && this._options.proxy.domain;\n      var isHashed = elem && elem.href.indexOf(\"#\") !== -1;\n      var isIgnore = elem && elem.className.indexOf(\"js-router--ignore\") !== -1;\n      var isMetaKey = elem && e.metaKey;\n      var isBlank = elem && elem.target === \"_blank\";\n      var isFile = elem && isDomain && elem.href.match(rFiles);\n\n      // 0.1 => Ensure url passes MatchRoute config\n      // 0.2 => Ensure url is on the Document's Domain\n      // 0.X => Allow proxy domain's to go through this checkpoint\n      if (isMatched && isDomain || isProxy) {\n        // 0.3 => Ensure url is not a #hash\n        // 0.4 => Ensure the element does not contain a `js-router--ignore` className\n        // 0.5 => Ensure the Event.metaKey is not TRUE - Commandclick\n        // 0.6 => Ensure the element target is not for a new tab\n        // 0.7 => Ensure url is not a file link on the same document domain\n        if (!isHashed && !isIgnore && !isMetaKey && !isBlank && !isFile) {\n          activeEl = elem;\n          this._preventDefault(e);\n          if (!this._isRouting) {\n            this._route(elem.href);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_handlePopstate\",\n    value: function _handlePopstate(url /*, state*/) {\n      // Hook around browsers firing popstate on pageload\n      if (this._ready) {\n        var dat;\n        for (var i = this._callbacks.length; i--;) {\n          dat = this._matcher.parse(url, this._callbacks[i]._routerRoutes);\n          if (dat.matched) {\n            break;\n          }\n        }\n        var data = {\n          route: this._matcher._cleanRoute(url),\n          response: this._responses[url],\n          request: dat,\n          status: this._responses[url].status\n        };\n        this.fire(\"popget\", data);\n      } else {\n        this._ready = true;\n      }\n    }\n  }, {\n    key: \"_route\",\n    value: function _route(url, callback) {\n      var _this3 = this;\n      var urls = {\n        // For XHR\n        request: url,\n        // For history and cache\n        original: url\n      };\n      this._isRouting = true;\n      this._matchUrl(urls.original);\n\n      // Handle proxy first since we modify the request URL\n      // Basically, just piece together a URL that swaps this domain with proxy domain\n      if (this._options.proxy && this._options.proxy.domain) {\n        // Use window.location.host so it includes port for localhost\n        urls.request = this._options.proxy.domain  \"/\"  urls.request.replace(rHTTPs, \"\");\n      }\n      this._getUrl(urls, function (response, status) {\n        _this3._isRouting = false;\n\n        // Push the URL to window History\n        _this3._history.push(urls.original);\n\n        // Fire event for routing\n        _this3._fire(urls.original, response, status);\n        if (typeof callback === \"function\") {\n          callback(response, status);\n        }\n      });\n    }\n  }, {\n    key: \"_matchUrl\",\n    value: function _matchUrl(url) {\n      if (!this._ready) {\n        return;\n      }\n      for (var i = this._callbacks.length; i--;) {\n        var data = this._matcher.parse(url, this._callbacks[i]._routerRoutes);\n        if (data.matched) {\n          this.fire(\"preget\", data);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"_getUrl\",\n    value: function _getUrl(urls, callback) {\n      var _this4 = this;\n      var handler = function handler(res, stat) {\n        // Cache if option enabled\n        _this4._cache(urls.original, res);\n        if (typeof callback === \"function\") {\n          callback(res, stat);\n        }\n      };\n      var xhr = null;\n\n      // Cached response ?\n      if (this._responses[urls.original]) {\n        handler(this._responses[urls.original], this._responses[urls.original].status);\n\n        // Fresh request ?\n      } else if (this._options.async) {\n        xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", urls.request, true);\n        xhr.onreadystatechange = function () {\n          if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n              handler(xhr, 200);\n            } else if (xhr.status === 404 && _this4._options.handle404) {\n              handler(xhr, 404);\n            } else if (xhr.status === 500 && _this4._options.handle500) {\n              handler(xhr, 500);\n            }\n          }\n        };\n        xhr.send();\n      } else {\n        handler({\n          responseText: \"\"\n        }, 200);\n      }\n    }\n  }, {\n    key: \"_cache\",\n    value: function _cache(url, res) {\n      // Caching is enabled, Not currently cached yet\n      if (this._options.caching && !this._responses[url]) {\n        this._responses[url] = res;\n      }\n    }\n  }, {\n    key: \"_fire\",\n    value: function _fire(url, response, status) {\n      // GET events have routes and are special ;-P\n      // This means we bypass the Controller event system for these handlers\n      for (var i = this._callbacks.length; i--;) {\n        var data = this._matcher.parse(url, this._callbacks[i]._routerRoutes);\n        if (data.matched) {\n          this._callbacks[i].call(this, {\n            route: this._matcher._cleanRoute(url),\n            response: response,\n            request: data,\n            status: status\n          });\n        }\n      }\n    }\n  }]);\n  return Router;\n}(properjs_controller__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtcGFnZWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL3Byb3BlcmpzLXJvdXRlci9Sb3V0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUM7QUFDSTtBQUNBO0FBSTdDLElBQUlHLFNBQVM7QUFDYixJQUFJQyxRQUFRO0FBQ1osSUFBTUMsU0FBUyxHQUFHLEdBQUc7QUFDckIsSUFBTUMsTUFBTSxHQUFHLHFCQUFxQjtBQUNwQyxJQUFNQyxNQUFNLEdBQUcsdUVBQXVFO0FBQ3RGLElBQU1DLE9BQU8sR0FBRyxJQUFJQyxNQUFNLENBQUVDLFFBQVEsQ0FBQ0MsTUFBTyxDQUFDO0FBQUMsSUFLekJDLE1BQU0sMEJBQUFDLFdBQUE7RUFBQUMsU0FBQSxDQUFBRixNQUFBLEVBQUFDLFdBQUE7RUFBQSxJQUFBRSxNQUFBLEdBQUFDLFlBQUEsQ0FBQUosTUFBQTtFQUN2QixTQUFBQSxPQUFjSyxPQUFPLEVBQUc7SUFBQSxJQUFBQyxLQUFBO0lBQUFDLGVBQUEsT0FBQVAsTUFBQTtJQUNwQk0sS0FBQSxHQUFBSCxNQUFBLENBQUFLLElBQUE7SUFFQUYsS0FBQSxDQUFLRyxRQUFRLEdBQUc7TUFDWkMsS0FBSyxFQUFFLElBQUk7TUFDWEMsS0FBSyxFQUFFLEtBQUs7TUFDWkMsT0FBTyxFQUFFLElBQUk7TUFDYkMsU0FBUyxFQUFFLElBQUk7TUFDZkMsU0FBUyxFQUFFLElBQUk7TUFDZkMsY0FBYyxFQUFFLENBQUM7SUFDckIsQ0FBQzs7SUFFRDtJQUNBVixPQUFPLEdBQUlBLE9BQU8sSUFBSSxDQUFDLENBQUU7O0lBRXpCO0lBQ0EsS0FBTSxJQUFJVyxDQUFDLElBQUlYLE9BQU8sRUFBRztNQUNyQkMsS0FBQSxDQUFLRyxRQUFRLENBQUVPLENBQUMsQ0FBRSxHQUFHWCxPQUFPLENBQUVXLENBQUMsQ0FBRTtJQUNyQztJQUVBVixLQUFBLENBQUtXLFFBQVEsR0FBRyxJQUFJNUIsMkRBQVUsQ0FBQyxDQUFDO0lBQ2hDaUIsS0FBQSxDQUFLWSxRQUFRLEdBQUcsSUFBSTlCLHlEQUFRLENBQUVrQixLQUFBLENBQUtHLFFBQVEsQ0FBQ00sY0FBZSxDQUFDO0lBQzVEVCxLQUFBLENBQUthLFVBQVUsR0FBRyxFQUFFO0lBQ3BCYixLQUFBLENBQUtjLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFDcEJkLEtBQUEsQ0FBS2UsTUFBTSxHQUFHLEtBQUs7SUFDbkJmLEtBQUEsQ0FBS2dCLFVBQVUsR0FBRyxLQUFLO0lBQUMsT0FBQWhCLEtBQUE7RUFDNUI7RUFBQ2lCLFlBQUEsQ0FBQXZCLE1BQUE7SUFBQXdCLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUFDLEtBQUEsRUFBUTtNQUFBLElBQUFDLE1BQUE7TUFDSjtNQUNBLElBQU1DLEdBQUcsR0FBR0MsTUFBTSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0MsT0FBTyxDQUFFSCxNQUFNLENBQUNDLFFBQVEsQ0FBQ0csSUFBSSxFQUFFLEVBQUcsQ0FBQzs7TUFFcEU7TUFDQW5DLFFBQVEsQ0FBQ29DLGdCQUFnQixDQUFFLE9BQU8sRUFBRSxVQUFFQyxDQUFDLEVBQU07UUFDekNSLE1BQUksQ0FBQ1MsWUFBWSxDQUFFRCxDQUFFLENBQUM7TUFFMUIsQ0FBQyxFQUFFLEtBQU0sQ0FBQzs7TUFFVjtNQUNBLElBQUksQ0FBQ2pCLFFBQVEsQ0FBQ21CLEVBQUUsQ0FBRSxVQUFVLEVBQUUsVUFBRVQsR0FBRyxFQUFFVSxLQUFLLEVBQU07UUFDNUNYLE1BQUksQ0FBQ1ksZUFBZSxDQUFFWCxHQUFHLEVBQUVVLEtBQU0sQ0FBQztNQUN0QyxDQUFDLENBQUM7O01BRUY7TUFDQTtNQUNBLElBQUssSUFBSSxDQUFDN0IsUUFBUSxDQUFDQyxLQUFLLElBQUksSUFBSSxDQUFDRCxRQUFRLENBQUNJLFNBQVMsRUFBRztRQUNsRCxJQUFJLENBQUMyQixNQUFNLENBQUVaLEdBQUcsRUFBRSxTQUFFO1FBQUEsR0FBMEI7VUFDMUNELE1BQUksQ0FBQ04sTUFBTSxHQUFHLElBQUk7UUFDdEIsQ0FBQyxDQUFDOztRQUVOO01BQ0EsQ0FBQyxNQUFNO1FBQ0hvQixVQUFVLENBQUMsWUFBTTtVQUNiO1VBQ0EsSUFBTUMsR0FBRyxHQUFHLElBQUlDLGFBQWEsQ0FBQyxDQUFDLENBQUNDLGlCQUFpQixDQUFFOUMsUUFBUyxDQUFDO1VBQzdELElBQU0rQyxHQUFHLEdBQUc7WUFDUkMsTUFBTSxFQUFFLEdBQUc7WUFDWEMsWUFBWSxFQUFFTDtVQUNsQixDQUFDO1VBRURmLE1BQUksQ0FBQ3FCLEtBQUssQ0FBRXBCLEdBQUcsRUFBRWlCLEdBQUcsRUFBRUEsR0FBRyxDQUFDQyxNQUFPLENBQUM7VUFDbENuQixNQUFJLENBQUNzQixNQUFNLENBQUVyQixHQUFHLEVBQUVpQixHQUFJLENBQUM7VUFDdkJsQixNQUFJLENBQUNOLE1BQU0sR0FBRyxJQUFJO1FBRXRCLENBQUMsRUFBRTVCLFNBQVUsQ0FBQztNQUNsQjtJQUNKO0VBQUM7SUFBQStCLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUF5QixRQUFVdEIsR0FBRyxFQUFHO01BQ1osSUFBSyxDQUFDckMsU0FBUyxFQUFHO1FBQ2RBLFNBQVMsR0FBR08sUUFBUSxDQUFDcUQsYUFBYSxDQUFFLEdBQUksQ0FBQztNQUM3QztNQUVBNUQsU0FBUyxDQUFDd0MsSUFBSSxHQUFHSCxHQUFHO01BRXBCLElBQUksQ0FBQ1EsWUFBWSxDQUFDO1FBQ2RnQixNQUFNLEVBQUU3RDtNQUNaLENBQUMsQ0FBQztJQUNOO0VBQUM7SUFBQWlDLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUE0QixJQUFNQyxLQUFLLEVBQUVDLFFBQVEsRUFBRztNQUNwQjtNQUNBLElBQUksQ0FBQ3RDLFFBQVEsQ0FBQ3VDLE1BQU0sQ0FBRSxDQUFDRixLQUFLLENBQUUsQ0FBQzs7TUFFL0I7TUFDQSxJQUFLQyxRQUFRLENBQUNFLGFBQWEsRUFBRztRQUMxQkYsUUFBUSxDQUFDRSxhQUFhLENBQUNDLElBQUksQ0FBRUosS0FBTSxDQUFDO01BRXhDLENBQUMsTUFBTTtRQUNIQyxRQUFRLENBQUNFLGFBQWEsR0FBRyxDQUFDSCxLQUFLLENBQUM7TUFDcEM7O01BRUE7TUFDQTtNQUNBO01BQ0E7TUFDQSxJQUFLQyxRQUFRLENBQUNFLGFBQWEsQ0FBQ0UsTUFBTSxLQUFLLENBQUMsRUFBRztRQUN2QztRQUNBLElBQUksQ0FBQ3hDLFVBQVUsQ0FBQ3VDLElBQUksQ0FBRUgsUUFBUyxDQUFDO01BQ3BDO0lBQ0o7RUFBQztJQUFBL0IsR0FBQTtJQUFBQyxLQUFBLEVBR0QsU0FBQW1DLFlBQUEsRUFBZTtNQUNYLE9BQU9wRSxRQUFRO0lBQ25CO0VBQUM7SUFBQWdDLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUFvQyxlQUFpQmpDLEdBQUcsRUFBRztNQUNuQixPQUFPLElBQUksQ0FBQ1gsUUFBUSxDQUFDNkMsV0FBVyxDQUFFbEMsR0FBSSxDQUFDO0lBQzNDO0VBQUM7SUFBQUosR0FBQTtJQUFBQyxLQUFBLEVBR0QsU0FBQXNDLG1CQUFxQm5DLEdBQUcsRUFBRztNQUN2QixPQUFPLElBQUksQ0FBQ1gsUUFBUSxDQUFDK0MsS0FBSyxDQUFFcEMsR0FBRyxFQUFFLElBQUksQ0FBQ1gsUUFBUSxDQUFDZ0QsU0FBUyxDQUFDLENBQUUsQ0FBQyxDQUFDQyxNQUFNO0lBQ3ZFO0VBQUM7SUFBQTFDLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUEwQyxnQkFBa0JoQyxDQUFDLEVBQUc7TUFDbEIsSUFBS0EsQ0FBQyxDQUFDaUMsY0FBYyxFQUFHO1FBQ3BCakMsQ0FBQyxDQUFDaUMsY0FBYyxDQUFDLENBQUM7TUFFdEIsQ0FBQyxNQUFNO1FBQ0hqQyxDQUFDLENBQUNrQyxXQUFXLEdBQUcsS0FBSztNQUN6QjtJQUNKO0VBQUM7SUFBQTdDLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUFXLGFBQWVELENBQUMsRUFBRztNQUNmLElBQU1tQyxFQUFFLEdBQUduQyxDQUFDLENBQUNpQixNQUFNO01BQ25CLElBQU1tQixJQUFJLEdBQUlELEVBQUUsQ0FBQ0UsT0FBTyxDQUFFLEdBQUksQ0FBQyxHQUFHRixFQUFFLEdBQUdBLEVBQUUsQ0FBQ0csT0FBTyxDQUFFLEdBQUksQ0FBRTtNQUN6RCxJQUFNQyxTQUFTLEdBQUdILElBQUksSUFBSSxJQUFJLENBQUN0RCxRQUFRLENBQUMwRCxJQUFJLENBQUVKLElBQUksQ0FBQ3hDLElBQUssQ0FBQztNQUN6RCxJQUFNNkMsUUFBUSxHQUFHTCxJQUFJLElBQUkzRSxPQUFPLENBQUMrRSxJQUFJLENBQUVKLElBQUksQ0FBQ3hDLElBQUssQ0FBQztNQUNsRCxJQUFNOEMsT0FBTyxHQUFHTixJQUFJLElBQUksSUFBSSxDQUFDOUQsUUFBUSxDQUFDRSxLQUFLLElBQUksSUFBSSxDQUFDRixRQUFRLENBQUNFLEtBQUssQ0FBQ1osTUFBTTtNQUN6RSxJQUFNK0UsUUFBUSxHQUFHUCxJQUFJLElBQUlBLElBQUksQ0FBQ3hDLElBQUksQ0FBQ2dELE9BQU8sQ0FBRSxHQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDeEQsSUFBTUMsUUFBUSxHQUFHVCxJQUFJLElBQUlBLElBQUksQ0FBQ1UsU0FBUyxDQUFDRixPQUFPLENBQUUsbUJBQW9CLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDN0UsSUFBTUcsU0FBUyxHQUFHWCxJQUFJLElBQUlwQyxDQUFDLENBQUNnRCxPQUFPO01BQ25DLElBQU1DLE9BQU8sR0FBR2IsSUFBSSxJQUFJQSxJQUFJLENBQUNuQixNQUFNLEtBQUssUUFBUTtNQUNoRCxJQUFNaUMsTUFBTSxHQUFHZCxJQUFJLElBQUlLLFFBQVEsSUFBSUwsSUFBSSxDQUFDeEMsSUFBSSxDQUFDdUQsS0FBSyxDQUFFM0YsTUFBTyxDQUFDOztNQUU1RDtNQUNBO01BQ0E7TUFDQSxJQUFNK0UsU0FBUyxJQUFJRSxRQUFRLElBQUtDLE9BQU8sRUFBRztRQUN0QztRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsSUFBSyxDQUFDQyxRQUFRLElBQUksQ0FBQ0UsUUFBUSxJQUFJLENBQUNFLFNBQVMsSUFBSSxDQUFDRSxPQUFPLElBQUksQ0FBQ0MsTUFBTSxFQUFHO1VBQy9EN0YsUUFBUSxHQUFHK0UsSUFBSTtVQUVmLElBQUksQ0FBQ0osZUFBZSxDQUFFaEMsQ0FBRSxDQUFDO1VBRXpCLElBQUssQ0FBQyxJQUFJLENBQUNiLFVBQVUsRUFBRztZQUNwQixJQUFJLENBQUNrQixNQUFNLENBQUUrQixJQUFJLENBQUN4QyxJQUFLLENBQUM7VUFDNUI7UUFDSjtNQUNKO0lBQ0o7RUFBQztJQUFBUCxHQUFBO0lBQUFDLEtBQUEsRUFHRCxTQUFBYyxnQkFBa0JYLEdBQUcsY0FBYztNQUMvQjtNQUNBLElBQUssSUFBSSxDQUFDUCxNQUFNLEVBQUc7UUFDZixJQUFJa0UsR0FBRztRQUVQLEtBQU0sSUFBSXZFLENBQUMsR0FBRyxJQUFJLENBQUNHLFVBQVUsQ0FBQ3dDLE1BQU0sRUFBRTNDLENBQUMsRUFBRSxHQUFJO1VBQ3pDdUUsR0FBRyxHQUFHLElBQUksQ0FBQ3RFLFFBQVEsQ0FBQytDLEtBQUssQ0FBRXBDLEdBQUcsRUFBRSxJQUFJLENBQUNULFVBQVUsQ0FBRUgsQ0FBQyxDQUFFLENBQUN5QyxhQUFjLENBQUM7VUFFcEUsSUFBSzhCLEdBQUcsQ0FBQ0MsT0FBTyxFQUFHO1lBQ2Y7VUFDSjtRQUNKO1FBRUEsSUFBTUMsSUFBSSxHQUFHO1VBQ1RuQyxLQUFLLEVBQUUsSUFBSSxDQUFDckMsUUFBUSxDQUFDNkMsV0FBVyxDQUFFbEMsR0FBSSxDQUFDO1VBQ3ZDOEQsUUFBUSxFQUFFLElBQUksQ0FBQ3RFLFVBQVUsQ0FBRVEsR0FBRyxDQUFFO1VBQ2hDK0QsT0FBTyxFQUFFSixHQUFHO1VBQ1p6QyxNQUFNLEVBQUUsSUFBSSxDQUFDMUIsVUFBVSxDQUFFUSxHQUFHLENBQUUsQ0FBQ2tCO1FBQ25DLENBQUM7UUFFRCxJQUFJLENBQUM4QyxJQUFJLENBQUUsUUFBUSxFQUFFSCxJQUFLLENBQUM7TUFFL0IsQ0FBQyxNQUFNO1FBQ0gsSUFBSSxDQUFDcEUsTUFBTSxHQUFHLElBQUk7TUFDdEI7SUFDSjtFQUFDO0lBQUFHLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUFlLE9BQVNaLEdBQUcsRUFBRTJCLFFBQVEsRUFBRztNQUFBLElBQUFzQyxNQUFBO01BQ3JCLElBQU1DLElBQUksR0FBRztRQUNUO1FBQ0FILE9BQU8sRUFBRS9ELEdBQUc7UUFFWjtRQUNBbUUsUUFBUSxFQUFFbkU7TUFDZCxDQUFDO01BRUQsSUFBSSxDQUFDTixVQUFVLEdBQUcsSUFBSTtNQUV0QixJQUFJLENBQUMwRSxTQUFTLENBQUVGLElBQUksQ0FBQ0MsUUFBUyxDQUFDOztNQUUvQjtNQUNBO01BQ0EsSUFBSyxJQUFJLENBQUN0RixRQUFRLENBQUNFLEtBQUssSUFBSSxJQUFJLENBQUNGLFFBQVEsQ0FBQ0UsS0FBSyxDQUFDWixNQUFNLEVBQUc7UUFDckQ7UUFDQStGLElBQUksQ0FBQ0gsT0FBTyxHQUFJLElBQUksQ0FBQ2xGLFFBQVEsQ0FBQ0UsS0FBSyxDQUFDWixNQUFNLEdBQUcsR0FBRyxHQUFHK0YsSUFBSSxDQUFDSCxPQUFPLENBQUMzRCxPQUFPLENBQUV0QyxNQUFNLEVBQUUsRUFBRyxDQUFFO01BQzFGO01BRUEsSUFBSSxDQUFDdUcsT0FBTyxDQUFFSCxJQUFJLEVBQUUsVUFBRUosUUFBUSxFQUFFNUMsTUFBTSxFQUFNO1FBQ3hDK0MsTUFBSSxDQUFDdkUsVUFBVSxHQUFHLEtBQUs7O1FBRXZCO1FBQ0F1RSxNQUFJLENBQUMzRSxRQUFRLENBQUN3QyxJQUFJLENBQUVvQyxJQUFJLENBQUNDLFFBQVMsQ0FBQzs7UUFFbkM7UUFDQUYsTUFBSSxDQUFDN0MsS0FBSyxDQUFFOEMsSUFBSSxDQUFDQyxRQUFRLEVBQUVMLFFBQVEsRUFBRTVDLE1BQU8sQ0FBQztRQUU3QyxJQUFLLE9BQU9TLFFBQVEsS0FBSyxVQUFVLEVBQUc7VUFDbENBLFFBQVEsQ0FBRW1DLFFBQVEsRUFBRTVDLE1BQU8sQ0FBQztRQUNoQztNQUNKLENBQUMsQ0FBQztJQUNOO0VBQUM7SUFBQXRCLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUF1RSxVQUFZcEUsR0FBRyxFQUFHO01BQ2QsSUFBSyxDQUFDLElBQUksQ0FBQ1AsTUFBTSxFQUFHO1FBQ2hCO01BQ0o7TUFFQSxLQUFNLElBQUlMLENBQUMsR0FBRyxJQUFJLENBQUNHLFVBQVUsQ0FBQ3dDLE1BQU0sRUFBRTNDLENBQUMsRUFBRSxHQUFJO1FBQ3pDLElBQU15RSxJQUFJLEdBQUcsSUFBSSxDQUFDeEUsUUFBUSxDQUFDK0MsS0FBSyxDQUFFcEMsR0FBRyxFQUFFLElBQUksQ0FBQ1QsVUFBVSxDQUFFSCxDQUFDLENBQUUsQ0FBQ3lDLGFBQWMsQ0FBQztRQUUzRSxJQUFLZ0MsSUFBSSxDQUFDRCxPQUFPLEVBQUc7VUFDaEIsSUFBSSxDQUFDSSxJQUFJLENBQUUsUUFBUSxFQUFFSCxJQUFLLENBQUM7VUFDM0I7UUFDSjtNQUNKO0lBQ0o7RUFBQztJQUFBakUsR0FBQTtJQUFBQyxLQUFBLEVBR0QsU0FBQXdFLFFBQVVILElBQUksRUFBRXZDLFFBQVEsRUFBRztNQUFBLElBQUEyQyxNQUFBO01BQ3ZCLElBQU1DLE9BQU8sR0FBRyxTQUFWQSxPQUFPQSxDQUFLQyxHQUFHLEVBQUVDLElBQUksRUFBTTtRQUM3QjtRQUNBSCxNQUFJLENBQUNqRCxNQUFNLENBQUU2QyxJQUFJLENBQUNDLFFBQVEsRUFBRUssR0FBSSxDQUFDO1FBRWpDLElBQUssT0FBTzdDLFFBQVEsS0FBSyxVQUFVLEVBQUc7VUFDbENBLFFBQVEsQ0FBRTZDLEdBQUcsRUFBRUMsSUFBSyxDQUFDO1FBQ3pCO01BQ0osQ0FBQztNQUNELElBQUl4RCxHQUFHLEdBQUcsSUFBSTs7TUFFZDtNQUNBLElBQUssSUFBSSxDQUFDekIsVUFBVSxDQUFFMEUsSUFBSSxDQUFDQyxRQUFRLENBQUUsRUFBRztRQUNwQ0ksT0FBTyxDQUFFLElBQUksQ0FBQy9FLFVBQVUsQ0FBRTBFLElBQUksQ0FBQ0MsUUFBUSxDQUFFLEVBQUUsSUFBSSxDQUFDM0UsVUFBVSxDQUFFMEUsSUFBSSxDQUFDQyxRQUFRLENBQUUsQ0FBQ2pELE1BQU8sQ0FBQzs7UUFFeEY7TUFDQSxDQUFDLE1BQU0sSUFBSyxJQUFJLENBQUNyQyxRQUFRLENBQUNDLEtBQUssRUFBRztRQUM5Qm1DLEdBQUcsR0FBRyxJQUFJeUQsY0FBYyxDQUFDLENBQUM7UUFFMUJ6RCxHQUFHLENBQUMwRCxJQUFJLENBQUUsS0FBSyxFQUFFVCxJQUFJLENBQUNILE9BQU8sRUFBRSxJQUFLLENBQUM7UUFFckM5QyxHQUFHLENBQUMyRCxrQkFBa0IsR0FBRyxZQUFNO1VBQzNCLElBQUszRCxHQUFHLENBQUM0RCxVQUFVLEtBQUssQ0FBQyxFQUFHO1lBQ3hCLElBQUs1RCxHQUFHLENBQUNDLE1BQU0sS0FBSyxHQUFHLEVBQUc7Y0FDdEJxRCxPQUFPLENBQUV0RCxHQUFHLEVBQUUsR0FBSSxDQUFDO1lBRXZCLENBQUMsTUFBTSxJQUFLQSxHQUFHLENBQUNDLE1BQU0sS0FBSyxHQUFHLElBQUlvRCxNQUFJLENBQUN6RixRQUFRLENBQUNJLFNBQVMsRUFBRztjQUN4RHNGLE9BQU8sQ0FBRXRELEdBQUcsRUFBRSxHQUFJLENBQUM7WUFFdkIsQ0FBQyxNQUFNLElBQUtBLEdBQUcsQ0FBQ0MsTUFBTSxLQUFLLEdBQUcsSUFBSW9ELE1BQUksQ0FBQ3pGLFFBQVEsQ0FBQ0ssU0FBUyxFQUFHO2NBQ3hEcUYsT0FBTyxDQUFFdEQsR0FBRyxFQUFFLEdBQUksQ0FBQztZQUN2QjtVQUNKO1FBQ0osQ0FBQztRQUVEQSxHQUFHLENBQUM2RCxJQUFJLENBQUMsQ0FBQztNQUVkLENBQUMsTUFBTTtRQUNIUCxPQUFPLENBQUU7VUFBRXBELFlBQVksRUFBRTtRQUFHLENBQUMsRUFBRSxHQUFJLENBQUM7TUFDeEM7SUFDSjtFQUFDO0lBQUF2QixHQUFBO0lBQUFDLEtBQUEsRUFHRCxTQUFBd0IsT0FBU3JCLEdBQUcsRUFBRXdFLEdBQUcsRUFBRztNQUNoQjtNQUNBLElBQUssSUFBSSxDQUFDM0YsUUFBUSxDQUFDRyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUNRLFVBQVUsQ0FBRVEsR0FBRyxDQUFFLEVBQUc7UUFDcEQsSUFBSSxDQUFDUixVQUFVLENBQUVRLEdBQUcsQ0FBRSxHQUFHd0UsR0FBRztNQUNoQztJQUNKO0VBQUM7SUFBQTVFLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUF1QixNQUFRcEIsR0FBRyxFQUFFOEQsUUFBUSxFQUFFNUMsTUFBTSxFQUFHO01BQzVCO01BQ0E7TUFDQSxLQUFNLElBQUk5QixDQUFDLEdBQUcsSUFBSSxDQUFDRyxVQUFVLENBQUN3QyxNQUFNLEVBQUUzQyxDQUFDLEVBQUUsR0FBSTtRQUN6QyxJQUFNeUUsSUFBSSxHQUFHLElBQUksQ0FBQ3hFLFFBQVEsQ0FBQytDLEtBQUssQ0FBRXBDLEdBQUcsRUFBRSxJQUFJLENBQUNULFVBQVUsQ0FBRUgsQ0FBQyxDQUFFLENBQUN5QyxhQUFjLENBQUM7UUFFM0UsSUFBS2dDLElBQUksQ0FBQ0QsT0FBTyxFQUFHO1VBQ2hCLElBQUksQ0FBQ3JFLFVBQVUsQ0FBRUgsQ0FBQyxDQUFFLENBQUNSLElBQUksQ0FBRSxJQUFJLEVBQUU7WUFDN0I4QyxLQUFLLEVBQUUsSUFBSSxDQUFDckMsUUFBUSxDQUFDNkMsV0FBVyxDQUFFbEMsR0FBSSxDQUFDO1lBQ3ZDOEQsUUFBUSxFQUFFQSxRQUFRO1lBQ2xCQyxPQUFPLEVBQUVGLElBQUk7WUFDYjNDLE1BQU0sRUFBRUE7VUFDWixDQUFDLENBQUM7UUFDTjtNQUNKO0lBQ0o7RUFBQztFQUFBLE9BQUE5QyxNQUFBO0FBQUEsRUF4VCtCViwyREFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1wYWdlY29udHJvbGxlci9ub2RlX21vZHVsZXMvcHJvcGVyanMtcm91dGVyL1JvdXRlci5qcz8yNzI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIaXN0b3JpYSBmcm9tIFwicHJvcGVyanMtaGlzdG9yaWFcIjtcbmltcG9ydCBNYXRjaFJvdXRlIGZyb20gXCJwcm9wZXJqcy1tYXRjaHJvdXRlXCI7XG5pbXBvcnQgQ29udHJvbGxlciBmcm9tIFwicHJvcGVyanMtY29udHJvbGxlclwiO1xuXG5cblxubGV0IHRyaWdnZXJFbDtcbmxldCBhY3RpdmVFbDtcbmNvbnN0IGluaXREZWxheSA9IDIwMDtcbmNvbnN0IHJIVFRQcyA9IC9eaHR0cFtzXT86XFwvXFwvLio/XFwvLztcbmNvbnN0IHJGaWxlcyA9IC9cXC4oanBnfGpwZWd8cG5nfGdpZnxwZGZ8Y3N2fHR4dHxtZHxkb2N8ZG9jeHx4bHN8eGxzeHx3ZWJtfG1wNHxtcDMpJC9naTtcbmNvbnN0IHJEb21haW4gPSBuZXcgUmVnRXhwKCBkb2N1bWVudC5kb21haW4gKTtcblxuXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IgKCBvcHRpb25zICkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIHByb3h5OiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hpbmc6IHRydWUsXG4gICAgICAgICAgICBoYW5kbGU0MDQ6IHRydWUsXG4gICAgICAgICAgICBoYW5kbGU1MDA6IHRydWUsXG4gICAgICAgICAgICBoaXN0b3J5T3B0aW9uczoge31cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdXNhZ2Ugb3B0aW9ucyBwYXNzZWQgaW5cbiAgICAgICAgb3B0aW9ucyA9IChvcHRpb25zIHx8IHt9KTtcblxuICAgICAgICAvLyBNZXJnZSB1c2FnZSBvcHRpb25zIHdpdGggZGVmYXVsdHNcbiAgICAgICAgZm9yICggbGV0IGkgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnNbIGkgXSA9IG9wdGlvbnNbIGkgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hdGNoZXIgPSBuZXcgTWF0Y2hSb3V0ZSgpO1xuICAgICAgICB0aGlzLl9oaXN0b3J5ID0gbmV3IEhpc3RvcmlhKCB0aGlzLl9vcHRpb25zLmhpc3RvcnlPcHRpb25zICk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLl9yZXNwb25zZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNSb3V0aW5nID0gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBiaW5kICgpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoaXMgZmlyc3QgY2FjaGUgVVJMIGlzIGNsZWFuIGFzIGEgd2hpc3RsZVxuICAgICAgICBjb25zdCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5yZXBsYWNlKCB3aW5kb3cubG9jYXRpb24uaGFzaCwgXCJcIiApO1xuXG4gICAgICAgIC8vIEJpbmQgR0VUIHJlcXVlc3RzIHRvIGxpbmtzXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiY2xpY2tcIiwgKCBlICkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2xpY2soIGUgKTtcblxuICAgICAgICB9LCBmYWxzZSApO1xuXG4gICAgICAgIC8vIEJpbmQgcG9wc3RhdGUgZXZlbnQgZm9yIGhpc3RvcnlcbiAgICAgICAgdGhpcy5faGlzdG9yeS5vbiggXCJwb3BzdGF0ZVwiLCAoIHVybCwgc3RhdGUgKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVQb3BzdGF0ZSggdXJsLCBzdGF0ZSApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaXJlIGZpcnN0IHJvdXRlXG4gICAgICAgIC8vIEFzeW5jIHRoaXMgaW4gb3JkZXIgdG8gYWxsb3cgLmdldCgpIHRvIHdvcmsgYWZ0ZXIgaW5zdGFudGlhdGlvblxuICAgICAgICBpZiAoIHRoaXMuX29wdGlvbnMuYXN5bmMgJiYgdGhpcy5fb3B0aW9ucy5oYW5kbGU0MDQgKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3V0ZSggdXJsLCAoIC8qcmVzcG9uc2UsIHN0YXR1cyovICkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNoaW0gYSBsaXR0bGUgYW5kIGJ5cGFzcyB0cnVlIFhIUiBoZXJlIGlmIG5vdCBoYW5kbGluZyA0MDRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0IHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MU2VyaWFsaXplclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoIGRvY3VtZW50ICk7XG4gICAgICAgICAgICAgICAgY29uc3QgeGhyID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0OiBkb2MsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoIHVybCwgeGhyLCB4aHIuc3RhdHVzICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUoIHVybCwgeGhyICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZHkgPSB0cnVlO1xuXG4gICAgICAgICAgICB9LCBpbml0RGVsYXkgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgdHJpZ2dlciAoIHVybCApIHtcbiAgICAgICAgaWYgKCAhdHJpZ2dlckVsICkge1xuICAgICAgICAgICAgdHJpZ2dlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyaWdnZXJFbC5ocmVmID0gdXJsO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZUNsaWNrKHtcbiAgICAgICAgICAgIHRhcmdldDogdHJpZ2dlckVsLFxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGdldCAoIHJvdXRlLCBjYWxsYmFjayApIHtcbiAgICAgICAgLy8gQWRkIHJvdXRlIHRvIG1hdGNoZXJcbiAgICAgICAgdGhpcy5fbWF0Y2hlci5jb25maWcoIFtyb3V0ZV0gKTtcblxuICAgICAgICAvLyBCaW5kIHRoZSByb3V0ZSB0byB0aGUgY2FsbGJhY2tcbiAgICAgICAgaWYgKCBjYWxsYmFjay5fcm91dGVyUm91dGVzICkge1xuICAgICAgICAgICAgY2FsbGJhY2suX3JvdXRlclJvdXRlcy5wdXNoKCByb3V0ZSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjay5fcm91dGVyUm91dGVzID0gW3JvdXRlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gYmluZGluZyBtdWx0aXBsZSByb3V0ZXMgdG8gYSBzaW5nbGVcbiAgICAgICAgLy8gY2FsbGJhY2ssIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBjYWxsYmFja3NcbiAgICAgICAgLy8gcm91dGVzIGFycmF5IGlzIHVwZGF0ZWQgYWJvdmUgYnV0IHRoZSBjYWxsYmFja1xuICAgICAgICAvLyBvbmx5IGdldHMgYWRkZWQgdG8gdGhlIGxpc3Qgb25jZS5cbiAgICAgICAgaWYgKCBjYWxsYmFjay5fcm91dGVyUm91dGVzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgIC8vIHRoaXMub24oIFwiZ2V0XCIsIGNhbGxiYWNrICk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaCggY2FsbGJhY2sgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZ2V0QWN0aXZlRWwgKCkge1xuICAgICAgICByZXR1cm4gYWN0aXZlRWw7XG4gICAgfVxuXG5cbiAgICBnZXRSb3V0ZUZvclVybCAoIHVybCApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoZXIuX2NsZWFuUm91dGUoIHVybCApO1xuICAgIH1cblxuXG4gICAgZ2V0Um91dGVEYXRhRm9yVXJsICggdXJsICkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0Y2hlci5wYXJzZSggdXJsLCB0aGlzLl9tYXRjaGVyLmdldFJvdXRlcygpICkucGFyYW1zO1xuICAgIH1cblxuXG4gICAgX3ByZXZlbnREZWZhdWx0ICggZSApIHtcbiAgICAgICAgaWYgKCBlLnByZXZlbnREZWZhdWx0ICkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9oYW5kbGVDbGljayAoIGUgKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZS50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGVsZW0gPSAoZWwubWF0Y2hlcyggXCJhXCIgKSA/IGVsIDogZWwuY2xvc2VzdCggXCJhXCIgKSk7XG4gICAgICAgIGNvbnN0IGlzTWF0Y2hlZCA9IGVsZW0gJiYgdGhpcy5fbWF0Y2hlci50ZXN0KCBlbGVtLmhyZWYgKTtcbiAgICAgICAgY29uc3QgaXNEb21haW4gPSBlbGVtICYmIHJEb21haW4udGVzdCggZWxlbS5ocmVmICk7XG4gICAgICAgIGNvbnN0IGlzUHJveHkgPSBlbGVtICYmIHRoaXMuX29wdGlvbnMucHJveHkgJiYgdGhpcy5fb3B0aW9ucy5wcm94eS5kb21haW47XG4gICAgICAgIGNvbnN0IGlzSGFzaGVkID0gZWxlbSAmJiBlbGVtLmhyZWYuaW5kZXhPZiggXCIjXCIgKSAhPT0gLTE7XG4gICAgICAgIGNvbnN0IGlzSWdub3JlID0gZWxlbSAmJiBlbGVtLmNsYXNzTmFtZS5pbmRleE9mKCBcImpzLXJvdXRlci0taWdub3JlXCIgKSAhPT0gLTE7XG4gICAgICAgIGNvbnN0IGlzTWV0YUtleSA9IGVsZW0gJiYgZS5tZXRhS2V5O1xuICAgICAgICBjb25zdCBpc0JsYW5rID0gZWxlbSAmJiBlbGVtLnRhcmdldCA9PT0gXCJfYmxhbmtcIjtcbiAgICAgICAgY29uc3QgaXNGaWxlID0gZWxlbSAmJiBpc0RvbWFpbiAmJiBlbGVtLmhyZWYubWF0Y2goIHJGaWxlcyApO1xuXG4gICAgICAgIC8vIDAuMSA9PiBFbnN1cmUgdXJsIHBhc3NlcyBNYXRjaFJvdXRlIGNvbmZpZ1xuICAgICAgICAvLyAwLjIgPT4gRW5zdXJlIHVybCBpcyBvbiB0aGUgRG9jdW1lbnQncyBEb21haW5cbiAgICAgICAgLy8gMC5YID0IEFsbG93IHByb3h5IGRvbWFpbidzIHRvIGdvIHRocm91Z2ggdGhpcyBjaGVja3BvaW50XG4gICAgICAgIGlmICggKGlzTWF0Y2hlZCAmJiBpc0RvbWFpbikgfHwgaXNQcm94eSApIHtcbiAgICAgICAgICAgIC8vIDAuMyA9PiBFbnN1cmUgdXJsIGlzIG5vdCBhICNoYXNoXG4gICAgICAgICAgICAvLyAwLjQgPT4gRW5zdXJlIHRoZSBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gYSBganMtcm91dGVyLS1pZ25vcmVgIGNsYXNzTmFtZVxuICAgICAgICAgICAgLy8gMC41ID0IEVuc3VyZSB0aGUgRXZlbnQubWV0YUtleSBpcyBub3QgVFJVRSAtIENvbW1hbmQrY2xpY2tcbiAgICAgICAgICAgIC8vIDAuNiA9PiBFbnN1cmUgdGhlIGVsZW1lbnQgdGFyZ2V0IGlzIG5vdCBmb3IgYSBuZXcgdGFiXG4gICAgICAgICAgICAvLyAwLjcgPT4gRW5zdXJlIHVybCBpcyBub3QgYSBmaWxlIGxpbmsgb24gdGhlIHNhbWUgZG9jdW1lbnQgZG9tYWluXG4gICAgICAgICAgICBpZiAoICFpc0hhc2hlZCAmJiAhaXNJZ25vcmUgJiYgIWlzTWV0YUtleSAmJiAhaXNCbGFuayAmJiAhaXNGaWxlICkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUVsID0gZWxlbTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0KCBlICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICF0aGlzLl9pc1JvdXRpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRlKCBlbGVtLmhyZWYgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9oYW5kbGVQb3BzdGF0ZSAoIHVybC8qLCBzdGF0ZSovICkge1xuICAgICAgICAvLyBIb29rIGFyb3VuZCBicm93c2VycyBmaXJpbmcgcG9wc3RhdGUgb24gcGFnZWxvYWRcbiAgICAgICAgaWYgKCB0aGlzLl9yZWFkeSApIHtcbiAgICAgICAgICAgIGxldCBkYXQ7XG5cbiAgICAgICAgICAgIGZvciAoIGxldCBpID0gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgICAgICBkYXQgPSB0aGlzLl9tYXRjaGVyLnBhcnNlKCB1cmwsIHRoaXMuX2NhbGxiYWNrc1sgaSBdLl9yb3V0ZXJSb3V0ZXMgKTtcblxuICAgICAgICAgICAgICAgIGlmICggZGF0Lm1hdGNoZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5fbWF0Y2hlci5fY2xlYW5Sb3V0ZSggdXJsICksXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHRoaXMuX3Jlc3BvbnNlc1sgdXJsIF0sXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZGF0LFxuICAgICAgICAgICAgICAgIHN0YXR1czogdGhpcy5fcmVzcG9uc2VzWyB1cmwgXS5zdGF0dXMsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoIFwicG9wZ2V0XCIsIGRhdGEgKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBfcm91dGUgKCB1cmwsIGNhbGxiYWNrICkge1xuICAgICAgICBjb25zdCB1cmxzID0ge1xuICAgICAgICAgICAgLy8gRm9yIFhIUlxuICAgICAgICAgICAgcmVxdWVzdDogdXJsLFxuXG4gICAgICAgICAgICAvLyBGb3IgaGlzdG9yeSBhbmQgY2FjaGVcbiAgICAgICAgICAgIG9yaWdpbmFsOiB1cmwsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faXNSb3V0aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9tYXRjaFVybCggdXJscy5vcmlnaW5hbCApO1xuXG4gICAgICAgIC8vIEhhbmRsZSBwcm94eSBmaXJzdCBzaW5jZSB3ZSBtb2RpZnkgdGhlIHJlcXVlc3QgVVJMXG4gICAgICAgIC8vIEJhc2ljYWxseSwganVzdCBwaWVjZSB0b2dldGhlciBhIFVSTCB0aGF0IHN3YXBzIHRoaXMgZG9tYWluIHdpdGggcHJveHkgZG9tYWluXG4gICAgICAgIGlmICggdGhpcy5fb3B0aW9ucy5wcm94eSAmJiB0aGlzLl9vcHRpb25zLnByb3h5LmRvbWFpbiApIHtcbiAgICAgICAgICAgIC8vIFVzZSB3aW5kb3cubG9jYXRpb24uaG9zdCBzbyBpdCBpbmNsdWRlcyBwb3J0IGZvciBsb2NhbGhvc3RcbiAgICAgICAgICAgIHVybHMucmVxdWVzdCA9ICh0aGlzLl9vcHRpb25zLnByb3h5LmRvbWFpbiArIFwiL1wiICsgdXJscy5yZXF1ZXN0LnJlcGxhY2UoIHJIVFRQcywgXCJcIiApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2dldFVybCggdXJscywgKCByZXNwb25zZSwgc3RhdHVzICkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faXNSb3V0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIFB1c2ggdGhlIFVSTCB0byB3aW5kb3cgSGlzdG9yeVxuICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoKCB1cmxzLm9yaWdpbmFsICk7XG5cbiAgICAgICAgICAgIC8vIEZpcmUgZXZlbnQgZm9yIHJvdXRpbmdcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoIHVybHMub3JpZ2luYWwsIHJlc3BvbnNlLCBzdGF0dXMgKTtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayggcmVzcG9uc2UsIHN0YXR1cyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIF9tYXRjaFVybCAoIHVybCApIHtcbiAgICAgICAgaWYgKCAhdGhpcy5fcmVhZHkgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCBsZXQgaSA9IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fbWF0Y2hlci5wYXJzZSggdXJsLCB0aGlzLl9jYWxsYmFja3NbIGkgXS5fcm91dGVyUm91dGVzICk7XG5cbiAgICAgICAgICAgIGlmICggZGF0YS5tYXRjaGVkICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSggXCJwcmVnZXRcIiwgZGF0YSApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBfZ2V0VXJsICggdXJscywgY2FsbGJhY2sgKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoIHJlcywgc3RhdCApID0IHtcbiAgICAgICAgICAgIC8vIENhY2hlIGlmIG9wdGlvbiBlbmFibGVkXG4gICAgICAgICAgICB0aGlzLl9jYWNoZSggdXJscy5vcmlnaW5hbCwgcmVzICk7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soIHJlcywgc3RhdCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgeGhyID0gbnVsbDtcblxuICAgICAgICAvLyBDYWNoZWQgcmVzcG9uc2UgP1xuICAgICAgICBpZiAoIHRoaXMuX3Jlc3BvbnNlc1sgdXJscy5vcmlnaW5hbCBdICkge1xuICAgICAgICAgICAgaGFuZGxlciggdGhpcy5fcmVzcG9uc2VzWyB1cmxzLm9yaWdpbmFsIF0sIHRoaXMuX3Jlc3BvbnNlc1sgdXJscy5vcmlnaW5hbCBdLnN0YXR1cyApO1xuXG4gICAgICAgIC8vIEZyZXNoIHJlcXVlc3QgP1xuICAgICAgICB9IGVsc2UgaWYgKCB0aGlzLl9vcHRpb25zLmFzeW5jICkge1xuICAgICAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICAgIHhoci5vcGVuKCBcIkdFVFwiLCB1cmxzLnJlcXVlc3QsIHRydWUgKTtcblxuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0IHtcbiAgICAgICAgICAgICAgICBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHhoci5zdGF0dXMgPT09IDIwMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoIHhociwgMjAwICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggeGhyLnN0YXR1cyA9PT0gNDA0ICYmIHRoaXMuX29wdGlvbnMuaGFuZGxlNDA0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlciggeGhyLCA0MDQgKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB4aHIuc3RhdHVzID09PSA1MDAgJiYgdGhpcy5fb3B0aW9ucy5oYW5kbGU1MDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKCB4aHIsIDUwMCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlciggeyByZXNwb25zZVRleHQ6IFwiXCIgfSwgMjAwICk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9jYWNoZSAoIHVybCwgcmVzICkge1xuICAgICAgICAvLyBDYWNoaW5nIGlzIGVuYWJsZWQsIE5vdCBjdXJyZW50bHkgY2FjaGVkIHlldFxuICAgICAgICBpZiAoIHRoaXMuX29wdGlvbnMuY2FjaGluZyAmJiAhdGhpcy5fcmVzcG9uc2VzWyB1cmwgXSApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlc1sgdXJsIF0gPSByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9maXJlICggdXJsLCByZXNwb25zZSwgc3RhdHVzICkge1xuICAgICAgICAvLyBHRVQgZXZlbnRzIGhhdmUgcm91dGVzIGFuZCBhcmUgc3BlY2lhbCA7LVBcbiAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSBieXBhc3MgdGhlIENvbnRyb2xsZXIgZXZlbnQgc3lzdGVtIGZvciB0aGVzZSBoYW5kbGVyc1xuICAgICAgICBmb3IgKCBsZXQgaSA9IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fbWF0Y2hlci5wYXJzZSggdXJsLCB0aGlzLl9jYWxsYmFja3NbIGkgXS5fcm91dGVyUm91dGVzICk7XG5cbiAgICAgICAgICAgIGlmICggZGF0YS5tYXRjaGVkICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1sgaSBdLmNhbGwoIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGU6IHRoaXMuX21hdGNoZXIuX2NsZWFuUm91dGUoIHVybCApLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkhpc3RvcmlhIiwiTWF0Y2hSb3V0ZSIsIkNvbnRyb2xsZXIiLCJ0cmlnZ2VyRWwiLCJhY3RpdmVFbCIsImluaXREZWxheSIsInJIVFRQcyIsInJGaWxlcyIsInJEb21haW4iLCJSZWdFeHAiLCJkb2N1bWVudCIsImRvbWFpbiIsIlJvdXRlciIsIl9Db250cm9sbGVyIiwiX2luaGVyaXRzIiwiX3N1cGVyIiwiX2NyZWF0ZVN1cGVyIiwib3B0aW9ucyIsIl90aGlzIiwiX2NsYXNzQ2FsbENoZWNrIiwiY2FsbCIsIl9vcHRpb25zIiwiYXN5bmMiLCJwcm94eSIsImNhY2hpbmciLCJoYW5kbGU0MDQiLCJoYW5kbGU1MDAiLCJoaXN0b3J5T3B0aW9ucyIsImkiLCJfbWF0Y2hlciIsIl9oaXN0b3J5IiwiX2NhbGxiYWNrcyIsIl9yZXNwb25zZXMiLCJfcmVhZHkiLCJfaXNSb3V0aW5nIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJiaW5kIiwiX3RoaXMyIiwidXJsIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwicmVwbGFjZSIsImhhc2giLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsIl9oYW5kbGVDbGljayIsIm9uIiwic3RhdGUiLCJfaGFuZGxlUG9wc3RhdGUiLCJfcm91dGUiLCJzZXRUaW1lb3V0IiwiZG9jIiwiWE1MU2VyaWFsaXplciIsInNlcmlhbGl6ZVRvU3RyaW5nIiwieGhyIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0IiwiX2ZpcmUiLCJfY2FjaGUiLCJ0cmlnZ2VyIiwiY3JlYXRlRWxlbWVudCIsInRhcmdldCIsImdldCIsInJvdXRlIiwiY2FsbGJhY2siLCJjb25maWciLCJfcm91dGVyUm91dGVzIiwicHVzaCIsImxlbmd0aCIsImdldEFjdGl2ZUVsIiwiZ2V0Um91dGVGb3JVcmwiLCJfY2xlYW5Sb3V0ZSIsImdldFJvdXRlRGF0YUZvclVybCIsInBhcnNlIiwiZ2V0Um91dGVzIiwicGFyYW1zIiwiX3ByZXZlbnREZWZhdWx0IiwicHJldmVudERlZmF1bHQiLCJyZXR1cm5WYWx1ZSIsImVsIiwiZWxlbSIsIm1hdGNoZXMiLCJjbG9zZXN0IiwiaXNNYXRjaGVkIiwidGVzdCIsImlzRG9tYWluIiwiaXNQcm94eSIsImlzSGFzaGVkIiwiaW5kZXhPZiIsImlzSWdub3JlIiwiY2xhc3NOYW1lIiwiaXNNZXRhS2V5IiwibWV0YUtleSIsImlzQmxhbmsiLCJpc0ZpbGUiLCJtYXRjaCIsImRhdCIsIm1hdGNoZWQiLCJkYXRhIiwicmVzcG9uc2UiLCJyZXF1ZXN0IiwiZmlyZSIsIl90aGlzMyIsInVybHMiLCJvcmlnaW5hbCIsIl9tYXRjaFVybCIsIl9nZXRVcmwiLCJfdGhpczQiLCJoYW5kbGVyIiwicmVzIiwic3RhdCIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzZW5kIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/properjs-pagecontroller/node_modules/properjs-router/Router.js\n");

/***/ }),

/***/ "./node_modules/properjs-resizecontroller/ResizeController.js":
/*!********************************************************************!*\
  !*** ./node_modules/properjs-resizecontroller/ResizeController.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n *\n * Window resize / orientationchange event controller\n *\n * @ResizeController\n * @author: kitajchuk\n *\n *\n */\n(function (factory) {\n  if (( false ? 0 : _typeof(exports)) === \"object\" && \"object\" !== \"undefined\") {\n    module.exports = factory();\n  } else if (typeof window !== \"undefined\") {\n    window.ResizeController = factory();\n  }\n})(function () {\n  var Controller = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-controller/Controller.js\");\n\n  /**\n   *\n   * Window resize / orientationchange event controller\n   * @constructor ResizeController\n   * @augments Controller\n   * @requires Controller\n   * @memberof! <global>\n   *\n   * @fires resize\n   * @fires resizedown\n   * @fires resizeup\n   * @fires resizewidth\n   * @fires resizeheight\n   * @fires orientationchange\n   * @fires orientationportrait\n   * @fires orientationlandscape\n   *\n   */\n  var ResizeController = function ResizeController() {\n    Controller.call(this);\n    this.currentView = this.getViewport();\n    this.hasOrientation = \"orientation\" in window;\n    this.start();\n  };\n  ResizeController.prototype = Object.create(Controller.prototype);\n\n  /**\n   *\n   * Starts the request animation frame cycle\n   * @memberof ResizeController\n   * @method destroy\n   *\n   */\n  ResizeController.prototype.start = function () {\n    var self = this;\n\n    // Call on parent cycle\n    this.go(function () {\n      var currentView = self.getViewport(),\n        isStill = currentView.width === self.currentView.width && currentView.height === self.currentView.height,\n        isResize = currentView.width !== self.currentView.width || currentView.height !== self.currentView.height,\n        isResizeUp = currentView.width > self.currentView.width || currentView.height > self.currentView.height,\n        isResizeDown = currentView.width < self.currentView.width || currentView.height < self.currentView.height,\n        isResizeWidth = currentView.width !== self.currentView.width,\n        isResizeHeight = currentView.height !== self.currentView.height,\n        isOrientation = currentView.orient !== self.currentView.orient,\n        isOrientationPortrait = currentView.orient !== self.currentView.orient && currentView.orient !== 90,\n        isOrientationLandscape = currentView.orient !== self.currentView.orient && currentView.orient === 90;\n\n      // Fire blanket resize event\n      if (isResize) {\n        /**\n         *\n         * @event resize\n         *\n         */\n        self.fire(\"resize\");\n      }\n\n      // Fire resizeup and resizedown\n      if (isResizeDown) {\n        /**\n         *\n         * @event resizedown\n         *\n         */\n        self.fire(\"resizedown\");\n      } else if (isResizeUp) {\n        /**\n         *\n         * @event resizeup\n         *\n         */\n        self.fire(\"resizeup\");\n      }\n\n      // Fire resizewidth and resizeheight\n      if (isResizeWidth) {\n        /**\n         *\n         * @event resizewidth\n         *\n         */\n        self.fire(\"resizewidth\");\n      } else if (isResizeHeight) {\n        /**\n         *\n         * @event resizeheight\n         *\n         */\n        self.fire(\"resizeheight\");\n      }\n\n      // Fire blanket orientationchange event\n      if (isOrientation) {\n        /**\n         *\n         * @event orientationchange\n         *\n         */\n        self.fire(\"orientationchange\");\n      }\n\n      // Fire orientationportrait and orientationlandscape\n      if (isOrientationPortrait) {\n        /**\n         *\n         * @event orientationportrait\n         *\n         */\n        self.fire(\"orientationportrait\");\n      } else if (isOrientationLandscape) {\n        /**\n         *\n         * @event orientationlandscape\n         *\n         */\n        self.fire(\"orientationlandscape\");\n      }\n      self.currentView = currentView;\n    });\n  };\n\n  /**\n   *\n   * Stops the request animation frame cycle\n   * @memberof ResizeController\n   * @method destroy\n   *\n   */\n  ResizeController.prototype.destroy = function () {\n    this.stop();\n  };\n\n  /**\n   *\n   * Returns the current window viewport specs\n   * @memberof ResizeController\n   * @method getViewport\n   * @returns object\n   *\n   */\n  ResizeController.prototype.getViewport = function () {\n    return {\n      width: window.innerWidth,\n      height: window.innerHeight,\n      orient: this.hasOrientation ? Math.abs(window.orientation) : null\n    };\n  };\n\n  /**\n   *\n   * Tells if the viewport is in protrait mode\n   * @memberof ResizeController\n   * @method isPortrait\n   * @returns boolean\n   *\n   */\n  ResizeController.prototype.isPortrait = function () {\n    var orient = this.getViewport().orient;\n    return orient !== null && orient !== 90;\n  };\n\n  /**\n   *\n   * Tells if the viewport is in landscape mode\n   * @memberof ResizeController\n   * @method isLandscape\n   * @returns boolean\n   *\n   */\n  ResizeController.prototype.isLandscape = function () {\n    var orient = this.getViewport().orient;\n    return orient !== null && orient === 90;\n  };\n  return ResizeController;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtcmVzaXplY29udHJvbGxlci9SZXNpemVDb250cm9sbGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVdBLE9BQU8sRUFBRztFQUVsQixJQUFLLE9BQWMsT0FBQUUsT0FBQSxDQUFQRCxPQUFPLE9BQUssUUFBUSxJQUFJLFFBQWEsS0FBSyxXQUFXLEVBQUc7SUFDaEVFLE1BQU0sQ0FBQ0YsT0FBTyxHQUFHRCxPQUFPLENBQUMsQ0FBQztFQUU5QixDQUFDLE1BQU0sSUFBSyxPQUFPSSxNQUFNLEtBQUssV0FBVyxFQUFHO0lBQ3hDQSxNQUFNLENBQUNDLGdCQUFnQixHQUFHTCxPQUFPLENBQUMsQ0FBQztFQUN2QztBQUVKLENBQUMsRUFBRSxZQUFZO0VBRVgsSUFBSU0sVUFBVSxHQUFHQyxtQkFBTyxDQUFFLDZFQUFzQixDQUFDOztFQUVqRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJRixnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQWdCQSxDQUFBLEVBQWU7SUFDL0JDLFVBQVUsQ0FBQ0UsSUFBSSxDQUFFLElBQUssQ0FBQztJQUV2QixJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJLENBQUNDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JDLElBQUksQ0FBQ0MsY0FBYyxHQUFJLGFBQWEsSUFBSVAsTUFBTztJQUUvQyxJQUFJLENBQUNRLEtBQUssQ0FBQyxDQUFDO0VBQ2hCLENBQUM7RUFFRFAsZ0JBQWdCLENBQUNRLFNBQVMsR0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUVULFVBQVUsQ0FBQ08sU0FBVSxDQUFDOztFQUVsRTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJUixnQkFBZ0IsQ0FBQ1EsU0FBUyxD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NUMsQ0FBQztFQUdELE9BQU90QixnQkFBZ0I7QUFFM0IsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLXJlc2l6ZWNvbnRyb2xsZXIvUmVzaXplQ29udHJvbGxlci5qcz80ZDRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICpcbiAqIFdpbmRvdyByZXNpemUgLyBvcmllbnRhdGlvbmNoYW5nZSBldmVudCBjb250cm9sbGVyXG4gKlxuICogQFJlc2l6ZUNvbnRyb2xsZXJcbiAqIEBhdXRob3I6IGtpdGFqY2h1a1xuICpcbiAqXG4gKi9cbihmdW5jdGlvbiAoIGZhY3RvcnkgKSB7XG5cbiAgICBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgd2luZG93LlJlc2l6ZUNvbnRyb2xsZXIgPSBmYWN0b3J5KCk7XG4gICAgfVxuXG59KShmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgQ29udHJvbGxlciA9IHJlcXVpcmUoIFwicHJvcGVyanMtY29udHJvbGxlclwiICk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdpbmRvdyByZXNpemUgLyBvcmllbnRhdGlvbmNoYW5nZSBldmVudCBjb250cm9sbGVyXG4gICAgICogQGNvbnN0cnVjdG9yIFJlc2l6ZUNvbnRyb2xsZXJcbiAgICAgKiBAYXVnbWVudHMgQ29udHJvbGxlclxuICAgICAqIEByZXF1aXJlcyBDb250cm9sbGVyXG4gICAgICogQG1lbWJlcm9mISA8Z2xvYmFsPlxuICAgICAqXG4gICAgICogQGZpcmVzIHJlc2l6ZVxuICAgICAqIEBmaXJlcyByZXNpemVkb3duXG4gICAgICogQGZpcmVzIHJlc2l6ZXVwXG4gICAgICogQGZpcmVzIHJlc2l6ZXdpZHRoXG4gICAgICogQGZpcmVzIHJlc2l6ZWhlaWdodFxuICAgICAqIEBmaXJlcyBvcmllbnRhdGlvbmNoYW5nZVxuICAgICAqIEBmaXJlcyBvcmllbnRhdGlvbnBvcnRyYWl0XG4gICAgICogQGZpcmVzIG9yaWVudGF0aW9ubGFuZHNjYXBlXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgUmVzaXplQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQ29udHJvbGxlci5jYWxsKCB0aGlzICk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IHRoaXMuZ2V0Vmlld3BvcnQoKTtcbiAgICAgICAgdGhpcy5oYXNPcmllbnRhdGlvbiA9IChcIm9yaWVudGF0aW9uXCIgaW4gd2luZG93KTtcblxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIFJlc2l6ZUNvbnRyb2xsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29udHJvbGxlci5wcm90b3R5cGUgKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU3RhcnRzIHRoZSByZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZSBjeWNsZVxuICAgICAqIEBtZW1iZXJvZiBSZXNpemVDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICpcbiAgICAgKi9cbiAgICBSZXNpemVDb250cm9sbGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIENhbGwgb24gcGFyZW50IGN5Y2xlXG4gICAgICAgIHRoaXMuZ28oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWaWV3ID0gc2VsZi5nZXRWaWV3cG9ydCgpLFxuICAgICAgICAgICAgICAgIGlzU3RpbGwgPSAoY3VycmVudFZpZXcud2lkdGggPT09IHNlbGYuY3VycmVudFZpZXcud2lkdGggJiYgY3VycmVudFZpZXcuaGVpZ2h0ID09PSBzZWxmLmN1cnJlbnRWaWV3LmhlaWdodCksXG4gICAgICAgICAgICAgICAgaXNSZXNpemUgPSAoY3VycmVudFZpZXcud2lkdGggIT09IHNlbGYuY3VycmVudFZpZXcud2lkdGggfHwgY3VycmVudFZpZXcuaGVpZ2h0ICE9PSBzZWxmLmN1cnJlbnRWaWV3LmhlaWdodCksXG4gICAgICAgICAgICAgICAgaXNSZXNpemVVcCA9IChjdXJyZW50Vmlldy53aWR0aCAIHNlbGYuY3VycmVudFZpZXcud2lkdGggfHwgY3VycmVudFZpZXcuaGVpZ2h0ID4gc2VsZi5jdXJyZW50Vmlldy5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIGlzUmVzaXplRG93biA9IChjdXJyZW50Vmlldy53aWR0aCA8IHNlbGYuY3VycmVudFZpZXcud2lkdGggfHwgY3VycmVudFZpZXcuaGVpZ2h0IDwgc2VsZi5jdXJyZW50Vmlldy5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIGlzUmVzaXplV2lkdGggPSAoY3VycmVudFZpZXcud2lkdGggIT09IHNlbGYuY3VycmVudFZpZXcud2lkdGgpLFxuICAgICAgICAgICAgICAgIGlzUmVzaXplSGVpZ2h0ID0gKGN1cnJlbnRWaWV3LmhlaWdodCAhPT0gc2VsZi5jdXJyZW50Vmlldy5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIGlzT3JpZW50YXRpb24gPSAoY3VycmVudFZpZXcub3JpZW50ICE9PSBzZWxmLmN1cnJlbnRWaWV3Lm9yaWVudCksXG4gICAgICAgICAgICAgICAgaXNPcmllbnRhdGlvblBvcnRyYWl0ID0gKGN1cnJlbnRWaWV3Lm9yaWVudCAhPT0gc2VsZi5jdXJyZW50Vmlldy5vcmllbnQgJiYgY3VycmVudFZpZXcub3JpZW50ICE9PSA5MCksXG4gICAgICAgICAgICAgICAgaXNPcmllbnRhdGlvbkxhbmRzY2FwZSA9IChjdXJyZW50Vmlldy5vcmllbnQgIT09IHNlbGYuY3VycmVudFZpZXcub3JpZW50ICYmIGN1cnJlbnRWaWV3Lm9yaWVudCA9PT0gOTApO1xuXG4gICAgICAgICAgICAvLyBGaXJlIGJsYW5rZXQgcmVzaXplIGV2ZW50XG4gICAgICAgICAgICBpZiAoIGlzUmVzaXplICkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IHJlc2l6ZVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2VsZi5maXJlKCBcInJlc2l6ZVwiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcmUgcmVzaXpldXAgYW5kIHJlc2l6ZWRvd25cbiAgICAgICAgICAgIGlmICggaXNSZXNpemVEb3duICkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IHJlc2l6ZWRvd25cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZSggXCJyZXNpemVkb3duXCIgKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggaXNSZXNpemVVcCApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCByZXNpemV1cFxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2VsZi5maXJlKCBcInJlc2l6ZXVwXCIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlyZSByZXNpemV3aWR0aCBhbmQgcmVzaXplaGVpZ2h0XG4gICAgICAgICAgICBpZiAoIGlzUmVzaXplV2lkdGggKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgcmVzaXpld2lkdGhcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZSggXCJyZXNpemV3aWR0aFwiICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlzUmVzaXplSGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IHJlc2l6ZWhlaWdodFxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2VsZi5maXJlKCBcInJlc2l6ZWhlaWdodFwiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcmUgYmxhbmtldCBvcmllbnRhdGlvbmNoYW5nZSBldmVudFxuICAgICAgICAgICAgaWYgKCBpc09yaWVudGF0aW9uICkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQGV2ZW50IG9yaWVudGF0aW9uY2hhbmdlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZWxmLmZpcmUoIFwib3JpZW50YXRpb25jaGFuZ2VcIiApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlIG9yaWVudGF0aW9ucG9ydHJhaXQgYW5kIG9yaWVudGF0aW9ubGFuZHNjYXBlXG4gICAgICAgICAgICBpZiAoIGlzT3JpZW50YXRpb25Qb3J0cmFpdCApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBvcmllbnRhdGlvbnBvcnRyYWl0XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZWxmLmZpcmUoIFwib3JpZW50YXRpb25wb3J0cmFpdFwiICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlzT3JpZW50YXRpb25MYW5kc2NhcGUgKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgb3JpZW50YXRpb25sYW5kc2NhcGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZSggXCJvcmllbnRhdGlvbmxhbmRzY2FwZVwiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY3VycmVudFZpZXcgPSBjdXJyZW50VmlldztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU3RvcHMgdGhlIHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lIGN5Y2xlXG4gICAgICogQG1lbWJlcm9mIFJlc2l6ZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICAgKlxuICAgICAqL1xuICAgIFJlc2l6ZUNvbnRyb2xsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgd2luZG93IHZpZXdwb3J0IHNwZWNzXG4gICAgICogQG1lbWJlcm9mIFJlc2l6ZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGdldFZpZXdwb3J0XG4gICAgICogQHJldHVybnMgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBSZXNpemVDb250cm9sbGVyLnByb3RvdHlwZS5nZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgb3JpZW50OiB0aGlzLmhhc09yaWVudGF0aW9uID8gTWF0aC5hYnMoIHdpbmRvdy5vcmllbnRhdGlvbiApIDogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIGlmIHRoZSB2aWV3cG9ydCBpcyBpbiBwcm90cmFpdCBtb2RlXG4gICAgICogQG1lbWJlcm9mIFJlc2l6ZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIGlzUG9ydHJhaXRcbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICpcbiAgICAgKi9cbiAgICBSZXNpemVDb250cm9sbGVyLnByb3RvdHlwZS5pc1BvcnRyYWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3JpZW50ID0gdGhpcy5nZXRWaWV3cG9ydCgpLm9yaWVudDtcblxuICAgICAgICByZXR1cm4gKG9yaWVudCAhPT0gbnVsbCAmJiBvcmllbnQgIT09IDkwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUZWxscyBpZiB0aGUgdmlld3BvcnQgaXMgaW4gbGFuZHNjYXBlIG1vZGVcbiAgICAgKiBAbWVtYmVyb2YgUmVzaXplQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgaXNMYW5kc2NhcGVcbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICpcbiAgICAgKi9cbiAgICBSZXNpemVDb250cm9sbGVyLnByb3RvdHlwZS5pc0xhbmRzY2FwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9yaWVudCA9IHRoaXMuZ2V0Vmlld3BvcnQoKS5vcmllbnQ7XG5cbiAgICAgICAgcmV0dXJuIChvcmllbnQgIT09IG51bGwgJiYgb3JpZW50ID09PSA5MCk7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIFJlc2l6ZUNvbnRyb2xsZXI7XG5cbn0pO1xuIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJleHBvcnRzIiwiX3R5cGVvZiIsIm1vZHVsZSIsIndpbmRvdyIsIlJlc2l6ZUNvbnRyb2xsZXIiLCJDb250cm9sbGVyIiwicmVxdWlyZSIsImNhbGwiLCJjdXJyZW50VmlldyIsImdldFZpZXdwb3J0IiwiaGFzT3JpZW50YXRpb24iLCJzdGFydCIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsInNlbGYiLCJnbyIsImlzU3RpbGwiLCJ3aWR0aCIsImhlaWdodCIsImlzUmVzaXplIiwiaXNSZXNpemVVcCIsImlzUmVzaXplRG93biIsImlzUmVzaXplV2lkdGgiLCJpc1Jlc2l6ZUhlaWdodCIsImlzT3JpZW50YXRpb24iLCJvcmllbnQiLCJpc09yaWVudGF0aW9uUG9ydHJhaXQiLCJpc09yaWVudGF0aW9uTGFuZHNjYXBlIiwiZmlyZSIsImRlc3Ryb3kiLCJzdG9wIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiTWF0aCIsImFicyIsIm9yaWVudGF0aW9uIiwiaXNQb3J0cmFpdCIsImlzTGFuZHNjYXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-resizecontroller/ResizeController.js\n");

/***/ }),

/***/ "./node_modules/properjs-scrollcontroller/ScrollController.js":
/*!********************************************************************!*\
  !*** ./node_modules/properjs-scrollcontroller/ScrollController.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ScrollController)\n/* harmony export */ });\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-scrollcontroller/node_modules/properjs-controller/Controller.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar ScrollController = /*#__PURE__*/function (_Controller) {\n  _inherits(ScrollController, _Controller);\n  var _super = _createSuper(ScrollController);\n  function ScrollController(element) {\n    var _this;\n    _classCallCheck(this, ScrollController);\n    _this = _super.call(this);\n    _this.current = null;\n    _this.element = element || window;\n    _this.isWindow = _this.element === window;\n    _this.start();\n    return _this;\n  }\n  _createClass(ScrollController, [{\n    key: \"getScrollY\",\n    value: function getScrollY() {\n      return this.isWindow ? window.scrollY : this.element.scrollTop;\n    }\n  }, {\n    key: \"getScrollMax\",\n    value: function getScrollMax() {\n      var max = null;\n      if (this.isWindow) {\n        max = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight);\n      } else {\n        max = Math.max(this.element.scrollHeight, this.element.offsetHeight, this.element.clientHeight);\n      }\n      return max - window.innerHeight;\n    }\n  }, {\n    key: \"isScrollMax\",\n    value: function isScrollMax() {\n      return this.getScrollY() >= this.getScrollMax();\n    }\n  }, {\n    key: \"isScrollMin\",\n    value: function isScrollMin() {\n      return this.getScrollY() <= 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n      this.go(function () {\n        var current = _this2.getScrollY();\n        var isStill = current === _this2.current;\n        var isScroll = current !== _this2.current;\n        var isScrollUp = current < _this2.current;\n        var isScrollDown = current > _this2.current;\n        var isScrollMax = current !== _this2.current && _this2.isScrollMax();\n        var isScrollMin = current !== _this2.current && _this2.isScrollMin();\n\n        // Fire blanket scroll event\n        if (isStill) {\n          _this2.fire(\"idle\", current);\n        } else if (isScroll) {\n          _this2.fire(\"scroll\", current);\n        }\n\n        // Fire scrollup and scrolldown\n        if (isScrollDown) {\n          _this2.fire(\"scrolldown\", current);\n        } else if (isScrollUp) {\n          _this2.fire(\"scrollup\", current);\n        }\n\n        // Fire scrollmax and scrollmin\n        if (isScrollMax) {\n          _this2.fire(\"scrollmax\", current);\n        } else if (isScrollMin) {\n          _this2.fire(\"scrollmin\", current);\n        }\n        _this2.current = current;\n      });\n    }\n  }]);\n  return ScrollController;\n}(properjs_controller__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtc2Nyb2xsY29udHJvbGxlci9TY3JvbGxDb250cm9sbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QztBQUFBLElBSXhCQyxnQkFBZ0IsMEJBQUFDLFdBQUE7RUFBQUMsU0FBQSxDQUFBRixnQkFBQSxFQUFBQyxXQUFBO0VBQUEsSUFBQUUsTUFBQSxHQUFBQyxZQUFBLENBQUFKLGdCQUFBO0VBQ2pDLFNBQUFBLGlCQUFjSyxPQUFPLEVBQUc7SUFBQSxJQUFBQyxLQUFBO0lBQUFDLGVBQUEsT0FBQVAsZ0JBQUE7SUFDcEJNLEtBQUEsR0FBQUgsTUFBQSxDQUFBSyxJQUFBO0lBRUFGLEtBQUEsQ0FBS0csT0FBTyxHQUFHLElBQUk7SUFDbkJILEtBQUEsQ0FBS0QsT0FBTyxHQUFJQSxPQUFPLElBQUlLLE1BQU87SUFDbENKLEtBQUEsQ0FBS0ssUUFBUSxHQUFJTCxLQUFBLENBQUtELE9BQU8sS0FBS0ssTUFBTztJQUV6Q0osS0FBQSxDQUFLTSxLQUFLLENBQUMsQ0FBQztJQUFDLE9BQUFOLEtBQUE7RUFDakI7RUFBQ08sWUFBQSxDQUFBYixnQkFBQTtJQUFBYyxHQUFBO0lBQUFDLEtBQUEsRUFHRCxTQUFBQyxXQUFBLEVBQWM7TUFDVixPQUFRLElBQUksQ0FBQ0wsUUFBUSxHQUFHRCxNQUFNLENBQUNPLE9BQU8sR0FBRyxJQUFJLENBQUNaLE9BQU8sQ0FBQ2EsU0FBUztJQUNuRTtFQUFDO0lBQUFKLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUFJLGFBQUEsRUFBZ0I7TUFDWixJQUFJQyxHQUFHLEdBQUcsSUFBSTtNQUVkLElBQUssSUFBSSxDQUFDVCxRQUFRLEVBQUc7UUFDakJTLEdBQUcsR0FBR0MsSUFBSSxDQUFDRCxHQUFHLENBQ1ZFLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxZQUFZLEVBQUVGLFFBQVEsQ0FBQ0csZUFBZSxDQUFDRCxZQUFZLEVBQ2pFRixRQUFRLENBQUNDLElBQUksQ0FBQ0csWUFBWSxFQUFFSixRQUFRLENBQUNHLGVBQWUsQ0FBQ0MsWUFBWSxFQUNqRUosUUFBUSxDQUFDRyxlQUFlLENBQUNFLFlBQzdCLENBQUM7TUFFTCxDQUFDLE1BQU07UUFDSFAsR0FBRyxHQUFHQyxJQUFJLENBQUNELEdBQUcsQ0FDVixJQUFJLENBQUNmLE9BQU8sQ0FBQ21CLFlBQVksRUFDekIsSUFBSSxDQUFDbkIsT0FBTyxDQUFDcUIsWUFBWSxFQUN6QixJQUFJLENBQUNyQixPQUFPLENBQUNzQixZQUNqQixDQUFDO01BQ0w7TUFFQSxPQUFRUCxHQUFHLEdBQUdWLE1BQU0sQ0FBQ2tCLFdBQVc7SUFDcEM7RUFBQztJQUFBZCxHQUFBO0lBQUFDLEtBQUEsRUFHRCxTQUFBYyxZQUFBLEVBQWU7TUFDWCxPQUFRLElBQUksQ0FBQ2IsVUFBVSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUNHLFlBQVksQ0FBQyxDQUFDO0lBQ3BEO0VBQUM7SUFBQUwsR0FBQTtJQUFBQyxLQUFBLEVBR0QsU0FBQWUsWUFBQSxFQUFlO01BQ1gsT0FBUSxJQUFJLENBQUNkLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNsQztFQUFDO0lBQUFGLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUFILE1BQUEsRUFBUztNQUFBLElBQUFtQixNQUFBO01BQ0wsSUFBSSxDQUFDQyxFQUFFLENBQUMsWUFBTTtRQUNWLElBQU12QixPQUFPLEdBQUdzQixNQUFJLENBQUNmLFVBQVUsQ0FBQyxDQUFDO1FBQ2pDLElBQU1pQixPQUFPLEdBQUl4QixPQUFPLEtBQUtzQixNQUFJLENBQUN0QixPQUFRO1FBQzFDLElBQU15QixRQUFRLEdBQUl6QixPQUFPLEtBQUtzQixNQUFJLENBQUN0QixPQUFRO1FBQzNDLElBQU0wQixVQUFVLEdBQUkxQixPQUFPLEdBQUdzQixNQUFJLENBQUN0QixPQUFRO1FBQzNDLElBQU0yQixZQUFZLEdBQUkzQixPQUFPLEdBQUdzQixNQUFJLENBQUN0QixPQUFRO1FBQzdDLElBQU1vQixXQUFXLEdBQUlwQixPQUFPLEtBQUtzQixNQUFJLENBQUN0QixPQUFPLElBQUlzQixNQUFJLENBQUNGLFdBQVcsQ0FBQyxDQUFFO1FBQ3BFLElBQU1DLFdBQVcsR0FBSXJCLE9BQU8sS0FBS3NCLE1BQUksQ0FBQ3RCLE9BQU8sSUFBSXNCLE1BQUksQ0FBQ0QsV0FBVyxDQUFDLENBQUU7O1FBRXBFO1FBQ0EsSUFBS0csT0FBTyxFQUFHO1VBQ1hGLE1BQUksQ0FBQ00sSUFBSSxDQUFFLE1BQU0sRUFBRTVCLE9BQVEsQ0FBQztRQUVoQyxDQUFDLE1BQU0sSUFBS3lCLFFBQVEsRUFBRztVQUNuQkgsTUFBSSxDQUFDTSxJQUFJLENBQUUsUUFBUSxFQUFFNUIsT0FBUSxDQUFDO1FBQ2xDOztRQUVBO1FBQ0EsSUFBSzJCLFlBQVksRUFBRztVQUNoQkwsTUFBSSxDQUFDTSxJQUFJLENBQUUsWUFBWSxFQUFFNUIsT0FBUSxDQUFDO1FBRXRDLENBQUMsTUFBTSxJQUFLMEIsVUFBVSxFQUFHO1VBQ3JCSixNQUFJLENBQUNNLElBQUksQ0FBRSxVQUFVLEVBQUU1QixPQUFRLENBQUM7UUFDcEM7O1FBRUE7UUFDQSxJQUFLb0IsV0FBVyxFQUFHO1VBQ2ZFLE1BQUksQ0FBQ00sSUFBSSxDQUFFLFdBQVcsRUFBRTVCLE9BQVEsQ0FBQztRQUVyQyxDQUFDLE1BQU0sSUFBS3FCLFdBQVcsRUFBRztVQUN0QkMsTUFBSSxDQUFDTSxJQUFJLENBQUUsV0FBVyxFQUFFNUIsT0FBUSxDQUFDO1FBQ3JDO1FBRUFzQixNQUFJLENBQUN0QixPQUFPLEdBQUdBLE9BQU87TUFDMUIsQ0FBQyxDQUFDO0lBQ047RUFBQztFQUFBLE9BQUFULGdCQUFBO0FBQUEsRUFyRnlDRCwyREFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9wcm9wZXJqcy1zY3JvbGxjb250cm9sbGVyL1Njcm9sbENvbnRyb2xsZXIuanM/NjZkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udHJvbGxlciBmcm9tIFwicHJvcGVyanMtY29udHJvbGxlclwiO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yICggZWxlbWVudCApIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSAoZWxlbWVudCB8fCB3aW5kb3cpO1xuICAgICAgICB0aGlzLmlzV2luZG93ID0gKHRoaXMuZWxlbWVudCA9PT0gd2luZG93KTtcblxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuXG5cbiAgICBnZXRTY3JvbGxZICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzV2luZG93ID8gd2luZG93LnNjcm9sbFkgOiB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICB9XG5cblxuICAgIGdldFNjcm9sbE1heCAoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuXG4gICAgICAgIGlmICggdGhpcy5pc1dpbmRvdyApIHtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChtYXggLSB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cblxuXG4gICAgaXNTY3JvbGxNYXggKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0U2Nyb2xsWSgpID49IHRoaXMuZ2V0U2Nyb2xsTWF4KCkpO1xuICAgIH1cblxuXG4gICAgaXNTY3JvbGxNaW4gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0U2Nyb2xsWSgpIDw9IDApO1xuICAgIH1cblxuXG4gICAgc3RhcnQgKCkge1xuICAgICAgICB0aGlzLmdvKCgpID0IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldFNjcm9sbFkoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzU3RpbGwgPSAoY3VycmVudCA9PT0gdGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2Nyb2xsID0gKGN1cnJlbnQgIT09IHRoaXMuY3VycmVudCk7XG4gICAgICAgICAgICBjb25zdCBpc1Njcm9sbFVwID0gKGN1cnJlbnQgPCB0aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgY29uc3QgaXNTY3JvbGxEb3duID0gKGN1cnJlbnQgPiB0aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgY29uc3QgaXNTY3JvbGxNYXggPSAoY3VycmVudCAhPT0gdGhpcy5jdXJyZW50ICYmIHRoaXMuaXNTY3JvbGxNYXgoKSk7XG4gICAgICAgICAgICBjb25zdCBpc1Njcm9sbE1pbiA9IChjdXJyZW50ICE9PSB0aGlzLmN1cnJlbnQgJiYgdGhpcy5pc1Njcm9sbE1pbigpKTtcblxuICAgICAgICAgICAgLy8gRmlyZSBibGFua2V0IHNjcm9sbCBldmVudFxuICAgICAgICAgICAgaWYgKCBpc1N0aWxsICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSggXCJpZGxlXCIsIGN1cnJlbnQgKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggaXNTY3JvbGwgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCBcInNjcm9sbFwiLCBjdXJyZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcmUgc2Nyb2xsdXAgYW5kIHNjcm9sbGRvd25cbiAgICAgICAgICAgIGlmICggaXNTY3JvbGxEb3duICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSggXCJzY3JvbGxkb3duXCIsIGN1cnJlbnQgKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggaXNTY3JvbGxVcCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoIFwic2Nyb2xsdXBcIiwgY3VycmVudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlIHNjcm9sbG1heCBhbmQgc2Nyb2xsbWluXG4gICAgICAgICAgICBpZiAoIGlzU2Nyb2xsTWF4ICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSggXCJzY3JvbGxtYXhcIiwgY3VycmVudCApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBpc1Njcm9sbE1pbiApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoIFwic2Nyb2xsbWluXCIsIGN1cnJlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkNvbnRyb2xsZXIiLCJTY3JvbGxDb250cm9sbGVyIiwiX0NvbnRyb2xsZXIiLCJfaW5oZXJpdHMiLCJfc3VwZXIiLCJfY3JlYXRlU3VwZXIiLCJlbGVtZW50IiwiX3RoaXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJjYWxsIiwiY3VycmVudCIsIndpbmRvdyIsImlzV2luZG93Iiwic3RhcnQiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsImdldFNjcm9sbFkiLCJzY3JvbGxZIiwic2Nyb2xsVG9wIiwiZ2V0U2Nyb2xsTWF4IiwibWF4IiwiTWF0aCIsImRvY3VtZW50IiwiYm9keSIsInNjcm9sbEhlaWdodCIsImRvY3VtZW50RWxlbWVudCIsIm9mZnNldEhlaWdodCIsImNsaWVudEhlaWdodCIsImlubmVySGVpZ2h0IiwiaXNTY3JvbGxNYXgiLCJpc1Njcm9sbE1pbiIsIl90aGlzMiIsImdvIiwiaXNTdGlsbCIsImlzU2Nyb2xsIiwiaXNTY3JvbGxVcCIsImlzU2Nyb2xsRG93biIsImZpcmUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/properjs-scrollcontroller/ScrollController.js\n");

/***/ }),

/***/ "./node_modules/properjs-scrollcontroller/node_modules/properjs-controller/Controller.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/properjs-scrollcontroller/node_modules/properjs-controller/Controller.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Controller)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar raf = window.requestAnimationFrame;\nvar caf = window.cancelAnimationFrame;\n\n/**\n *\n * Easing functions\n * @namespace Easing\n * @memberof! <global>\n *\n */\nvar ease = {\n  /**\n   *\n   * Produce a linear ease\n   * @method linear\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  linear: function linear(t) {\n    return t;\n  },\n  /**\n   *\n   * Produce a swing ease like in jQuery\n   * @method swing\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  swing: function swing(t) {\n    return (1 - Math.cos(t * Math.PI)) / 2;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInQuad\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutQuad\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutQuad: function easeOutQuad(t) {\n    return t * (2 - t);\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutQuad\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutQuad: function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1  (4 - 2 * t) * t;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInCubic\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutCubic\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutCubic: function easeOutCubic(t) {\n    return --t * t * t  1;\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutCubic\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutCubic: function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2)  1;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInQuart\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutQuart\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutQuart: function easeOutQuart(t) {\n    return 1 - --t * t * t * t;\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutQuart\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutQuart: function easeInOutQuart(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n  /**\n   *\n   * Accelerating from zero velocity\n   * @method easeInQuint\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n  /**\n   *\n   * Decelerating to zero velocity\n   * @method easeOutQuint\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeOutQuint: function easeOutQuint(t) {\n    return 1  --t * t * t * t * t;\n  },\n  /**\n   *\n   * Acceleration until halfway, then deceleration\n   * @method easeInOutQuint\n   * @param {number} t Difference in time\n   * @returns a new t value\n   *\n   */\n  easeInOutQuint: function easeInOutQuint(t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1  16 * --t * t * t * t * t;\n  }\n};\nvar defs = {\n  ease: ease.swing,\n  duration: 500,\n  from: 0,\n  to: 500,\n  update: function update() {},\n  complete: function complete() {}\n};\nvar Controller = /*#__PURE__*/function () {\n  function Controller() {\n    _classCallCheck(this, Controller);\n    // Unique event IDs\n    this._uid = 0;\n    this._uprop = \"properjsUID\";\n\n    // Store for event handlers\n    this._handlers = {};\n\n    // RAF manager props\n    this._started = false;\n    this._paused = false;\n    this._cycle = null;\n  }\n  _createClass(Controller, [{\n    key: \"uid\",\n    value: function uid() {\n      this._uid = this._uid  1;\n      return this._uid;\n    }\n  }, {\n    key: \"go\",\n    value: function go(callback) {\n      var _this = this;\n      if (this._started) {\n        return this;\n      }\n      this._started = true;\n      this._anim = function (elapsed) {\n        _this._cycle = raf(_this._anim);\n        if (typeof callback === \"function\") {\n          callback(elapsed);\n        }\n      };\n      this._cycle = raf(this._anim);\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._paused = true;\n      return this;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      this._paused = false;\n      return this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      caf(this._cycle);\n      this._paused = false;\n      this._started = false;\n      this._cycle = null;\n      return this;\n    }\n  }, {\n    key: \"tween\",\n    value: function tween(opts) {\n      var _this2 = this;\n      for (var i in defs) {\n        if (opts[i] === undefined) {\n          opts[i] = defs[i];\n        }\n      }\n      var startTime = null;\n      var tweenDiff = opts.to - opts.from;\n      this.stop().go(function (elapsed) {\n        if (startTime === null) {\n          startTime = elapsed;\n        }\n        var diff = elapsed - startTime;\n        var tweenTo = tweenDiff * opts.ease(diff / opts.duration)  opts.from;\n        opts.update(tweenTo);\n        if (diff > opts.duration) {\n          opts.complete(opts.to);\n          _this2.stop();\n        }\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, handler) {\n      var events = event.split(\" \");\n      handler[this._uprop] = this.uid();\n      for (var i = events.length; i--;) {\n        if (typeof handler === \"function\") {\n          if (!this._handlers[events[i]]) {\n            this._handlers[events[i]] = [];\n          }\n          this._handlers[events[i]].push(handler);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      if (!this._handlers[event]) {\n        return this;\n      }\n      if (handler) {\n        this._offOne(event, handler);\n      } else {\n        this._offAll(event);\n      }\n      return this;\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(event) {\n      if (!this._handlers[event]) {\n        return this;\n      }\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key) {\n        args[_key - 1] = arguments[_key];\n      }\n      for (var i = this._handlers[event].length; i--;) {\n        this._handlers[event][i].apply(this, args);\n      }\n      return this;\n    }\n  }, {\n    key: \"_offOne\",\n    value: function _offOne(event, handler) {\n      for (var i = 0, len = this._handlers[event].length; i < len; i) {\n        if (handler[this._uprop] === this._handlers[event][i][this._uprop]) {\n          this._handlers[event].splice(i, 1);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"_offAll\",\n    value: function _offAll(event) {\n      for (var i = this._handlers[event].length; i--;) {\n        this._handlers[event][i] = null;\n      }\n      delete this._handlers[event];\n    }\n  }]);\n  return Controller;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtc2Nyb2xsY29udHJvbGxlci9ub2RlX21vZHVsZXMvcHJvcGVyanMtY29udHJvbGxlci9Db250cm9sbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxJQUFNQSxHQUFHLEdBQUdDLE1BQU0sQ0FBQ0MscUJBQXFCO0FBQ3hDLElBQU1DLEdBQUcsR0FBR0YsTUFBTSxDQUFDRyxvQkFBb0I7O0FBSXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUMsSUFBSSxHQUFHO0VBQ1Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxNQUFNLFdBQUFBLE9BQUdDLENBQUMsRUFBRztJQUFFLE9BQU9BLENBQUM7RUFBRSxDQUFDO0VBRTFCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsS0FBSyxXQUFBQSxNQUFHRCxDQUFDLEVBQUc7SUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFDRSxJQUFJLENBQUNDLEdBQUcsQ0FBRUgsQ0FBQyxHQUFDRSxJQUFJLENBQUNFLEVBQUcsQ0FBQyxJQUFFLENBQUM7RUFBRSxDQUFDO0VBRW5EO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsVUFBVSxXQUFBQSxXQUFHTCxDQUFDLEVBQUc7SUFBRSxPQUFPQSxDQUFDLEdBQUNBLENBQUM7RUFBRSxDQUFDO0VBRWhDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSU0sV0FBVyxXQUFBQSxZQUFHTixDQUFDLEVBQUc7SUFBRSxPQUFPQSxDQUFDLElBQUUsQ0FBQyxHQUFDQSxDQUFDLENBQUM7RUFBRSxDQUFDO0VBRXJDO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSU8sYUFBYSxXQUFBQSxjQUFHUCxDQUFDLEVBQUc7SUFBRSxPQUFPQSxDQUFDLEdBQUMsR0FBRyxHQUFHLENBQUMsR0FBQ0EsQ0FB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RyxHQUFHLElBQUksQ0FBQzFDLFNBQVMsQ0FBRTBCLEtBQUssQ0FBRSxDQUFDSSxNQUFNLEVBQUVYLENBQUMsR0FBR3VCLEdBQUcsRUFBRXZCLENBQUMsRUFBRSxFQUFHO1FBQ2xFLElBQUtRLE9BQU8sQ0FBRSxJQUFJLENBQUM1QixNQUFNLENBQUUsS0FBSyxJQUFJLENBQUNDLFNBQVMsQ0FBRTBCLEtBQUssQ0FBRSxDQUFFUCxDQUFDLENBQUUsQ0FBRSxJQUFJLENBQUNwQixNQUFNLENBQUUsRUFBRztVQUMxRSxJQUFJLENBQUNDLFNBQVMsQ0FBRTBCLEtBQUssQ0FBRSxDQUFDaUIsTUFBTSxDQUFFeEIsQ0FBQyxFQUFFLENBQUUsQ0FBQztVQUV0QztRQUNKO01BQ0o7SUFDSjtFQUFDO0lBQUFkLEdBQUE7SUFBQUMsS0FBQSxFQUdELFNBQUE0QixRQUFVUixLQUFLLEVBQUc7TUFDZCxLQUFNLElBQUlQLENBQUMsR0FBRyxJQUFJLENBQUNuQixTQUFTLENBQUUwQixLQUFLLENBQUUsQ0FBQ0ksTUFBTSxFQUFFWCxDQUFDLEVBQUUsR0FBSTtRQUNqRCxJQUFJLENBQUNuQixTQUFTLENBQUUwQixLQUFLLENBQUUsQ0FBRVAsQ0FBQyxDQUFFLEdBQUcsSUFBSTtNQUN2QztNQUVBLE9BQU8sSUFBSSxDQUFDbkIsU0FBUyxDQUFFMEIsS0FBSyxDQUFFO0lBQ2xDO0VBQUM7RUFBQSxPQUFBOUIsVUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3Byb3BlcmpzLXNjcm9sbGNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL3Byb3BlcmpzLWNvbnRyb2xsZXIvQ29udHJvbGxlci5qcz82OTdlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5jb25zdCBjYWYgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cblxuXG4vKipcbiAqXG4gKiBFYXNpbmcgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIEVhc2luZ1xuICogQG1lbWJlcm9mISA8Z2xvYmFsPlxuICpcbiAqL1xuY29uc3QgZWFzZSA9IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByb2R1Y2UgYSBsaW5lYXIgZWFzZVxuICAgICAqIEBtZXRob2QgbGluZWFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgbGluZWFyICggdCApIHsgcmV0dXJuIHQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByb2R1Y2UgYSBzd2luZyBlYXNlIGxpa2UgaW4galF1ZXJ5XG4gICAgICogQG1ldGhvZCBzd2luZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIHN3aW5nICggdCApIHsgcmV0dXJuICgxLU1hdGguY29zKCB0Kk1hdGguUEkgKSkvMjsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAqIEBtZXRob2QgZWFzZUluUXVhZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IERpZmZlcmVuY2UgaW4gdGltZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIGVhc2VJblF1YWQgKCB0ICkgeyByZXR1cm4gdCp0OyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgICAqIEBtZXRob2QgZWFzZU91dFF1YWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVhZCAoIHQgKSB7IHJldHVybiB0KigyLXQpOyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgKiBAbWV0aG9kIGVhc2VJbk91dFF1YWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWFkICggdCApIHsgcmV0dXJuIHQ8MC41ID8gMip0KnQgOiAtMSsoNC0yKnQpKnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICAgKiBAbWV0aG9kIGVhc2VJbkN1YmljXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgZWFzZUluQ3ViaWMgKCB0ICkgeyByZXR1cm4gdCp0KnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlT3V0Q3ViaWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlT3V0Q3ViaWMgKCB0ICkgeyByZXR1cm4gKC0tdCkqdCp0KzE7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAqIEBtZXRob2QgZWFzZUluT3V0Q3ViaWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRDdWJpYyAoIHQgKSB7IHJldHVybiB0PDAuNSA/IDQqdCp0KnQgOiAodC0xKSooMip0LTIpKigyKnQtMikrMTsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAqIEBtZXRob2QgZWFzZUluUXVhcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlSW5RdWFydCAoIHQgKSB7IHJldHVybiB0KnQqdCp0OyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgICAqIEBtZXRob2QgZWFzZU91dFF1YXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgZWFzZU91dFF1YXJ0ICggdCApIHsgcmV0dXJuIDEtKC0tdCkqdCp0KnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAqIEBtZXRob2QgZWFzZUluT3V0UXVhcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWFydCAoIHQgKSB7IHJldHVybiB0PDAuNSA/IDgqdCp0KnQqdCA6IDEtOCooLS10KSp0KnQqdDsgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAqIEBtZXRob2QgZWFzZUluUXVpbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlSW5RdWludCAoIHQgKSB7IHJldHVybiB0KnQqdCp0KnQ7IH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICogQG1ldGhvZCBlYXNlT3V0UXVpbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBEaWZmZXJlbmNlIGluIHRpbWVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB0IHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVpbnQgKCB0ICkgeyByZXR1cm4gMSsoLS10KSp0KnQqdCp0OyB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgKiBAbWV0aG9kIGVhc2VJbk91dFF1aW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgRGlmZmVyZW5jZSBpbiB0aW1lXG4gICAgICogQHJldHVybnMgYSBuZXcgdCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgZWFzZUluT3V0UXVpbnQgKCB0ICkgeyByZXR1cm4gdDwwLjUgPyAxNip0KnQqdCp0KnQgOiAxKzE2KigtLXQpKnQqdCp0KnQ7IH1cbn07XG5cblxuXG5jb25zdCBkZWZzID0ge1xuICAgIGVhc2U6IGVhc2Uuc3dpbmcsXG4gICAgZHVyYXRpb246IDUwMCxcbiAgICBmcm9tOiAwLFxuICAgIHRvOiA1MDAsXG4gICAgdXBkYXRlOiAoKSA9PiB7fSxcbiAgICBjb21wbGV0ZTogKCkgPT4ge30sXG59O1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICAvLyBVbmlxdWUgZXZlbnQgSURzXG4gICAgICAgIHRoaXMuX3VpZCA9IDA7XG4gICAgICAgIHRoaXMuX3Vwcm9wID0gXCJwcm9wZXJqc1VJRFwiO1xuXG4gICAgICAgIC8vIFN0b3JlIGZvciBldmVudCBoYW5kbGVyc1xuICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgICAgIC8vIFJBRiBtYW5hZ2VyIHByb3BzXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N5Y2xlID0gbnVsbDtcbiAgICB9XG5cblxuICAgIHVpZCAoKSB7XG4gICAgICAgIHRoaXMuX3VpZCA9ICh0aGlzLl91aWQgKyAxKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdWlkO1xuICAgIH1cblxuXG4gICAgZ28gKCBjYWxsYmFjayApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9zdGFydGVkICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYW5pbSA9ICggZWxhcHNlZCApID0IHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlID0gcmFmKCB0aGlzLl9hbmltICk7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soIGVsYXBzZWQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY3ljbGUgPSByYWYoIHRoaXMuX2FuaW0gKTtcbiAgICB9XG5cblxuICAgIHBhdXNlICgpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIHBsYXkgKCkge1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIHN0b3AgKCkge1xuICAgICAgICBjYWYoIHRoaXMuX2N5Y2xlICk7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3ljbGUgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgdHdlZW4gKCBvcHRzICkge1xuICAgICAgICBmb3IgKCBsZXQgaSBpbiBkZWZzICkge1xuICAgICAgICAgICAgaWYgKCBvcHRzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBvcHRzWyBpIF0gPSBkZWZzWyBpIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgY29uc3QgdHdlZW5EaWZmID0gKG9wdHMudG8gLSBvcHRzLmZyb20pO1xuXG4gICAgICAgIHRoaXMuc3RvcCgpLmdvKCggZWxhcHNlZCApID0IHtcbiAgICAgICAgICAgIGlmICggc3RhcnRUaW1lID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IGVsYXBzZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBlbGFwc2VkIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgY29uc3QgdHdlZW5UbyA9ICh0d2VlbkRpZmYgKiBvcHRzLmVhc2UoIGRpZmYgLyBvcHRzLmR1cmF0aW9uICkpICsgb3B0cy5mcm9tO1xuXG4gICAgICAgICAgICBvcHRzLnVwZGF0ZSggdHdlZW5UbyApO1xuXG4gICAgICAgICAgICBpZiAoIGRpZmYgPiBvcHRzLmR1cmF0aW9uICkge1xuICAgICAgICAgICAgICAgIG9wdHMuY29tcGxldGUoIG9wdHMudG8gKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIG9uICggZXZlbnQsIGhhbmRsZXIgKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGV2ZW50LnNwbGl0KCBcIiBcIiApO1xuXG4gICAgICAgIGhhbmRsZXJbIHRoaXMuX3Vwcm9wIF0gPSB0aGlzLnVpZCgpO1xuXG4gICAgICAgIGZvciAoIGxldCBpID0gZXZlbnRzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgICAgICAgICAgICBpZiAoICF0aGlzLl9oYW5kbGVyc1sgZXZlbnRzWyBpIF0gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbIGV2ZW50c1sgaSBdIF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1sgZXZlbnRzWyBpIF0gXS5wdXNoKCBoYW5kbGVyICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIG9mZiAoIGV2ZW50LCBoYW5kbGVyICkge1xuICAgICAgICBpZiAoICF0aGlzLl9oYW5kbGVyc1sgZXZlbnQgXSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBoYW5kbGVyICkge1xuICAgICAgICAgICAgdGhpcy5fb2ZmT25lKCBldmVudCwgaGFuZGxlciApO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZBbGwoIGV2ZW50ICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZpcmUgKCBldmVudCwgLi4uYXJncyApIHtcbiAgICAgICAgaWYgKCAhdGhpcy5faGFuZGxlcnNbIGV2ZW50IF0gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGxldCBpID0gdGhpcy5faGFuZGxlcnNbIGV2ZW50IF0ubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbIGV2ZW50IF1bIGkgXS5hcHBseSggdGhpcywgYXJncyApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBfb2ZmT25lICggZXZlbnQsIGhhbmRsZXIgKSB7XG4gICAgICAgIGZvciAoIGxldCBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnNbIGV2ZW50IF0ubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoIGhhbmRsZXJbIHRoaXMuX3Vwcm9wIF0gPT09IHRoaXMuX2hhbmRsZXJzWyBldmVudCBdWyBpIF1bIHRoaXMuX3Vwcm9wIF0gKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbIGV2ZW50IF0uc3BsaWNlKCBpLCAxICk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgX29mZkFsbCAoIGV2ZW50ICkge1xuICAgICAgICBmb3IgKCBsZXQgaSA9IHRoaXMuX2hhbmRsZXJzWyBldmVudCBdLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzWyBldmVudCBdWyBpIF0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzWyBldmVudCBdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJyYWYiLCJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYWYiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImVhc2UiLCJsaW5lYXIiLCJ0Iiwic3dpbmciLCJNYXRoIiwiY29zIiwiUEkiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50IiwiZGVmcyIsImR1cmF0aW9uIiwiZnJvbSIsInRvIiwidXBkYXRlIiwiY29tcGxldGUiLCJDb250cm9sbGVyIiwiX2NsYXNzQ2FsbENoZWNrIiwiX3VpZCIsIl91cHJvcCIsIl9oYW5kbGVycyIsIl9zdGFydGVkIiwiX3BhdXNlZCIsIl9jeWNsZSIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwidWlkIiwiZ28iLCJjYWxsYmFjayIsIl90aGlzIiwiX2FuaW0iLCJlbGFwc2VkIiwicGF1c2UiLCJwbGF5Iiwic3RvcCIsInR3ZWVuIiwib3B0cyIsIl90aGlzMiIsImkiLCJ1bmRlZmluZWQiLCJzdGFydFRpbWUiLCJ0d2VlbkRpZmYiLCJkaWZmIiwidHdlZW5UbyIsIm9uIiwiZXZlbnQiLCJoYW5kbGVyIiwiZXZlbnRzIiwic3BsaXQiLCJsZW5ndGgiLCJwdXNoIiwib2ZmIiwiX29mZk9uZSIsIl9vZmZBbGwiLCJmaXJlIiwiX2xlbiIsImFyZ3VtZW50cyIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsImxlbiIsInNwbGljZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-scrollcontroller/node_modules/properjs-controller/Controller.js\n");

/***/ }),

/***/ "./node_modules/properjs-throttle/throttle.js":
/*!****************************************************!*\
  !*** ./node_modules/properjs-throttle/throttle.js ***!
  \****************************************************/
/***/ ((module, exports) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n *\n * Throttle callbacks\n *\n * @throttle\n * @author: kitajchuk\n *\n */\n(function (factory) {\n  if (( false ? 0 : _typeof(exports)) === \"object\" && \"object\" !== \"undefined\") {\n    module.exports = factory();\n  } else if (typeof window !== \"undefined\") {\n    window.throttle = factory();\n  }\n})(function () {\n  /**\n   *\n   * Rev limit your method calls\n   * @requires debounce\n   * @memberof! <global>\n   * @method throttle\n   * @param {function} callback The method handler\n   * @param {number} threshold The timeout delay in ms\n   *\n   */\n  var throttle = function throttle(callback, threshold) {\n    var wait = false;\n    return function () {\n      if (!wait) {\n        callback.call();\n        wait = true;\n        setTimeout(function () {\n          wait = false;\n        }, threshold || 100);\n      }\n    };\n  };\n  return throttle;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtdGhyb3R0bGUvdGhyb3R0bGUuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVdBLE9BQU8sRUFBRztFQUVsQixJQUFLLE9BQWMsT0FBQUUsT0FBQSxDQUFQRCxPQUFPLE9BQUssUUFBUSxJQUFJLFFBQWEsS0FBSyxXQUFXLEVBQUc7SUFDaEVFLE1BQU0sQ0FBQ0YsT0FBTyxHQUFHRCxPQUFPLENBQUMsQ0FBQztFQUU5QixDQUFDLE1BQU0sSUFBSyxPQUFPSSxNQUFNLEtBQUssV0FBVyxFQUFHO0lBQ3hDQSxNQUFNLENBQUNDLFFBQVEsR0FBR0wsT0FBTyxDQUFDLENBQUM7RUFDL0I7QUFFSixDQUFDLEVBQUUsWUFBWTtFQUdYO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSUssUUFBUSxHQUFHLFNBQVhBLFFBQVFBLENBQWNDLFFBQVEsRUFBRUMsU0FBUyxFQUFHO0lBQzVDLElBQUlDLElBQUksR0FBRyxLQUFLO0lBRWhCLE9BQU8sWUFBWTtNQUNmLElBQUssQ0FBQ0EsSUFBSSxFQUFHO1FBQ1RGLFFBQVEsQ0FBQ0csSUFBSSxDQUFDLENBQUM7UUFDZkQsSUFBSSxHQUFHLElBQUk7UUFFWEUsVUFBVSxDQUFDLFlBQVk7VUFDbkJGLElBQUksR0FBRyxLQUFLO1FBRWhCLENBQUMsRUFBR0QsU0FBUyxJQUFJLEdBQUssQ0FBQztNQUMzQjtJQUNKLENBQUM7RUFDTCxDQUFDO0VBR0QsT0FBT0YsUUFBUTtBQUduQixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcHJvcGVyanMtdGhyb3R0bGUvdGhyb3R0bGUuanM/YTYwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqXG4gKiBUaHJvdHRsZSBjYWxsYmFja3NcbiAqXG4gKiBAdGhyb3R0bGVcbiAqIEBhdXRob3I6IGtpdGFqY2h1a1xuICpcbiAqL1xuKGZ1bmN0aW9uICggZmFjdG9yeSApIHtcbiAgICBcbiAgICBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgd2luZG93LnRocm90dGxlID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgICBcbn0pKGZ1bmN0aW9uICgpIHtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXYgbGltaXQgeW91ciBtZXRob2QgY2FsbHNcbiAgICAgKiBAcmVxdWlyZXMgZGVib3VuY2VcbiAgICAgKiBAbWVtYmVyb2YhIDxnbG9iYWwXG4gICAgICogQG1ldGhvZCB0aHJvdHRsZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBtZXRob2QgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJlc2hvbGQgVGhlIHRpbWVvdXQgZGVsYXkgaW4gbXNcbiAgICAgKlxuICAgICAqL1xuICAgIHZhciB0aHJvdHRsZSA9IGZ1bmN0aW9uICggY2FsbGJhY2ssIHRocmVzaG9sZCApIHtcbiAgICAgICAgdmFyIHdhaXQgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCAhd2FpdCApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKCk7XG4gICAgICAgICAgICAgICAgd2FpdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgfSwgKHRocmVzaG9sZCB8fCAxMDApICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICBcbiAgICByZXR1cm4gdGhyb3R0bGU7XG5cblxufSk7Il0sIm5hbWVzIjpbImZhY3RvcnkiLCJleHBvcnRzIiwiX3R5cGVvZiIsIm1vZHVsZSIsIndpbmRvdyIsInRocm90dGxlIiwiY2FsbGJhY2siLCJ0aHJlc2hvbGQiLCJ3YWl0IiwiY2FsbCIsInNldFRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/properjs-throttle/throttle.js\n");

/***/ }),

/***/ "./source/js/app.js":
/*!**************************!*\
  !*** ./source/js/app.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./router */ \"./source/js/router.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core */ \"./source/js/core/index.js\");\n/* harmony import */ var _intro__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./intro */ \"./source/js/intro.js\");\n/* harmony import */ var _class_Nav__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./class/Nav */ \"./source/js/class/Nav.js\");\n/* harmony import */ var _class_ImageLoop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./class/ImageLoop */ \"./source/js/class/ImageLoop.js\");\n/* harmony import */ var _class_HoverListImage__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./class/HoverListImage */ \"./source/js/class/HoverListImage.js\");\n\n\n\n\n\n\n\n\n\n/**\n *\n * @public\n * @class App\n * @classdesc Load the App application Class to handle it ALL.\n *\n */\nvar App = /*#__PURE__*/function () {\n  function App() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, App);\n    this.core = _core__WEBPACK_IMPORTED_MODULE_3__;\n    this.intro = _intro__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n    this.nav = _class_Nav__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n    this.imageLoop = _class_ImageLoop__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n    this.hoverListImage = _class_HoverListImage__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\n    this.router = _router__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n    this.initModules();\n  }\n\n  /**\n   *\n   * @public\n   * @instance\n   * @method initModules\n   * @memberof App\n   * @description Initialize application modules.\n   *\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(App, [{\n    key: \"initModules\",\n    value: function initModules() {\n      // Detect\n      this.core.detect.init();\n\n      // Navigation\n      this.nav.init();\n\n      // Views\n      this.intro.init();\n\n      // Scrolls\n      this.core.scrolls.init();\n\n      // Resizes\n      this.core.resizes.init();\n\n      // Controller\n      this.router.init();\n\n      // Image Loop\n      this.imageLoop.init();\n\n      // Image List Hover\n      this.hoverListImage.init();\n\n      // Analytics\n      // this.analytics = new Analytics();\n    }\n  }]);\n  return App;\n}();\n/******************************************************************************\n * Expose\n*******************************************************************************/\nwindow.onload = function () {\n  window.app = new App();\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (window.app);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThCO0FBQ0M7QUFDSDtBQUNFO0FBQ1k7QUFDVTs7QUFHcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQSxJQU9NTSxHQUFHO0VBQ0wsU0FBQUEsSUFBQSxFQUFlO0lBQUFDLGlGQUFBLE9BQUFELEdBQUE7SUFDWCxJQUFJLENBQUNMLElBQUksR0FBR0Esa0NBQUk7SUFDaEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBLDhDQUFLO0lBQ2xCLElBQUksQ0FBQ0MsR0FBRyxHQUFHQSxrREFBRztJQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHQSx3REFBUztJQUMxQixJQUFJLENBQUNDLGNBQWMsR0FBR0EsNkRBQWM7SUFDcEMsSUFBSSxDQUFDTCxNQUFNLEdBQUdBLCtDQUFNO0lBQ3BCLElBQUksQ0FBQ1EsV0FBVyxDQUFDLENBQUM7RUFDdEI7O0VBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUklDLDhFQUFBLENBQUFILEdBQUE7SUFBQUksR0FBQTtJQUFBQyxLQUFBLEVBU0EsU0FBQUgsWUFBQSxFQUFlO01BQ1g7TUFDQSxJQUFJLENBQUNQLElBQUksQ0FBQ1csTUFBTSxDQUFDQyxJQUFJLENBQUMsQ0FBQzs7TUFFdkI7TUFDQSxJQUFJLENBQUNWLEdBQUcsQ0FBQ1UsSUFBSSxDQUFDLENBQUM7O01BRWY7TUFDQSxJQUFJLENBQUNYLEtBQUssQ0FBQ1csSUFBSSxDQUFDLENBQUM7O01BRWpCO01BQ0EsSUFBSSxDQUFDWixJQUFJLENBQUNhLE9BQU8sQ0FBQ0QsSUFBSSxDQUFDLENBQUM7O01BRXhCO01BQ0EsSUFBSSxDQUFDWixJQUFJLENBQUNjLE9BQU8sQ0FBQ0YsSUFBSSxDQUFDLENBQUM7O01BRXhCO01BQ0EsSUFBSSxDQUFDYixNQUFNLENBQUNhLElBQUksQ0FBQyxDQUFDOztNQUVsQjtNQUNBLElBQUksQ0FBQ1QsU0FBUyxDQUFDUyxJQUFJLENBQUMsQ0FBQzs7TUFFckI7TUFDQSxJQUFJLENBQUNSLGNBQWMsQ0FBQ1EsSUFBSSxDQUFDLENBQUM7O01BRzFCO01BQ0E7SUFDSjtFQUFDO0VBQUEsT0FBQVAsR0FBQTtBQUFBO0FBSUw7QUFDQTtBQUNBO0FBQ0FVLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHLFlBQVc7RUFFekJELE1BQU0sQ0FBQ0UsR0FBRyxHQUFHLElBQUlaLEdBQUcsQ0FBQyxDQUFDO0FBRXhCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsaUVBQWVVLE1BQU0sQ0FBQ0UsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL3NvdXJjZS9qcy9hcHAuanM/NDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm91dGVyIGZyb20gXCIuL3JvdXRlclwiO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi9jb3JlXCI7XG5pbXBvcnQgaW50cm8gZnJvbSBcIi4vaW50cm9cIjtcbmltcG9ydCBuYXYgZnJvbSBcIi4vY2xhc3MvTmF2XCI7XG5pbXBvcnQgaW1hZ2VMb29wIGZyb20gXCIuL2NsYXNzL0ltYWdlTG9vcFwiO1xuaW1wb3J0IGhvdmVyTGlzdEltYWdlIGZyb20gXCIuL2NsYXNzL0hvdmVyTGlzdEltYWdlXCI7XG5cblxuLyoqXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzIEFwcFxuICogQGNsYXNzZGVzYyBMb2FkIHRoZSBBcHAgYXBwbGljYXRpb24gQ2xhc3MgdG8gaGFuZGxlIGl0IEFMTC5cbiAqXG4gKi9cbmNsYXNzIEFwcCB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICB0aGlzLmNvcmUgPSBjb3JlO1xuICAgICAgICB0aGlzLmludHJvID0gaW50cm87XG4gICAgICAgIHRoaXMubmF2ID0gbmF2O1xuICAgICAgICB0aGlzLmltYWdlTG9vcCA9IGltYWdlTG9vcDtcbiAgICAgICAgdGhpcy5ob3Zlckxpc3RJbWFnZSA9IGhvdmVyTGlzdEltYWdlO1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5pbml0TW9kdWxlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgaW5pdE1vZHVsZXNcbiAgICAgKiBAbWVtYmVyb2YgQXBwXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemUgYXBwbGljYXRpb24gbW9kdWxlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRNb2R1bGVzICgpIHtcbiAgICAgICAgLy8gRGV0ZWN0XG4gICAgICAgIHRoaXMuY29yZS5kZXRlY3QuaW5pdCgpO1xuXG4gICAgICAgIC8vIE5hdmlnYXRpb25cbiAgICAgICAgdGhpcy5uYXYuaW5pdCgpO1xuXG4gICAgICAgIC8vIFZpZXdzXG4gICAgICAgIHRoaXMuaW50cm8uaW5pdCgpO1xuXG4gICAgICAgIC8vIFNjcm9sbHNcbiAgICAgICAgdGhpcy5jb3JlLnNjcm9sbHMuaW5pdCgpO1xuXG4gICAgICAgIC8vIFJlc2l6ZXNcbiAgICAgICAgdGhpcy5jb3JlLnJlc2l6ZXMuaW5pdCgpO1xuXG4gICAgICAgIC8vIENvbnRyb2xsZXJcbiAgICAgICAgdGhpcy5yb3V0ZXIuaW5pdCgpO1xuXG4gICAgICAgIC8vIEltYWdlIExvb3BcbiAgICAgICAgdGhpcy5pbWFnZUxvb3AuaW5pdCgpO1xuXG4gICAgICAgIC8vIEltYWdlIExpc3QgSG92ZXJcbiAgICAgICAgdGhpcy5ob3Zlckxpc3RJbWFnZS5pbml0KCk7XG5cbiAgICAgICAgXG4gICAgICAgIC8vIEFuYWx5dGljc1xuICAgICAgICAvLyB0aGlzLmFuYWx5dGljcyA9IG5ldyBBbmFseXRpY3MoKTtcbiAgICB9XG59XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwb3NlXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xud2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gIHdpbmRvdy5hcHAgPSBuZXcgQXBwKCk7XG5cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEV4cG9ydFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBkZWZhdWx0IHdpbmRvdy5hcHA7XG4iXSwibmFtZXMiOlsicm91dGVyIiwiY29yZSIsImludHJvIiwibmF2IiwiaW1hZ2VMb29wIiwiaG92ZXJMaXN0SW1hZ2UiLCJBcHAiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbml0TW9kdWxlcyIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwiZGV0ZWN0IiwiaW5pdCIsInNjcm9sbHMiLCJyZXNpemVzIiwid2luZG93Iiwib25sb2FkIiwiYXBwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/app.js\n");

/***/ }),

/***/ "./source/js/class/AnimateController.js":
/*!**********************************************!*\
  !*** ./source/js/class/AnimateController.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-controller/Controller.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(properjs_controller__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core */ \"./source/js/core/index.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/dist/gsap.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(gsap__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n/**\n *\n * @public\n * @global\n * @class AnimateController\n * @param {Element} element The dom element to work with.\n * @classdesc Handle scroll events for a DOMElement.\n *\n */\nvar AnimateController = /*#__PURE__*/function (_Controller) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(AnimateController, _Controller);\n  var _super = _createSuper(AnimateController);\n  function AnimateController(elements) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, AnimateController);\n    _this = _super.call(this);\n    _this.elements = elements;\n    _this.appTransitionIn = _this.transitionIn.bind((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_this));\n    _core__WEBPACK_IMPORTED_MODULE_7__.emitter.on(\"app--transition-in\", _this.appTransitionIn);\n    _this.start();\n    return _this;\n  }\n\n  /**\n   *\n   * @instance\n   * @description Initialize the animation frame\n   * @memberof AnimateController\n   * @method start\n   *\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(AnimateController, [{\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n      // Call on parent cycle\n      this.go(function () {\n        _this2.elements.forEach(function (element, i) {\n          if (_core__WEBPACK_IMPORTED_MODULE_7__.util.isElementVisible(element)) {\n            _this2.elements.eq(i).addClass(\"is-animate\");\n          } else {\n            _this2.elements.eq(i).removeClass(\"is-animate\");\n          }\n        });\n      });\n    }\n\n    /**\n     *\n     * @instance\n     * @description Initialize the animation on Transition In\n     * @memberof AnimateController\n     * @method start\n     *\n     */\n  }, {\n    key: \"transitionIn\",\n    value: function transitionIn() {\n      var _this3 = this;\n      //Animate Intro Mask Reveal Elements\n      this.introMask = _core__WEBPACK_IMPORTED_MODULE_7__.dom.body.find(\".js-animate-intro\");\n      if (this.introMask.length > 0) {\n        this.introMask.forEach(function (element, i) {\n          var delay = i * .01;\n          var maskedElement = element.querySelectorAll(\".-masked\");\n          gsap__WEBPACK_IMPORTED_MODULE_8___default().to(maskedElement, {\n            duration: 2,\n            delay: delay,\n            ease: \"expo.out\",\n            y: 0,\n            stagger: .05\n          });\n        });\n      }\n\n      // Animate Intro Fade Elements\n      this.introFade = _core__WEBPACK_IMPORTED_MODULE_7__.dom.body.find(\".js-animate-intro-fade\");\n      if (this.introFade.length > 0) {\n        this.introFade.forEach(function (element, i) {\n          var delay = null;\n          if (i == _this3.introFade.length - 1) {\n            delay = 1;\n          } else {\n            delay = i * .05;\n          }\n          var fadeElement = element.querySelectorAll(\".-fade-item\");\n          gsap__WEBPACK_IMPORTED_MODULE_8___default().to(fadeElement, {\n            duration: 2,\n            delay: delay,\n            opacity: 1,\n            stagger: .02\n          });\n        });\n      }\n    }\n\n    /**\n     *\n     * @instance\n     * @description Stop the animation frame\n     * @memberof AnimateController\n     * @method destroy\n     *\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stop();\n    }\n  }]);\n  return AnimateController;\n}((properjs_controller__WEBPACK_IMPORTED_MODULE_6___default()));\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnimateController);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1MsU0FBUyxDQUFDdEIsT0FBTyxDQUFDLFVBQUVDLE9BQU8sRUFBRUMsQ0FBQyxFQUFNO1VBRXJDLElBQUlZLEtBQUssR0FBRyxJQUFJO1VBRWhCLElBQUdaLENBQUMsSUFBS00sTUFBSSxDQUFDYyxTQUFTLENBQUNULE1BQU0sR0FBRyxDQUFFLEVBQUM7WUFDaENDLEtBQUssR0FBRyxDQUFDO1VBQ2IsQ0FBQyxNQUFJO1lBQ0RBLEtBQUssR0FBR1osQ0FBQyxHQUFHLEdBQUc7VUFDbkI7VUFFQSxJQUFJcUIsV0FBVyxHQUFHdEIsT0FBTyxDQUFDZSxnQkFBZ0IsQ0FBQyxhQUFhLENBQUM7VUFDekR0Qyw4Q0FBTyxDQUFFNkMsV0FBVyxFQUFHO1lBQUNMLFFBQVEsRUFBRSxDQUFDO1lBQUVKLEtBQUssRUFBRUEsS0FBSztZQUFFVSxPQUFPLEVBQUUsQ0FBQztZQUFFSCxPQUFPLEVBQUU7VUFBRyxDQUFDLENBQUM7UUFDakYsQ0FBQyxDQUFDO01BQ047SUFJSjs7SUFHQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUEk7SUFBQXpCLEdBQUE7SUFBQUMsS0FBQSxFQVFBLFNBQUE0QixRQUFBLEVBQVc7TUFDUCxJQUFJLENBQUNDLElBQUksQ0FBQyxDQUFDO0lBQ2Y7RUFBQztFQUFBLE9BQUEvQyxpQkFBQTtBQUFBLEVBL0YyQkgsNERBQVU7QUFvRzFDO0FBQ0E7QUFDQTtBQUNBLGlFQUFlRyxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY2xhc3MvQW5pbWF0ZUNvbnRyb2xsZXIuanM/ZGZjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udHJvbGxlciBmcm9tIFwicHJvcGVyanMtY29udHJvbGxlclwiO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcblxuLyoqXG4gKlxuICogQHB1YmxpY1xuICogQGdsb2JhbFxuICogQGNsYXNzIEFuaW1hdGVDb250cm9sbGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGRvbSBlbGVtZW50IHRvIHdvcmsgd2l0aC5cbiAqIEBjbGFzc2Rlc2MgSGFuZGxlIHNjcm9sbCBldmVudHMgZm9yIGEgRE9NRWxlbWVudC5cbiAqXG4gKi9cbmNsYXNzIEFuaW1hdGVDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IgKCBlbGVtZW50cyApIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG5cbiAgICAgICAgdGhpcy5hcHBUcmFuc2l0aW9uSW4gPSB0aGlzLnRyYW5zaXRpb25Jbi5iaW5kKCB0aGlzICk7XG4gICAgICAgIGNvcmUuZW1pdHRlci5vbiggXCJhcHAtLXRyYW5zaXRpb24taW5cIiwgdGhpcy5hcHBUcmFuc2l0aW9uSW4gKTtcblxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplIHRoZSBhbmltYXRpb24gZnJhbWVcbiAgICAgKiBAbWVtYmVyb2YgQW5pbWF0ZUNvbnRyb2xsZXJcbiAgICAgKiBAbWV0aG9kIHN0YXJ0XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGFydCAoKSB7XG4gICAgICAgIC8vIENhbGwgb24gcGFyZW50IGN5Y2xlXG4gICAgICAgIHRoaXMuZ28oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKCggZWxlbWVudCwgaSApID0IHtcbiAgICAgICAgICAgICAgICBpZiAoIGNvcmUudXRpbC5pc0VsZW1lbnRWaXNpYmxlKCBlbGVtZW50ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuZXEoIGkgKS5hZGRDbGFzcyggXCJpcy1hbmltYXRlXCIgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuZXEoIGkgKS5yZW1vdmVDbGFzcyggXCJpcy1hbmltYXRlXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplIHRoZSBhbmltYXRpb24gb24gVHJhbnNpdGlvbiBJblxuICAgICAqIEBtZW1iZXJvZiBBbmltYXRlQ29udHJvbGxlclxuICAgICAqIEBtZXRob2Qgc3RhcnRcbiAgICAgKlxuICAgICAqL1xuICAgIHRyYW5zaXRpb25Jbigpe1xuXG4gICAgICAgIC8vQW5pbWF0ZSBJbnRybyBNYXNrIFJldmVhbCBFbGVtZW50c1xuICAgICAgICB0aGlzLmludHJvTWFzayA9IGNvcmUuZG9tLmJvZHkuZmluZChcIi5qcy1hbmltYXRlLWludHJvXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLmludHJvTWFzay5sZW5ndGggPiAwICl7XG5cbiAgICAgICAgICAgIHRoaXMuaW50cm9NYXNrLmZvckVhY2goKCBlbGVtZW50LCBpICkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IGkgKiAuMDE7XG4gICAgICAgICAgICAgICAgbGV0IG1hc2tlZEVsZW1lbnQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuLW1hc2tlZFwiKTtcbiAgICAgICAgICAgICAgICBnc2FwLnRvKCBtYXNrZWRFbGVtZW50ICwge2R1cmF0aW9uOiAyLCBkZWxheTogZGVsYXksIGVhc2U6XCJleHBvLm91dFwiLCB5OiAwLCBzdGFnZ2VyOiAuMDUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cblxuICAgICAgICAvLyBBbmltYXRlIEludHJvIEZhZGUgRWxlbWVudHNcbiAgICAgICAgdGhpcy5pbnRyb0ZhZGUgPSBjb3JlLmRvbS5ib2R5LmZpbmQoXCIuanMtYW5pbWF0ZS1pbnRyby1mYWRlXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLmludHJvRmFkZS5sZW5ndGggPiAwICl7XG4gICAgICBcbiAgICAgICAgICAgIHRoaXMuaW50cm9GYWRlLmZvckVhY2goKCBlbGVtZW50LCBpICkgPT4ge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZihpID09ICh0aGlzLmludHJvRmFkZS5sZW5ndGggLSAxKSl7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gMTtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBpICogLjA1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgZmFkZUVsZW1lbnQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuLWZhZGUtaXRlbVwiKTtcbiAgICAgICAgICAgICAgICBnc2FwLnRvKCBmYWRlRWxlbWVudCAsIHtkdXJhdGlvbjogMiwgZGVsYXk6IGRlbGF5LCBvcGFjaXR5OiAxLCBzdGFnZ2VyOiAuMDJ9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgXG4gICAgICAgICAgIFxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZGVzY3JpcHRpb24gU3RvcCB0aGUgYW5pbWF0aW9uIGZyYW1lXG4gICAgICogQG1lbWJlcm9mIEFuaW1hdGVDb250cm9sbGVyXG4gICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95ICgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwb3J0XG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGRlZmF1bHQgQW5pbWF0ZUNvbnRyb2xsZXI7XG5cblxuIl0sIm5hbWVzIjpbIkNvbnRyb2xsZXIiLCJjb3JlIiwiZ3NhcCIsIkFuaW1hdGVDb250cm9sbGVyIiwiX0NvbnRyb2xsZXIiLCJfaW5oZXJpdHMiLCJfc3VwZXIiLCJfY3JlYXRlU3VwZXIiLCJlbGVtZW50cyIsIl90aGlzIiwiX2NsYXNzQ2FsbENoZWNrIiwiY2FsbCIsImFwcFRyYW5zaXRpb25JbiIsInRyYW5zaXRpb25JbiIsImJpbmQiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiZW1pdHRlciIsIm9uIiwic3RhcnQiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsIl90aGlzMiIsImdvIiwiZm9yRWFjaCIsImVsZW1lbnQiLCJpIiwidXRpbCIsImlzRWxlbWVudFZpc2libGUiLCJlcSIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJfdGhpczMiLCJpbnRyb01hc2siLCJkb20iLCJib2R5IiwiZmluZCIsImxlbmd0aCIsImRlbGF5IiwibWFza2VkRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0byIsImR1cmF0aW9uIiwiZWFzZSIsInkiLCJzdGFnZ2VyIiwiaW50cm9GYWRlIiwiZmFkZUVsZW1lbnQiLCJvcGFjaXR5IiwiZGVzdHJveSIsInN0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/class/AnimateController.js\n");

/***/ }),

/***/ "./source/js/class/Bar.js":
/*!********************************!*\
  !*** ./source/js/class/Bar.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core */ \"./source/js/core/index.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/dist/gsap.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gsap__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! properjs-hobo */ \"./node_modules/properjs-hobo/dist/hobo.build.js\");\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(properjs_hobo__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\nvar _instance = null;\nvar $_jsBar = properjs_hobo__WEBPACK_IMPORTED_MODULE_3___default()('<div class=\"load-bar\"><div class=\"bar-inner\"></div></div>');\nvar $_jsInner = $_jsBar.find(\".bar-inner\");\nvar barCounter = {\n  width: 0\n};\n\n/**\n *\n * @private\n * @class Bar\n * @classdesc Shimmed load bars set a high initial animation duration\n *            that can be stopped and completed upon request.\n * @memberof loading\n *\n */\nvar Bar = /*#__PURE__*/function () {\n  function Bar() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Bar);\n    this.tween = null;\n    this.timeout = 5;\n  }\n\n  /**\n   *\n   * @instance\n   * @method append\n   * @memberof loading.Bar\n   * @description Append the element to the DOM.\n   *\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Bar, [{\n    key: \"append\",\n    value: function append() {\n      _core__WEBPACK_IMPORTED_MODULE_2__.dom.body.append($_jsBar);\n    }\n\n    /**\n     *\n     * @instance\n     * @method load\n     * @memberof loading.Bar\n     * @description Initialize the load bar ui for progress shim.\n     *\n     */\n  }, {\n    key: \"load\",\n    value: function load() {\n      this.append();\n      this.tween = gsap__WEBPACK_IMPORTED_MODULE_4___default().to(barCounter, this.timeout, {\n        width: window.innerWidth,\n        onUpdate: this.update.bind()\n      });\n    }\n\n    /**\n     *\n     * @instance\n     * @method stop\n     * @param {function} callback The function to call when Tween is complete\n     * @memberof loading.Bar\n     * @description Terminate the load bar animation.\n     *\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      this.tween.kill();\n      var bar = this.getFrom();\n      this.tween = gsap__WEBPACK_IMPORTED_MODULE_4___default().fromTo(barCounter, .5, {\n        bar: bar\n      }, {\n        width: window.innerWidth,\n        onUpdate: this.update.bind(),\n        onComplete: this.complete.bind(this, callback),\n        ease: 'easeInOutCirc'\n      });\n    }\n\n    /**\n     *\n     * @instance\n     * @method update\n     * @param {number} value The new value to tween to\n     * @memberof loading.Bar\n     * @description Animate/Tween the load bar ui.\n     *\n     */\n  }, {\n    key: \"update\",\n    value: function update() {\n      $_jsInner[0].style.width = _core__WEBPACK_IMPORTED_MODULE_2__.util.px(barCounter.width);\n    }\n\n    /**\n     *\n     * @instance\n     * @method complete\n     * @param {function} callback The function to call when transition is complete\n     * @memberof loading.Bar\n     * @description Complete the load bar ui sequence and detach the node.\n     *\n     */\n  }, {\n    key: \"complete\",\n    value: function complete(callback) {\n      $_jsBar.addClass(\"is-done\");\n      setTimeout(function () {\n        $_jsBar.detach().removeClass(\"is-done\");\n        $_jsInner.attr(\"style\", \"\");\n        barCounter.width = 0;\n        callback();\n      }, _core__WEBPACK_IMPORTED_MODULE_2__.util.getTransitionDuration($_jsBar[0]));\n    }\n\n    /**\n     *\n     * @instance\n     * @method getFrom\n     * @memberof loading.Bar\n     * @description Get the current value to tween from.\\\n     * @returns {number}\n     *\n     */\n  }, {\n    key: \"getFrom\",\n    value: function getFrom() {\n      return $_jsInner[0].clientWidth;\n    }\n  }]);\n  return Bar;\n}();\n/**\n *\n * @public\n * @namespace bar\n * @description Performs a loader bar interaction.\n * @memberof loading\n *\n */\nvar bar = {\n  /**\n   *\n   * @public\n   * @method load\n   * @param {string} position The placement position for the load bar.\n   * @param {string} color The optional color tone for the load bar.\n   * @memberof loading.bar\n   * @description Shims a \"loading\" progress bar based on... nothing!\n   *\n   */\n  load: function load(position, color) {\n    _instance = new Bar(position, color);\n    _instance.load();\n  },\n  /**\n   *\n   * @public\n   * @method stop\n   * @memberof loading.bar\n   * @description Stops load bar animation and removes the bar instance.\n   *\n   */\n  stop: function stop() {\n    if (_instance) {\n      _instance.stop(function () {\n        _instance = null;\n      });\n    }\n  }\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bar);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cEMsU0FBUyxDQUFDcUMsSUFBSSxDQUFFLE9BQU8sRUFBRSxFQUFHLENBQUM7UUFFN0JuQyxVQUFVLENBQUNDLEtBQUssR0FBRyxDQUFDO1FBRXBCbUIsUUFBUSxDQUFDLENBQUM7TUFFZCxDQUFDLEVBQUUzQiw2REFBK0IsQ0FBRUksT0FBTyxDQUFFLENBQUMsQ0FBRyxDQUFFLENBQUM7SUFDeEQ7O0lBS0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUkk7SUFBQVUsR0FBQTtJQUFBQyxLQUFBLEVBU0EsU0FBQWUsUUFBQSxFQUFXO01BQ1AsT0FBT3pCLFNBQVMsQ0FBRSxDQUFDLENBQUUsQ0FBQ3VDLFdBQVc7SUFDckM7RUFBQztFQUFBLE9BQUFuQyxHQUFBO0FBQUE7QUFJTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTW9CLEdBQUcsR0FBRztFQUdSO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lWLElBQUksV0FBQUEsS0FBRzBCLFFBQVEsRUFBRUMsS0FBSyxFQUFHO0lBQ3JCM0MsU0FBUyxHQUFHLElBQUlNLEdBQUcsQ0FBRW9DLFFBQVEsRUFBRUMsS0FBTSxDQUFDO0lBQ3RDM0MsU0FBUyxDQUFDZ0IsSUFBSSxDQUFDLENBQUM7RUFDcEIsQ0FBQztFQUtEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSU8sSUFBSSxXQUFBQSxLQUFBLEVBQUk7SUFDSixJQUFLdkIsU0FBUyxFQUFHO01BQ2JBLFNBQVMsQ0FBQ3VCLElBQUksQ0FBQyxZQUFNO1FBQ2pCdkIsU0FBUyxHQUFHLElBQUk7TUFDcEIsQ0FBQyxDQUFDO0lBQ047RUFDSjtBQUdKLENBQUM7O0FBR0Q7QUFDQTtBQUNBO0FBQ0EsaUVBQWUwQixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vc291cmNlL2pzL2NsYXNzL0Jhci5qcz9jMjMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCI7XG5pbXBvcnQgJCBmcm9tIFwicHJvcGVyanMtaG9ib1wiO1xuXG5cbmxldCBfaW5zdGFuY2UgPSBudWxsO1xuY29uc3QgJF9qc0JhciA9ICQoICc8ZGl2IGNsYXNzPVwibG9hZC1iYXJcIj48ZGl2IGNsYXNzPVwiYmFyLWlubmVyXCIPC9kaXYPC9kaXYJyApO1xuY29uc3QgJF9qc0lubmVyID0gJF9qc0Jhci5maW5kKCBcIi5iYXItaW5uZXJcIiApO1xuY29uc3QgYmFyQ291bnRlciA9IHt3aWR0aDowfVxuXG5cbi8qKlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2xhc3MgQmFyXG4gKiBAY2xhc3NkZXNjIFNoaW1tZWQgbG9hZCBiYXJzIHNldCBhIGhpZ2ggaW5pdGlhbCBhbmltYXRpb24gZHVyYXRpb25cbiAqICAgICAgICAgICAgdGhhdCBjYW4gYmUgc3RvcHBlZCBhbmQgY29tcGxldGVkIHVwb24gcmVxdWVzdC5cbiAqIEBtZW1iZXJvZiBsb2FkaW5nXG4gKlxuICovXG5jbGFzcyBCYXIge1xuXG5cbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHRoaXMudHdlZW4gPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSA1O1xuICAgIH1cblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1ldGhvZCBhcHBlbmRcbiAgICAgKiBAbWVtYmVyb2YgbG9hZGluZy5CYXJcbiAgICAgKiBAZGVzY3JpcHRpb24gQXBwZW5kIHRoZSBlbGVtZW50IHRvIHRoZSBET00uXG4gICAgICpcbiAgICAgKi9cbiAgICBhcHBlbmQgKCkge1xuICAgICAgICBjb3JlLmRvbS5ib2R5LmFwcGVuZCggJF9qc0JhciApO1xuICAgIH1cblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1ldGhvZCBsb2FkXG4gICAgICogQG1lbWJlcm9mIGxvYWRpbmcuQmFyXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemUgdGhlIGxvYWQgYmFyIHVpIGZvciBwcm9ncmVzcyBzaGltLlxuICAgICAqXG4gICAgICovXG4gICAgbG9hZCAoKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKCk7XG5cbiAgICAgICAgdGhpcy50d2VlbiA9IGdzYXAudG8oYmFyQ291bnRlciwgdGhpcy50aW1lb3V0LCB7XG4gICAgICAgICAgd2lkdGg6d2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgb25VcGRhdGU6dGhpcy51cGRhdGUuYmluZCgpXG4gICAgICAgIH0pXG4gICAgfVxuXG5cblxuICAgIFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1ldGhvZCBzdG9wXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBUd2VlbiBpcyBjb21wbGV0ZVxuICAgICAqIEBtZW1iZXJvZiBsb2FkaW5nLkJhclxuICAgICAqIEBkZXNjcmlwdGlvbiBUZXJtaW5hdGUgdGhlIGxvYWQgYmFyIGFuaW1hdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIHN0b3AgKCBjYWxsYmFjayApIHtcbiAgICAgICAgdGhpcy50d2Vlbi5raWxsKCk7XG4gICAgICAgIGNvbnN0IGJhciA9IHRoaXMuZ2V0RnJvbSgpO1xuICAgICAgICB0aGlzLnR3ZWVuID0gZ3NhcC5mcm9tVG8oYmFyQ291bnRlciwgLjUsIHtiYXJ9LCB7XG4gICAgICAgICAgd2lkdGg6d2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgb25VcGRhdGU6dGhpcy51cGRhdGUuYmluZCgpLFxuICAgICAgICAgIG9uQ29tcGxldGU6IHRoaXMuY29tcGxldGUuYmluZCh0aGlzLCBjYWxsYmFjayksXG4gICAgICAgICAgZWFzZTogJ2Vhc2VJbk91dENpcmMnfVxuICAgICAgICApXG4gICAgfVxuXG5cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHR3ZWVuIHRvXG4gICAgICogQG1lbWJlcm9mIGxvYWRpbmcuQmFyXG4gICAgICogQGRlc2NyaXB0aW9uIEFuaW1hdGUvVHdlZW4gdGhlIGxvYWQgYmFyIHVpLlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlICggKSB7XG4gICAgICAgICRfanNJbm5lclsgMCBdLnN0eWxlLndpZHRoID0gY29yZS51dGlsLnB4KGJhckNvdW50ZXIud2lkdGgpO1xuICAgIH1cblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1ldGhvZCBjb21wbGV0ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdHJhbnNpdGlvbiBpcyBjb21wbGV0ZVxuICAgICAqIEBtZW1iZXJvZiBsb2FkaW5nLkJhclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb21wbGV0ZSB0aGUgbG9hZCBiYXIgdWkgc2VxdWVuY2UgYW5kIGRldGFjaCB0aGUgbm9kZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbXBsZXRlICggY2FsbGJhY2sgKSB7XG4gICAgICAgICRfanNCYXIuYWRkQ2xhc3MoIFwiaXMtZG9uZVwiICk7XG5cbiAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgICAgJF9qc0JhclxuICAgICAgICAgICAgICAgIC5kZXRhY2goKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyggXCJpcy1kb25lXCIgKTtcbiAgICAgICAgICAgICRfanNJbm5lci5hdHRyKCBcInN0eWxlXCIsIFwiXCIgKTtcblxuICAgICAgICAgICAgYmFyQ291bnRlci53aWR0aCA9IDA7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG5cbiAgICAgICAgfSwgY29yZS51dGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbiggJF9qc0JhclsgMCBdICkgKTtcbiAgICB9XG5cblxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgZ2V0RnJvbVxuICAgICAqIEBtZW1iZXJvZiBsb2FkaW5nLkJhclxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgdG8gdHdlZW4gZnJvbS5cXFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRGcm9tICgpIHtcbiAgICAgICAgcmV0dXJuICRfanNJbm5lclsgMCBdLmNsaWVudFdpZHRoO1xuICAgIH1cbn1cblxuXG4vKipcbiAqXG4gKiBAcHVibGljXG4gKiBAbmFtZXNwYWNlIGJhclxuICogQGRlc2NyaXB0aW9uIFBlcmZvcm1zIGEgbG9hZGVyIGJhciBpbnRlcmFjdGlvbi5cbiAqIEBtZW1iZXJvZiBsb2FkaW5nXG4gKlxuICovXG5jb25zdCBiYXIgPSB7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiBUaGUgcGxhY2VtZW50IHBvc2l0aW9uIGZvciB0aGUgbG9hZCBiYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIFRoZSBvcHRpb25hbCBjb2xvciB0b25lIGZvciB0aGUgbG9hZCBiYXIuXG4gICAgICogQG1lbWJlcm9mIGxvYWRpbmcuYmFyXG4gICAgICogQGRlc2NyaXB0aW9uIFNoaW1zIGEgXCJsb2FkaW5nXCIgcHJvZ3Jlc3MgYmFyIGJhc2VkIG9uLi4uIG5vdGhpbmchXG4gICAgICpcbiAgICAgKi9cbiAgICBsb2FkICggcG9zaXRpb24sIGNvbG9yICkge1xuICAgICAgICBfaW5zdGFuY2UgPSBuZXcgQmFyKCBwb3NpdGlvbiwgY29sb3IgKTtcbiAgICAgICAgX2luc3RhbmNlLmxvYWQoKTtcbiAgICB9LFxuXG5cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBzdG9wXG4gICAgICogQG1lbWJlcm9mIGxvYWRpbmcuYmFyXG4gICAgICogQGRlc2NyaXB0aW9uIFN0b3BzIGxvYWQgYmFyIGFuaW1hdGlvbiBhbmQgcmVtb3ZlcyB0aGUgYmFyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICovXG4gICAgc3RvcCAoKSB7XG4gICAgICAgIGlmICggX2luc3RhbmNlICkge1xuICAgICAgICAgICAgX2luc3RhbmNlLnN0b3AoKCkgPT4ge1xuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEV4cG9ydFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBkZWZhdWx0IGJhcjsiXSwibmFtZXMiOlsiY29yZSIsImdzYXAiLCIkIiwiX2luc3RhbmNlIiwiJF9qc0JhciIsIiRfanNJbm5lciIsImZpbmQiLCJiYXJDb3VudGVyIiwid2lkdGgiLCJCYXIiLCJfY2xhc3NDYWxsQ2hlY2siLCJ0d2VlbiIsInRpbWVvdXQiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsImFwcGVuZCIsImRvbSIsImJvZHkiLCJsb2FkIiwidG8iLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwib25VcGRhdGUiLCJ1cGRhdGUiLCJiaW5kIiwic3RvcCIsImNhbGxiYWNrIiwia2lsbCIsImJhciIsImdldEZyb20iLCJmcm9tVG8iLCJvbkNvbXBsZXRlIiwiY29tcGxldGUiLCJlYXNlIiwic3R5bGUiLCJ1dGlsIiwicHgiLCJhZGRDbGFzcyIsInNldFRpbWVvdXQiLCJkZXRhY2giLCJyZW1vdmVDbGFzcyIsImF0dHIiLCJnZXRUcmFuc2l0aW9uRHVyYXRpb24iLCJjbGllbnRXaWR0aCIsInBvc2l0aW9uIiwiY29sb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/class/Bar.js\n");

/***/ }),

/***/ "./source/js/class/HoverListImage.js":
/*!*******************************************!*\
  !*** ./source/js/class/HoverListImage.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core */ \"./source/js/core/index.js\");\n/* harmony import */ var _MouseFollow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MouseFollow */ \"./source/js/class/MouseFollow.js\");\n\n\n\n\n\n\n/**\n *\n * @public\n * @namespace hoverListImage\n * @description Executes hoverable images in a list\n * @memberof class\n *\n */\nvar hoverListImage = {\n  /**\n   *\n   * @public\n   * @method init\n   * @memberof hoverListImage\n   * @description Initialize image stack\n   *\n   */\n  init: function init() {\n    _core__WEBPACK_IMPORTED_MODULE_0__.emitter.on(\"app--init\", this.bind.bind(this));\n\n    // Variables\n    this.list = null;\n    this.rowHover = null;\n  },\n  /**\n  *\n  * @public\n  * @method bind\n  * @memberof hoverListImage\n  * @description Bind hoverListImage interactions \n  *\n  */\n  bind: function bind() {\n    var activeImage;\n    this.gallery = \".js-hover-gallery\";\n    var galleryItems = document.querySelector(this.gallery);\n\n    // Check if Hover List exists \n    if (galleryItems === null) {\n      return;\n    }\n\n    // Set initial active image \n    activeImage = galleryItems.querySelector('[data-default=\"true\"]');\n    activeImage.classList.add(\"active\");\n\n    // Row hover elements \n    this.rowHover = document.querySelectorAll(\".js-row-hover\");\n    this.rowHover.forEach(function (row) {\n      // Mouse Enter Row\n      row.addEventListener('mouseover', function hover() {\n        // Fade Siblings\n        var siblings = _core__WEBPACK_IMPORTED_MODULE_0__.util.getSiblings(row.parentElement);\n        siblings.forEach(function (sibling) {\n          sibling.classList.add(\"in-active\");\n        });\n        activeImage.classList.remove(\"active\");\n\n        // Select image within galleryItems\n        var id = row.getAttribute(\"data-project\");\n        activeImage = galleryItems.querySelector('[data-project=\"'  id  '\"]');\n\n        // Add Class to Hovered Row & galleryItems Image\n        row.classList.remove(\"in-active\");\n        activeImage.classList.add(\"active\");\n        var imgSiblings = _core__WEBPACK_IMPORTED_MODULE_0__.util.getSiblings(activeImage);\n        imgSiblings.forEach(function (sibling) {\n          sibling.classList.remove(\"active\");\n        });\n      });\n    });\n  },\n  /**\n   *\n   * @public\n   * @method teardown\n   * @memberof hoverListImage\n   * @description Teardown hoverListImage \n   *\n   */\n  teardown: function teardown() {}\n};\n\n/******************************************************************************\n * Export\n *******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hoverListImage);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY2xhc3MvSG92ZXJMaXN0SW1hZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQ1I7QUFDZ0I7QUFDRDtBQUNROztBQUkvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUssY0FBYyxHQUFHO0VBR25CO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsSUFBSSxXQUFBQSxLQUFBLEVBQUk7SUFFTk4sMENBQVksQ0FBQ1EsRUFBRSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUNDLElBQUksQ0FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztJQUVsRDtJQUNBLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUk7SUFDaEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSTtFQUV0QixDQUFDO0VBS0E7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJRixJQUFJLFdBQUFBLEtBQUEsRUFBSTtJQUdOLElBQUlHLFdBQVc7SUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRyxtQkFBbUI7SUFDbEMsSUFBSUMsWUFBWSxHQUFHQyxRQUFRLENBQUNDLGFBQWEsQ0FBRSxJQUFJLENBQUNILE9BQVEsQ0FBQzs7SUFHekQ7SUFDQSxJQUFJQyxZQUFZLEtBQUssSUFBSSxFQUFDO01BQUU7SUFBTzs7SUFFbkM7SUFDQUYsV0FBVyxHQUFHRSxZQUFZLENBQUNFLGFBQWEsQ0FBQyx1QkFBdUIsQ0FBQztJQUNqRUosV0FBVyxDQUFDSyxTQUFTLENBQUNDLEdBQUcsQ0FBQyxRQUFRLENBQUM7O0lBRW5DO0lBQ0EsSUFBSSxDQUFDUCxRQUFRLEdBQUdJLFFBQVEsQ0FBQ0ksZ0JBQWdCLENBQUMsZUFBZSxDQUFDO0lBRTFELElBQUksQ0FBQ1IsUUFBUSxDQUFDUyxPQUFPLENBQUMsVUFBVUMsR0FBRyxFQUFHO01BR3BDO01BQ0FBLEdBQUcsQ0FBQ0MsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLFNBQVNDLEtBQUtBLENBQUEsRUFBRztRQUVqRDtRQUNBLElBQUlDLFFBQVEsR0FBR3hCLG1EQUFxQixDQUFFcUIsR0FBRyxDQUFDTSxhQUFjLENBQUM7UUFFekRILFFBQVEsQ0FBQ0osT0FBTyxDQUFDLFVBQVVRLE9BQU8sRUFBRztVQUNuQ0EsT0FBTyxDQUFDWCxTQUFTLENBQUNDLEdBQUcsQ0FBQyxXQUFXLENBQUM7UUFDcEMsQ0FBQyxDQUFDO1FBRUZOLFdBQVcsQ0FBQ0ssU0FBUyxDQUFDWSxNQUFNLENBQUMsUUFBUSxDQUFDOztRQUV0QztRQUNBLElBQUlDLEVBQUUsR0FBR1QsR0FBRyxDQUFDVSxZQUFZLENBQUMsY0FBYyxDQUFDO1FBQ3pDbkIsV0FBVyxHQUFHRSxZQUFZLENBQUNFLGFBQWEsQ0FBQyxpQkFBaUIsR0FBR2MsRUFBRSxHQUFHLElBQUksQ0FBQzs7UUFFdkU7UUFDQVQsR0FBRyxDQUFDSixTQUFTLENBQUNZLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFDakNqQixXQUFXLENBQUNLLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLFFBQVEsQ0FBQztRQUVuQyxJQUFJYyxXQUFXLEdBQUdoQyxtREFBcUIsQ0FBQ1ksV0FBWSxDQUFDO1FBQ25Eb0IsV0FBVyxDQUFDWixPQUFPLENBQUMsVUFBVVEsT0FBTyxFQUFHO1VBQ3hDQSxPQUFPLENBQUNYLFNBQVMsQ0FBQ1ksTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUNwQyxDQUFDLENBQUM7TUFDSixDQUFDLENBQUM7SUFFSixDQUFDLENBQUM7RUFHSixDQUFDO0VBR0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJSSxRQUFRLFdBQUFBLFNBQUEsRUFBSSxDQUVaO0FBQ0osQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxpRUFBZTVCLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY2xhc3MvSG92ZXJMaXN0SW1hZ2UuanM/Zjc0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgZ3NhcCBmcm9tIFwiZ3NhcFwiO1xuaW1wb3J0IE1vdXNlRm9sbG93IGZyb20gXCIuL01vdXNlRm9sbG93XCI7XG5pbXBvcnQgRHJhZ2dhYmxlIGZyb20gXCJnc2FwL0RyYWdnYWJsZVwiO1xuaW1wb3J0IEluZXJ0aWFQbHVnaW4gZnJvbSBcImdzYXAvSW5lcnRpYVBsdWdpblwiO1xuXG5cblxuLyoqXG4gKlxuICogQHB1YmxpY1xuICogQG5hbWVzcGFjZSBob3Zlckxpc3RJbWFnZVxuICogQGRlc2NyaXB0aW9uIEV4ZWN1dGVzIGhvdmVyYWJsZSBpbWFnZXMgaW4gYSBsaXN0XG4gKiBAbWVtYmVyb2YgY2xhc3NcbiAqXG4gKi9cbmNvbnN0IGhvdmVyTGlzdEltYWdlID0ge1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgKiBAbWVtYmVyb2YgaG92ZXJMaXN0SW1hZ2VcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZSBpbWFnZSBzdGFja1xuICAgICAqXG4gICAgICovXG4gICAgaW5pdCAoKSB7XG5cbiAgICAgIGNvcmUuZW1pdHRlci5vbihcImFwcC0taW5pdFwiLCB0aGlzLmJpbmQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIFZhcmlhYmxlc1xuICAgICAgdGhpcy5saXN0ID0gbnVsbDtcbiAgICAgIHRoaXMucm93SG92ZXIgPSBudWxsO1xuXG4gICAgfSxcblxuXG5cblxuICAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGJpbmRcbiAgICAgKiBAbWVtYmVyb2YgaG92ZXJMaXN0SW1hZ2VcbiAgICAgKiBAZGVzY3JpcHRpb24gQmluZCBob3Zlckxpc3RJbWFnZSBpbnRlcmFjdGlvbnMgXG4gICAgICpcbiAgICAgKi9cbiAgICBiaW5kICgpIHtcblxuICBcbiAgICAgIGxldCBhY3RpdmVJbWFnZTtcbiAgICAgIHRoaXMuZ2FsbGVyeSA9IFwiLmpzLWhvdmVyLWdhbGxlcnlcIjtcbiAgICAgIGxldCBnYWxsZXJ5SXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCB0aGlzLmdhbGxlcnkgKTtcblxuXG4gICAgICAvLyBDaGVjayBpZiBIb3ZlciBMaXN0IGV4aXN0cyBcbiAgICAgIGlmIChnYWxsZXJ5SXRlbXMgPT09IG51bGwpeyByZXR1cm4gfVxuICAgICAgICBcbiAgICAgIC8vIFNldCBpbml0aWFsIGFjdGl2ZSBpbWFnZSBcbiAgICAgIGFjdGl2ZUltYWdlID0gZ2FsbGVyeUl0ZW1zLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWRlZmF1bHQ9XCJ0cnVlXCJdJyk7XG4gICAgICBhY3RpdmVJbWFnZS5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuXG4gICAgICAvLyBSb3cgaG92ZXIgZWxlbWVudHMgXG4gICAgICB0aGlzLnJvd0hvdmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5qcy1yb3ctaG92ZXJcIik7XG5cbiAgICAgIHRoaXMucm93SG92ZXIuZm9yRWFjaChmdW5jdGlvbiggcm93ICkge1xuXG4gICBcbiAgICAgICAgLy8gTW91c2UgRW50ZXIgUm93XG4gICAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbiBob3ZlcigpIHtcblxuICAgICAgICAgIC8vIEZhZGUgU2libGluZ3NcbiAgICAgICAgICBsZXQgc2libGluZ3MgPSBjb3JlLnV0aWwuZ2V0U2libGluZ3MoIHJvdy5wYXJlbnRFbGVtZW50ICk7XG4gICAgICAgICBcbiAgICAgICAgICBzaWJsaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKCBzaWJsaW5nICkge1xuICAgICAgICAgICAgc2libGluZy5jbGFzc0xpc3QuYWRkKFwiaW4tYWN0aXZlXCIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYWN0aXZlSW1hZ2UuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcblxuICAgICAgICAgIC8vIFNlbGVjdCBpbWFnZSB3aXRoaW4gZ2FsbGVyeUl0ZW1zXG4gICAgICAgICAgbGV0IGlkID0gcm93LmdldEF0dHJpYnV0ZShcImRhdGEtcHJvamVjdFwiKTtcbiAgICAgICAgICBhY3RpdmVJbWFnZSA9IGdhbGxlcnlJdGVtcy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1wcm9qZWN0PVwiJyArIGlkICsgJ1wiXScpO1xuXG4gICAgICAgICAgLy8gQWRkIENsYXNzIHRvIEhvdmVyZWQgUm93ICYgZ2FsbGVyeUl0ZW1zIEltYWdlXG4gICAgICAgICAgcm93LmNsYXNzTGlzdC5yZW1vdmUoXCJpbi1hY3RpdmVcIik7XG4gICAgICAgICAgYWN0aXZlSW1hZ2UuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsZXQgaW1nU2libGluZ3MgPSBjb3JlLnV0aWwuZ2V0U2libGluZ3MoYWN0aXZlSW1hZ2UgKTtcbiAgICAgICAgICAgIGltZ1NpYmxpbmdzLmZvckVhY2goZnVuY3Rpb24oIHNpYmxpbmcgKSB7XG4gICAgICAgICAgICBzaWJsaW5nLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcblxuXG4gICAgfSxcblxuICBcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIHRlYXJkb3duXG4gICAgICogQG1lbWJlcm9mIGhvdmVyTGlzdEltYWdlXG4gICAgICogQGRlc2NyaXB0aW9uIFRlYXJkb3duIGhvdmVyTGlzdEltYWdlIFxuICAgICAqXG4gICAgICovXG4gICAgdGVhcmRvd24gKCkge1xuXG4gICAgfVxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwb3J0XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBkZWZhdWx0IGhvdmVyTGlzdEltYWdlOyJdLCJuYW1lcyI6WyJjb3JlIiwiZ3NhcCIsIk1vdXNlRm9sbG93IiwiRHJhZ2dhYmxlIiwiSW5lcnRpYVBsdWdpbiIsImhvdmVyTGlzdEltYWdlIiwiaW5pdCIsImVtaXR0ZXIiLCJvbiIsImJpbmQiLCJsaXN0Iiwicm93SG92ZXIiLCJhY3RpdmVJbWFnZSIsImdhbGxlcnkiLCJnYWxsZXJ5SXRlbXMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJjbGFzc0xpc3QiLCJhZGQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsInJvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJob3ZlciIsInNpYmxpbmdzIiwidXRpbCIsImdldFNpYmxpbmdzIiwicGFyZW50RWxlbWVudCIsInNpYmxpbmciLCJyZW1vdmUiLCJpZCIsImdldEF0dHJpYnV0ZSIsImltZ1NpYmxpbmdzIiwidGVhcmRvd24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/class/HoverListImage.js\n");

/***/ }),

/***/ "./source/js/class/ImageController.js":
/*!********************************************!*\
  !*** ./source/js/class/ImageController.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _core_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/util */ \"./source/js/core/util.js\");\n/* harmony import */ var _core_log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/log */ \"./source/js/core/log.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-controller/Controller.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(properjs_controller__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! properjs-hobo */ \"./node_modules/properjs-hobo/dist/hobo.build.js\");\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(properjs_hobo__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n/**\n *\n * @public\n * @class ImageController\n * @param {Hobo} $images The image collection to load\n * @classdesc Handles breaking out the preload vs lazyload batches\n * @memberof core\n *\n */\nvar ImageController = /*#__PURE__*/function (_Controller) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ImageController, _Controller);\n  var _super = _createSuper(ImageController);\n  function ImageController($images) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, ImageController);\n    _this = _super.call(this);\n\n    //this.$preload = util.getElementsInView( $images );\n    // Preload All Images\n    _this.$preload = $images;\n    _this.$lazyload = $images.not(_this.$preload);\n    _this.loaders = {};\n    if (_this.$preload.length) {\n      _this.handleLoading(_this.$preload, \"preload\", _core_util__WEBPACK_IMPORTED_MODULE_5__.noop);\n    } else {\n      setTimeout(function () {\n        _this.fire(\"preloaded\");\n      }, 0);\n    }\n    if (_this.$lazyload.length) {\n      _this.handleLoading(_this.$lazyload, \"lazyload\", _core_util__WEBPACK_IMPORTED_MODULE_5__.isElementLoadable);\n    }\n    return _this;\n  }\n\n  /**\n   *\n   * @public\n   * @method handleLoading\n   * @param {Hobo} $images The batch to load\n   * @param {string} event The event to fire\n   * @param {function} handler The executor method to determine image loadability\n   * @memberof core.ImageController\n   * @description ImageLoader instance for loading a batch.\n   *\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ImageController, [{\n    key: \"handleLoading\",\n    value: function handleLoading($images, event, handler) {\n      var _this2 = this;\n      (0,_core_log__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"ImageController \".concat(event, \" queue:\"), $images.length);\n      var curr = 0;\n      this.loaders[event] = _core_util__WEBPACK_IMPORTED_MODULE_5__.loadImages($images, handler);\n      this.loaders[event].on(\"load\", function (elem) {\n        curr;\n        _this2.fire(event, {\n          done: curr,\n          total: $images.length,\n          element: elem\n        });\n      });\n      this.loaders[event].on(\"done\", function () {\n        (0,_core_log__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"ImageController \".concat(event, \"ed:\"), $images.length);\n        _this2.fire(\"\".concat(event, \"ed\"));\n      });\n    }\n\n    /**\n     *\n     * @public\n     * @method destroy\n     * @memberof core.ImageController\n     * @description Stop and kill ImageLoader instances.\n     *\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var loader = null;\n      for (loader in this.loaders) {\n        if (this.loaders.hasOwnProperty(loader)) {\n          this.loaders[loader].stop();\n          this.loaders[loader] = null;\n          delete this.loaders[loader];\n        }\n      }\n    }\n  }]);\n  return ImageController;\n}((properjs_controller__WEBPACK_IMPORTED_MODULE_7___default()));\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageController);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUEsTUFBTSxJQUFJLElBQUksQ0FBQ3RCLE9BQU8sRUFBRztRQUMzQixJQUFLLElBQUksQ0FBQ0EsT0FBTyxDQUFDdUIsY0FBYyxDQUFFRCxNQUFPLENBQUMsRUFBRztVQUN6QyxJQUFJLENBQUN0QixPQUFPLENBQUVzQixNQUFNLENBQUUsQ0FBQ0UsSUFBSSxDQUFDLENBQUM7VUFDN0IsSUFBSSxDQUFDeEIsT0FBTyxDQUFFc0IsTUFBTSxDQUFFLEdBQUcsSUFBSTtVQUU3QixPQUFPLElBQUksQ0FBQ3RCLE9BQU8sQ0FBRXNCLE1BQU0sQ0FBRTtRQUNqQztNQUNKO0lBQ0o7RUFBQztFQUFBLE9BQUFsQyxlQUFBO0FBQUEsRUEvRXlCRiw0REFBVTtBQW9GeEM7QUFDQTtBQUNBO0FBQ0EsaUVBQWVFLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY2xhc3MvSW1hZ2VDb250cm9sbGVyLmpzPzJmMDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi4vY29yZS91dGlsXCI7XG5pbXBvcnQgbG9nIGZyb20gXCIuLi9jb3JlL2xvZ1wiO1xuaW1wb3J0IENvbnRyb2xsZXIgZnJvbSBcInByb3BlcmpzLWNvbnRyb2xsZXJcIjtcbmltcG9ydCAkIGZyb20gXCJwcm9wZXJqcy1ob2JvXCI7XG5cblxuLyoqXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzIEltYWdlQ29udHJvbGxlclxuICogQHBhcmFtIHtIb2JvfSAkaW1hZ2VzIFRoZSBpbWFnZSBjb2xsZWN0aW9uIHRvIGxvYWRcbiAqIEBjbGFzc2Rlc2MgSGFuZGxlcyBicmVha2luZyBvdXQgdGhlIHByZWxvYWQgdnMgbGF6eWxvYWQgYmF0Y2hlc1xuICogQG1lbWJlcm9mIGNvcmVcbiAqXG4gKi9cbmNsYXNzIEltYWdlQ29udHJvbGxlciBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yICggJGltYWdlcyApIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvL3RoaXMuJHByZWxvYWQgPSB1dGlsLmdldEVsZW1lbnRzSW5WaWV3KCAkaW1hZ2VzICk7XG4gICAgICAgIC8vIFByZWxvYWQgQWxsIEltYWdlc1xuICAgICAgICB0aGlzLiRwcmVsb2FkID0gJGltYWdlcztcbiAgICAgICAgdGhpcy4kbGF6eWxvYWQgPSAkaW1hZ2VzLm5vdCggdGhpcy4kcHJlbG9hZCApO1xuICAgICAgICB0aGlzLmxvYWRlcnMgPSB7fTtcblxuICAgICAgICBpZiAoIHRoaXMuJHByZWxvYWQubGVuZ3RoICkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVMb2FkaW5nKCB0aGlzLiRwcmVsb2FkLCBcInByZWxvYWRcIiwgdXRpbC5ub29wICk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSggXCJwcmVsb2FkZWRcIiApO1xuXG4gICAgICAgICAgICB9LCAwICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuJGxhenlsb2FkLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTG9hZGluZyggdGhpcy4kbGF6eWxvYWQsIFwibGF6eWxvYWRcIiwgdXRpbC5pc0VsZW1lbnRMb2FkYWJsZSApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGhhbmRsZUxvYWRpbmdcbiAgICAgKiBAcGFyYW0ge0hvYm99ICRpbWFnZXMgVGhlIGJhdGNoIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHRvIGZpcmVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBleGVjdXRvciBtZXRob2QgdG8gZGV0ZXJtaW5lIGltYWdlIGxvYWRhYmlsaXR5XG4gICAgICogQG1lbWJlcm9mIGNvcmUuSW1hZ2VDb250cm9sbGVyXG4gICAgICogQGRlc2NyaXB0aW9uIEltYWdlTG9hZGVyIGluc3RhbmNlIGZvciBsb2FkaW5nIGEgYmF0Y2guXG4gICAgICpcbiAgICAgKi9cbiAgICBoYW5kbGVMb2FkaW5nICggJGltYWdlcywgZXZlbnQsIGhhbmRsZXIgKSB7XG4gICAgICAgIGxvZyggYEltYWdlQ29udHJvbGxlciAke2V2ZW50fSBxdWV1ZTpgLCAkaW1hZ2VzLmxlbmd0aCApO1xuXG4gICAgICAgIGxldCBjdXJyID0gMDtcblxuICAgICAgICB0aGlzLmxvYWRlcnNbIGV2ZW50IF0gPSB1dGlsLmxvYWRJbWFnZXMoICRpbWFnZXMsIGhhbmRsZXIgKTtcbiAgICAgICAgdGhpcy5sb2FkZXJzWyBldmVudCBdLm9uKCBcImxvYWRcIiwgKCBlbGVtICkgPT4ge1xuICAgICAgICAgICAgY3VycisrO1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoIGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgZG9uZTogY3VycixcbiAgICAgICAgICAgICAgICB0b3RhbDogJGltYWdlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxvYWRlcnNbIGV2ZW50IF0ub24oIFwiZG9uZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBsb2coIGBJbWFnZUNvbnRyb2xsZXIgJHtldmVudH1lZDpgLCAkaW1hZ2VzLmxlbmd0aCApO1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoIGAke2V2ZW50fWVkYCApO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqIEBtZW1iZXJvZiBjb3JlLkltYWdlQ29udHJvbGxlclxuICAgICAqIEBkZXNjcmlwdGlvbiBTdG9wIGFuZCBraWxsIEltYWdlTG9hZGVyIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3kgKCkge1xuICAgICAgICBsZXQgbG9hZGVyID0gbnVsbDtcblxuICAgICAgICBmb3IgKCBsb2FkZXIgaW4gdGhpcy5sb2FkZXJzICkge1xuICAgICAgICAgICAgaWYgKCB0aGlzLmxvYWRlcnMuaGFzT3duUHJvcGVydHkoIGxvYWRlciApICkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyc1sgbG9hZGVyIF0uc3RvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyc1sgbG9hZGVyIF0gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1sgbG9hZGVyIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvcnRcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZGVmYXVsdCBJbWFnZUNvbnRyb2xsZXI7Il0sIm5hbWVzIjpbInV0aWwiLCJsb2ciLCJDb250cm9sbGVyIiwiJCIsIkltYWdlQ29udHJvbGxlciIsIl9Db250cm9sbGVyIiwiX2luaGVyaXRzIiwiX3N1cGVyIiwiX2NyZWF0ZVN1cGVyIiwiJGltYWdlcyIsIl90aGlzIiwiX2NsYXNzQ2FsbENoZWNrIiwiY2FsbCIsIiRwcmVsb2FkIiwiJGxhenlsb2FkIiwibm90IiwibG9hZGVycyIsImxlbmd0aCIsImhhbmRsZUxvYWRpbmciLCJub29wIiwic2V0VGltZW91dCIsImZpcmUiLCJpc0VsZW1lbnRMb2FkYWJsZSIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwiZXZlbnQiLCJoYW5kbGVyIiwiX3RoaXMyIiwiY29uY2F0IiwiY3VyciIsImxvYWRJbWFnZXMiLCJvbiIsImVsZW0iLCJkb25lIiwidG90YWwiLCJlbGVtZW50IiwiZGVzdHJveSIsImxvYWRlciIsImhhc093blByb3BlcnR5Iiwic3RvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/class/ImageController.js\n");

/***/ }),

/***/ "./source/js/class/ImageLoop.js":
/*!**************************************!*\
  !*** ./source/js/class/ImageLoop.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core */ \"./source/js/core/index.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/dist/gsap.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(gsap__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _class_MouseFollow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../class/MouseFollow */ \"./source/js/class/MouseFollow.js\");\n/* harmony import */ var gsap_Draggable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap/Draggable */ \"./node_modules/gsap/Draggable.js\");\n/* harmony import */ var gsap_InertiaPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gsap/InertiaPlugin */ \"./node_modules/gsap/InertiaPlugin.js\");\n\n\n\n\n\n\n/**\n *\n * @public\n * @namespace imageLoop\n * @description Executes flashing images in array, at a set FPS\n * @memberof class\n *\n */\nvar imageLoop = {\n  /**\n   *\n   * @public\n   * @method init\n   * @memberof imageLoop\n   * @description Initialize image stack\n   *\n   */\n  init: function init() {\n    var _this = this;\n    _core__WEBPACK_IMPORTED_MODULE_0__.emitter.on(\"app--init\", this.bind.bind(this));\n    _core__WEBPACK_IMPORTED_MODULE_0__.emitter.on(\"app--resize-debounced\", this.reCalcDragger.bind(this));\n    gsap__WEBPACK_IMPORTED_MODULE_2___default().registerPlugin(gsap_Draggable__WEBPACK_IMPORTED_MODULE_3__[\"default\"], gsap_InertiaPlugin__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n\n    // Variables\n    this.fps = null;\n    this.featuredImage = 0;\n    this.imageStack = null;\n    this.numberOfItems = null;\n    this.imageContainer = null;\n\n    // Reset loop on App view change \n    _core__WEBPACK_IMPORTED_MODULE_0__.emitter.on(\"app--view-change\", function () {\n      _this.fps.pause();\n      _this.mouseFollow.stop();\n      // Reset styles \n      setTimeout(function () {\n        _this.imageContainer[0].removeAttribute('style');\n      }, _core__WEBPACK_IMPORTED_MODULE_0__.config.defaultDuration);\n    });\n  },\n  /**\n  *\n  * @public\n  * @method bind\n  * @memberof imageLoop\n  * @description Bind imageLoop interactions \n  *\n  */\n  bind: function bind() {\n    var _this2 = this;\n    // Select Images in Loop\n    this.imageStack = document.querySelectorAll(\".js-image-loop .js-image-stack\");\n    this.imageContainer = _core__WEBPACK_IMPORTED_MODULE_0__.dom.body.find(\".js-image-loop\");\n\n    // Remove browser drag on images\n    var images = document.querySelectorAll(\"img\");\n    images.forEach(function (img) {\n      img.addEventListener('dragstart', function (event) {\n        event.preventDefault();\n      });\n    });\n\n    // Set current featured item in archive stack\n    this.imageStack[this.featuredImage].style.display = \"\";\n    this.imageStack[this.featuredImage].classList.remove(\"hide-img\");\n\n    // Gather images \n    this.numberOfItems = this.imageStack.length;\n\n    // Initialize Mouse Following based on non-touch devices\n    this.follow = \".js-image-loop\";\n    this.mouseFollow = new _class_MouseFollow__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.follow);\n\n    // Initialize Draggable based on touch devices\n    this.dragBoundsHeight = null;\n    this.dragBoundsWidth = null;\n    this.dragBoundsLeft = null;\n    this.dragBoundsTop = null;\n    this.draggable = null;\n    this.dragger();\n\n    /**\n     *\n     * @public\n     * @method fps\n     * @memberof imageLoop\n     * @description Bind new fpsLoop\n     *\n     */\n    this.fps = new this.fpsLoop(2, function (e) {\n      _this2.imageStack[_this2.featuredImage].classList.add(\"hide-img\");\n      if (_this2.featuredImage == _this2.numberOfItems - 1) {\n        _this2.featuredImage = 0;\n      } else {\n        _this2.featuredImage;\n      }\n      _this2.imageStack[_this2.featuredImage].classList.remove(\"hide-img\");\n    });\n\n    /**\n     *\n     * @public\n     * @method imageContainer\n     * @memberof imageLoop\n     * @description Action for toggling image loop on/off\n     *\n     */\n    this.imageContainer.on(\"click\", function (e) {\n      if (_this2.fps.isPlaying) {\n        _this2.fps.pause();\n        document.documentElement.classList.remove(\"loop-active\");\n        _this2.mouseFollow.stop();\n      } else {\n        document.documentElement.classList.add(\"loop-active\");\n        _this2.fps.start();\n        _this2.mouseFollow.start();\n      }\n    });\n  },\n  /**\n   *\n   * @method dragger\n   * @memberof imageLoop\n   * @param  \n   * @description Initliaze drag on drag enabled elements\n   *\n   */\n  dragger: function dragger() {\n    if (_core__WEBPACK_IMPORTED_MODULE_0__.detect.isMobile()) {\n      this.dragBoundsHeight = window.innerHeight * 1.3;\n      this.dragBoundsWidth = window.innerWidth * 1.3;\n      this.dragBoundsLeft = -((window.innerWidth * 1.3 - window.innerWidth) / 2);\n      this.dragBoundsTop = -((window.innerHeight * 1.3 - window.innerHeight) / 2);\n      this.draggable = gsap_Draggable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create(this.imageContainer, {\n        bounds: {\n          top: this.dragBoundsTop,\n          left: this.dragBoundsLeft,\n          width: this.dragBoundsWidth,\n          height: this.dragBoundsHeight\n        },\n        throwProps: true,\n        edgeResistance: 0.6,\n        dragResistance: 0.3,\n        callbackScope: this,\n        onDragStart: this.dragStart\n      });\n    }\n  },\n  /**\n   *\n   * @method draw\n   * @memberof imageLoop\n   * @param  \n   * @description dragStart\n   *\n   */\n  dragStart: function dragStart() {\n    if (!this.fps.isPlaying) {\n      document.documentElement.classList.add(\"archive-active\");\n      this.fps.start();\n    }\n  },\n  /**\n   *\n   * @method reCalcDragger\n   * @memberof imageLoop\n   * @param  \n   * @description reCalculate bounds on resize\n   *\n   */\n  reCalcDragger: function reCalcDragger() {\n    if (_core__WEBPACK_IMPORTED_MODULE_0__.detect.isMobile()) {\n      this.draggable[0].kill();\n      this.dragger();\n    }\n  },\n  /**\n   *\n   * @method fpsLoop\n   * @memberof imageLoop\n   * @param fps Frames per second\n   * @description Run through a sequence at a set duration\n   *\n   */\n  fpsLoop: function fpsLoop(fps, callback) {\n    var delay = 500;\n    var time = null;\n    var frame = -1;\n    var tref;\n    function loop(timestamp) {\n      if (time === null) time = timestamp;\n      var seg = Math.floor((timestamp - time) / delay);\n      if (seg > frame) {\n        frame = seg;\n        callback({\n          time: timestamp,\n          frame: frame\n        });\n      }\n      tref = requestAnimationFrame(loop);\n    }\n    this.isPlaying = false;\n    this.frameRate = function (newfps) {\n      if (!arguments.length) return fps;\n      fps = newfps;\n      delay = 1000 / fps;\n      frame = -1;\n      time = null;\n    };\n    this.start = function () {\n      if (!this.isPlaying) {\n        this.isPlaying = true;\n        tref = requestAnimationFrame(loop);\n      }\n    };\n    this.pause = function () {\n      if (this.isPlaying) {\n        cancelAnimationFrame(tref);\n        this.isPlaying = false;\n        time = null;\n        frame = -1;\n      }\n    };\n  },\n  /**\n   *\n   * @public\n   * @method teardown\n   * @memberof imageLoop\n   * @description Teardown imageLoop \n   *\n   */\n  teardown: function teardown() {}\n};\n\n/******************************************************************************\n * Export\n *******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (imageLoop);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY2xhc3MvSW1hZ2VMb29wLmpzP2M5YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcbmltcG9ydCBNb3VzZUZvbGxvdyBmcm9tIFwiLi4vY2xhc3MvTW91c2VGb2xsb3dcIjtcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSBcImdzYXAvRHJhZ2dhYmxlXCI7XG5pbXBvcnQgSW5lcnRpYVBsdWdpbiBmcm9tIFwiZ3NhcC9JbmVydGlhUGx1Z2luXCI7XG5cblxuXG4vKipcbiAqXG4gKiBAcHVibGljXG4gKiBAbmFtZXNwYWNlIGltYWdlTG9vcFxuICogQGRlc2NyaXB0aW9uIEV4ZWN1dGVzIGZsYXNoaW5nIGltYWdlcyBpbiBhcnJheSwgYXQgYSBzZXQgRlBTXG4gKiBAbWVtYmVyb2YgY2xhc3NcbiAqXG4gKi9cbmNvbnN0IGltYWdlTG9vcCA9IHtcbiAgIFxuICBcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgKiBAbWVtYmVyb2YgaW1hZ2VMb29wXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemUgaW1hZ2Ugc3RhY2tcbiAgICAgKlxuICAgICAqL1xuICAgIGluaXQgKCkge1xuXG4gICAgICBjb3JlLmVtaXR0ZXIub24oXCJhcHAtLWluaXRcIiwgdGhpcy5iaW5kLmJpbmQodGhpcykpO1xuICAgICAgY29yZS5lbWl0dGVyLm9uKFwiYXBwLS1yZXNpemUtZGVib3VuY2VkXCIsIHRoaXMucmVDYWxjRHJhZ2dlci5iaW5kKHRoaXMpICk7XG5cbiAgICAgIGdzYXAucmVnaXN0ZXJQbHVnaW4oRHJhZ2dhYmxlLCBJbmVydGlhUGx1Z2luKTtcblxuICAgICAgLy8gVmFyaWFibGVzXG4gICAgICB0aGlzLmZwcyA9IG51bGw7XG4gICAgICB0aGlzLmZlYXR1cmVkSW1hZ2UgPSAwO1xuICAgICAgdGhpcy5pbWFnZVN0YWNrID0gbnVsbDtcbiAgICAgIHRoaXMubnVtYmVyT2ZJdGVtcyA9IG51bGw7XG4gICAgICB0aGlzLmltYWdlQ29udGFpbmVyID0gbnVsbDtcblxuICAgICAgLy8gUmVzZXQgbG9vcCBvbiBBcHAgdmlldyBjaGFuZ2UgXG4gICAgICBjb3JlLmVtaXR0ZXIub24oXCJhcHAtLXZpZXctY2hhbmdlXCIsICgpID0e1xuICAgICAgICB0aGlzLmZwcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLm1vdXNlRm9sbG93LnN0b3AoKTtcbiAgICAgICAgLy8gUmVzZXQgc3R5bGVzIFxuICAgICAgICBzZXRUaW1lb3V0KCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5pbWFnZUNvbnRhaW5lclswXS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIH0sIGNvcmUuY29uZmlnLmRlZmF1bHREdXJhdGlvbiApO1xuICAgICAgfSk7XG5cbiAgICB9LFxuXG5cblxuXG4gICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZXRob2QgYmluZFxuICAgICAqIEBtZW1iZXJvZiBpbWFnZUxvb3BcbiAgICAgKiBAZGVzY3JpcHRpb24gQmluZCBpbWFnZUxvb3AgaW50ZXJhY3Rpb25zIFxuICAgICAqXG4gICAgICovXG4gICAgYmluZCAoKSB7XG5cbiAgICAgIC8vIFNlbGVjdCBJbWFnZXMgaW4gTG9vcFxuICAgICAgdGhpcy5pbWFnZVN0YWNrID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5qcy1pbWFnZS1sb29wIC5qcy1pbWFnZS1zdGFja1wiKTtcbiAgICAgIHRoaXMuaW1hZ2VDb250YWluZXIgPSBjb3JlLmRvbS5ib2R5LmZpbmQoXCIuanMtaW1hZ2UtbG9vcFwiKTtcblxuICAgICAgLy8gUmVtb3ZlIGJyb3dzZXIgZHJhZyBvbiBpbWFnZXNcbiAgICAgIGxldCBpbWFnZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nXCIpO1xuXG4gICAgICBpbWFnZXMuZm9yRWFjaChmdW5jdGlvbiggaW1nICkge1xuICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IGN1cnJlbnQgZmVhdHVyZWQgaXRlbSBpbiBhcmNoaXZlIHN0YWNrXG4gICAgICB0aGlzLmltYWdlU3RhY2tbIHRoaXMuZmVhdHVyZWRJbWFnZSBdLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgdGhpcy5pbWFnZVN0YWNrWyB0aGlzLmZlYXR1cmVkSW1hZ2UgXS5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZS1pbWdcIik7XG5cbiAgICAgIC8vIEdhdGhlciBpbWFnZXMgXG4gICAgICB0aGlzLm51bWJlck9mSXRlbXMgPSB0aGlzLmltYWdlU3RhY2subGVuZ3RoO1xuXG4gICAgICAvLyBJbml0aWFsaXplIE1vdXNlIEZvbGxvd2luZyBiYXNlZCBvbiBub24tdG91Y2ggZGV2aWNlc1xuICAgICAgdGhpcy5mb2xsb3cgPSBcIi5qcy1pbWFnZS1sb29wXCI7XG4gICAgICB0aGlzLm1vdXNlRm9sbG93ID0gbmV3IE1vdXNlRm9sbG93KCB0aGlzLmZvbGxvdyApO1xuXG4gICAgICAvLyBJbml0aWFsaXplIERyYWdnYWJsZSBiYXNlZCBvbiB0b3VjaCBkZXZpY2VzXG4gICAgICB0aGlzLmRyYWdCb3VuZHNIZWlnaHQgPSBudWxsO1xuICAgICAgdGhpcy5kcmFnQm91bmRzV2lkdGggPSBudWxsO1xuICAgICAgdGhpcy5kcmFnQm91bmRzTGVmdCA9IG51bGw7XG4gICAgICB0aGlzLmRyYWdCb3VuZHNUb3AgPSBudWxsO1xuICAgICAgdGhpcy5kcmFnZ2FibGUgPSBudWxsO1xuXG4gICAgICB0aGlzLmRyYWdnZXIoKTtcblxuXG5cblxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICogQG1ldGhvZCBmcHNcbiAgICAgICAqIEBtZW1iZXJvZiBpbWFnZUxvb3BcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBCaW5kIG5ldyBmcHNMb29wXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICB0aGlzLmZwcyA9IG5ldyB0aGlzLmZwc0xvb3AoMiwgKGUpID0IHtcblxuICAgICAgICB0aGlzLmltYWdlU3RhY2tbIHRoaXMuZmVhdHVyZWRJbWFnZSBdLmNsYXNzTGlzdC5hZGQoXCJoaWRlLWltZ1wiKTtcblxuICAgICAgICBpZiggdGhpcy5mZWF0dXJlZEltYWdlID09IHRoaXMubnVtYmVyT2ZJdGVtcyAtMSApe1xuICAgICAgICAgIHRoaXMuZmVhdHVyZWRJbWFnZSA9IDA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHRoaXMuZmVhdHVyZWRJbWFnZSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWFnZVN0YWNrWyB0aGlzLmZlYXR1cmVkSW1hZ2UgXS5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZS1pbWdcIik7XG5cbiAgICAgIH0pO1xuXG5cblxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKiBAbWV0aG9kIGltYWdlQ29udGFpbmVyXG4gICAgICAgKiBAbWVtYmVyb2YgaW1hZ2VMb29wXG4gICAgICAgKiBAZGVzY3JpcHRpb24gQWN0aW9uIGZvciB0b2dnbGluZyBpbWFnZSBsb29wIG9uL29mZlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgdGhpcy5pbWFnZUNvbnRhaW5lci5vbihcImNsaWNrXCIsICggZSApID0IHtcblxuICAgICAgICBpZiAoIHRoaXMuZnBzLmlzUGxheWluZyApe1xuICAgICAgICAgIHRoaXMuZnBzLnBhdXNlKCk7XG4gICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJsb29wLWFjdGl2ZVwiKTtcbiAgICAgICAgICB0aGlzLm1vdXNlRm9sbG93LnN0b3AoKTtcbiAgICAgICAgXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibG9vcC1hY3RpdmVcIik7XG4gICAgICAgICAgdGhpcy5mcHMuc3RhcnQoKTtcbiAgICAgICAgICB0aGlzLm1vdXNlRm9sbG93LnN0YXJ0KCk7XG4gICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgfSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkcmFnZ2VyXG4gICAgICogQG1lbWJlcm9mIGltYWdlTG9vcFxuICAgICAqIEBwYXJhbSAgXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRsaWF6ZSBkcmFnIG9uIGRyYWcgZW5hYmxlZCBlbGVtZW50c1xuICAgICAqXG4gICAgICovXG4gICAgZHJhZ2dlcigpe1xuXG4gICAgICBpZiAoIGNvcmUuZGV0ZWN0LmlzTW9iaWxlKCkgKXtcblxuICAgICAgICB0aGlzLmRyYWdCb3VuZHNIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiAxLjM7XG4gICAgICAgIHRoaXMuZHJhZ0JvdW5kc1dpZHRoID0gd2luZG93LmlubmVyV2lkdGggKiAxLjM7XG4gICAgICAgIHRoaXMuZHJhZ0JvdW5kc0xlZnQgPSAtKCAoICggd2luZG93LmlubmVyV2lkdGggKiAxLjMgKSAtIHdpbmRvdy5pbm5lcldpZHRoICkgLyAyICk7XG4gICAgICAgIHRoaXMuZHJhZ0JvdW5kc1RvcCA9IC0oICggKCB3aW5kb3cuaW5uZXJIZWlnaHQgKiAxLjMgKSAtIHdpbmRvdy5pbm5lckhlaWdodCApIC8gMiApO1xuXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gRHJhZ2dhYmxlLmNyZWF0ZSggdGhpcy5pbWFnZUNvbnRhaW5lciwge1xuICAgICAgICAgIGJvdW5kczp7IHRvcDogdGhpcy5kcmFnQm91bmRzVG9wLCBsZWZ0OiB0aGlzLmRyYWdCb3VuZHNMZWZ0LCB3aWR0aDogdGhpcy5kcmFnQm91bmRzV2lkdGggLCBoZWlnaHQ6IHRoaXMuZHJhZ0JvdW5kc0hlaWdodCB9LFxuICAgICAgICAgIHRocm93UHJvcHM6dHJ1ZSxcbiAgICAgICAgICBlZGdlUmVzaXN0YW5jZTogMC42LFxuICAgICAgICAgIGRyYWdSZXNpc3RhbmNlOjAuMyxcbiAgICAgICAgICBjYWxsYmFja1Njb3BlOiB0aGlzLFxuICAgICAgICAgIG9uRHJhZ1N0YXJ0OiB0aGlzLmRyYWdTdGFydFxuICAgICAgICB9KTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkcmF3XG4gICAgICogQG1lbWJlcm9mIGltYWdlTG9vcFxuICAgICAqIEBwYXJhbSAgXG4gICAgICogQGRlc2NyaXB0aW9uIGRyYWdTdGFydFxuICAgICAqXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0KCl7XG5cbiAgICAgIGlmICghdGhpcy5mcHMuaXNQbGF5aW5nKXtcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJhcmNoaXZlLWFjdGl2ZVwiKTtcbiAgICAgICAgdGhpcy5mcHMuc3RhcnQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuXG5cbiAgICBcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVDYWxjRHJhZ2dlclxuICAgICAqIEBtZW1iZXJvZiBpbWFnZUxvb3BcbiAgICAgKiBAcGFyYW0gIFxuICAgICAqIEBkZXNjcmlwdGlvbiByZUNhbGN1bGF0ZSBib3VuZHMgb24gcmVzaXplXG4gICAgICpcbiAgICAgKi9cbiAgICByZUNhbGNEcmFnZ2VyKCl7XG5cbiAgICAgIGlmICggY29yZS5kZXRlY3QuaXNNb2JpbGUoKSApe1xuICAgICAgICB0aGlzLmRyYWdnYWJsZVswXS5raWxsKCk7XG4gICAgICAgIHRoaXMuZHJhZ2dlcigpO1xuICAgICAgfVxuXG4gICAgfSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1ldGhvZCBmcHNMb29wXG4gICAgICogQG1lbWJlcm9mIGltYWdlTG9vcFxuICAgICAqIEBwYXJhbSBmcHMgRnJhbWVzIHBlciBzZWNvbmRcbiAgICAgKiBAZGVzY3JpcHRpb24gUnVuIHRocm91Z2ggYSBzZXF1ZW5jZSBhdCBhIHNldCBkdXJhdGlvblxuICAgICAqXG4gICAgICovXG4gICAgZnBzTG9vcChmcHMsIGNhbGxiYWNrKSB7XG5cbiAgICAgIGxldCBkZWxheSA9IDUwMDtcbiAgICAgIGxldCB0aW1lID0gbnVsbDtcbiAgICAgIGxldCBmcmFtZSA9IC0xO1xuICAgICAgbGV0IHRyZWY7XG5cbiAgICAgIGZ1bmN0aW9uIGxvb3AodGltZXN0YW1wKSB7XG5cbiAgICAgICAgaWYgKHRpbWUgPT09IG51bGwpIHRpbWUgPSB0aW1lc3RhbXA7XG4gICAgICAgIHZhciBzZWcgPSBNYXRoLmZsb29yKCh0aW1lc3RhbXAgLSB0aW1lKSAvIGRlbGF5KTtcbiAgICAgICAgaWYgKHNlZyAIGZyYW1lKSB7XG4gICAgICAgICAgZnJhbWUgPSBzZWc7XG4gICAgICAgIFxuICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIHRpbWU6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGZyYW1lOiBmcmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgdHJlZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLmZyYW1lUmF0ZSA9IGZ1bmN0aW9uKG5ld2Zwcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmcHM7XG4gICAgICAgIGZwcyA9IG5ld2ZwcztcbiAgICAgICAgZGVsYXkgPSAxMDAwIC8gZnBzO1xuICAgICAgICBmcmFtZSA9IC0xO1xuICAgICAgICB0aW1lID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUGxheWluZykge1xuICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgICB0cmVmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRyZWYpO1xuICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGltZSA9IG51bGw7XG4gICAgICAgICAgZnJhbWUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIH0sXG5cblxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIHRlYXJkb3duXG4gICAgICogQG1lbWJlcm9mIGltYWdlTG9vcFxuICAgICAqIEBkZXNjcmlwdGlvbiBUZWFyZG93biBpbWFnZUxvb3AgXG4gICAgICpcbiAgICAgKi9cbiAgICB0ZWFyZG93biAoKSB7XG5cbiAgICB9XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvcnRcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGRlZmF1bHQgaW1hZ2VMb29wOyJdLCJuYW1lcyI6WyJjb3JlIiwiZ3NhcCIsIk1vdXNlRm9sbG93IiwiRHJhZ2dhYmxlIiwiSW5lcnRpYVBsdWdpbiIsImltYWdlTG9vcCIsImluaXQiLCJfdGhpcyIsImVtaXR0ZXIiLCJvbiIsImJpbmQiLCJyZUNhbGNEcmFnZ2VyIiwicmVnaXN0ZXJQbHVnaW4iLCJmcHMiLCJmZWF0dXJlZEltYWdlIiwiaW1hZ2VTdGFjayIsIm51bWJlck9mSXRlbXMiLCJpbWFnZUNvbnRhaW5lciIsInBhdXNlIiwibW91c2VGb2xsb3ciLCJzdG9wIiwic2V0VGltZW91dCIsInJlbW92ZUF0dHJpYnV0ZSIsImNvbmZpZyIsImRlZmF1bHREdXJhdGlvbiIsIl90aGlzMiIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImRvbSIsImJvZHkiLCJmaW5kIiwiaW1hZ2VzIiwiZm9yRWFjaCIsImltZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwic3R5bGUiLCJkaXNwbGF5IiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwibGVuZ3RoIiwiZm9sbG93IiwiZHJhZ0JvdW5kc0hlaWdodCIsImRyYWdCb3VuZHNXaWR0aCIsImRyYWdCb3VuZHNMZWZ0IiwiZHJhZ0JvdW5kc1RvcCIsImRyYWdnYWJsZSIsImRyYWdnZXIiLCJmcHNMb29wIiwiZSIsImFkZCIsImlzUGxheWluZyIsImRvY3VtZW50RWxlbWVudCIsInN0YXJ0IiwiZGV0ZWN0IiwiaXNNb2JpbGUiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsImlubmVyV2lkdGgiLCJjcmVhdGUiLCJib3VuZHMiLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJ0aHJvd1Byb3BzIiwiZWRnZVJlc2lzdGFuY2UiLCJkcmFnUmVzaXN0YW5jZSIsImNhbGxiYWNrU2NvcGUiLCJvbkRyYWdTdGFydCIsImRyYWdTdGFydCIsImtpbGwiLCJjYWxsYmFjayIsImRlbGF5IiwidGltZSIsImZyYW1lIiwidHJlZiIsImxvb3AiLCJ0aW1lc3RhbXAiLCJzZWciLCJNYXRoIiwiZmxvb3IiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJmcmFtZVJhdGUiLCJuZXdmcHMiLCJhcmd1bWVudHMiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInRlYXJkb3duIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/class/ImageLoop.js\n");

/***/ }),

/***/ "./source/js/class/ModuleController.js":
/*!*********************************************!*\
  !*** ./source/js/class/ModuleController.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core */ \"./source/js/core/index.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-controller/Controller.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(properjs_controller__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n/**\n *\n * @public\n * @class Module Controller\n * @classdesc Handles page events and data\n * @memberof core\n *\n */\nvar ModuleController = /*#__PURE__*/function (_Controller) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ModuleController, _Controller);\n  var _super = _createSuper(ModuleController);\n  function ModuleController() {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, ModuleController);\n    _this = _super.call(this);\n\n    // Bind\n    _this.bind();\n    _this.tools();\n    return _this;\n  }\n\n  /**\n   *\n   * @instance\n   * @description Initialize Tools for Development\n   * @memberof ModuleController\n   * @method bind\n   *\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ModuleController, [{\n    key: \"tools\",\n    value: function tools() {\n      // Show Grid overlay\n      document.addEventListener('keydown', function (e) {\n        if (e.keyCode === 75 && e.metaKey) {\n          if (_core__WEBPACK_IMPORTED_MODULE_5__.dom.html[0].classList.contains(\"grid-active\")) {\n            _core__WEBPACK_IMPORTED_MODULE_5__.dom.html[0].classList.remove(\"grid-active\");\n          } else {\n            _core__WEBPACK_IMPORTED_MODULE_5__.dom.html[0].classList.add(\"grid-active\");\n          }\n        }\n      });\n    }\n\n    /**\n    *\n    * @instance\n    * @description Initialize Module Controller\n    * @memberof ModuleController\n    * @method bind\n    *\n    */\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      this.initPage();\n    }\n\n    /**\n     *\n     * @instance\n     * @description Initialize App Page\n     * @memberof ModuleController\n     * @method Page events\n     *\n     */\n  }, {\n    key: \"initPage\",\n    value: function initPage() {\n      _core__WEBPACK_IMPORTED_MODULE_5__.util.currentTime();\n    }\n\n    /**\n     *\n     * @public\n     * @method destroy\n     * @memberof class.ModuleController\n     * @description Stop and kill Module Controller instances.\n     *\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {}\n  }]);\n  return ModuleController;\n}((properjs_controller__WEBPACK_IMPORTED_MODULE_6___default()));\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ModuleController);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY2xhc3MvTW9kdWxlQ29udHJvbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ2E7O0FBSzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQSxJQVFNRSxnQkFBZ0IsMEJBQUFDLFdBQUE7RUFBQUMsMkVBQUEsQ0FBQUYsZ0JBQUEsRUFBQUMsV0FBQTtFQUFBLElBQUFFLE1BQUEsR0FBQUMsWUFBQSxDQUFBSixnQkFBQTtFQUNsQixTQUFBQSxpQkFBQSxFQUFnQjtJQUFBLElBQUFLLEtBQUE7SUFBQUMsaUZBQUEsT0FBQU4sZ0JBQUE7SUFFWkssS0FBQSxHQUFBRixNQUFBLENBQUFJLElBQUE7O0lBRUE7SUFDQUYsS0FBQSxDQUFLRyxJQUFJLENBQUMsQ0FBQztJQUNYSCxLQUFBLENBQUtJLEtBQUssQ0FBQyxDQUFDO0lBQUMsT0FBQUosS0FBQTtFQUVqQjs7RUFLQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBUElLLDhFQUFBLENBQUFWLGdCQUFBO0lBQUFXLEdBQUE7SUFBQUMsS0FBQSxFQVFBLFNBQUFILE1BQUEsRUFBUztNQUNMO01BQ0FJLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFVBQUNDLENBQUMsRUFBSztRQUN4QyxJQUFJQSxDQUFDLENBQUNDLE9BQU8sS0FBSyxFQUFFLElBQUlELENBQUMsQ0FBQ0UsT0FBTyxFQUFFO1VBQ25DLElBQUtuQixzQ0FBUSxDQUFDcUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDQyxTQUFTLENBQUNDLFFBQVEsQ0FBQyxhQUFhLENBQUMsRUFBRztZQUN0RHZCLHNDQUFRLENBQUNxQixJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUNDLFNBQVMsQ0FBQ0UsTUFBTSxDQUFDLGFBQWEsQ0FBQztVQUNwRCxDQUFDLE1BQUk7WUFDRHhCLHNDQUFRLENBQUNxQixJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUNDLFNBQVMsQ0FBQ0csR0FBRyxDQUFDLGFBQWEsQ0FBQztVQUNqRDtRQUNBO01BQ0osQ0FBQyxDQUFDO0lBQ047O0lBS0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBJO0lBQUFaLEdBQUE7SUFBQUMsS0FBQSxFQVNBLFNBQUFKLEtBQUEsRUFBUTtNQUVKLElBQUksQ0FBQ2dCLFFBQVEsQ0FBQyxDQUFDO0lBRW5COztJQUtBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFQSTtJQUFBYixHQUFBO0lBQUFDLEtBQUEsRUFRQSxTQUFBWSxTQUFBLEVBQVU7TUFFTjFCLG1EQUFxQixDQUFDLENBQUM7SUFHM0I7O0lBS0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBJO0lBQUFhLEdBQUE7SUFBQUMsS0FBQSxFQVFBLFNBQUFlLFFBQUEsRUFBVyxDQUVYO0VBQUM7RUFBQSxPQUFBM0IsZ0JBQUE7QUFBQSxFQXBGMEJELDREQUFVO0FBeUZ6QztBQUNBO0FBQ0E7QUFDQSxpRUFBZUMsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vc291cmNlL2pzL2NsYXNzL01vZHVsZUNvbnRyb2xsZXIuanM/NWE1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgQ29udHJvbGxlciBmcm9tIFwicHJvcGVyanMtY29udHJvbGxlclwiO1xuXG5cblxuXG4vKipcbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3MgTW9kdWxlIENvbnRyb2xsZXJcbiAqIEBjbGFzc2Rlc2MgSGFuZGxlcyBwYWdlIGV2ZW50cyBhbmQgZGF0YVxuICogQG1lbWJlcm9mIGNvcmVcbiAqXG4gKi9cbmNsYXNzIE1vZHVsZUNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoICkge1xuXG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gQmluZFxuICAgICAgICB0aGlzLmJpbmQoKTtcbiAgICAgICAgdGhpcy50b29scygpO1xuXG4gICAgfVxuXG5cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZSBUb29scyBmb3IgRGV2ZWxvcG1lbnRcbiAgICAgKiBAbWVtYmVyb2YgTW9kdWxlQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgYmluZFxuICAgICAqXG4gICAgICovXG4gICAgdG9vbHMgKCApe1xuICAgICAgICAvLyBTaG93IEdyaWQgb3ZlcmxheVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0IHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDc1ICYmIGUubWV0YUtleSkge1xuICAgICAgICAgICAgaWYgKCBjb3JlLmRvbS5odG1sWzBdLmNsYXNzTGlzdC5jb250YWlucyhcImdyaWQtYWN0aXZlXCIpICkge1xuICAgICAgICAgICAgICAgIGNvcmUuZG9tLmh0bWxbMF0uY2xhc3NMaXN0LnJlbW92ZShcImdyaWQtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgY29yZS5kb20uaHRtbFswXS5jbGFzc0xpc3QuYWRkKFwiZ3JpZC1hY3RpdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG5cblxuICAgIC8qKlxuICAgICpcbiAgICAqIEBpbnN0YW5jZVxuICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemUgTW9kdWxlIENvbnRyb2xsZXJcbiAgICAqIEBtZW1iZXJvZiBNb2R1bGVDb250cm9sbGVyXG4gICAgKiBAbWV0aG9kIGJpbmRcbiAgICAqXG4gICAgKi9cblxuICAgIGJpbmQgKCApe1xuXG4gICAgICAgIHRoaXMuaW5pdFBhZ2UoKTtcblxuICAgIH1cblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemUgQXBwIFBhZ2VcbiAgICAgKiBAbWVtYmVyb2YgTW9kdWxlQ29udHJvbGxlclxuICAgICAqIEBtZXRob2QgUGFnZSBldmVudHNcbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRQYWdlKCl7XG5cbiAgICAgICAgY29yZS51dGlsLmN1cnJlbnRUaW1lKCk7XG5cblxuICAgIH1cblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAqIEBtZW1iZXJvZiBjbGFzcy5Nb2R1bGVDb250cm9sbGVyXG4gICAgICogQGRlc2NyaXB0aW9uIFN0b3AgYW5kIGtpbGwgTW9kdWxlIENvbnRyb2xsZXIgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSAoKSB7XG5cbiAgICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvcnRcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZGVmYXVsdCBNb2R1bGVDb250cm9sbGVyO1xuIl0sIm5hbWVzIjpbImNvcmUiLCJDb250cm9sbGVyIiwiTW9kdWxlQ29udHJvbGxlciIsIl9Db250cm9sbGVyIiwiX2luaGVyaXRzIiwiX3N1cGVyIiwiX2NyZWF0ZVN1cGVyIiwiX3RoaXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJjYWxsIiwiYmluZCIsInRvb2xzIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwia2V5Q29kZSIsIm1ldGFLZXkiLCJkb20iLCJodG1sIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJyZW1vdmUiLCJhZGQiLCJpbml0UGFnZSIsInV0aWwiLCJjdXJyZW50VGltZSIsImRlc3Ryb3kiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/class/ModuleController.js\n");

/***/ }),

/***/ "./source/js/class/MouseFollow.js":
/*!****************************************!*\
  !*** ./source/js/class/MouseFollow.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core */ \"./source/js/core/index.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/dist/gsap.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(gsap__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! properjs-hobo */ \"./node_modules/properjs-hobo/dist/hobo.build.js\");\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(properjs_hobo__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-controller/Controller.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(properjs_controller__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n/**\n *\n * @private\n * @class MouseFollow\n * @classdesc Fix element to follow mouse\n * @memberof effects\n *\n */\nvar MouseFollow = /*#__PURE__*/function (_Controller) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(MouseFollow, _Controller);\n  var _super = _createSuper(MouseFollow);\n  function MouseFollow(element) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, MouseFollow);\n    _this = _super.call(this);\n    _core__WEBPACK_IMPORTED_MODULE_5__.dom.mouseFollow = document.querySelector(element);\n    return _this;\n  }\n\n  /**\n   *\n   * @instance\n   * @method load\n   * @memberof effects.MouseFollow\n   * @description Initialize the mouse follow animation for non touch screens\n   *\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(MouseFollow, [{\n    key: \"start\",\n    value: function start() {\n      //gsap.registerPlugin(CSSPlugin);\n\n      if (!_core__WEBPACK_IMPORTED_MODULE_5__.detect._isTouch) {\n        _core__WEBPACK_IMPORTED_MODULE_5__.dom.body.on('mousemove', this.update);\n      }\n    }\n\n    /**\n     *\n     * @instance\n     * @method stop\n     * @memberof effects.MouseFollow\n     * @description Terminate mouse follow animation.\n     *\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      _core__WEBPACK_IMPORTED_MODULE_5__.dom.body.off('mousemove', this.update);\n    }\n\n    /**\n     *\n     * @instance\n     * @method update\n     * @param {number} value The new value to tween to\n     * @memberof loading.Bar\n     * @description Animate/Tween the load bar ui.\n     *\n     */\n  }, {\n    key: \"update\",\n    value: function update(e) {\n      gsap__WEBPACK_IMPORTED_MODULE_8___default().to(_core__WEBPACK_IMPORTED_MODULE_5__.dom.mouseFollow, {\n        duration: .8,\n        css: {\n          left: e.pageX,\n          top: e.pageY\n        }\n      });\n    }\n  }]);\n  return MouseFollow;\n}((properjs_controller__WEBPACK_IMPORTED_MODULE_7___default()));\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MouseFollow);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY2xhc3MvTW91c2VGb2xsb3cuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDUjtBQUNhO0FBQ1A7QUFDZTs7QUFHN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBLElBUU1LLFdBQVcsMEJBQUFDLFdBQUE7RUFBQUMsMkVBQUEsQ0FBQUYsV0FBQSxFQUFBQyxXQUFBO0VBQUEsSUFBQUUsTUFBQSxHQUFBQyxZQUFBLENBQUFKLFdBQUE7RUFFYixTQUFBQSxZQUFjSyxPQUFPLEVBQUc7SUFBQSxJQUFBQyxLQUFBO0lBQUFDLGlGQUFBLE9BQUFQLFdBQUE7SUFFcEJNLEtBQUEsR0FBQUgsTUFBQSxDQUFBSyxJQUFBO0lBRUFiLHNDQUFRLENBQUNlLFdBQVcsR0FBR0MsUUFBUSxDQUFDQyxhQUFhLENBQUNQLE9BQU8sQ0FBQztJQUFDLE9BQUFDLEtBQUE7RUFFM0Q7O0VBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBJTyw4RUFBQSxDQUFBYixXQUFBO0lBQUFjLEdBQUE7SUFBQUMsS0FBQSxFQVFBLFNBQUFDLE1BQUEsRUFBUztNQUVQOztNQUdBLElBQUksQ0FBRXJCLHlDQUFXLENBQUN1QixRQUFRLEVBQUc7UUFDekJ2QixzQ0FBUSxDQUFDd0IsSUFBSSxDQUFDQyxFQUFFLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQ0MsTUFBTyxDQUFDO01BQzlDO0lBRUg7O0lBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQVBJO0lBQUFQLEdBQUE7SUFBQUMsS0FBQSxFQVFBLFNBQUFPLEtBQU9DLFFBQVEsRUFBRztNQUNkNUIsc0NBQVEsQ0FBQ3dCLElBQUksQ0FBQ0ssR0FBRyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUNILE1BQU8sQ0FBQztJQUNoRDs7SUFHQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFSSTtJQUFBUCxHQUFBO0lBQUFDLEtBQUEsRUFTQSxTQUFBTSxPQUFRSSxDQUFDLEVBQUU7TUFFVDdCLDhDQUFPLENBQUVELHNDQUFRLENBQUNlLFdBQVcsRUFBRztRQUM5QmlCLFFBQVEsRUFBQyxFQUFFO1FBQ1hDLEdBQUcsRUFBRTtVQUNIQyxJQUFJLEVBQUVKLENBQUMsQ0FBQ0ssS0FBSztVQUNiQyxHQUFHLEVBQUVOLENBQUMsQ0FBQ087UUFDVDtNQUVGLENBQUMsQ0FBQztJQUVKO0VBQUM7RUFBQSxPQUFBaEMsV0FBQTtBQUFBLEVBOURxQkQsNERBQVU7QUFtRXBDO0FBQ0E7QUFDQTtBQUNBLGlFQUFlQyxXQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vc291cmNlL2pzL2NsYXNzL01vdXNlRm9sbG93LmpzPzRhZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcbmltcG9ydCBFYXNlUGFjayBmcm9tIFwiZ3NhcC9FYXNlUGFja1wiO1xuaW1wb3J0ICQgZnJvbSBcInByb3BlcmpzLWhvYm9cIjtcbmltcG9ydCBDb250cm9sbGVyIGZyb20gXCJwcm9wZXJqcy1jb250cm9sbGVyXCI7XG5cblxuLyoqXG4gKlxuICogQHByaXZhdGVcbiAqIEBjbGFzcyBNb3VzZUZvbGxvd1xuICogQGNsYXNzZGVzYyBGaXggZWxlbWVudCB0byBmb2xsb3cgbW91c2VcbiAqIEBtZW1iZXJvZiBlZmZlY3RzXG4gKlxuICovXG5jbGFzcyBNb3VzZUZvbGxvdyBleHRlbmRzIENvbnRyb2xsZXJ7XG5cbiAgICBjb25zdHJ1Y3RvciAoIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBjb3JlLmRvbS5tb3VzZUZvbGxvdyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAqIEBtZW1iZXJvZiBlZmZlY3RzLk1vdXNlRm9sbG93XG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemUgdGhlIG1vdXNlIGZvbGxvdyBhbmltYXRpb24gZm9yIG5vbiB0b3VjaCBzY3JlZW5zXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGFydCAoKSB7XG5cbiAgICAgIC8vZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pO1xuXG5cbiAgICAgIGlmICghIGNvcmUuZGV0ZWN0Ll9pc1RvdWNoICkge1xuICAgICAgICAgIGNvcmUuZG9tLmJvZHkub24oJ21vdXNlbW92ZScsIHRoaXMudXBkYXRlICk7XG4gICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHN0b3BcbiAgICAgKiBAbWVtYmVyb2YgZWZmZWN0cy5Nb3VzZUZvbGxvd1xuICAgICAqIEBkZXNjcmlwdGlvbiBUZXJtaW5hdGUgbW91c2UgZm9sbG93IGFuaW1hdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIHN0b3AgKCBjYWxsYmFjayApIHtcbiAgICAgICAgY29yZS5kb20uYm9keS5vZmYoJ21vdXNlbW92ZScsIHRoaXMudXBkYXRlICk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gdHdlZW4gdG9cbiAgICAgKiBAbWVtYmVyb2YgbG9hZGluZy5CYXJcbiAgICAgKiBAZGVzY3JpcHRpb24gQW5pbWF0ZS9Ud2VlbiB0aGUgbG9hZCBiYXIgdWkuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGUgKGUpIHtcblxuICAgICAgZ3NhcC50byggY29yZS5kb20ubW91c2VGb2xsb3cgLCB7XG4gICAgICAgIGR1cmF0aW9uOi44LFxuICAgICAgICBjc3M6IHtcbiAgICAgICAgICBsZWZ0OiBlLnBhZ2VYLFxuICAgICAgICAgIHRvcDogZS5wYWdlWVxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgfVxuXG59XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwb3J0XG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGRlZmF1bHQgTW91c2VGb2xsb3c7XG4iXSwibmFtZXMiOlsiY29yZSIsImdzYXAiLCJFYXNlUGFjayIsIiQiLCJDb250cm9sbGVyIiwiTW91c2VGb2xsb3ciLCJfQ29udHJvbGxlciIsIl9pbmhlcml0cyIsIl9zdXBlciIsIl9jcmVhdGVTdXBlciIsImVsZW1lbnQiLCJfdGhpcyIsIl9jbGFzc0NhbGxDaGVjayIsImNhbGwiLCJkb20iLCJtb3VzZUZvbGxvdyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwic3RhcnQiLCJkZXRlY3QiLCJfaXNUb3VjaCIsImJvZHkiLCJvbiIsInVwZGF0ZSIsInN0b3AiLCJjYWxsYmFjayIsIm9mZiIsImUiLCJ0byIsImR1cmF0aW9uIiwiY3NzIiwibGVmdCIsInBhZ2VYIiwidG9wIiwicGFnZVkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/class/MouseFollow.js\n");

/***/ }),

/***/ "./source/js/class/Nav.js":
/*!********************************!*\
  !*** ./source/js/class/Nav.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/config */ \"./source/js/core/config.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core */ \"./source/js/core/index.js\");\n/* harmony import */ var _core_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/util */ \"./source/js/core/util.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/dist/gsap.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(gsap__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n/**\n *\n * @public\n * @namespace nav\n * @description Site-wide navigation\n * @memberof menus\n *\n */\nvar nav = {\n  /**\n   *\n   * @public\n   * @method init\n   * @memberof menus.init\n   * @description Method initializes intro node in DOM.\n   *\n   */\n  init: function init() {\n    _core__WEBPACK_IMPORTED_MODULE_1__.emitter.on(\"app--transition-out\", this.teardown.bind(this));\n    _core__WEBPACK_IMPORTED_MODULE_1__.emitter.on(\"app--resize\", this.resize.bind(this));\n    _core__WEBPACK_IMPORTED_MODULE_1__.emitter.on(\"app--init\", this.bind.bind(this));\n  },\n  bind: function bind() {\n    var navItems = document.querySelectorAll(\".js-navigation .a\");\n    var listRow = document.querySelectorAll(\".js-row-hover\");\n\n    // Set active class on link matching pathname\n    navItems.forEach(function (item) {\n      // Hide page for transition \n      item.addEventListener('click', function (event) {\n        var target = event.target.getAttribute(\"data-view\");\n\n        // Return if already active\n        if (document.body.classList.contains(\"archive-active\") && target === \"Selected Work\" || document.body.classList.contains(\"index-active\") && target === \"Index\") {\n          return;\n        }\n\n        // Transition \n        document.body.classList.add(\"is-inactive\");\n\n        // View Change \n        setTimeout(function () {\n          if (document.body.classList.contains(\"archive-active\")) {\n            // Index\n            document.body.classList.remove(\"archive-active\");\n            document.body.classList.add(\"index-active\");\n            gsap__WEBPACK_IMPORTED_MODULE_3___default().fromTo(listRow, {\n              opacity: 0\n            }, {\n              opacity: 1,\n              duration: 1,\n              stagger: 0.015\n            });\n            _core__WEBPACK_IMPORTED_MODULE_1__.emitter.fire(\"app--view-change\");\n          } else {\n            // Archive\n            document.body.classList.remove(\"index-active\");\n            document.body.classList.add(\"archive-active\");\n            _core__WEBPACK_IMPORTED_MODULE_1__.emitter.fire(\"app--view-change\");\n          }\n          document.body.classList.remove(\"is-inactive\");\n        }, _core__WEBPACK_IMPORTED_MODULE_1__.config.defaultDuration);\n      });\n    });\n  },\n  resize: function resize() {\n    // Hide index on mobile \n    if (window.innerWidth <= 1200) {\n      if (document.body.classList.contains(\"index-active\")) {\n        _core__WEBPACK_IMPORTED_MODULE_1__.emitter.fire(\"app--view-change\");\n        document.body.classList.remove(\"index-active\");\n        document.body.classList.add(\"archive-active\");\n      }\n    }\n  },\n  teardown: function teardown() {}\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nav);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVEdEIsTUFBTSxXQUFBQSxPQUFBLEVBQUU7SUFFTjtJQUNBLElBQUl1QixNQUFNLENBQUNDLFVBQVUsSUFBSSxJQUFJLEVBQUM7TUFDNUIsSUFBSXRCLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDQyxTQUFTLENBQUNDLFFBQVEsQ0FBQyxjQUFjLENBQUMsRUFBQztRQUNuRHRCLDBDQUFZLENBQUM4QixJQUFJLENBQUUsa0JBQW1CLENBQUM7UUFDdkNuQixRQUFRLENBQUNTLElBQUksQ0FBQ0MsU0FBUyxDQUFDSSxNQUFNLENBQUMsY0FBYyxDQUFDO1FBQzlDZCxRQUFRLENBQUNTLElBQUksQ0FBQ0MsU0FBUyxDQUFDRSxHQUFHLENBQUMsZ0JBQWdCLENBQUM7TUFDL0M7SUFDRjtFQUVGLENBQUM7RUFFRGhCLFFBQVEsV0FBQUEsU0FBQSxFQUFJLENBRVo7QUFDSixDQUFDOztBQUdEO0FBQ0E7QUFDQTtBQUNBLGlFQUFlSixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vc291cmNlL2pzL2NsYXNzL05hdi5qcz8wYzczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjb25maWcgZnJvbSBcIi4uL2NvcmUvY29uZmlnXCI7XG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuLi9jb3JlL3V0aWxcIjtcbmltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCI7XG5cbi8qKlxuICpcbiAqIEBwdWJsaWNcbiAqIEBuYW1lc3BhY2UgbmF2XG4gKiBAZGVzY3JpcHRpb24gU2l0ZS13aWRlIG5hdmlnYXRpb25cbiAqIEBtZW1iZXJvZiBtZW51c1xuICpcbiAqL1xuY29uc3QgbmF2ID0ge1xuICAgIFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZXRob2QgaW5pdFxuICAgICAqIEBtZW1iZXJvZiBtZW51cy5pbml0XG4gICAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCBpbml0aWFsaXplcyBpbnRybyBub2RlIGluIERPTS5cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXQgKCkge1xuICAgICAgY29yZS5lbWl0dGVyLm9uKFwiYXBwLS10cmFuc2l0aW9uLW91dFwiLCB0aGlzLnRlYXJkb3duLmJpbmQodGhpcykpO1xuICAgICAgY29yZS5lbWl0dGVyLm9uKFwiYXBwLS1yZXNpemVcIiwgdGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICBjb3JlLmVtaXR0ZXIub24oXCJhcHAtLWluaXRcIiwgdGhpcy5iaW5kLmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBiaW5kICgpIHtcblxuICAgICAgICBsZXQgbmF2SXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmpzLW5hdmlnYXRpb24gLmFcIik7XG4gICAgICAgIGxldCBsaXN0Um93ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5qcy1yb3ctaG92ZXJcIik7XG5cbiAgICAgICAgLy8gU2V0IGFjdGl2ZSBjbGFzcyBvbiBsaW5rIG1hdGNoaW5nIHBhdGhuYW1lXG4gICAgICAgIG5hdkl0ZW1zLmZvckVhY2goZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGlkZSBwYWdlIGZvciB0cmFuc2l0aW9uIFxuICAgICAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkgeyBcblxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZpZXdcIik7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBpZiBhbHJlYWR5IGFjdGl2ZVxuICAgICAgICAgICAgaWYgKCBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucyhcImFyY2hpdmUtYWN0aXZlXCIpICYmIHRhcmdldCA9PT0gXCJTZWxlY3RlZCBXb3JrXCIgfHwgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoXCJpbmRleC1hY3RpdmVcIikgJiYgdGFyZ2V0ID09PSBcIkluZGV4XCIgKSB7IHJldHVybiB9XG5cbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb24gXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJpcy1pbmFjdGl2ZVwiKTtcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAvLyBWaWV3IENoYW5nZSBcbiAgICAgICAgICAgIHNldFRpbWVvdXQoICgpID0IHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmICggZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoXCJhcmNoaXZlLWFjdGl2ZVwiKSApe1xuICAgICAgICAgICAgICAgICAgLy8gSW5kZXhcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImFyY2hpdmUtYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiaW5kZXgtYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgZ3NhcC5mcm9tVG8oIGxpc3RSb3cgLCB7b3BhY2l0eTogMH0sIHtvcGFjaXR5OiAxLCBkdXJhdGlvbjogMSwgc3RhZ2dlcjogMC4wMTV9KTtcbiAgICAgICAgICAgICAgICAgIGNvcmUuZW1pdHRlci5maXJlKCBcImFwcC0tdmlldy1jaGFuZ2VcIiApO1xuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIC8vIEFyY2hpdmVcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImluZGV4LWFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcImFyY2hpdmUtYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgY29yZS5lbWl0dGVyLmZpcmUoIFwiYXBwLS12aWV3LWNoYW5nZVwiICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1pbmFjdGl2ZVwiKTtcblxuICAgICAgICAgICAgfSwgY29yZS5jb25maWcuZGVmYXVsdER1cmF0aW9uICk7XG5cbiAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVzaXplKCl7XG5cbiAgICAgIC8vIEhpZGUgaW5kZXggb24gbW9iaWxlIFxuICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDw9IDEyMDApe1xuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoXCJpbmRleC1hY3RpdmVcIikpe1xuICAgICAgICAgIGNvcmUuZW1pdHRlci5maXJlKCBcImFwcC0tdmlldy1jaGFuZ2VcIiApO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImluZGV4LWFjdGl2ZVwiKTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJhcmNoaXZlLWFjdGl2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfSxcblxuICAgIHRlYXJkb3duICgpIHtcblxuICAgIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwb3J0XG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGRlZmF1bHQgbmF2O1xuIl0sIm5hbWVzIjpbImNvbmZpZyIsImNvcmUiLCJ1dGlsIiwiZ3NhcCIsIm5hdiIsImluaXQiLCJlbWl0dGVyIiwib24iLCJ0ZWFyZG93biIsImJpbmQiLCJyZXNpemUiLCJuYXZJdGVtcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImxpc3RSb3ciLCJmb3JFYWNoIiwiaXRlbSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsImJvZHkiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImFkZCIsInNldFRpbWVvdXQiLCJyZW1vdmUiLCJmcm9tVG8iLCJvcGFjaXR5IiwiZHVyYXRpb24iLCJzdGFnZ2VyIiwiZmlyZSIsImRlZmF1bHREdXJhdGlvbiIsIndpbmRvdyIsImlubmVyV2lkdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/class/Nav.js\n");

/***/ }),

/***/ "./source/js/core/Scroller.js":
/*!************************************!*\
  !*** ./source/js/core/Scroller.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var properjs_scrollcontroller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-scrollcontroller */ \"./node_modules/properjs-scrollcontroller/ScrollController.js\");\n\n\n/**\n *\n * @description Single app instanceof [ScrollController]{@link https://github.com/ProperJS/ScrollController} for raf scroll handling\n * @member scroller\n * @memberof core\n *\n */\nvar scroller = new properjs_scrollcontroller__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scroller);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9TY3JvbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5RDs7QUFHekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQyxRQUFRLEdBQUcsSUFBSUQsaUVBQWdCLENBQUMsQ0FBQzs7QUFHdkM7QUFDQTtBQUNBO0FBQ0EsaUVBQWVDLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY29yZS9TY3JvbGxlci5qcz8xZjczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTY3JvbGxDb250cm9sbGVyIGZyb20gXCJwcm9wZXJqcy1zY3JvbGxjb250cm9sbGVyXCI7XG5cblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIFNpbmdsZSBhcHAgaW5zdGFuY2VvZiBbU2Nyb2xsQ29udHJvbGxlcl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL1Byb3BlckpTL1Njcm9sbENvbnRyb2xsZXJ9IGZvciByYWYgc2Nyb2xsIGhhbmRsaW5nXG4gKiBAbWVtYmVyIHNjcm9sbGVyXG4gKiBAbWVtYmVyb2YgY29yZVxuICpcbiAqL1xuY29uc3Qgc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsQ29udHJvbGxlcigpO1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEV4cG9ydFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBkZWZhdWx0IHNjcm9sbGVyO1xuIl0sIm5hbWVzIjpbIlNjcm9sbENvbnRyb2xsZXIiLCJzY3JvbGxlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/core/Scroller.js\n");

/***/ }),

/***/ "./source/js/core/config.js":
/*!**********************************!*\
  !*** ./source/js/core/config.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var properjs_easing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-easing */ \"./node_modules/properjs-easing/Easing.js\");\n/* harmony import */ var properjs_easing__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(properjs_easing__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n *\n * @public\n * @namespace config\n * @memberof core\n * @description Stores app-wide config values.\n *\n */\nvar config = {\n  /**\n   *\n   * @public\n   * @member defaultEasing\n   * @memberof core.config\n   * @description The default easing function for javascript Tweens.\n   *\n   */\n  defaultEasing: (properjs_easing__WEBPACK_IMPORTED_MODULE_0___default().easeInOutCubic),\n  /**\n   *\n   * @public\n   * @member defaultDuration\n   * @memberof core.config\n   * @description The default duration for javascript Tweens.\n   *\n   */\n  defaultDuration: 800,\n  /**\n   *\n   * @public\n   * @member mainSelector\n   * @memberof core.config\n   * @description The string selector used for <main> node.\n   *\n   */\n  mainSelector: \".js-main\",\n  /**\n   *\n   * @public\n   * @member introSelector\n   * @memberof core.config\n   * @description The string selector used for <intro> node.\n   *\n   */\n  introSelector: \".js-intro\",\n  /**\n   *\n   * @public\n   * @member viewSelector\n   * @memberof core.config\n   * @description The string selector used for <view> nodes.\n   *\n   */\n  viewSelector: \".js-view\",\n  /**\n   *\n   * @public\n   * @member naviSelector\n   * @memberof core.config\n   * @description The string selector used for <navi> node.\n   *\n   */\n  naviSelector: \".js-navi\",\n  /**\n   *\n   * @public\n   * @member lazyImageSelector\n   * @memberof core.config\n   * @description The string selector used for images deemed lazy-loadable.\n   *\n   */\n  lazyImageSelector: \".js-lazy-image\",\n  /**\n   *\n   * @public\n   * @member animSelector\n   * @memberof core.config\n   * @description The string selector used for animatables.\n   *\n   */\n  animSelector: \".js-animate\",\n  /**\n   *\n   * @public\n   * @member lazyImageAttr\n   * @memberof core.config\n   * @description The string attribute for lazy image source URLs.\n   *\n   */\n  lazyImageAttr: \"data-img-src\",\n  /**\n   *\n   * @public\n   * @member imageLoaderAttr\n   * @memberof core.config\n   * @description The string attribute ImageLoader gives loaded images.\n   *\n   */\n  imageLoaderAttr: \"data-imageloader\",\n  /**\n   *\n   * @public\n   * @member plate\n   * @memberof core.config\n   * @description The string selector used for plates\n   *\n   */\n  plate: \".js-plate\",\n  /**\n   *\n   * @public\n   * @member navigation\n   * @memberof core.config\n   * @description The string selector used for navigation elements\n   *\n   */\n  navigation: \".js-navigation\",\n  /**\n   *\n   * @public\n   * @member mouseFollowSelector\n   * @memberof core.config\n   * @description The string selector used for animatables.\n   *\n   */\n  mouseFollowSelector: \".js-follow\"\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (config);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDOztBQUdyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUMsTUFBTSxHQUFHO0VBQ1g7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxhQUFhLEVBQUVGLHVFQUFxQjtFQUdwQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lJLGVBQWUsRUFBRSxHQUFHO0VBR3BCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsWUFBWSxFQUFFLFVBQVU7RUFHeEI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxhQUFhLEVBQUUsV0FBVztFQUcxQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLFlBQVksRUFBRSxVQUFVO0VBR3hCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsWUFBWSxFQUFFLFVBQVU7RUFHeEI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxpQkFBaUIsRUFBRSxnQkFBZ0I7RUFHbkM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxZQUFZLEVBQUUsYUFBYTtFQUczQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLGFBQWEsRUFBRSxjQUFjO0VBRzdCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsZUFBZSxFQUFFLGtCQUFrQjtFQUduQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLEtBQUssRUFBRSxXQUFXO0VBR2xCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsVUFBVSxFQUFFLGdCQUFnQjtFQUc1QjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLG1CQUFtQixFQUFFO0FBR3pCLENBQUM7O0FBSUQ7QUFDQTtBQUNBO0FBQ0EsaUVBQWVkLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY29yZS9jb25maWcuanM/ZTYxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRWFzaW5nIGZyb20gXCJwcm9wZXJqcy1lYXNpbmdcIjtcblxuXG4vKipcbiAqXG4gKiBAcHVibGljXG4gKiBAbmFtZXNwYWNlIGNvbmZpZ1xuICogQG1lbWJlcm9mIGNvcmVcbiAqIEBkZXNjcmlwdGlvbiBTdG9yZXMgYXBwLXdpZGUgY29uZmlnIHZhbHVlcy5cbiAqXG4gKi9cbmNvbnN0IGNvbmZpZyA9IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWVtYmVyIGRlZmF1bHRFYXNpbmdcbiAgICAgKiBAbWVtYmVyb2YgY29yZS5jb25maWdcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIGZvciBqYXZhc2NyaXB0IFR3ZWVucy5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlZmF1bHRFYXNpbmc6IEVhc2luZy5lYXNlSW5PdXRDdWJpYyxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlciBkZWZhdWx0RHVyYXRpb25cbiAgICAgKiBAbWVtYmVyb2YgY29yZS5jb25maWdcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGRlZmF1bHQgZHVyYXRpb24gZm9yIGphdmFzY3JpcHQgVHdlZW5zLlxuICAgICAqXG4gICAgICovXG4gICAgZGVmYXVsdER1cmF0aW9uOiA4MDAsXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXIgbWFpblNlbGVjdG9yXG4gICAgICogQG1lbWJlcm9mIGNvcmUuY29uZmlnXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBzdHJpbmcgc2VsZWN0b3IgdXNlZCBmb3IgPG1haW4IG5vZGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBtYWluU2VsZWN0b3I6IFwiLmpzLW1haW5cIixcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlciBpbnRyb1NlbGVjdG9yXG4gICAgICogQG1lbWJlcm9mIGNvcmUuY29uZmlnXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBzdHJpbmcgc2VsZWN0b3IgdXNlZCBmb3IgPGludHJvPiBub2RlLlxuICAgICAqXG4gICAgICovXG4gICAgaW50cm9TZWxlY3RvcjogXCIuanMtaW50cm9cIixcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlciB2aWV3U2VsZWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgY29yZS5jb25maWdcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHN0cmluZyBzZWxlY3RvciB1c2VkIGZvciA8dmlldz4gbm9kZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICB2aWV3U2VsZWN0b3I6IFwiLmpzLXZpZXdcIixcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlciBuYXZpU2VsZWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgY29yZS5jb25maWdcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHN0cmluZyBzZWxlY3RvciB1c2VkIGZvciA8bmF2aT4gbm9kZS5cbiAgICAgKlxuICAgICAqL1xuICAgIG5hdmlTZWxlY3RvcjogXCIuanMtbmF2aVwiLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWVtYmVyIGxhenlJbWFnZVNlbGVjdG9yXG4gICAgICogQG1lbWJlcm9mIGNvcmUuY29uZmlnXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBzdHJpbmcgc2VsZWN0b3IgdXNlZCBmb3IgaW1hZ2VzIGRlZW1lZCBsYXp5LWxvYWRhYmxlLlxuICAgICAqXG4gICAgICovXG4gICAgbGF6eUltYWdlU2VsZWN0b3I6IFwiLmpzLWxhenktaW1hZ2VcIixcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlciBhbmltU2VsZWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgY29yZS5jb25maWdcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHN0cmluZyBzZWxlY3RvciB1c2VkIGZvciBhbmltYXRhYmxlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGFuaW1TZWxlY3RvcjogXCIuanMtYW5pbWF0ZVwiLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWVtYmVyIGxhenlJbWFnZUF0dHJcbiAgICAgKiBAbWVtYmVyb2YgY29yZS5jb25maWdcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHN0cmluZyBhdHRyaWJ1dGUgZm9yIGxhenkgaW1hZ2Ugc291cmNlIFVSTHMuXG4gICAgICpcbiAgICAgKi9cbiAgICBsYXp5SW1hZ2VBdHRyOiBcImRhdGEtaW1nLXNyY1wiLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWVtYmVyIGltYWdlTG9hZGVyQXR0clxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmNvbmZpZ1xuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgc3RyaW5nIGF0dHJpYnV0ZSBJbWFnZUxvYWRlciBnaXZlcyBsb2FkZWQgaW1hZ2VzLlxuICAgICAqXG4gICAgICovXG4gICAgaW1hZ2VMb2FkZXJBdHRyOiBcImRhdGEtaW1hZ2Vsb2FkZXJcIixcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlciBwbGF0ZVxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmNvbmZpZ1xuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgc3RyaW5nIHNlbGVjdG9yIHVzZWQgZm9yIHBsYXRlc1xuICAgICAqXG4gICAgICovXG4gICAgcGxhdGU6IFwiLmpzLXBsYXRlXCIsXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXIgbmF2aWdhdGlvblxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmNvbmZpZ1xuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgc3RyaW5nIHNlbGVjdG9yIHVzZWQgZm9yIG5hdmlnYXRpb24gZWxlbWVudHNcbiAgICAgKlxuICAgICAqL1xuICAgIG5hdmlnYXRpb246IFwiLmpzLW5hdmlnYXRpb25cIixcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlciBtb3VzZUZvbGxvd1NlbGVjdG9yXG4gICAgICogQG1lbWJlcm9mIGNvcmUuY29uZmlnXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBzdHJpbmcgc2VsZWN0b3IgdXNlZCBmb3IgYW5pbWF0YWJsZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBtb3VzZUZvbGxvd1NlbGVjdG9yOiBcIi5qcy1mb2xsb3dcIlxuXG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvcnRcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZGVmYXVsdCBjb25maWc7XG4iXSwibmFtZXMiOlsiRWFzaW5nIiwiY29uZmlnIiwiZGVmYXVsdEVhc2luZyIsImVhc2VJbk91dEN1YmljIiwiZGVmYXVsdER1cmF0aW9uIiwibWFpblNlbGVjdG9yIiwiaW50cm9TZWxlY3RvciIsInZpZXdTZWxlY3RvciIsIm5hdmlTZWxlY3RvciIsImxhenlJbWFnZVNlbGVjdG9yIiwiYW5pbVNlbGVjdG9yIiwibGF6eUltYWdlQXR0ciIsImltYWdlTG9hZGVyQXR0ciIsInBsYXRlIiwibmF2aWdhdGlvbiIsIm1vdXNlRm9sbG93U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/core/config.js\n");

/***/ }),

/***/ "./source/js/core/detect.js":
/*!**********************************!*\
  !*** ./source/js/core/detect.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ \"./source/js/core/dom.js\");\n\nvar vendors = [\"Webkit\", \"Moz\", \"ms\"];\n\n/**\n *\n * @public\n * @namespace detect\n * @memberof core\n * @description Handles basic detection of touch devices.\n *\n */\nvar detect = {\n  /**\n   *\n   * @public\n   * @method init\n   * @memberof core.detect\n   * @description Initializes the detect module.\n   *\n   */\n  init: function init() {\n    this._isTouch = \"ontouchstart\" in window || \"DocumentTouch\" in window;\n    this._isMobile = /Android|BlackBerry|iPhone|iPad|iPod|IEMobile|Opera Mini/gi.test(window.navigator.userAgent);\n    this._prefix = this.getPrefix();\n\n    // Touch support mode\n    if (this._isTouch) {\n      _dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"].html.addClass(\"is-touchable\");\n\n      // Mouse support mode\n    } else {\n      _dom__WEBPACK_IMPORTED_MODULE_0__[\"default\"].html.addClass(\"is-hoverable\");\n    }\n  },\n  /**\n   *\n   * @public\n   * @method getPrefix\n   * @memberof core.detect\n   * @description Get the vendor prefix.\n   * @returns {string}\n   *\n   */\n  getPrefix: function getPrefix() {\n    var i = vendors.length;\n    if (document.body.style.transform === null) {\n      for (i; i--;) {\n        if (document.body.style[\"\".concat(vendors[i], \"Transform\")]) {\n          return vendors[i];\n        }\n      }\n    }\n    return \"\";\n  },\n  /**\n   *\n   * @public\n   * @method getPrefixed\n   * @param {string} property The property to be prefixed\n   * @memberof core.detect\n   * @description Get the vendor prefixed property.\n   * @returns {string}\n   *\n   */\n  getPrefixed: function getPrefixed(property) {\n    var camelProp = property[0].toUpperCase()  property.slice(1);\n    return this._prefix ? this._prefix  camelProp : property;\n  },\n  /**\n   *\n   * @public\n   * @method isMobile\n   * @memberof core.detect\n   * @description Check for high-end mobile device user agents.\n   * @returns {boolean}\n   *\n   */\n  isMobile: function isMobile() {\n    return this._isMobile;\n  },\n  /**\n   *\n   * @public\n   * @method isTouch\n   * @memberof core.detect\n   * @description Check whether this is a touch device or not.\n   * [See Modernizr]{@link https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js}\n   * @returns {boolean}\n   *\n   */\n  isTouch: function isTouch() {\n    return this._isTouch;\n  },\n  /**\n   *\n   * @public\n   * @method isDevice\n   * @memberof core.detect\n   * @description Must be `isMobile` and `isTouch`.\n   * @returns {boolean}\n   *\n   */\n  isDevice: function isDevice() {\n    return this._isTouch && this._isMobile;\n  }\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (detect);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9kZXRlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0I7QUFHeEIsSUFBTUMsT0FBTyxHQUFHLENBQ1osUUFBUSxFQUNSLEtBQUssRUFDTCxJQUFJLENBQ1A7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1DLE1BQU0sR0FBRztFQUNYO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsSUFBSSxXQUFBQSxLQUFBLEVBQUk7SUFDSixJQUFJLENBQUNDLFFBQVEsR0FBSSxjQUFjLElBQUlDLE1BQU0sSUFBSSxlQUFlLElBQUlBLE1BQU87SUFDdkUsSUFBSSxDQUFDQyxTQUFTLEdBQUksMkRBQTJELENBQUNDLElBQUksQ0FBRUYsTUFBTSxDQUFDRyxTQUFTLENBQUNDLFNBQVUsQ0FBRTtJQUNqSCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJLENBQUNDLFNBQVMsQ0FBQyxDQUFDOztJQUUvQjtJQUNBLElBQUssSUFBSSxDQUFDUCxRQUFRLEVBQUc7TUFDakJKLDRDQUFHLENBQUNZLElBQUksQ0FBQ0MsUUFBUSxDQUFFLGNBQWUsQ0FBQzs7TUFFdkM7SUFDQSxDQUFDLE1BQU07TUFDSGIsNENBQUcsQ0FBQ1ksSUFBSSxDQUFDQyxRQUFRLENBQUUsY0FBZSxDQUFDO0lBQ3ZDO0VBQ0osQ0FBQztFQUdEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJRixTQUFTLFdBQUFBLFVBQUEsRUFBSTtJQUNULElBQUlHLENBQUMsR0FBR2IsT0FBTyxDQUFDYyxNQUFNO0lBRXRCLElBQUtDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxLQUFLLENBQUNDLFNBQVMsS0FBSyxJQUFJLEVBQUc7TUFDMUMsS0FBTUwsQ0FBQyxFQUFFQSxDQUFDLEVBQUUsR0FBSTtRQUNaLElBQUtFLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxLQUFLLElBQUFFLE1BQUEsQ0FBS25CLE9BQU8sQ0FBRWEsQ0FBQyxDQUFFLGVBQWEsRUFBRztVQUNyRCxPQUFPYixPQUFPLENBQUVhLENBQUMsQ0FBRTtRQUN2QjtNQUNKO0lBQ0o7SUFFQSxPQUFPLEVBQUU7RUFDYixDQUFDO0VBR0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSU8sV0FBVyxXQUFBQSxZQUFHQyxRQUFRLEVBQUc7SUFDckIsSUFBTUMsU0FBUyxHQUFJRCxRQUFRLENBQUUsQ0FBQyxDQUFFLENBQUNFLFdBQVcsQ0FBQyxDQUFDLEdBQUdGLFFBQVEsQ0FBQ0csS0FBSyxDQUFFLENBQUUsQ0FBRTtJQUVyRSxPQUFRLElBQUksQ0FBQ2YsT0FBTyxHQUFJLElBQUksQ0FBQ0EsT0FBTyxHQUFHYSxTQUFTLEdBQUlELFFBQVE7RUFDaEUsQ0FBQztFQUdEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJSSxRQUFRLFdBQUFBLFNBQUEsRUFBSTtJQUNSLE9BQU8sSUFBSSxDQUFDcEIsU0FBUztFQUN6QixDQUFDO0VBR0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSXFCLE9BQU8sV0FBQUEsUUFBQSxFQUFJO0lBQ1AsT0FBTyxJQUFJLENBQUN2QixRQUFRO0VBQ3hCLENBQUM7RUFHRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSXdCLFFBQVEsV0FBQUEsU0FBQSxFQUFJO0lBQ1IsT0FBUSxJQUFJLENBQUN4QixRQUFRLElBQUksSUFBSSxDQUFDRSxTQUFTO0VBQzNDO0FBQ0osQ0FBQzs7QUFJRDtBQUNBO0FBQ0E7QUFDQSxpRUFBZUosTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL3NvdXJjZS9qcy9jb3JlL2RldGVjdC5qcz81N2Y1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkb20gZnJvbSBcIi4vZG9tXCI7XG5cblxuY29uc3QgdmVuZG9ycyA9IFtcbiAgICBcIldlYmtpdFwiLFxuICAgIFwiTW96XCIsXG4gICAgXCJtc1wiXG5dO1xuXG5cbi8qKlxuICpcbiAqIEBwdWJsaWNcbiAqIEBuYW1lc3BhY2UgZGV0ZWN0XG4gKiBAbWVtYmVyb2YgY29yZVxuICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgYmFzaWMgZGV0ZWN0aW9uIG9mIHRvdWNoIGRldmljZXMuXG4gKlxuICovXG5jb25zdCBkZXRlY3QgPSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBpbml0XG4gICAgICogQG1lbWJlcm9mIGNvcmUuZGV0ZWN0XG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBkZXRlY3QgbW9kdWxlLlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdCAoKSB7XG4gICAgICAgIHRoaXMuX2lzVG91Y2ggPSAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cgfHwgXCJEb2N1bWVudFRvdWNoXCIgaW4gd2luZG93KTtcbiAgICAgICAgdGhpcy5faXNNb2JpbGUgPSAoL0FuZHJvaWR8QmxhY2tCZXJyeXxpUGhvbmV8aVBhZHxpUG9kfElFTW9iaWxlfE9wZXJhIE1pbmkvZ2kudGVzdCggd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQgKSk7XG4gICAgICAgIHRoaXMuX3ByZWZpeCA9IHRoaXMuZ2V0UHJlZml4KCk7XG5cbiAgICAgICAgLy8gVG91Y2ggc3VwcG9ydCBtb2RlXG4gICAgICAgIGlmICggdGhpcy5faXNUb3VjaCApIHtcbiAgICAgICAgICAgIGRvbS5odG1sLmFkZENsYXNzKCBcImlzLXRvdWNoYWJsZVwiICk7XG5cbiAgICAgICAgLy8gTW91c2Ugc3VwcG9ydCBtb2RlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20uaHRtbC5hZGRDbGFzcyggXCJpcy1ob3ZlcmFibGVcIiApO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBnZXRQcmVmaXhcbiAgICAgKiBAbWVtYmVyb2YgY29yZS5kZXRlY3RcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSB2ZW5kb3IgcHJlZml4LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRQcmVmaXggKCkge1xuICAgICAgICBsZXQgaSA9IHZlbmRvcnMubGVuZ3RoO1xuXG4gICAgICAgIGlmICggZG9jdW1lbnQuYm9keS5zdHlsZS50cmFuc2Zvcm0gPT09IG51bGwgKSB7XG4gICAgICAgICAgICBmb3IgKCBpOyBpLS07ICkge1xuICAgICAgICAgICAgICAgIGlmICggZG9jdW1lbnQuYm9keS5zdHlsZVsgYCR7dmVuZG9yc1sgaSBdfVRyYW5zZm9ybWAgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlbmRvcnNbIGkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGdldFByZWZpeGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBiZSBwcmVmaXhlZFxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmRldGVjdFxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0UHJlZml4ZWQgKCBwcm9wZXJ0eSApIHtcbiAgICAgICAgY29uc3QgY2FtZWxQcm9wID0gKHByb3BlcnR5WyAwIF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKCAxICkpO1xuXG4gICAgICAgIHJldHVybiAodGhpcy5fcHJlZml4ID8gKHRoaXMuX3ByZWZpeCArIGNhbWVsUHJvcCkgOiBwcm9wZXJ0eSk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBpc01vYmlsZVxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmRldGVjdFxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGVjayBmb3IgaGlnaC1lbmQgbW9iaWxlIGRldmljZSB1c2VyIGFnZW50cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKlxuICAgICAqL1xuICAgIGlzTW9iaWxlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzTW9iaWxlO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZXRob2QgaXNUb3VjaFxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmRldGVjdFxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGVjayB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaCBkZXZpY2Ugb3Igbm90LlxuICAgICAqIFtTZWUgTW9kZXJuaXpyXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvdG91Y2hldmVudHMuanN9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICpcbiAgICAgKi9cbiAgICBpc1RvdWNoICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVG91Y2g7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBpc0RldmljZVxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmRldGVjdFxuICAgICAqIEBkZXNjcmlwdGlvbiBNdXN0IGJlIGBpc01vYmlsZWAgYW5kIGBpc1RvdWNoYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKlxuICAgICAqL1xuICAgIGlzRGV2aWNlICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9pc1RvdWNoICYmIHRoaXMuX2lzTW9iaWxlKTtcbiAgICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwb3J0XG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGRlZmF1bHQgZGV0ZWN0O1xuIl0sIm5hbWVzIjpbImRvbSIsInZlbmRvcnMiLCJkZXRlY3QiLCJpbml0IiwiX2lzVG91Y2giLCJ3aW5kb3ciLCJfaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiX3ByZWZpeCIsImdldFByZWZpeCIsImh0bWwiLCJhZGRDbGFzcyIsImkiLCJsZW5ndGgiLCJkb2N1bWVudCIsImJvZHkiLCJzdHlsZSIsInRyYW5zZm9ybSIsImNvbmNhdCIsImdldFByZWZpeGVkIiwicHJvcGVydHkiLCJjYW1lbFByb3AiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiaXNNb2JpbGUiLCJpc1RvdWNoIiwiaXNEZXZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/core/detect.js\n");

/***/ }),

/***/ "./source/js/core/dom.js":
/*!*******************************!*\
  !*** ./source/js/core/dom.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-hobo */ \"./node_modules/properjs-hobo/dist/hobo.build.js\");\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(properjs_hobo__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./source/js/core/config.js\");\n\n\n\n/**\n *\n * @public\n * @namespace dom\n * @memberof core\n * @description Holds high-level cached Nodes.\n *\n */\nvar dom = {\n  /**\n   *\n   * @public\n   * @member doc\n   * @memberof core.dom\n   * @description The cached document.\n   *\n   */\n  doc: properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(document),\n  /**\n   *\n   * @public\n   * @member html\n   * @memberof core.dom\n   * @description The cached documentElement node.\n   *\n   */\n  html: properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(document.documentElement),\n  /**\n   *\n   * @public\n   * @member body\n   * @memberof core.dom\n   * @description The cached body node.\n   *\n   */\n  body: properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(document.body),\n  /**\n   *\n   * @public\n   * @member views\n   * @memberof core.dom\n   * @description The cached view nodes.\n   *\n   */\n  views: properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].viewSelector),\n  /**\n   *\n   * @public\n   * @member intro\n   * @memberof core.dom\n   * @description The cached intro node.\n   *\n   */\n  intro: properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].introSelector),\n  /**\n   *\n   * @public\n   * @member main\n   * @memberof core.dom\n   * @description The cached main node.\n   *\n   */\n  main: properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mainSelector),\n  /**\n   *\n   * @public\n   * @member navigation\n   * @memberof core.dom\n   * @description The cached <nav> nodes.\n   *\n   */\n  navigation: document.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].navigation),\n  /**\n   *\n   * @public\n   * @member follow\n   * @memberof core.dom\n   * @description The cached mouse follow nodes.\n   *\n   */\n  mouseFollow: document.querySelector(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].mouseFollowSelector)\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dom);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9kb20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4QjtBQUNBOztBQUc5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUUsR0FBRyxHQUFHO0VBQ1I7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxHQUFHLEVBQUVILG9EQUFDLENBQUVJLFFBQVMsQ0FBQztFQUdsQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLElBQUksRUFBRUwsb0RBQUMsQ0FBRUksUUFBUSxDQUFDRSxlQUFnQixDQUFDO0VBR25DO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsSUFBSSxFQUFFUCxvREFBQyxDQUFFSSxRQUFRLENBQUNHLElBQUssQ0FBQztFQUd4QjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLEtBQUssRUFBRVIsb0RBQUMsQ0FBRUMsK0NBQU0sQ0FBQ1EsWUFBYSxDQUFDO0VBRy9CO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsS0FBSyxFQUFFVixvREFBQyxDQUFFQywrQ0FBTSxDQUFDVSxhQUFjLENBQUM7RUFHaEM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxJQUFJLEVBQUVaLG9EQUFDLENBQUVDLCtDQUFNLENBQUNZLFlBQWEsQ0FBQztFQUc5QjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLFVBQVUsRUFBRVYsUUFBUSxDQUFDVyxhQUFhLENBQUVkLCtDQUFNLENBQUNhLFVBQVcsQ0FBQztFQUd2RDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lFLFdBQVcsRUFBRVosUUFBUSxDQUFDVyxhQUFhLENBQUdkLCtDQUFNLENBQUNnQixtQkFBb0I7QUFHckUsQ0FBQzs7QUFJRDtBQUNBO0FBQ0E7QUFDQSxpRUFBZWYsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL3NvdXJjZS9qcy9jb3JlL2RvbS5qcz9iZGI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkIGZyb20gXCJwcm9wZXJqcy1ob2JvXCI7XG5pbXBvcnQgY29uZmlnIGZyb20gXCIuL2NvbmZpZ1wiO1xuXG5cbi8qKlxuICpcbiAqIEBwdWJsaWNcbiAqIEBuYW1lc3BhY2UgZG9tXG4gKiBAbWVtYmVyb2YgY29yZVxuICogQGRlc2NyaXB0aW9uIEhvbGRzIGhpZ2gtbGV2ZWwgY2FjaGVkIE5vZGVzLlxuICpcbiAqL1xuY29uc3QgZG9tID0ge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXIgZG9jXG4gICAgICogQG1lbWJlcm9mIGNvcmUuZG9tXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBjYWNoZWQgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBkb2M6ICQoIGRvY3VtZW50ICksXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXIgaHRtbFxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmRvbVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgY2FjaGVkIGRvY3VtZW50RWxlbWVudCBub2RlLlxuICAgICAqXG4gICAgICovXG4gICAgaHRtbDogJCggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICksXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXIgYm9keVxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmRvbVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgY2FjaGVkIGJvZHkgbm9kZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGJvZHk6ICQoIGRvY3VtZW50LmJvZHkgKSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlciB2aWV3c1xuICAgICAqIEBtZW1iZXJvZiBjb3JlLmRvbVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgY2FjaGVkIHZpZXcgbm9kZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICB2aWV3czogJCggY29uZmlnLnZpZXdTZWxlY3RvciApLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWVtYmVyIGludHJvXG4gICAgICogQG1lbWJlcm9mIGNvcmUuZG9tXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBjYWNoZWQgaW50cm8gbm9kZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGludHJvOiAkKCBjb25maWcuaW50cm9TZWxlY3RvciApLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWVtYmVyIG1haW5cbiAgICAgKiBAbWVtYmVyb2YgY29yZS5kb21cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGNhY2hlZCBtYWluIG5vZGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBtYWluOiAkKCBjb25maWcubWFpblNlbGVjdG9yICksXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZW1iZXIgbmF2aWdhdGlvblxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmRvbVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgY2FjaGVkIDxuYXYIG5vZGVzLlxuICAgICAqXG4gICAgICovXG4gICAgbmF2aWdhdGlvbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvciggY29uZmlnLm5hdmlnYXRpb24gKSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1lbWJlciBmb2xsb3dcbiAgICAgKiBAbWVtYmVyb2YgY29yZS5kb21cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGNhY2hlZCBtb3VzZSBmb2xsb3cgbm9kZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBtb3VzZUZvbGxvdzogZG9jdW1lbnQucXVlcnlTZWxlY3RvciAoIGNvbmZpZy5tb3VzZUZvbGxvd1NlbGVjdG9yIClcblxuICAgIFxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEV4cG9ydFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBkZWZhdWx0IGRvbTtcbiJdLCJuYW1lcyI6WyIkIiwiY29uZmlnIiwiZG9tIiwiZG9jIiwiZG9jdW1lbnQiLCJodG1sIiwiZG9jdW1lbnRFbGVtZW50IiwiYm9keSIsInZpZXdzIiwidmlld1NlbGVjdG9yIiwiaW50cm8iLCJpbnRyb1NlbGVjdG9yIiwibWFpbiIsIm1haW5TZWxlY3RvciIsIm5hdmlnYXRpb24iLCJxdWVyeVNlbGVjdG9yIiwibW91c2VGb2xsb3ciLCJtb3VzZUZvbGxvd1NlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/dom.js\n");

/***/ }),

/***/ "./source/js/core/emitter.js":
/*!***********************************!*\
  !*** ./source/js/core/emitter.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-controller */ \"./node_modules/properjs-controller/Controller.js\");\n/* harmony import */ var properjs_controller__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(properjs_controller__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n *\n * @description Single app instanceof [Controller]{@link https://github.com/ProperJS/Controller} for arbitrary event emitting\n * @member emitter\n * @memberof core\n *\n */\nvar emitter = new (properjs_controller__WEBPACK_IMPORTED_MODULE_0___default())();\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (emitter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9lbWl0dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2Qzs7QUFHN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQyxPQUFPLEdBQUcsSUFBSUQsNERBQVUsQ0FBQyxDQUFDOztBQUloQztBQUNBO0FBQ0E7QUFDQSxpRUFBZUMsT0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL3NvdXJjZS9qcy9jb3JlL2VtaXR0ZXIuanM/NDhmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udHJvbGxlciBmcm9tIFwicHJvcGVyanMtY29udHJvbGxlclwiO1xuXG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBTaW5nbGUgYXBwIGluc3RhbmNlb2YgW0NvbnRyb2xsZXJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9wZXJKUy9Db250cm9sbGVyfSBmb3IgYXJiaXRyYXJ5IGV2ZW50IGVtaXR0aW5nXG4gKiBAbWVtYmVyIGVtaXR0ZXJcbiAqIEBtZW1iZXJvZiBjb3JlXG4gKlxuICovXG5jb25zdCBlbWl0dGVyID0gbmV3IENvbnRyb2xsZXIoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEV4cG9ydFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBkZWZhdWx0IGVtaXR0ZXI7Il0sIm5hbWVzIjpbIkNvbnRyb2xsZXIiLCJlbWl0dGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/emitter.js\n");

/***/ }),

/***/ "./source/js/core/env.js":
/*!*******************************!*\
  !*** ./source/js/core/env.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar DEV = \"development\";\nvar PROD = \"production\";\n\n/**\n *\n * @public\n * @namespace env\n * @memberof core\n * @description Set the app environment.\n *\n */\nvar env = {\n  /**\n   *\n   * @member ENV\n   * @memberof core.env\n   * @description The applied environment ref.\n   *              Looks at IP, localhost and staging for DEV, otherwise PROD\n   *\n   */\n  ENV: /^localhost|^[0-9]{0,3}\\.[0-9]{0,3}\\.[0-9]{0,3}\\.[0-9]{0,3}/g.test(document.domain) ? DEV : PROD,\n  /**\n   *\n   * @method get\n   * @memberof core.isDev\n   * @description Returns true for dev / staging.\n   * @returns {boolean}\n   *\n   */\n  isDev: function isDev() {\n    return this.ENV === DEV;\n  },\n  /**\n   *\n   * @method get\n   * @memberof core.isProd\n   * @description Returns true for production.\n   * @returns {boolean}\n   *\n   */\n  isProd: function isProd() {\n    return this.ENV === PROD;\n  }\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (env);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9lbnYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQU1BLEdBQUcsR0FBRyxhQUFhO0FBQ3pCLElBQU1DLElBQUksR0FBRyxZQUFZOztBQUd6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUMsR0FBRyxHQUFHO0VBQ1I7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxHQUFHLEVBQUcsNkRBQTZELENBQUNDLElBQUksQ0FBRUMsUUFBUSxDQUFDQyxNQUFPLENBQUMsR0FBR04sR0FBRyxHQUFHQyxJQUFLO0VBR3pHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSU0sS0FBSyxXQUFBQSxNQUFBLEVBQUk7SUFDTCxPQUFRLElBQUksQ0FBQ0osR0FBRyxLQUFLSCxHQUFHO0VBQzVCLENBQUM7RUFHRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lRLE1BQU0sV0FBQUEsT0FBQSxFQUFJO0lBQ04sT0FBUSxJQUFJLENBQUNMLEdBQUcsS0FBS0YsSUFBSTtFQUM3QjtBQUNKLENBQUM7O0FBSUQ7QUFDQTtBQUNBO0FBQ0EsaUVBQWVDLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY29yZS9lbnYuanM/MGZhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBERVYgPSBcImRldmVsb3BtZW50XCI7XG5jb25zdCBQUk9EID0gXCJwcm9kdWN0aW9uXCI7XG5cblxuLyoqXG4gKlxuICogQHB1YmxpY1xuICogQG5hbWVzcGFjZSBlbnZcbiAqIEBtZW1iZXJvZiBjb3JlXG4gKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBhcHAgZW52aXJvbm1lbnQuXG4gKlxuICovXG5jb25zdCBlbnYgPSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIEVOVlxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmVudlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgYXBwbGllZCBlbnZpcm9ubWVudCByZWYuXG4gICAgICogICAgICAgICAgICAgIExvb2tzIGF0IElQLCBsb2NhbGhvc3QgYW5kIHN0YWdpbmcgZm9yIERFViwgb3RoZXJ3aXNlIFBST0RcbiAgICAgKlxuICAgICAqL1xuICAgIEVOVjogKC9ebG9jYWxob3N0fF5bMC05XXswLDN9XFwuWzAtOV17MCwzfVxcLlswLTldezAsM31cXC5bMC05XXswLDN9L2cudGVzdCggZG9jdW1lbnQuZG9tYWluICkgPyBERVYgOiBQUk9EKSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEBtZW1iZXJvZiBjb3JlLmlzRGV2XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdHJ1ZSBmb3IgZGV2IC8gc3RhZ2luZy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKlxuICAgICAqL1xuICAgIGlzRGV2ICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLkVOViA9PT0gREVWKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICogQG1lbWJlcm9mIGNvcmUuaXNQcm9kXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdHJ1ZSBmb3IgcHJvZHVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKlxuICAgICAqL1xuICAgIGlzUHJvZCAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5FTlYgPT09IFBST0QpO1xuICAgIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvcnRcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZGVmYXVsdCBlbnY7XG4iXSwibmFtZXMiOlsiREVWIiwiUFJPRCIsImVudiIsIkVOViIsInRlc3QiLCJkb2N1bWVudCIsImRvbWFpbiIsImlzRGV2IiwiaXNQcm9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/env.js\n");

/***/ }),

/***/ "./source/js/core/index.js":
/*!*********************************!*\
  !*** ./source/js/core/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   detect: () => (/* reexport safe */ _detect__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   dom: () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   emitter: () => (/* reexport safe */ _emitter__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   env: () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   log: () => (/* reexport safe */ _log__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   resizes: () => (/* reexport safe */ _resizes__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   scrolls: () => (/* reexport safe */ _scrolls__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   util: () => (/* reexport module object */ _util__WEBPACK_IMPORTED_MODULE_2__)\n/* harmony export */ });\n/* harmony import */ var _detect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./detect */ \"./source/js/core/detect.js\");\n/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom */ \"./source/js/core/dom.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./source/js/core/util.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ \"./source/js/core/config.js\");\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env */ \"./source/js/core/env.js\");\n/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./log */ \"./source/js/core/log.js\");\n/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./emitter */ \"./source/js/core/emitter.js\");\n/* harmony import */ var _scrolls__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scrolls */ \"./source/js/core/scrolls.js\");\n/* harmony import */ var _resizes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./resizes */ \"./source/js/core/resizes.js\");\n/**\n *\n * @public\n * @namespace core\n * @description Holds the different core modules.\n *\n */\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QjtBQUNOO0FBQ087QUFDRDtBQUNOO0FBQ0E7QUFDUTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY29yZS9pbmRleC5qcz83YTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIEBwdWJsaWNcbiAqIEBuYW1lc3BhY2UgY29yZVxuICogQGRlc2NyaXB0aW9uIEhvbGRzIHRoZSBkaWZmZXJlbnQgY29yZSBtb2R1bGVzLlxuICpcbiAqL1xuaW1wb3J0IGRldGVjdCBmcm9tIFwiLi9kZXRlY3RcIjtcbmltcG9ydCBkb20gZnJvbSBcIi4vZG9tXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCBjb25maWcgZnJvbSBcIi4vY29uZmlnXCI7XG5pbXBvcnQgZW52IGZyb20gXCIuL2VudlwiO1xuaW1wb3J0IGxvZyBmcm9tIFwiLi9sb2dcIjtcbmltcG9ydCBlbWl0dGVyIGZyb20gXCIuL2VtaXR0ZXJcIjtcbmltcG9ydCBzY3JvbGxzIGZyb20gXCIuL3Njcm9sbHNcIjtcbmltcG9ydCByZXNpemVzIGZyb20gXCIuL3Jlc2l6ZXNcIjtcblxuXG5leHBvcnQge1xuICAgIGRldGVjdCxcbiAgICBkb20sXG4gICAgdXRpbCxcbiAgICBjb25maWcsXG4gICAgZW52LFxuICAgIGxvZyxcbiAgICBlbWl0dGVyLFxuICAgIHNjcm9sbHMsXG4gICAgcmVzaXplc1xufTtcbiJdLCJuYW1lcyI6WyJkZXRlY3QiLCJkb20iLCJ1dGlsIiwiY29uZmlnIiwiZW52IiwibG9nIiwiZW1pdHRlciIsInNjcm9sbHMiLCJyZXNpemVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/index.js\n");

/***/ }),

/***/ "./source/js/core/log.js":
/*!*******************************!*\
  !*** ./source/js/core/log.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ \"./source/js/core/env.js\");\n\n\n/**\n *\n * @public\n * @method log\n * @memberof core\n * @description Normalized app console logger.\n *              If you want to use another console method like `info` or `warn`\n *              you can pass it as the first argument to the `log` method here.\n *              The default method that will be assumed is `console.log`.\n *\n *              Examples:\n *              log( \"info\", ...args )\n *              log( \"warn\", ...args )\n *              log( \"trace\", ...args )\n *              log( \"debug\", ...args )\n *\n */\nvar log = function log() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key) {\n    args[_key] = arguments[_key];\n  }\n  // Only log for development environments\n  if (!_env__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isDev() || !(\"console\" in window)) {\n    return;\n  }\n  var method = \"log\";\n\n  // First arg can be another `console` method to call ?\n  if (typeof console[args[0]] === \"function\") {\n    method = args[0];\n    args = args.slice(1, args.length);\n  }\n  window.console[method](args);\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (log);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9sb2cuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0I7O0FBR3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQyxHQUFHLEdBQUcsU0FBTkEsR0FBR0EsQ0FBQSxFQUF3QjtFQUFBLFNBQUFDLElBQUEsR0FBQUMsU0FBQSxDQUFBQyxNQUFBLEVBQVBDLElBQUksT0FBQUMsS0FBQSxDQUFBSixJQUFBLEdBQUFLLElBQUEsTUFBQUEsSUFBQSxHQUFBTCxJQUFBLEVBQUFLLElBQUE7SUFBSkYsSUFBSSxDQUFBRSxJQUFBLElBQUFKLFNBQUEsQ0FBQUksSUFBQTtFQUFBO0VBQzFCO0VBQ0EsSUFBSyxDQUFDUCw0Q0FBRyxDQUFDUSxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxJQUFJQyxNQUFNLENBQUMsRUFBRztJQUMxQztFQUNKO0VBRUEsSUFBSUMsTUFBTSxHQUFHLEtBQUs7O0VBRWxCO0VBQ0EsSUFBSyxPQUFPQyxPQUFPLENBQUVOLElBQUksQ0FBRSxDQUFDLENBQUUsQ0FBRSxLQUFLLFVBQVUsRUFBRztJQUM5Q0ssTUFBTSxHQUFHTCxJQUFJLENBQUUsQ0FBQyxDQUFFO0lBQ2xCQSxJQUFJLEdBQUdBLElBQUksQ0FBQ08sS0FBSyxDQUFFLENBQUMsRUFBRVAsSUFBSSxDQUFDRCxNQUFPLENBQUM7RUFDdkM7RUFFQUssTUFBTSxDQUFDRSxPQUFPLENBQUVELE1BQU0sQ0FBRSxDQUFFTCxJQUFLLENBQUM7QUFDcEMsQ0FBQzs7QUFJRDtBQUNBO0FBQ0E7QUFDQSxpRUFBZUosR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL3NvdXJjZS9qcy9jb3JlL2xvZy5qcz81ZjY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlbnYgZnJvbSBcIi4vZW52XCI7XG5cblxuLyoqXG4gKlxuICogQHB1YmxpY1xuICogQG1ldGhvZCBsb2dcbiAqIEBtZW1iZXJvZiBjb3JlXG4gKiBAZGVzY3JpcHRpb24gTm9ybWFsaXplZCBhcHAgY29uc29sZSBsb2dnZXIuXG4gKiAgICAgICAgICAgICAgSWYgeW91IHdhbnQgdG8gdXNlIGFub3RoZXIgY29uc29sZSBtZXRob2QgbGlrZSBgaW5mb2Agb3IgYHdhcm5gXG4gKiAgICAgICAgICAgICAgeW91IGNhbiBwYXNzIGl0IGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgYGxvZ2AgbWV0aG9kIGhlcmUuXG4gKiAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgbWV0aG9kIHRoYXQgd2lsbCBiZSBhc3N1bWVkIGlzIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogICAgICAgICAgICAgIEV4YW1wbGVzOlxuICogICAgICAgICAgICAgIGxvZyggXCJpbmZvXCIsIC4uLmFyZ3MgKVxuICogICAgICAgICAgICAgIGxvZyggXCJ3YXJuXCIsIC4uLmFyZ3MgKVxuICogICAgICAgICAgICAgIGxvZyggXCJ0cmFjZVwiLCAuLi5hcmdzIClcbiAqICAgICAgICAgICAgICBsb2coIFwiZGVidWdcIiwgLi4uYXJncyApXG4gKlxuICovXG5jb25zdCBsb2cgPSBmdW5jdGlvbiAoIC4uLmFyZ3MgKSB7XG4gICAgLy8gT25seSBsb2cgZm9yIGRldmVsb3BtZW50IGVudmlyb25tZW50c1xuICAgIGlmICggIWVudi5pc0RldigpIHx8ICEoXCJjb25zb2xlXCIgaW4gd2luZG93KSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBtZXRob2QgPSBcImxvZ1wiO1xuXG4gICAgLy8gRmlyc3QgYXJnIGNhbiBiZSBhbm90aGVyIGBjb25zb2xlYCBtZXRob2QgdG8gY2FsbCA/XG4gICAgaWYgKCB0eXBlb2YgY29uc29sZVsgYXJnc1sgMCBdIF0gPT09IFwiZnVuY3Rpb25cIiApIHtcbiAgICAgICAgbWV0aG9kID0gYXJnc1sgMCBdO1xuICAgICAgICBhcmdzID0gYXJncy5zbGljZSggMSwgYXJncy5sZW5ndGggKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuY29uc29sZVsgbWV0aG9kIF0oIGFyZ3MgKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvcnRcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZGVmYXVsdCBsb2c7Il0sIm5hbWVzIjpbImVudiIsImxvZyIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiaXNEZXYiLCJ3aW5kb3ciLCJtZXRob2QiLCJjb25zb2xlIiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/core/log.js\n");

/***/ }),

/***/ "./source/js/core/resizer.js":
/*!***********************************!*\
  !*** ./source/js/core/resizer.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var properjs_resizecontroller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-resizecontroller */ \"./node_modules/properjs-resizecontroller/ResizeController.js\");\n/* harmony import */ var properjs_resizecontroller__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(properjs_resizecontroller__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n *\n * @description Single app instanceof [ResizeController]{@link https://github.com/ProperJS/ResizeController} for raf resize handling\n * @member resizer\n * @memberof core\n *\n */\nvar resizer = new (properjs_resizecontroller__WEBPACK_IMPORTED_MODULE_0___default())();\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resizer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9yZXNpemVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQyxPQUFPLEdBQUcsSUFBSUQsa0VBQWdCLENBQUMsQ0FBQzs7QUFHdEM7QUFDQTtBQUNBO0FBQ0EsaUVBQWVDLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY29yZS9yZXNpemVyLmpzP2I4OTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlc2l6ZUNvbnRyb2xsZXIgZnJvbSBcInByb3BlcmpzLXJlc2l6ZWNvbnRyb2xsZXJcIjtcblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIFNpbmdsZSBhcHAgaW5zdGFuY2VvZiBbUmVzaXplQ29udHJvbGxlcl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL1Byb3BlckpTL1Jlc2l6ZUNvbnRyb2xsZXJ9IGZvciByYWYgcmVzaXplIGhhbmRsaW5nXG4gKiBAbWVtYmVyIHJlc2l6ZXJcbiAqIEBtZW1iZXJvZiBjb3JlXG4gKlxuICovXG5jb25zdCByZXNpemVyID0gbmV3IFJlc2l6ZUNvbnRyb2xsZXIoKTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvcnRcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZGVmYXVsdCByZXNpemVyO1xuIl0sIm5hbWVzIjpbIlJlc2l6ZUNvbnRyb2xsZXIiLCJyZXNpemVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/resizer.js\n");

/***/ }),

/***/ "./source/js/core/resizes.js":
/*!***********************************!*\
  !*** ./source/js/core/resizes.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./source/js/core/util.js\");\n/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emitter */ \"./source/js/core/emitter.js\");\n/* harmony import */ var _resizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resizer */ \"./source/js/core/resizer.js\");\n/* harmony import */ var properjs_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! properjs-throttle */ \"./node_modules/properjs-throttle/throttle.js\");\n/* harmony import */ var properjs_throttle__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(properjs_throttle__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var properjs_debounce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! properjs-debounce */ \"./node_modules/properjs-debounce/debounce.js\");\n/* harmony import */ var properjs_debounce__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(properjs_debounce__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/config */ \"./source/js/core/config.js\");\n/* harmony import */ var _core_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/dom */ \"./source/js/core/dom.js\");\n\n\n\n\n\n\n\nvar _throttled = 5;\nvar _debounced = 100;\n\n/**\n *\n * @public\n * @namespace resizes\n * @memberof core\n * @description Handles app-wide emission of various resize detection events.\n *\n */\nvar resizes = {\n  /**\n   *\n   * @public\n   * @method init\n   * @memberof core.resizes\n   * @description Method binds event listeners for resize controller.\n   *\n   */\n  init: function init() {\n    _resizer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].on('resize', properjs_throttle__WEBPACK_IMPORTED_MODULE_3___default()(onThrottle, _throttled));\n\n    // Hook into resize of `width` only for this handler\n    // @bug: iOS window size changes when Safari's chrome switches between full and minimal-ui.\n    _resizer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].on('resizewidth', properjs_debounce__WEBPACK_IMPORTED_MODULE_4___default()(onDebounce, _debounced));\n  }\n};\n\n/**\n *\n * @private\n * @method onDebounce\n * @memberof core.resizes\n * @description Debounced resize events.\n *\n */\nvar onDebounce = function onDebounce() {\n  _emitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire('app--resize-debounced');\n  _util__WEBPACK_IMPORTED_MODULE_0__.updateImages();\n};\n\n/**\n *\n * @private\n * @method onThrottle\n * @memberof core.resizes\n * @description Method handles the window resize event via [ResizeController]{@link https://github.com/ProperJS/ResizeController}.\n *\n */\nvar onThrottle = function onThrottle() {\n  _emitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire('app--resize');\n};\n\n/******************************************************************************\n * Export\n *******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resizes);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9yZXNpemVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDQztBQUNBO0FBQ1M7QUFDQTtBQUNMO0FBQ047QUFFOUIsSUFBTU8sVUFBVSxHQUFHLENBQUM7QUFDcEIsSUFBTUMsVUFBVSxHQUFHLEdBQUc7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQyxPQUFPLEdBQUc7RUFDZjtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0NDLElBQUksV0FBQUEsS0FBQSxFQUFHO0lBQ05SLGdEQUFPLENBQUNTLEVBQUUsQ0FBQyxRQUFRLEVBQUVSLHdEQUFRLENBQUNTLFVBQVUsRUFBRUwsVUFBVSxDQUFDLENBQUM7O0lBRXREO0lBQ0E7SUFDQUwsZ0RBQU8sQ0FBQ1MsRUFBRSxDQUFDLGFBQWEsRUFBRVAsd0RBQVEsQ0FBQ1MsVUFBVSxFQUFFTCxVQUFVLENBQUMsQ0FBQztFQUM1RDtBQUNELENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQU1LLFVBQVUsR0FBRyxTQUFiQSxVQUFVQSxDQUFBLEVBQWM7RUFDN0JaLGdEQUFPLENBQUNhLElBQUksQ0FBQyx1QkFBdUIsQ0FBQztFQUNyQ2QsK0NBQWlCLENBQUMsQ0FBQztBQUNwQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNWSxVQUFVLEdBQUcsU0FBYkEsVUFBVUEsQ0FBQSxFQUFjO0VBQzdCWCxnREFBTyxDQUFDYSxJQUFJLENBQUMsYUFBYSxDQUFDO0FBRzVCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsaUVBQWVMLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvY29yZS9yZXNpemVzLmpzPzBkZWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGVtaXR0ZXIgZnJvbSAnLi9lbWl0dGVyJztcbmltcG9ydCByZXNpemVyIGZyb20gJy4vcmVzaXplcic7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAncHJvcGVyanMtdGhyb3R0bGUnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ3Byb3BlcmpzLWRlYm91bmNlJztcbmltcG9ydCBjb25maWcgZnJvbSAnLi4vY29yZS9jb25maWcnO1xuaW1wb3J0IGRvbSBmcm9tICcuLi9jb3JlL2RvbSc7XG5cbmNvbnN0IF90aHJvdHRsZWQgPSA1O1xuY29uc3QgX2RlYm91bmNlZCA9IDEwMDtcblxuLyoqXG4gKlxuICogQHB1YmxpY1xuICogQG5hbWVzcGFjZSByZXNpemVzXG4gKiBAbWVtYmVyb2YgY29yZVxuICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgYXBwLXdpZGUgZW1pc3Npb24gb2YgdmFyaW91cyByZXNpemUgZGV0ZWN0aW9uIGV2ZW50cy5cbiAqXG4gKi9cbmNvbnN0IHJlc2l6ZXMgPSB7XG5cdC8qKlxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAbWVtYmVyb2YgY29yZS5yZXNpemVzXG5cdCAqIEBkZXNjcmlwdGlvbiBNZXRob2QgYmluZHMgZXZlbnQgbGlzdGVuZXJzIGZvciByZXNpemUgY29udHJvbGxlci5cblx0ICpcblx0ICovXG5cdGluaXQoKSB7XG5cdFx0cmVzaXplci5vbigncmVzaXplJywgdGhyb3R0bGUob25UaHJvdHRsZSwgX3Rocm90dGxlZCkpO1xuXG5cdFx0Ly8gSG9vayBpbnRvIHJlc2l6ZSBvZiBgd2lkdGhgIG9ubHkgZm9yIHRoaXMgaGFuZGxlclxuXHRcdC8vIEBidWc6IGlPUyB3aW5kb3cgc2l6ZSBjaGFuZ2VzIHdoZW4gU2FmYXJpJ3MgY2hyb21lIHN3aXRjaGVzIGJldHdlZW4gZnVsbCBhbmQgbWluaW1hbC11aS5cblx0XHRyZXNpemVyLm9uKCdyZXNpemV3aWR0aCcsIGRlYm91bmNlKG9uRGVib3VuY2UsIF9kZWJvdW5jZWQpKTtcblx0fVxufTtcblxuLyoqXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2Qgb25EZWJvdW5jZVxuICogQG1lbWJlcm9mIGNvcmUucmVzaXplc1xuICogQGRlc2NyaXB0aW9uIERlYm91bmNlZCByZXNpemUgZXZlbnRzLlxuICpcbiAqL1xuY29uc3Qgb25EZWJvdW5jZSA9IGZ1bmN0aW9uKCkge1xuXHRlbWl0dGVyLmZpcmUoJ2FwcC0tcmVzaXplLWRlYm91bmNlZCcpO1xuXHR1dGlsLnVwZGF0ZUltYWdlcygpO1xufTtcblxuLyoqXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2Qgb25UaHJvdHRsZVxuICogQG1lbWJlcm9mIGNvcmUucmVzaXplc1xuICogQGRlc2NyaXB0aW9uIE1ldGhvZCBoYW5kbGVzIHRoZSB3aW5kb3cgcmVzaXplIGV2ZW50IHZpYSBbUmVzaXplQ29udHJvbGxlcl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL1Byb3BlckpTL1Jlc2l6ZUNvbnRyb2xsZXJ9LlxuICpcbiAqL1xuY29uc3Qgb25UaHJvdHRsZSA9IGZ1bmN0aW9uKCkge1xuXHRlbWl0dGVyLmZpcmUoJ2FwcC0tcmVzaXplJyk7XG5cblxufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwb3J0XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBkZWZhdWx0IHJlc2l6ZXM7XG4iXSwibmFtZXMiOlsidXRpbCIsImVtaXR0ZXIiLCJyZXNpemVyIiwidGhyb3R0bGUiLCJkZWJvdW5jZSIsImNvbmZpZyIsImRvbSIsIl90aHJvdHRsZWQiLCJfZGVib3VuY2VkIiwicmVzaXplcyIsImluaXQiLCJvbiIsIm9uVGhyb3R0bGUiLCJvbkRlYm91bmNlIiwiZmlyZSIsInVwZGF0ZUltYWdlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/core/resizes.js\n");

/***/ }),

/***/ "./source/js/core/scrolls.js":
/*!***********************************!*\
  !*** ./source/js/core/scrolls.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Scroller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scroller */ \"./source/js/core/Scroller.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core */ \"./source/js/core/index.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/dist/gsap.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(gsap__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var gsap_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap/ScrollToPlugin */ \"./node_modules/gsap/ScrollToPlugin.js\");\n/* harmony import */ var gsap_ScrollSmoother__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gsap/ScrollSmoother */ \"./node_modules/gsap/ScrollSmoother.js\");\n/* harmony import */ var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gsap/ScrollTrigger */ \"./node_modules/gsap/ScrollTrigger.js\");\n\n\n\n\n\n\n\n/**\n *\n * @public\n * @namespace scrolls\n * @description Executes Scrolls\n * @memberof menus\n *\n */\nvar scrolls = {\n  /**\n  *\n  * @public\n  * @method init\n  * @memberof scrolls\n  * @description Method initializes intro node in DOM.\n  *\n  */\n  init: function init() {\n    gsap__WEBPACK_IMPORTED_MODULE_2___default().registerPlugin(gsap_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_3__[\"default\"], gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_4__[\"default\"], gsap_ScrollSmoother__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n    _core__WEBPACK_IMPORTED_MODULE_1__.emitter.on(\"app--scroll-teardown\", this.teardown.bind(this));\n    _core__WEBPACK_IMPORTED_MODULE_1__.emitter.on(\"app--init-scroll\", this.scroller.bind(this));\n    _core__WEBPACK_IMPORTED_MODULE_1__.emitter.on(\"app--resize-debounced\", this.reCalc.bind(this));\n    _core__WEBPACK_IMPORTED_MODULE_1__.emitter.on(\"app--view-change\", this.reCalc.bind(this));\n    _core__WEBPACK_IMPORTED_MODULE_1__.emitter.on(\"app--transition-in\", this.scrollTriggerController.bind(this));\n    this.scrolls = null;\n    this.scrollTimeout = null;\n    this.gallery = null;\n    this.galleryRect = null;\n    this.list = null;\n    window.scrollTo(0, 0);\n  },\n  /**\n  *\n  * @public\n  * @method scroller\n  * @memberof scrolls\n  * @description Detect Device for scroll\n  *\n  */\n  scroller: function scroller() {\n    var _this = this;\n    _Scroller__WEBPACK_IMPORTED_MODULE_0__[\"default\"].on(\"scroll\", function (e) {\n      _this.scrollEvents(e);\n    });\n  },\n  /**\n  *\n  * @public\n  * @method scrollTriggerController\n  * @memberof scrolls\n  * @description Controlls all Scroll Triggers from Gsap\n  *\n  */\n  scrollTriggerController: function scrollTriggerController() {\n    var _this2 = this;\n    this.list = document.querySelector(\".js-index-list\");\n    var $galleryContainer = document.querySelector(\".js-hover-gallery\");\n    this.gallery = $galleryContainer;\n    this.galleryRect = this.gallery.getBoundingClientRect();\n    _core__WEBPACK_IMPORTED_MODULE_1__.log(this.list.offsetHeight);\n    gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_4__[\"default\"].matchMedia({\n      \"(min-width: 1200px)\": function minWidth1200px() {\n        // ScrollTrigger Elements\n        var $galleryIndex = document.querySelector(\".js-index-gallery\");\n        gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create({\n          trigger: $galleryIndex,\n          start: function start() {\n            return \"top \"  _this2.galleryRect.x;\n          },\n          end: function end() {\n            return \"bottom=\"  (_this2.list.offsetHeight - $galleryIndex.offsetHeight);\n          },\n          pin: true\n        });\n      }\n    });\n  },\n  /**\n  *\n  * @public\n  * @method reCalc\n  * @memberof scrolls\n  * @description Request to refresh dimension calculations\n  *\n  */\n  reCalc: function reCalc() {\n    if (this.galleryRect != null) {\n      this.galleryRect = this.gallery.getBoundingClientRect();\n    }\n    gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_4__[\"default\"].refresh();\n  },\n  /**\n  *\n  * @public\n  * @method scrollEvents\n  * @memberof scrolls\n  * @description All scroll based calcs\n  *\n  */\n  scrollEvents: function scrollEvents(e) {\n    _core__WEBPACK_IMPORTED_MODULE_1__.emitter.fire(\"app--scroll\", e);\n\n    // core.dom.html.addClass( \"is-scrolling\" );\n    //\n    // clearTimeout( this.scrollTimeout );\n    //\n    // this.scrollTimeout = setTimeout(() => {\n    //     core.dom.html.removeClass( \"is-scrolling\" );\n    // }, 300 );\n    //\n    // // Scroll Down\n    // if ( e.deltaY < 0 ) {\n    //     core.dom.html.removeClass( \"is-scroll-up\" ).addClass( \"is-scroll-down\" );\n    //     core.emitter.fire( \"app--scrolldown\", e );\n    //\n    // // Scroll Up\n    // } else {\n    //     core.dom.html.removeClass( \"is-scroll-down\" ).addClass( \"is-scroll-up\" );\n    //     core.emitter.fire( \"app--scrollup\", e );\n    // }\n  },\n  /**\n  *\n  * @public\n  * @method scrollTo\n  * @memberof scrolls\n  * @description Animate scroll to position\n  *\n  */\n  scrollTo: function scrollTo(scrollY) {\n    window.scrollTo(scrollY, 0);\n  },\n  /**\n  *\n  * @public\n  * @method teardown\n  * @memberof scrolls\n  * @description Stop and Kill Scroll Instances\n  *\n  */\n  teardown: function teardown() {\n    if (this.scrolls) {\n      this.scrolls.kill();\n    }\n  }\n};\n\n/******************************************************************************\n * Export\n *******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scrolls);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUQ7QUFDQTtBQUNBO0FBQ0EsaUVBQWVyQyxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vc291cmNlL2pzL2NvcmUvc2Nyb2xscy5qcz8xZjc0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzY3JvbGxlciBmcm9tIFwiLi9TY3JvbGxlclwiO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcbmltcG9ydCBTY3JvbGxUb1BsdWdpbiBmcm9tIFwiZ3NhcC9TY3JvbGxUb1BsdWdpblwiO1xuaW1wb3J0IFNjcm9sbFNtb290aGVyIGZyb20gXCJnc2FwL1Njcm9sbFNtb290aGVyXCI7XG5pbXBvcnQgU2Nyb2xsVHJpZ2dlciBmcm9tIFwiZ3NhcC9TY3JvbGxUcmlnZ2VyXCI7XG5cblxuLyoqXG4gKlxuICogQHB1YmxpY1xuICogQG5hbWVzcGFjZSBzY3JvbGxzXG4gKiBAZGVzY3JpcHRpb24gRXhlY3V0ZXMgU2Nyb2xsc1xuICogQG1lbWJlcm9mIG1lbnVzXG4gKlxuICovXG5jb25zdCBzY3JvbGxzID0ge1xuXG4gIC8qKlxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAbWVtYmVyb2Ygc2Nyb2xsc1xuXHQgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGluaXRpYWxpemVzIGludHJvIG5vZGUgaW4gRE9NLlxuXHQgKlxuXHQgKi9cbiAgICBpbml0ICgpIHtcblxuICAgICAgICBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRvUGx1Z2luLCBTY3JvbGxUcmlnZ2VyLCBTY3JvbGxTbW9vdGhlcik7XG5cbiAgICAgICAgY29yZS5lbWl0dGVyLm9uKFwiYXBwLS1zY3JvbGwtdGVhcmRvd25cIiwgdGhpcy50ZWFyZG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29yZS5lbWl0dGVyLm9uKFwiYXBwLS1pbml0LXNjcm9sbFwiLCB0aGlzLnNjcm9sbGVyLmJpbmQodGhpcykpO1xuICAgICAgICBjb3JlLmVtaXR0ZXIub24oXCJhcHAtLXJlc2l6ZS1kZWJvdW5jZWRcIiwgdGhpcy5yZUNhbGMuYmluZCh0aGlzKSApO1xuICAgICAgICBjb3JlLmVtaXR0ZXIub24oXCJhcHAtLXZpZXctY2hhbmdlXCIsIHRoaXMucmVDYWxjLmJpbmQodGhpcykgKTtcbiAgICAgICAgY29yZS5lbWl0dGVyLm9uKFwiYXBwLS10cmFuc2l0aW9uLWluXCIsIHRoaXMuc2Nyb2xsVHJpZ2dlckNvbnRyb2xsZXIuYmluZCh0aGlzKSApO1xuXG4gICAgICAgIHRoaXMuc2Nyb2xscyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5nYWxsZXJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5nYWxsZXJ5UmVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdCA9IG51bGw7XG4gICAgICAgXG4gICAgICBcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsMCk7XG4gICAgfSxcblxuXG5cbiAgICAvKipcbiAgXHQgKlxuICBcdCAqIEBwdWJsaWNcbiAgXHQgKiBAbWV0aG9kIHNjcm9sbGVyXG4gIFx0ICogQG1lbWJlcm9mIHNjcm9sbHNcbiAgXHQgKiBAZGVzY3JpcHRpb24gRGV0ZWN0IERldmljZSBmb3Igc2Nyb2xsXG4gIFx0ICpcbiAgXHQgKi9cbiAgICBzY3JvbGxlciAoKSB7XG4gICAgICAgIHNjcm9sbGVyLm9uKFwic2Nyb2xsXCIsIChlKSA9PiB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxFdmVudHMoZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cblxuXG4gICAgLyoqXG4gIFx0ICpcbiAgXHQgKiBAcHVibGljXG4gIFx0ICogQG1ldGhvZCBzY3JvbGxUcmlnZ2VyQ29udHJvbGxlclxuICBcdCAqIEBtZW1iZXJvZiBzY3JvbGxzXG4gIFx0ICogQGRlc2NyaXB0aW9uIENvbnRyb2xscyBhbGwgU2Nyb2xsIFRyaWdnZXJzIGZyb20gR3NhcFxuICBcdCAqXG4gIFx0ICovXG4gICAgc2Nyb2xsVHJpZ2dlckNvbnRyb2xsZXIoKXtcblxuICAgICAgdGhpcy5saXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5qcy1pbmRleC1saXN0XCIpO1xuICAgICAgbGV0ICRnYWxsZXJ5Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5qcy1ob3Zlci1nYWxsZXJ5XCIpO1xuICAgICAgdGhpcy5nYWxsZXJ5ID0gJGdhbGxlcnlDb250YWluZXI7XG4gICAgICB0aGlzLmdhbGxlcnlSZWN0ID0gdGhpcy5nYWxsZXJ5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBjb3JlLmxvZyh0aGlzLmxpc3Qub2Zmc2V0SGVpZ2h0KVxuICAgICBcbiAgICAgIFNjcm9sbFRyaWdnZXIubWF0Y2hNZWRpYSh7IFwiKG1pbi13aWR0aDogMTIwMHB4KVwiOiAoKSA9PiB7XG5cbiAgICAgICAgLy8gU2Nyb2xsVHJpZ2dlciBFbGVtZW50c1xuICAgICAgICBsZXQgJGdhbGxlcnlJbmRleCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuanMtaW5kZXgtZ2FsbGVyeVwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XG4gICAgICAgICAgdHJpZ2dlcjogJGdhbGxlcnlJbmRleCxcbiAgICAgICAgICBzdGFydDogKCkgPT4gXCJ0b3AgXCIgKyB0aGlzLmdhbGxlcnlSZWN0LnggLFxuICAgICAgICAgIGVuZDogKCkgPT4gXCJib3R0b20rPVwiICsgKCB0aGlzLmxpc3Qub2Zmc2V0SGVpZ2h0IC0gJGdhbGxlcnlJbmRleC5vZmZzZXRIZWlnaHQpICxcbiAgICAgICAgICBwaW46IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgfX0pO1xuXG4gICAgfSxcblxuXG5cbiAgICAvKipcbiAgXHQgKlxuICBcdCAqIEBwdWJsaWNcbiAgXHQgKiBAbWV0aG9kIHJlQ2FsY1xuICBcdCAqIEBtZW1iZXJvZiBzY3JvbGxzXG4gIFx0ICogQGRlc2NyaXB0aW9uIFJlcXVlc3QgdG8gcmVmcmVzaCBkaW1lbnNpb24gY2FsY3VsYXRpb25zXG4gIFx0ICpcbiAgXHQgKi9cbiAgICByZUNhbGMoKXtcblxuICAgICAgaWYgKCB0aGlzLmdhbGxlcnlSZWN0ICE9IG51bGwgKXtcbiAgICAgICAgdGhpcy5nYWxsZXJ5UmVjdCA9IHRoaXMuZ2FsbGVyeS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBcbiAgICAgIH1cblxuICAgICAgU2Nyb2xsVHJpZ2dlci5yZWZyZXNoKCk7XG5cbiAgICB9LFxuXG5cblxuICAgIC8qKlxuICBcdCAqXG4gIFx0ICogQHB1YmxpY1xuICBcdCAqIEBtZXRob2Qgc2Nyb2xsRXZlbnRzXG4gIFx0ICogQG1lbWJlcm9mIHNjcm9sbHNcbiAgXHQgKiBAZGVzY3JpcHRpb24gQWxsIHNjcm9sbCBiYXNlZCBjYWxjc1xuICBcdCAqXG4gIFx0ICovXG4gICAgc2Nyb2xsRXZlbnRzKGUpe1xuXG4gICAgICBjb3JlLmVtaXR0ZXIuZmlyZSggXCJhcHAtLXNjcm9sbFwiLCBlICk7XG4gICAgXG4gICAgICAvLyBjb3JlLmRvbS5odG1sLmFkZENsYXNzKCBcImlzLXNjcm9sbGluZ1wiICk7XG4gICAgICAvL1xuICAgICAgLy8gY2xlYXJUaW1lb3V0KCB0aGlzLnNjcm9sbFRpbWVvdXQgKTtcbiAgICAgIC8vXG4gICAgICAvLyB0aGlzLnNjcm9sbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0IHtcbiAgICAgIC8vICAgICBjb3JlLmRvbS5odG1sLnJlbW92ZUNsYXNzKCBcImlzLXNjcm9sbGluZ1wiICk7XG4gICAgICAvLyB9LCAzMDAgKTtcbiAgICAgIC8vXG4gICAgICAvLyAvLyBTY3JvbGwgRG93blxuICAgICAgLy8gaWYgKCBlLmRlbHRhWSA8IDAgKSB7XG4gICAgICAvLyAgICAgY29yZS5kb20uaHRtbC5yZW1vdmVDbGFzcyggXCJpcy1zY3JvbGwtdXBcIiApLmFkZENsYXNzKCBcImlzLXNjcm9sbC1kb3duXCIgKTtcbiAgICAgIC8vICAgICBjb3JlLmVtaXR0ZXIuZmlyZSggXCJhcHAtLXNjcm9sbGRvd25cIiwgZSApO1xuICAgICAgLy9cbiAgICAgIC8vIC8vIFNjcm9sbCBVcFxuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgICBjb3JlLmRvbS5odG1sLnJlbW92ZUNsYXNzKCBcImlzLXNjcm9sbC1kb3duXCIgKS5hZGRDbGFzcyggXCJpcy1zY3JvbGwtdXBcIiApO1xuICAgICAgLy8gICAgIGNvcmUuZW1pdHRlci5maXJlKCBcImFwcC0tc2Nyb2xsdXBcIiwgZSApO1xuICAgICAgLy8gfVxuICAgIH0sXG5cblxuXG4gICAgLyoqXG4gIFx0ICpcbiAgXHQgKiBAcHVibGljXG4gIFx0ICogQG1ldGhvZCBzY3JvbGxUb1xuICBcdCAqIEBtZW1iZXJvZiBzY3JvbGxzXG4gIFx0ICogQGRlc2NyaXB0aW9uIEFuaW1hdGUgc2Nyb2xsIHRvIHBvc2l0aW9uXG4gIFx0ICpcbiAgXHQgKi9cbiAgICBzY3JvbGxUbyhzY3JvbGxZKXtcblxuICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFksIDApO1xuXG4gICAgfSxcblxuXG5cbiAgICAvKipcbiAgXHQgKlxuICBcdCAqIEBwdWJsaWNcbiAgXHQgKiBAbWV0aG9kIHRlYXJkb3duXG4gIFx0ICogQG1lbWJlcm9mIHNjcm9sbHNcbiAgXHQgKiBAZGVzY3JpcHRpb24gU3RvcCBhbmQgS2lsbCBTY3JvbGwgSW5zdGFuY2VzXG4gIFx0ICpcbiAgXHQgKi9cbiAgICB0ZWFyZG93biAoKSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxzKXtcbiAgICAgICAgdGhpcy5zY3JvbGxzLmtpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEV4cG9ydFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZGVmYXVsdCBzY3JvbGxzOyJdLCJuYW1lcyI6WyJzY3JvbGxlciIsImNvcmUiLCJnc2FwIiwiU2Nyb2xsVG9QbHVnaW4iLCJTY3JvbGxTbW9vdGhlciIsIlNjcm9sbFRyaWdnZXIiLCJzY3JvbGxzIiwiaW5pdCIsInJlZ2lzdGVyUGx1Z2luIiwiZW1pdHRlciIsIm9uIiwidGVhcmRvd24iLCJiaW5kIiwicmVDYWxjIiwic2Nyb2xsVHJpZ2dlckNvbnRyb2xsZXIiLCJzY3JvbGxUaW1lb3V0IiwiZ2FsbGVyeSIsImdhbGxlcnlSZWN0IiwibGlzdCIsIndpbmRvdyIsInNjcm9sbFRvIiwiX3RoaXMiLCJlIiwic2Nyb2xsRXZlbnRzIiwiX3RoaXMyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiJGdhbGxlcnlDb250YWluZXIiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsb2ciLCJvZmZzZXRIZWlnaHQiLCJtYXRjaE1lZGlhIiwibWluV2lkdGgxMjAwcHgiLCIkZ2FsbGVyeUluZGV4IiwiY3JlYXRlIiwidHJpZ2dlciIsInN0YXJ0IiwieCIsImVuZCIsInBpbiIsInJlZnJlc2giLCJmaXJlIiwic2Nyb2xsWSIsImtpbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/core/scrolls.js\n");

/***/ }),

/***/ "./source/js/core/util.js":
/*!********************************!*\
  !*** ./source/js/core/util.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   currentTime: () => (/* binding */ currentTime),\n/* harmony export */   getClosestValue: () => (/* binding */ getClosestValue),\n/* harmony export */   getElementsInView: () => (/* binding */ getElementsInView),\n/* harmony export */   getSiblings: () => (/* binding */ getSiblings),\n/* harmony export */   getTransitionDuration: () => (/* binding */ getTransitionDuration),\n/* harmony export */   isElementLoadable: () => (/* binding */ isElementLoadable),\n/* harmony export */   isElementVisible: () => (/* binding */ isElementVisible),\n/* harmony export */   loadImages: () => (/* binding */ loadImages),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   px: () => (/* binding */ px),\n/* harmony export */   updateImages: () => (/* binding */ updateImages)\n/* harmony export */ });\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-hobo */ \"./node_modules/properjs-hobo/dist/hobo.build.js\");\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(properjs_hobo__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var properjs_imageloader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! properjs-imageloader */ \"./node_modules/properjs-imageloader/ImageLoader.js\");\n/* harmony import */ var properjs_imageloader__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(properjs_imageloader__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./source/js/core/config.js\");\n/* harmony import */ var _detect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./detect */ \"./source/js/core/detect.js\");\n/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./log */ \"./source/js/core/log.js\");\n/**\n *\n * @public\n * @namespace util\n * @memberof core\n * @description Houses app-wide utility methods.\n *\n */\n\n\n\n\n\n\n/**\n *\n * @description Module onImageLoadHander method, handles event\n * @method isElementLoadable\n * @param {object} el The DOMElement to check the offset of\n * @memberof core.util\n * @returns {boolean}\n *\n */\nvar isElementLoadable = function isElementLoadable(el) {\n  var ret = false;\n  if (el) {\n    var bounds = el.getBoundingClientRect();\n    ret = bounds.top < window.innerHeight * 2;\n  }\n  return ret;\n};\n\n/**\n *\n * @description Module isElementVisible method, handles element boundaries\n * @method isElementVisible\n * @param {object} el The DOMElement to check the offsets of\n * @memberof core.util\n * @returns {boolean}\n *\n */\nvar isElementVisible = function isElementVisible(el) {\n  var ret = false;\n  if (el) {\n    var bounds = el.getBoundingClientRect();\n    ret = bounds.top < window.innerHeight && bounds.bottom > 0;\n  }\n  return ret;\n};\n\n/**\n *\n * @description Handles plats when Element is Visible\n * @method updatePlates\n * @param {object} el The DOMElement to check the offsets of\n * @memberof core.util\n * @returns class\n *\n */\nvar updatePlates = function updatePlates($plates) {\n  var $plate = null;\n  var i = $plates.length;\n  for (i; i--;) {\n    $plate = $plates.eq(i);\n    if (isElementVisible($plate[0])) {\n      $plate.addClass(\"is-active\");\n    } else {\n      $plate.removeClass(\"is-active\");\n    }\n  }\n};\n\n/**\n *\n * @description Fresh query to lazyload images on page\n * @method loadImages\n * @param {object} images Optional collection of images to load\n * @param {function} handler Optional handler for load conditions\n * @memberof core.util\n * @returns {ImageLoader}\n *\n */\n\nvar loadImages = function loadImages(images, handler) {\n  var rQuery = /\\?(.*)$/;\n  var map = function map(vnt) {\n    return parseInt(vnt, 10);\n  };\n  var $img = null;\n  var data = null;\n  var imgWidths = null;\n  var width = null;\n  var breakpoints = null;\n  var currentBreakpoint = null;\n  var source = null;\n  var i = null;\n  var filename = null;\n  var extention = null;\n\n  // Normalize the handler\n  handler = handler || isElementLoadable;\n\n  // Normalize the images\n  images = images || properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lazyImageSelector);\n\n  // Hook here to determine image variant sizes to load ?\n\n  i = images.length;\n  for (i; i--;) {\n    $img = images.eq(i);\n    data = $img.data();\n    $img.addClass(\"loaded\");\n    if (data.breakpoints) {\n      width = window.innerWidth;\n\n      // Gather breakpoints and image sizes -> Then match\n\n      breakpoints = data.breakpoints.split(',').map(map);\n      currentBreakpoint = getClosestValue(breakpoints, width);\n      if (data.orientation) {\n        var orientationSource = $img.data(\"src\".concat(currentBreakpoint)).replace(rQuery, '');\n        $img[0].setAttribute(_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lazyImageAttr, \"\".concat(orientationSource));\n      } else {\n        source = data.imgSrc.replace(rQuery, '');\n        filename = source.replace(/(\\_)(?!.*\\1).*[0-9]x/, \"_\"  currentBreakpoint  \"x\");\n        $img[0].setAttribute(_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lazyImageAttr, \"\".concat(filename));\n      }\n\n      // if (data.orientation){\n      //\n      //\n      //\n      //   console.log(breakPointAsset);\n      //\n      //   let breakPointSrc = breakPointAsset.replace(rQuery, '');\n      //\n      //   console.log(breakPointSrc);\n      //\n      // }\n    }\n  }\n\n  return new (properjs_imageloader__WEBPACK_IMPORTED_MODULE_1___default())({\n    elements: images,\n    property: _config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lazyImageAttr,\n    executor: handler\n  });\n};\n\n/**\n *\n * @description Update image sizes on Resize (for images that have already been loaded)\n * @method updateImages\n * @param {Hobo} images The optional argument passed collection to reload\n * @memberof util\n *\n */\nvar updateImages = function updateImages(images) {\n  images = images || properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(\"[\".concat(_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].imageLoaderAttr, \"]\"));\n  if (images.length) {\n    images.attr(_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].imageLoaderAttr, '');\n    loadImages(images, noop);\n  }\n};\n\n/**\n *\n * @description All true all the time\n * @method noop\n * @memberof core.util\n * @returns {boolean}\n *\n */\nvar noop = function noop() {\n  return true;\n};\n\n/**\n *\n * @method getElementsInView\n * @memberof core.util\n * @param {Hobo} $nodes The collection to process\n * @param {function} executor Optional method to determin `in view`\n * @description Get elements within a loadable position on the page\n * @returns {Hobo}\n *\n */\nvar getElementsInView = function getElementsInView($nodes, executor) {\n  var i = $nodes.length;\n  var ret = [];\n  executor = executor || isElementVisible;\n  for (i; i--;) {\n    if (executor($nodes[i])) {\n      ret.push($nodes[i]);\n    }\n  }\n  return properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(ret);\n};\n\n/**\n *\n * @description Get the applied transition duration from CSS\n * @method getTransitionDuration\n * @param {object} el The DOMElement\n * @memberof util\n * @returns {number}\n *\n */\nvar getTransitionDuration = function getTransitionDuration(el) {\n  var ret = 0;\n  var duration = null;\n  var isSeconds = false;\n  var multiplyBy = 1000;\n  if (el) {\n    duration = getComputedStyle(el)[_detect__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getPrefixed(\"transition-duration\")];\n    isSeconds = duration.indexOf(\"ms\") === -1;\n    multiplyBy = isSeconds ? 1000 : 1;\n    ret = parseFloat(duration) * multiplyBy;\n  }\n  return ret;\n};\n\n/**\n *\n * @description Select siblings of element\n * @method getSiblings\n * @memberof core.util\n * @returns {boolean}\n *\n */\nvar getSiblings = function getSiblings(e) {\n  var siblings = [];\n\n  // if no parent, return no sibling\n  if (!e.parentNode) {\n    return siblings;\n  }\n\n  // first child of the array\n  var sibling = e.firstChild;\n\n  // collecting siblings\n  while (sibling) {\n    if (sibling.nodeType === 1 && sibling !== e) {\n      siblings.push(sibling);\n    }\n    sibling = sibling.nextSibling;\n  }\n  return siblings;\n};\n\n/**\n *\n * @description Get current time every second\n * @method currentTime\n * @memberof core.util\n * @returns {time}\n *\n */\nvar currentTime = function currentTime(e) {\n  var date = new Date();\n  var hh = date.getHours();\n  var mm = date.getMinutes();\n  var ss = date.getSeconds();\n  var session = \"AM\";\n  if (hh == 0) {\n    hh = 12;\n  }\n  if (hh > 12) {\n    hh = hh - 12;\n    session = \"PM\";\n  }\n  hh = hh < 10 ? \"0\"  hh : hh;\n  mm = mm < 10 ? \"0\"  mm : mm;\n  ss = ss < 10 ? \"0\"  ss : ss;\n  var time = hh  \"<span class='is-flashing'>:</span>\"  mm  \" \"  session;\n  document.getElementById(\"time\").innerHTML = time;\n  var t = setTimeout(function () {\n    currentTime();\n  }, 1000);\n};\n\n/**\n *\n * @method getClosestValue\n * @memberof util\n * @param {array} arr The array to process\n * @param {number} closestTo The number to get close to\n * @description Get closest number value without going under\n * @returns {number}\n *\n */\nvar getClosestValue = function getClosestValue(arr, closestTo) {\n  // Get the highest number in arr in case it matches nothing.\n  var close = Math.max.apply(null, arr);\n  var i = arr.length;\n  for (i; i--;) {\n    // Check if it's higher than your number, but lower than your closest value\n    if (arr[i] >= closestTo && arr[i] < close) {\n      close = arr[i];\n    }\n  }\n  return close;\n};\n\n/**\n *\n * @description Add pixel units when inline styling\n * @method px\n * @param {string} str The value to pixel-ify\n * @memberof util\n * @returns {string}\n *\n */\nvar px = function px(str) {\n  return \"\".concat(str, \"px\");\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MWQ1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBAcHVibGljXG4gKiBAbmFtZXNwYWNlIHV0aWxcbiAqIEBtZW1iZXJvZiBjb3JlXG4gKiBAZGVzY3JpcHRpb24gSG91c2VzIGFwcC13aWRlIHV0aWxpdHkgbWV0aG9kcy5cbiAqXG4gKi9cbmltcG9ydCAkIGZyb20gXCJwcm9wZXJqcy1ob2JvXCI7XG5pbXBvcnQgSW1hZ2VMb2FkZXIgZnJvbSBcInByb3BlcmpzLWltYWdlbG9hZGVyXCI7XG5pbXBvcnQgY29uZmlnIGZyb20gXCIuL2NvbmZpZ1wiO1xuaW1wb3J0IGRldGVjdCBmcm9tIFwiLi9kZXRlY3RcIjtcbmltcG9ydCBsb2cgZnJvbSBcIi4vbG9nXCI7XG5cblxuXG5cblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIE1vZHVsZSBvbkltYWdlTG9hZEhhbmRlciBtZXRob2QsIGhhbmRsZXMgZXZlbnRcbiAqIEBtZXRob2QgaXNFbGVtZW50TG9hZGFibGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbCBUaGUgRE9NRWxlbWVudCB0byBjaGVjayB0aGUgb2Zmc2V0IG9mXG4gKiBAbWVtYmVyb2YgY29yZS51dGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqXG4gKi9cbmNvbnN0IGlzRWxlbWVudExvYWRhYmxlID0gZnVuY3Rpb24gKCBlbCApIHtcbiAgICBsZXQgcmV0ID0gZmFsc2U7XG5cbiAgICBpZiAoIGVsICkge1xuICAgICAgICBjb25zdCBib3VuZHMgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICByZXQgPSAoIGJvdW5kcy50b3AgPCAod2luZG93LmlubmVySGVpZ2h0ICogMikgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxuXG5cblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIE1vZHVsZSBpc0VsZW1lbnRWaXNpYmxlIG1ldGhvZCwgaGFuZGxlcyBlbGVtZW50IGJvdW5kYXJpZXNcbiAqIEBtZXRob2QgaXNFbGVtZW50VmlzaWJsZVxuICogQHBhcmFtIHtvYmplY3R9IGVsIFRoZSBET01FbGVtZW50IHRvIGNoZWNrIHRoZSBvZmZzZXRzIG9mXG4gKiBAbWVtYmVyb2YgY29yZS51dGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqXG4gKi9cbmNvbnN0IGlzRWxlbWVudFZpc2libGUgPSBmdW5jdGlvbiAoIGVsICkge1xuICAgIGxldCByZXQgPSBmYWxzZTtcblxuICAgIGlmICggZWwgKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHJldCA9ICggYm91bmRzLnRvcCA8IHdpbmRvdy5pbm5lckhlaWdodCAmJiBib3VuZHMuYm90dG9tID4gMCApO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59O1xuXG5cblxuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gSGFuZGxlcyBwbGF0cyB3aGVuIEVsZW1lbnQgaXMgVmlzaWJsZVxuICogQG1ldGhvZCB1cGRhdGVQbGF0ZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbCBUaGUgRE9NRWxlbWVudCB0byBjaGVjayB0aGUgb2Zmc2V0cyBvZlxuICogQG1lbWJlcm9mIGNvcmUudXRpbFxuICogQHJldHVybnMgY2xhc3NcbiAqXG4gKi9cbmNvbnN0IHVwZGF0ZVBsYXRlcyA9IGZ1bmN0aW9uICggJHBsYXRlcyApIHtcblxuICAgIHZhciAkcGxhdGUgPSBudWxsO1xuXG4gICAgdmFyIGkgPSAkcGxhdGVzLmxlbmd0aDtcblxuICAgIGZvciAoIGk7IGktLTsgKSB7XG5cbiAgICAgICAgJHBsYXRlID0gJHBsYXRlcy5lcSggaSApO1xuXG4gICAgICAgIGlmICggaXNFbGVtZW50VmlzaWJsZSggJHBsYXRlWyAwIF0gKSApIHtcblxuICAgICAgICAgICAgJHBsYXRlLmFkZENsYXNzKCBcImlzLWFjdGl2ZVwiICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgJHBsYXRlLnJlbW92ZUNsYXNzKCBcImlzLWFjdGl2ZVwiICk7XG5cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBGcmVzaCBxdWVyeSB0byBsYXp5bG9hZCBpbWFnZXMgb24gcGFnZVxuICogQG1ldGhvZCBsb2FkSW1hZ2VzXG4gKiBAcGFyYW0ge29iamVjdH0gaW1hZ2VzIE9wdGlvbmFsIGNvbGxlY3Rpb24gb2YgaW1hZ2VzIHRvIGxvYWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgT3B0aW9uYWwgaGFuZGxlciBmb3IgbG9hZCBjb25kaXRpb25zXG4gKiBAbWVtYmVyb2YgY29yZS51dGlsXG4gKiBAcmV0dXJucyB7SW1hZ2VMb2FkZXJ9XG4gKlxuICovXG5cbmNvbnN0IGxvYWRJbWFnZXMgPSBmdW5jdGlvbihpbWFnZXMsIGhhbmRsZXIpIHtcblx0Y29uc3QgclF1ZXJ5ID0gL1xcPyguKikkLztcblx0Y29uc3QgbWFwID0gZnVuY3Rpb24odm50KSB7XG5cdFx0cmV0dXJuIHBhcnNlSW50KHZudCwgMTApO1xuXHR9O1xuXG5cdGxldCAkaW1nID0gbnVsbDtcblx0bGV0IGRhdGEgPSBudWxsO1xuXHRsZXQgaW1nV2lkdGhzID0gbnVsbDtcblx0bGV0IHdpZHRoID0gbnVsbDtcbiAgICBsZXQgYnJlYWtwb2ludHMgPSBudWxsO1xuXHRsZXQgY3VycmVudEJyZWFrcG9pbnQgPSBudWxsO1xuXHRsZXQgc291cmNlID0gbnVsbDtcblx0bGV0IGkgPSBudWxsO1xuXHRsZXQgZmlsZW5hbWUgPSBudWxsO1xuXHRsZXQgZXh0ZW50aW9uID0gbnVsbDtcblxuXHQvLyBOb3JtYWxpemUgdGhlIGhhbmRsZXJcblx0aGFuZGxlciA9IGhhbmRsZXIgfHwgaXNFbGVtZW50TG9hZGFibGU7XG5cblx0Ly8gTm9ybWFsaXplIHRoZSBpbWFnZXNcblx0aW1hZ2VzID0gaW1hZ2VzIHx8ICQoY29uZmlnLmxhenlJbWFnZVNlbGVjdG9yKTtcblxuXHQvLyBIb29rIGhlcmUgdG8gZGV0ZXJtaW5lIGltYWdlIHZhcmlhbnQgc2l6ZXMgdG8gbG9hZCA/XG5cblx0aSA9IGltYWdlcy5sZW5ndGg7XG5cblx0Zm9yIChpOyBpLS07ICkge1xuXHRcdCRpbWcgPSBpbWFnZXMuZXEoaSk7XG5cdFx0ZGF0YSA9ICRpbWcuZGF0YSgpO1xuXG4gICAgJGltZy5hZGRDbGFzcyhcImxvYWRlZFwiKVxuXG5cdFx0aWYgKGRhdGEuYnJlYWtwb2ludHMpIHtcblxuXHRcdFx0d2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcblxuICAgICAgLy8gR2F0aGVyIGJyZWFrcG9pbnRzIGFuZCBpbWFnZSBzaXplcyAtPiBUaGVuIG1hdGNoXG5cbiAgICAgIGJyZWFrcG9pbnRzID0gZGF0YS5icmVha3BvaW50cy5zcGxpdCgnLCcpLm1hcChtYXApO1xuXHRcdFx0Y3VycmVudEJyZWFrcG9pbnQgPSBnZXRDbG9zZXN0VmFsdWUoYnJlYWtwb2ludHMsIHdpZHRoKTtcblxuICAgICAgaWYgKGRhdGEub3JpZW50YXRpb24pe1xuXG4gICAgICAgIGxldCBvcmllbnRhdGlvblNvdXJjZSA9ICRpbWcuZGF0YShgc3JjJHtjdXJyZW50QnJlYWtwb2ludH1gKS5yZXBsYWNlKHJRdWVyeSwgJycpO1xuXG4gICAgICAgICRpbWdbMF0uc2V0QXR0cmlidXRlKGNvbmZpZy5sYXp5SW1hZ2VBdHRyLCBgJHtvcmllbnRhdGlvblNvdXJjZX1gKTtcblxuICAgICAgfWVsc2V7XG5cbiAgICAgICAgc291cmNlID0gZGF0YS5pbWdTcmMucmVwbGFjZShyUXVlcnksICcnKTtcblxuICAgICAgICBmaWxlbmFtZSA9IHNvdXJjZS5yZXBsYWNlKCAvKFxcXykoPyEuKlxcMSkuKlswLTldK3gvICwgXCJfXCIgKyBjdXJyZW50QnJlYWtwb2ludCArIFwieFwiICk7XG5cbiAgICAgICAgJGltZ1swXS5zZXRBdHRyaWJ1dGUoY29uZmlnLmxhenlJbWFnZUF0dHIsIGAke2ZpbGVuYW1lfWApO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIGlmIChkYXRhLm9yaWVudGF0aW9uKXtcbiAgICAgIC8vXG4gICAgICAvL1xuICAgICAgLy9cbiAgICAgIC8vICAgY29uc29sZS5sb2coYnJlYWtQb2ludEFzc2V0KTtcbiAgICAgIC8vXG4gICAgICAvLyAgIGxldCBicmVha1BvaW50U3JjID0gYnJlYWtQb2ludEFzc2V0LnJlcGxhY2UoclF1ZXJ5LCAnJyk7XG4gICAgICAvL1xuICAgICAgLy8gICBjb25zb2xlLmxvZyhicmVha1BvaW50U3JjKTtcbiAgICAgIC8vXG4gICAgICAvLyB9XG5cblxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgSW1hZ2VMb2FkZXIoe1xuXHRcdGVsZW1lbnRzOiBpbWFnZXMsXG5cdFx0cHJvcGVydHk6IGNvbmZpZy5sYXp5SW1hZ2VBdHRyLFxuXHRcdGV4ZWN1dG9yOiBoYW5kbGVyXG5cdH0pO1xufTtcblxuXG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBVcGRhdGUgaW1hZ2Ugc2l6ZXMgb24gUmVzaXplIChmb3IgaW1hZ2VzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gbG9hZGVkKVxuICogQG1ldGhvZCB1cGRhdGVJbWFnZXNcbiAqIEBwYXJhbSB7SG9ib30gaW1hZ2VzIFRoZSBvcHRpb25hbCBhcmd1bWVudCBwYXNzZWQgY29sbGVjdGlvbiB0byByZWxvYWRcbiAqIEBtZW1iZXJvZiB1dGlsXG4gKlxuICovXG5jb25zdCB1cGRhdGVJbWFnZXMgPSBmdW5jdGlvbihpbWFnZXMpIHtcblxuXHRpbWFnZXMgPSBpbWFnZXMgfHwgJChgWyR7Y29uZmlnLmltYWdlTG9hZGVyQXR0cn1dYCk7XG5cblx0aWYgKGltYWdlcy5sZW5ndGgpIHtcblx0XHRpbWFnZXMuYXR0cihjb25maWcuaW1hZ2VMb2FkZXJBdHRyLCAnJyk7XG5cblx0XHRsb2FkSW1hZ2VzKGltYWdlcywgbm9vcCk7XG5cdH1cbn07XG5cblxuXG5cblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIEFsbCB0cnVlIGFsbCB0aGUgdGltZVxuICogQG1ldGhvZCBub29wXG4gKiBAbWVtYmVyb2YgY29yZS51dGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqXG4gKi9cbmNvbnN0IG5vb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICpcbiAqIEBtZXRob2QgZ2V0RWxlbWVudHNJblZpZXdcbiAqIEBtZW1iZXJvZiBjb3JlLnV0aWxcbiAqIEBwYXJhbSB7SG9ib30gJG5vZGVzIFRoZSBjb2xsZWN0aW9uIHRvIHByb2Nlc3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGV4ZWN1dG9yIE9wdGlvbmFsIG1ldGhvZCB0byBkZXRlcm1pbiBgaW4gdmlld2BcbiAqIEBkZXNjcmlwdGlvbiBHZXQgZWxlbWVudHMgd2l0aGluIGEgbG9hZGFibGUgcG9zaXRpb24gb24gdGhlIHBhZ2VcbiAqIEByZXR1cm5zIHtIb2JvfVxuICpcbiAqL1xuY29uc3QgZ2V0RWxlbWVudHNJblZpZXcgPSBmdW5jdGlvbiAoICRub2RlcywgZXhlY3V0b3IgKSB7XG4gICAgbGV0IGkgPSAkbm9kZXMubGVuZ3RoO1xuICAgIGNvbnN0IHJldCA9IFtdO1xuXG4gICAgZXhlY3V0b3IgPSAoZXhlY3V0b3IgfHwgaXNFbGVtZW50VmlzaWJsZSk7XG5cbiAgICBmb3IgKCBpOyBpLS07ICkge1xuICAgICAgICBpZiAoIGV4ZWN1dG9yKCAkbm9kZXNbIGkgXSApICkge1xuICAgICAgICAgICAgcmV0LnB1c2goICRub2Rlc1sgaSBdICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJCggcmV0ICk7XG59O1xuXG5cblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIEdldCB0aGUgYXBwbGllZCB0cmFuc2l0aW9uIGR1cmF0aW9uIGZyb20gQ1NTXG4gKiBAbWV0aG9kIGdldFRyYW5zaXRpb25EdXJhdGlvblxuICogQHBhcmFtIHtvYmplY3R9IGVsIFRoZSBET01FbGVtZW50XG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHJldHVybnMge251bWJlcn1cbiAqXG4gKi9cbmNvbnN0IGdldFRyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uICggZWwgKSB7XG4gICAgbGV0IHJldCA9IDA7XG4gICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcbiAgICBsZXQgaXNTZWNvbmRzID0gZmFsc2U7XG4gICAgbGV0IG11bHRpcGx5QnkgPSAxMDAwO1xuXG4gICAgaWYgKCBlbCApIHtcbiAgICAgICAgZHVyYXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKCBlbCApWyBkZXRlY3QuZ2V0UHJlZml4ZWQoIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiICkgXTtcbiAgICAgICAgaXNTZWNvbmRzID0gZHVyYXRpb24uaW5kZXhPZiggXCJtc1wiICkgPT09IC0xO1xuICAgICAgICBtdWx0aXBseUJ5ID0gaXNTZWNvbmRzID8gMTAwMCA6IDE7XG5cbiAgICAgICAgcmV0ID0gcGFyc2VGbG9hdCggZHVyYXRpb24gKSAqIG11bHRpcGx5Qnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cblxuXG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBTZWxlY3Qgc2libGluZ3Mgb2YgZWxlbWVudFxuICogQG1ldGhvZCBnZXRTaWJsaW5nc1xuICogQG1lbWJlcm9mIGNvcmUudXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKlxuICovXG5jb25zdCBnZXRTaWJsaW5ncyA9IGZ1bmN0aW9uIChlKSB7XG5cbiAgICBsZXQgc2libGluZ3MgPSBbXTsgXG5cbiAgICAvLyBpZiBubyBwYXJlbnQsIHJldHVybiBubyBzaWJsaW5nXG4gICAgaWYoIWUucGFyZW50Tm9kZSkge1xuICAgICAgICByZXR1cm4gc2libGluZ3M7XG4gICAgfVxuXG4gICAgLy8gZmlyc3QgY2hpbGQgb2YgdGhlIGFycmF5XG4gICAgbGV0IHNpYmxpbmcgID0gZS5maXJzdENoaWxkO1xuICAgIFxuICAgIC8vIGNvbGxlY3Rpbmcgc2libGluZ3NcbiAgICB3aGlsZSAoc2libGluZykge1xuICAgICAgICBpZiAoc2libGluZy5ub2RlVHlwZSA9PT0gMSAmJiBzaWJsaW5nICE9PSBlKSB7XG4gICAgICAgICAgICBzaWJsaW5ncy5wdXNoKHNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gc2libGluZ3M7XG59O1xuXG5cblxuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gR2V0IGN1cnJlbnQgdGltZSBldmVyeSBzZWNvbmRcbiAqIEBtZXRob2QgY3VycmVudFRpbWVcbiAqIEBtZW1iZXJvZiBjb3JlLnV0aWxcbiAqIEByZXR1cm5zIHt0aW1lfVxuICpcbiAqL1xuY29uc3QgY3VycmVudFRpbWUgPSBmdW5jdGlvbiAoZSkge1xuXG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpOyBcbiAgICBsZXQgaGggPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgbGV0IG1tID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgbGV0IHNzID0gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgbGV0IHNlc3Npb24gPSBcIkFNXCI7XG4gICAgXG4gICAgaWYoaGggPT0gMCl7XG4gICAgICAgIGhoID0gMTI7XG4gICAgfVxuICAgIGlmKGhoID4gMTIpe1xuICAgICAgICBoaCA9IGhoIC0gMTI7XG4gICAgICAgIHNlc3Npb24gPSBcIlBNXCI7XG4gICAgICAgIH1cbiAgICBcbiAgICBoaCA9IChoaCA8IDEwKSA/IFwiMFwiICsgaGggOiBoaDtcbiAgICBtbSA9IChtbSA8IDEwKSA/IFwiMFwiICsgbW0gOiBtbTtcbiAgICBzcyA9IChzcyA8IDEwKSA/IFwiMFwiICsgc3MgOiBzcztcbiAgICBcbiAgICBsZXQgdGltZSA9IGhoICsgXCI8c3BhbiBjbGFzcz0naXMtZmxhc2hpbmcnPjo8L3NwYW4XCIgKyBtbSArIFwiIFwiICsgc2Vzc2lvbjtcbiAgICBcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRpbWVcIikuaW5uZXJIVE1MID0gdGltZTsgXG4gICAgbGV0IHQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGN1cnJlbnRUaW1lKCkgfSwgMTAwMCk7XG4gIFxufVxuXG5cbi8qKlxuICpcbiAqIEBtZXRob2QgZ2V0Q2xvc2VzdFZhbHVlXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHthcnJheX0gYXJyIFRoZSBhcnJheSB0byBwcm9jZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvc2VzdFRvIFRoZSBudW1iZXIgdG8gZ2V0IGNsb3NlIHRvXG4gKiBAZGVzY3JpcHRpb24gR2V0IGNsb3Nlc3QgbnVtYmVyIHZhbHVlIHdpdGhvdXQgZ29pbmcgdW5kZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKlxuICovXG5jb25zdCBnZXRDbG9zZXN0VmFsdWUgPSBmdW5jdGlvbiAoYXJyLCBjbG9zZXN0VG8pIHtcbiAgICAvLyBHZXQgdGhlIGhpZ2hlc3QgbnVtYmVyIGluIGFyciBpbiBjYXNlIGl0IG1hdGNoZXMgbm90aGluZy5cbiAgICBsZXQgY2xvc2UgPSBNYXRoLm1heC5hcHBseShudWxsLCBhcnIpO1xuICAgIGxldCBpID0gYXJyLmxlbmd0aDtcblxuICAgIGZvciAoaTsgaS0tOyApIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBoaWdoZXIgdGhhbiB5b3VyIG51bWJlciwgYnV0IGxvd2VyIHRoYW4geW91ciBjbG9zZXN0IHZhbHVlXG4gICAgICAgIGlmIChhcnJbIGkgXSAPSBjbG9zZXN0VG8gJiYgYXJyWyBpIF0gPCBjbG9zZSkge1xuICAgICAgICAgICAgY2xvc2UgPSBhcnJbIGkgXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9zZTtcbn07XG5cblxuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gQWRkIHBpeGVsIHVuaXRzIHdoZW4gaW5saW5lIHN0eWxpbmdcbiAqIEBtZXRob2QgcHhcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHZhbHVlIHRvIHBpeGVsLWlmeVxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKlxuICovXG5jb25zdCBweCA9IGZ1bmN0aW9uICggc3RyICkge1xuICAgIHJldHVybiBgJHtzdHJ9cHhgO1xufTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwb3J0XG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IHtcbiAgICBub29wLFxuICAgIGxvYWRJbWFnZXMsXG4gICAgdXBkYXRlSW1hZ2VzLFxuICAgIGlzRWxlbWVudExvYWRhYmxlLFxuICAgIGlzRWxlbWVudFZpc2libGUsXG4gICAgZ2V0RWxlbWVudHNJblZpZXcsXG4gICAgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgIGdldFNpYmxpbmdzLFxuICAgIGN1cnJlbnRUaW1lLFxuICAgIGdldENsb3Nlc3RWYWx1ZSxcbiAgICBweFxufTtcbiJdLCJuYW1lcyI6WyIkIiwiSW1hZ2VMb2FkZXIiLCJjb25maWciLCJkZXRlY3QiLCJsb2ciLCJpc0VsZW1lbnRMb2FkYWJsZSIsImVsIiwicmV0IiwiYm91bmRzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwid2luZG93IiwiaW5uZXJIZWlnaHQiLCJpc0VsZW1lbnRWaXNpYmxlIiwiYm90dG9tIiwidXBkYXRlUGxhdGVzIiwiJHBsYXRlcyIsIiRwbGF0ZSIsImkiLCJsZW5ndGgiLCJlcSIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJsb2FkSW1hZ2VzIiwiaW1hZ2VzIiwiaGFuZGxlciIsInJRdWVyeSIsIm1hcCIsInZudCIsInBhcnNlSW50IiwiJGltZyIsImRhdGEiLCJpbWdXaWR0aHMiLCJ3aWR0aCIsImJyZWFrcG9pbnRzIiwiY3VycmVudEJyZWFrcG9pbnQiLCJzb3VyY2UiLCJmaWxlbmFtZSIsImV4dGVudGlvbiIsImxhenlJbWFnZVNlbGVjdG9yIiwiaW5uZXJXaWR0aCIsInNwbGl0IiwiZ2V0Q2xvc2VzdFZhbHVlIiwib3JpZW50YXRpb24iLCJvcmllbnRhdGlvblNvdXJjZSIsImNvbmNhdCIsInJlcGxhY2UiLCJzZXRBdHRyaWJ1dGUiLCJsYXp5SW1hZ2VBdHRyIiwiaW1nU3JjIiwiZWxlbWVudHMiLCJwcm9wZXJ0eSIsImV4ZWN1dG9yIiwidXBkYXRlSW1hZ2VzIiwiaW1hZ2VMb2FkZXJBdHRyIiwiYXR0ciIsIm5vb3AiLCJnZXRFbGVtZW50c0luVmlldyIsIiRub2RlcyIsInB1c2giLCJnZXRUcmFuc2l0aW9uRHVyYXRpb24iLCJkdXJhdGlvbiIsImlzU2Vjb25kcyIsIm11bHRpcGx5QnkiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJlZml4ZWQiLCJpbmRleE9mIiwicGFyc2VGbG9hdCIsImdldFNpYmxpbmdzIiwiZSIsInNpYmxpbmdzIiwicGFyZW50Tm9kZSIsInNpYmxpbmciLCJmaXJzdENoaWxkIiwibm9kZVR5cGUiLCJuZXh0U2libGluZyIsImN1cnJlbnRUaW1lIiwiZGF0ZSIsIkRhdGUiLCJoaCIsImdldEhvdXJzIiwibW0iLCJnZXRNaW51dGVzIiwic3MiLCJnZXRTZWNvbmRzIiwic2Vzc2lvbiIsInRpbWUiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiaW5uZXJIVE1MIiwidCIsInNldFRpbWVvdXQiLCJhcnIiLCJjbG9zZXN0VG8iLCJjbG9zZSIsIk1hdGgiLCJtYXgiLCJhcHBseSIsInB4Iiwic3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/util.js\n");

/***/ }),

/***/ "./source/js/intro.js":
/*!****************************!*\
  !*** ./source/js/intro.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"./source/js/core/index.js\");\n/* harmony import */ var _class_Bar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./class/Bar */ \"./source/js/class/Bar.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/dist/gsap.js\");\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(gsap__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n/**\n *\n * @public\n * @namespace intro\n * @description Performs the branded load-in screen sequence.\n * @memberof menus\n *\n */\nvar intro = {\n  /**\n   *\n   * @public\n   * @method init\n   * @memberof menus.intro\n   * @description Method initializes intro node in DOM.\n   *\n   */\n  init: function init() {\n    _core__WEBPACK_IMPORTED_MODULE_0__.emitter.on(\"app--intro-teardown\", this.teardown.bind(this));\n\n    // Animate Pre-Load\n    this.countdown = document.querySelector(\".js-countdown\");\n    this.introMessage = document.querySelector(\".js-intro-fade\");\n    gsap__WEBPACK_IMPORTED_MODULE_2___default().to(this.introMessage, {\n      duration: 2,\n      delay: 0,\n      ease: \"expo.out\",\n      opacity: 1\n    });\n    var Cont = {\n        val: 14\n      },\n      NewVal = 20;\n    gsap__WEBPACK_IMPORTED_MODULE_2___default().to(Cont, 1.5, {\n      val: NewVal,\n      roundProps: \"val\",\n      ease: \"expo.out\",\n      callbackScope: this,\n      onUpdate: function onUpdate() {\n        this.countdown.innerHTML = \"(2013 - 20\"  Cont.val  \")\";\n      }\n    });\n    _class_Bar__WEBPACK_IMPORTED_MODULE_1__[\"default\"].load();\n  },\n  /**\n   *\n   * @public\n   * @method teardown\n   * @memberof menus.intro\n   * @description Tear down & Kill Intro Instance\n   *\n   */\n  teardown: function teardown() {\n    if (_core__WEBPACK_IMPORTED_MODULE_0__.dom.intro === null) {\n      _core__WEBPACK_IMPORTED_MODULE_0__.emitter.fire(\"app--transition-in\");\n      return;\n    }\n\n    // Intro Animation\n\n    var Cont = {\n        val: 0\n      },\n      NewVal = 24;\n    gsap__WEBPACK_IMPORTED_MODULE_2___default().to(Cont, 1.5, {\n      val: NewVal,\n      roundProps: \"val\",\n      ease: \"expo.out\",\n      callbackScope: this,\n      onUpdate: function onUpdate() {\n        this.countdown.innerHTML = \"(2013 - 20\"  Cont.val  \")\";\n      },\n      onComplete: function onComplete() {\n        gsap__WEBPACK_IMPORTED_MODULE_2___default().to(this.introMessage, {\n          duration: 1,\n          delay: 0,\n          ease: \"expo.inOut\",\n          opacity: 0\n        });\n        _class_Bar__WEBPACK_IMPORTED_MODULE_1__[\"default\"].stop();\n        var delay = _core__WEBPACK_IMPORTED_MODULE_0__.config.defaultDuration * 2;\n        setTimeout(function () {\n          _core__WEBPACK_IMPORTED_MODULE_0__.dom.intro.removeClass(\"is-active\");\n          document.body.classList.add(\"is-loaded\");\n          _core__WEBPACK_IMPORTED_MODULE_0__.emitter.fire(\"app--resize-debounced\");\n          _core__WEBPACK_IMPORTED_MODULE_0__.emitter.fire(\"app--transition-in\");\n        }, 1000);\n        setTimeout(function () {\n          _core__WEBPACK_IMPORTED_MODULE_0__.dom.body.addClass(\"is-active\");\n          _core__WEBPACK_IMPORTED_MODULE_0__.dom.intro.remove();\n          _core__WEBPACK_IMPORTED_MODULE_0__.dom.intro = null;\n        }, delay);\n      }\n    });\n  }\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (intro);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztVQUN4Q3BDLDBDQUFZLENBQUMyQixJQUFJLENBQUUsdUJBQXdCLENBQUM7VUFDNUMzQiwwQ0FBWSxDQUFDMkIsSUFBSSxDQUFFLG9CQUFxQixDQUFDO1FBQzNDLENBQUMsRUFBRSxJQUFJLENBQUM7UUFFUkssVUFBVSxDQUFFLFlBQU07VUFDaEJoQyxzQ0FBUSxDQUFDa0MsSUFBSSxDQUFDRyxRQUFRLENBQUUsV0FBWSxDQUFDO1VBRXJDckMsc0NBQVEsQ0FBQ0csS0FBSyxDQUFDbUMsTUFBTSxDQUFDLENBQUM7VUFDdkJ0QyxzQ0FBUSxDQUFDRyxLQUFLLEdBQUcsSUFBSTtRQUN2QixDQUFDLEVBQUVZLEtBQU0sQ0FBQztNQUVaO0lBQ0YsQ0FBQyxDQUFDO0VBR047QUFDSixDQUFDOztBQUdEO0FBQ0E7QUFDQTtBQUNBLGlFQUFlWixLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vc291cmNlL2pzL2ludHJvLmpzPzIxMzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi9jb3JlXCI7XG5pbXBvcnQgYmFyIGZyb20gXCIuL2NsYXNzL0JhclwiO1xuaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcblxuXG4vKipcbiAqXG4gKiBAcHVibGljXG4gKiBAbmFtZXNwYWNlIGludHJvXG4gKiBAZGVzY3JpcHRpb24gUGVyZm9ybXMgdGhlIGJyYW5kZWQgbG9hZC1pbiBzY3JlZW4gc2VxdWVuY2UuXG4gKiBAbWVtYmVyb2YgbWVudXNcbiAqXG4gKi9cbmNvbnN0IGludHJvID0ge1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGluaXRcbiAgICAgKiBAbWVtYmVyb2YgbWVudXMuaW50cm9cbiAgICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGluaXRpYWxpemVzIGludHJvIG5vZGUgaW4gRE9NLlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdCAoKSB7XG5cbiAgICAgICAgY29yZS5lbWl0dGVyLm9uKCBcImFwcC0taW50cm8tdGVhcmRvd25cIiwgdGhpcy50ZWFyZG93bi5iaW5kKCB0aGlzICkgKTtcblxuICAgICAgICAvLyBBbmltYXRlIFByZS1Mb2FkXG4gICAgICAgIHRoaXMuY291bnRkb3duID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5qcy1jb3VudGRvd25cIik7XG4gICAgICAgIHRoaXMuaW50cm9NZXNzYWdlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5qcy1pbnRyby1mYWRlXCIpO1xuXG4gICAgICAgIGdzYXAudG8odGhpcy5pbnRyb01lc3NhZ2Use2R1cmF0aW9uOjIsIGRlbGF5OjAsIGVhc2U6IFwiZXhwby5vdXRcIiwgb3BhY2l0eTogMX0pO1xuICAgICAgXG4gICAgICAgIHZhciBDb250ID0geyB2YWw6IDE0IH0sXG4gICAgICAgIE5ld1ZhbCA9IDIwO1xuXG4gICAgICAgIGdzYXAudG8oQ29udCwgMS41LCB7XG4gICAgICAgICAgdmFsOiBOZXdWYWwsXG4gICAgICAgICAgcm91bmRQcm9wczogXCJ2YWxcIixcbiAgICAgICAgICBlYXNlOiBcImV4cG8ub3V0XCIsXG4gICAgICAgICAgY2FsbGJhY2tTY29wZTogdGhpcyxcbiAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudGRvd24uaW5uZXJIVE1MID0gXCIoMjAxMyAtIDIwXCIgKyBDb250LnZhbCArIFwiKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmFyLmxvYWQoKTtcbiAgICAgIFxuICAgIH0sXG5cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCB0ZWFyZG93blxuICAgICAqIEBtZW1iZXJvZiBtZW51cy5pbnRyb1xuICAgICAqIEBkZXNjcmlwdGlvbiBUZWFyIGRvd24gJiBLaWxsIEludHJvIEluc3RhbmNlXG4gICAgICpcbiAgICAgKi9cbiAgICB0ZWFyZG93biAoKSB7XG5cbiAgICAgICAgaWYgKCBjb3JlLmRvbS5pbnRybyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvcmUuZW1pdHRlci5maXJlKCBcImFwcC0tdHJhbnNpdGlvbi1pblwiICk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRybyBBbmltYXRpb25cblxuICAgICAgICB2YXIgQ29udCA9IHsgdmFsOiAwIH0sXG4gICAgICAgIE5ld1ZhbCA9IDI0O1xuXG4gICAgICAgIGdzYXAudG8oQ29udCwgMS41LCB7XG4gICAgICAgICAgdmFsOiBOZXdWYWwsXG4gICAgICAgICAgcm91bmRQcm9wczogXCJ2YWxcIixcbiAgICAgICAgICBlYXNlOiBcImV4cG8ub3V0XCIsXG4gICAgICAgICAgY2FsbGJhY2tTY29wZTogdGhpcyxcbiAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudGRvd24uaW5uZXJIVE1MID0gXCIoMjAxMyAtIDIwXCIgKyBDb250LnZhbCArIFwiKVwiIDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBnc2FwLnRvKHRoaXMuaW50cm9NZXNzYWdlLHtkdXJhdGlvbjoxLCBkZWxheTowLCBlYXNlOiBcImV4cG8uaW5PdXRcIiwgb3BhY2l0eTogMH0pO1xuICAgICAgICAgICAgYmFyLnN0b3AoKTtcbiAgICAgICAgICAgIGxldCBkZWxheSA9IGNvcmUuY29uZmlnLmRlZmF1bHREdXJhdGlvbiAqIDI7XG4gXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvcmUuZG9tLmludHJvLnJlbW92ZUNsYXNzKCBcImlzLWFjdGl2ZVwiICk7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcImlzLWxvYWRlZFwiKTtcbiAgICAgICAgICAgICAgY29yZS5lbWl0dGVyLmZpcmUoIFwiYXBwLS1yZXNpemUtZGVib3VuY2VkXCIgKTtcbiAgICAgICAgICAgICAgY29yZS5lbWl0dGVyLmZpcmUoIFwiYXBwLS10cmFuc2l0aW9uLWluXCIgKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHNldFRpbWVvdXQoICgpID0IHtcbiAgICAgICAgICAgICAgY29yZS5kb20uYm9keS5hZGRDbGFzcyggXCJpcy1hY3RpdmVcIiApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29yZS5kb20uaW50cm8ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGNvcmUuZG9tLmludHJvID0gbnVsbDtcbiAgICAgICAgICAgIH0sIGRlbGF5ICk7XG5cbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgXG4gICAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBFeHBvcnRcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZGVmYXVsdCBpbnRybzsiXSwibmFtZXMiOlsiY29yZSIsImJhciIsImdzYXAiLCJpbnRybyIsImluaXQiLCJlbWl0dGVyIiwib24iLCJ0ZWFyZG93biIsImJpbmQiLCJjb3VudGRvd24iLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJpbnRyb01lc3NhZ2UiLCJ0byIsImR1cmF0aW9uIiwiZGVsYXkiLCJlYXNlIiwib3BhY2l0eSIsIkNvbnQiLCJ2YWwiLCJOZXdWYWwiLCJyb3VuZFByb3BzIiwiY2FsbGJhY2tTY29wZSIsIm9uVXBkYXRlIiwiaW5uZXJIVE1MIiwibG9hZCIsImRvbSIsImZpcmUiLCJvbkNvbXBsZXRlIiwic3RvcCIsImNvbmZpZyIsImRlZmF1bHREdXJhdGlvbiIsInNldFRpbWVvdXQiLCJyZW1vdmVDbGFzcyIsImJvZHkiLCJjbGFzc0xpc3QiLCJhZGQiLCJhZGRDbGFzcyIsInJlbW92ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/intro.js\n");

/***/ }),

/***/ "./source/js/router.js":
/*!*****************************!*\
  !*** ./source/js/router.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! properjs-hobo */ \"./node_modules/properjs-hobo/dist/hobo.build.js\");\n/* harmony import */ var properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(properjs_hobo__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var properjs_pagecontroller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! properjs-pagecontroller */ \"./node_modules/properjs-pagecontroller/PageController.js\");\n/* harmony import */ var _class_ImageController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./class/ImageController */ \"./source/js/class/ImageController.js\");\n/* harmony import */ var _class_AnimateController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./class/AnimateController */ \"./source/js/class/AnimateController.js\");\n/* harmony import */ var _class_ModuleController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./class/ModuleController */ \"./source/js/class/ModuleController.js\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core */ \"./source/js/core/index.js\");\n\n\n\n\n\n\n\n/**\n *\n * @public\n * @namespace router\n * @description Handles async web app routing for nice transitions.\n *\n */\nvar router = {\n  /**\n   *\n   * @public\n   * @method init\n   * @memberof router\n   * @description Initialize the router module.\n   *\n   */\n  init: function init() {\n    this.pageClass = \"\";\n    this.pageDuration = _core__WEBPACK_IMPORTED_MODULE_5__.config.defaultDuration;\n    this.bindEmpty();\n    this.initPages();\n  },\n  /**\n   *\n   * @public\n   * @method route\n   * @param {string} path The uri to route to\n   * @memberof router\n   * @description Trigger app to route a specific page. [Reference]{@link https://github.com/ProperJS/Router/blob/master/Router.js#L222}\n   *\n   */\n  route: function route(path) {\n    this.controller.getRouter().trigger(path);\n  },\n  /**\n   *\n   * @public\n   * @method push\n   * @param {string} path The uri to route to\n   * @param {function} cb Optional callback to fire\n   * @memberof router\n   * @description Trigger a silent route with a supplied callback.\n   *\n   */\n  push: function push(path, cb) {\n    this.controller.routeSilently(path, cb || _core__WEBPACK_IMPORTED_MODULE_5__.util.noop);\n  },\n  /**\n   *\n   * @public\n   * @method initPages\n   * @memberof router\n   * @description Create the PageController instance.\n   *\n   */\n  initPages: function initPages() {\n    this.controller = new properjs_pagecontroller__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      transitionTime: this.pageDuration,\n      // Default\n      routerOptions: {\n        // Default\n        historyOptions: {}\n      },\n      routes: [\"/\", \":view\", \":view/:uid\"] // Default\n    });\n\n    //this.controller.on( \"page-controller-router-samepage\", () => {} );\n    this.controller.on(\"transition-out\", this.changePageOut.bind(this));\n    this.controller.on(\"document\", this.changeContent.bind(this));\n    this.controller.on(\"transition-in\", this.changePageIn.bind(this));\n    this.controller.on(\"initialized\", this.initPage.bind(this));\n    this.controller.bind();\n  },\n  /**\n   *\n   * @public\n   * @method initPage\n   * @param {object} data The PageController data object\n   * @memberof router\n   * @description Cache the initial page load.\n   *\n   */\n  initPage: function initPage(data) {\n    this.changeClass(data);\n    this.execControllers();\n  },\n  /**\n   *\n   * @public\n   * @method parseDoc\n   * @param {string} html The responseText to parse out\n   * @memberof router\n   * @description Get the DOM information to cache for a request.\n   * @returns {object}\n   *\n   */\n  parseDoc: function parseDoc(html) {\n    var doc = document.createElement(\"html\");\n    var main = null;\n    doc.innerHTML = html;\n    doc = properjs_hobo__WEBPACK_IMPORTED_MODULE_0___default()(doc);\n    main = doc.find(_core__WEBPACK_IMPORTED_MODULE_5__.config.mainSelector);\n    document.title = doc.find('title')[0].innerText;\n    return {\n      doc: doc,\n      main: main,\n      html: main[0].innerHTML\n    };\n  },\n  /**\n   *\n   * @public\n   * @method bindEmpty\n   * @memberof router\n   * @description Suppress #hash links.\n   *\n   */\n  bindEmpty: function bindEmpty() {\n    _core__WEBPACK_IMPORTED_MODULE_5__.dom.body.on(\"click\", \"[href^='#']\", function (e) {\n      return e.preventDefault();\n    });\n  },\n  /**\n   *\n   * @public\n   * @method changeClass\n   * @param {object} data The PageController data object\n   * @memberof router\n   * @description Handle document className swapping by page section.\n   *\n   */\n  changeClass: function changeClass(data) {\n    if (this.view) {\n      document.documentElement.classList.remove(\"is-\".concat(this.view, \"-page\"));\n    }\n    this.view = data.request.params.uid || data.request.params.view || \"home\";\n    document.documentElement.classList.add(\"is-\".concat(this.view, \"-page\"));\n  },\n  /**\n   *\n   * @public\n   * @method changePageOut\n   * @param {object} data The PageController data object\n   * @memberof router\n   * @description Trigger transition-out animation.\n   *\n   */\n  changePageOut: function changePageOut(data) {\n    _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--transition-out\");\n    document.body.classList.add(\"is-routing\", \"is-inactive\");\n    document.body.classList.remove(\"transitions-enabled\");\n    document.b;\n    this.destroyControllers();\n  },\n  /**\n   *\n   * @public\n   * @method changeContent\n   * @param {object} data The PageController data object\n   * @memberof router\n   * @description Swap the new content into the DOM.\n   *\n   */\n  changeContent: function changeContent(data) {\n    var doc = this.parseDoc(data.response);\n    _core__WEBPACK_IMPORTED_MODULE_5__.dom.main[0].innerHTML = doc.html;\n    window.scrollTo(0, 0);\n    _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--scroll-teardown\");\n    _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--analytics-push\");\n    this.changeClass(data);\n  },\n  /**\n   *\n   * @public\n   * @method changePageIn\n   * @param {object} data The PageController data object\n   * @memberof router\n   * @description Trigger transition-in animation.\n   *\n   */\n  changePageIn: function changePageIn() {\n    document.body.classList.remove(\"is-routing\", \"is-inactive\");\n    this.execControllers();\n  } /* data */,\n  /**\n   *\n   * @public\n   * @method execControllers\n   * @memberof router\n   * @description Run page controllers.\n   * @notes Intro.js looks when app intilaizes, and when to emit app--exec-animations\n   * @notes AnimateController.js watches for transition in to exec transitionIn()\n   *\n   */\n  execControllers: function execControllers() {\n    var _this = this;\n    this.images = _core__WEBPACK_IMPORTED_MODULE_5__.dom.main.find(_core__WEBPACK_IMPORTED_MODULE_5__.config.lazyImageSelector);\n    this.imageController = new _class_ImageController__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.images);\n    this.imageController.on(\"preloaded\", function () {\n      _this.anims = _core__WEBPACK_IMPORTED_MODULE_5__.dom.main.find(_core__WEBPACK_IMPORTED_MODULE_5__.config.animSelector);\n      _this.animController = new _class_AnimateController__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_this.anims);\n      _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--intro-teardown\");\n      _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--init-image-events\");\n      _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--resize-debounced\");\n    });\n    this.imageController.on(\"lazyloaded\", function () {\n      _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--init-image-events\");\n      _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--resize-debounced\");\n    });\n    this.ModuleController = new _class_ModuleController__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n    _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--init\");\n    _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--init-scroll\");\n    _core__WEBPACK_IMPORTED_MODULE_5__.emitter.fire(\"app--init-media\");\n  },\n  /**\n   *\n   * @public\n   * @method destroyControllers\n   * @memberof router\n   * @description Kill page controllers.\n   *\n   */\n  destroyControllers: function destroyControllers() {\n    if (this.imageController) {\n      this.imageController.destroy();\n      this.imageController = null;\n    }\n    if (this.animController) {\n      this.animController.destroy();\n      this.animController = null;\n    }\n  }\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (router);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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L0J6RCwwQ0FBWSxDQUFDeUQsSUFBSSxDQUFFLGtCQUFtQixDQUFDO0lBQ3ZDekQsMENBQVksQ0FBQ3lELElBQUksQ0FBRSxpQkFBa0IsQ0FBQztFQUUxQyxDQUFDO0VBR0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJRSxrQkFBa0IsV0FBQUEsbUJBQUEsRUFBSTtJQUNsQixJQUFLLElBQUksQ0FBQ08sZUFBZSxFQUFHO01BQ3hCLElBQUksQ0FBQ0EsZUFBZSxDQUFDSSxPQUFPLENBQUMsQ0FBQztNQUM5QixJQUFJLENBQUNKLGVBQWUsR0FBRyxJQUFJO0lBQy9CO0lBRUEsSUFBSyxJQUFJLENBQUNHLGNBQWMsRUFBRztNQUN2QixJQUFJLENBQUNBLGNBQWMsQ0FBQ0MsT0FBTyxDQUFDLENBQUM7TUFDN0IsSUFBSSxDQUFDRCxjQUFjLEdBQUcsSUFBSTtJQUM5QjtFQUVKO0FBQ0osQ0FBQzs7QUFJRDtBQUNBO0FBQ0E7QUFDQSxpRUFBZXBFLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9zb3VyY2UvanMvcm91dGVyLmpzPzUxOTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICQgZnJvbSBcInByb3BlcmpzLWhvYm9cIjtcbmltcG9ydCBQYWdlQ29udHJvbGxlciBmcm9tIFwicHJvcGVyanMtcGFnZWNvbnRyb2xsZXJcIjtcbmltcG9ydCBJbWFnZUNvbnRyb2xsZXIgZnJvbSBcIi4vY2xhc3MvSW1hZ2VDb250cm9sbGVyXCI7XG5pbXBvcnQgQW5pbWF0ZUNvbnRyb2xsZXIgZnJvbSBcIi4vY2xhc3MvQW5pbWF0ZUNvbnRyb2xsZXJcIjtcbmltcG9ydCBNb2R1bGVDb250cm9sbGVyIGZyb20gXCIuL2NsYXNzL01vZHVsZUNvbnRyb2xsZXJcIjtcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4vY29yZVwiO1xuXG5cbi8qKlxuICpcbiAqIEBwdWJsaWNcbiAqIEBuYW1lc3BhY2Ugcm91dGVyXG4gKiBAZGVzY3JpcHRpb24gSGFuZGxlcyBhc3luYyB3ZWIgYXBwIHJvdXRpbmcgZm9yIG5pY2UgdHJhbnNpdGlvbnMuXG4gKlxuICovXG5jb25zdCByb3V0ZXIgPSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBpbml0XG4gICAgICogQG1lbWJlcm9mIHJvdXRlclxuICAgICAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplIHRoZSByb3V0ZXIgbW9kdWxlLlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdCAoKSB7XG4gICAgICAgIHRoaXMucGFnZUNsYXNzID0gXCJcIjtcbiAgICAgICAgdGhpcy5wYWdlRHVyYXRpb24gPSBjb3JlLmNvbmZpZy5kZWZhdWx0RHVyYXRpb247XG4gICAgICAgIHRoaXMuYmluZEVtcHR5KCk7XG4gICAgICAgIHRoaXMuaW5pdFBhZ2VzKCk7XG4gICAgfSxcblxuXG5cbiAgICBcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIHJvdXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHVyaSB0byByb3V0ZSB0b1xuICAgICAqIEBtZW1iZXJvZiByb3V0ZXJcbiAgICAgKiBAZGVzY3JpcHRpb24gVHJpZ2dlciBhcHAgdG8gcm91dGUgYSBzcGVjaWZpYyBwYWdlLiBbUmVmZXJlbmNlXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vUHJvcGVySlMvUm91dGVyL2Jsb2IvbWFzdGVyL1JvdXRlci5qcyNMMjIyfVxuICAgICAqXG4gICAgICovXG4gICAgcm91dGUgKCBwYXRoICkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuZ2V0Um91dGVyKCkudHJpZ2dlciggcGF0aCApO1xuICAgIH0sXG5cblxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIHB1c2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgdXJpIHRvIHJvdXRlIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgT3B0aW9uYWwgY2FsbGJhY2sgdG8gZmlyZVxuICAgICAqIEBtZW1iZXJvZiByb3V0ZXJcbiAgICAgKiBAZGVzY3JpcHRpb24gVHJpZ2dlciBhIHNpbGVudCByb3V0ZSB3aXRoIGEgc3VwcGxpZWQgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKi9cbiAgICBwdXNoICggcGF0aCwgY2IgKSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5yb3V0ZVNpbGVudGx5KCBwYXRoLCAoY2IgfHwgY29yZS51dGlsLm5vb3ApICk7XG4gICAgfSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBtZXRob2QgaW5pdFBhZ2VzXG4gICAgICogQG1lbWJlcm9mIHJvdXRlclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgdGhlIFBhZ2VDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdFBhZ2VzICgpIHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBQYWdlQ29udHJvbGxlcih7XG4gICAgICAgICAgdHJhbnNpdGlvblRpbWU6IHRoaXMucGFnZUR1cmF0aW9uLCAvLyBEZWZhdWx0XG4gICAgICAgICAgIHJvdXRlck9wdGlvbnM6IHsgLy8gRGVmYXVsdFxuICAgICAgICAgICAgICAgaGlzdG9yeU9wdGlvbnM6IHt9LFxuICAgICAgICAgICB9LFxuICAgICAgICAgICByb3V0ZXM6IFtcbiAgICAgICAgICAgICBcIi9cIixcbiAgICAgICAgICAgICBcIjp2aWV3XCIsXG4gICAgICAgICAgICAgXCI6dmlldy86dWlkXCJcbiAgICAgICAgICAgXSwgLy8gRGVmYXVsdFxuICAgICAgICB9KTtcblxuICAgICAgICAvL3RoaXMuY29udHJvbGxlci5vbiggXCJwYWdlLWNvbnRyb2xsZXItcm91dGVyLXNhbWVwYWdlXCIsICgpID0IHt9ICk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5vbiggXCJ0cmFuc2l0aW9uLW91dFwiLCB0aGlzLmNoYW5nZVBhZ2VPdXQuYmluZCggdGhpcyApICk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5vbiggXCJkb2N1bWVudFwiLCB0aGlzLmNoYW5nZUNvbnRlbnQuYmluZCggdGhpcyApICk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5vbiggXCJ0cmFuc2l0aW9uLWluXCIsIHRoaXMuY2hhbmdlUGFnZUluLmJpbmQoIHRoaXMgKSApO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIub24oIFwiaW5pdGlhbGl6ZWRcIiwgdGhpcy5pbml0UGFnZS5iaW5kKCB0aGlzICkgKTtcblxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYmluZCgpO1xuICAgIH0sXG5cblxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGluaXRQYWdlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIFBhZ2VDb250cm9sbGVyIGRhdGEgb2JqZWN0XG4gICAgICogQG1lbWJlcm9mIHJvdXRlclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZSB0aGUgaW5pdGlhbCBwYWdlIGxvYWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0UGFnZSAoIGRhdGEgKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlQ2xhc3MoIGRhdGEgKTtcbiAgICAgICAgdGhpcy5leGVjQ29udHJvbGxlcnMoKTtcbiAgICB9LFxuXG5cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBwYXJzZURvY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIFRoZSByZXNwb25zZVRleHQgdG8gcGFyc2Ugb3V0XG4gICAgICogQG1lbWJlcm9mIHJvdXRlclxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIERPTSBpbmZvcm1hdGlvbiB0byBjYWNoZSBmb3IgYSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICpcbiAgICAgKi9cbiAgICBwYXJzZURvYyAoIGh0bWwgKSB7XG4gICAgICAgIGxldCBkb2MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImh0bWxcIiApO1xuICAgICAgICBsZXQgbWFpbiA9IG51bGw7XG5cbiAgICAgICAgZG9jLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgZG9jID0gJCggZG9jICk7XG4gICAgICAgIG1haW4gPSBkb2MuZmluZCggY29yZS5jb25maWcubWFpblNlbGVjdG9yICk7XG5cbiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSBkb2MuZmluZCgndGl0bGUnKVswXS5pbm5lclRleHQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgbWFpbjogbWFpbixcbiAgICAgICAgICAgIGh0bWw6IG1haW5bIDAgXS5pbm5lckhUTUxcbiAgICAgICAgfTtcbiAgICB9LFxuXG5cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBiaW5kRW1wdHlcbiAgICAgKiBAbWVtYmVyb2Ygcm91dGVyXG4gICAgICogQGRlc2NyaXB0aW9uIFN1cHByZXNzICNoYXNoIGxpbmtzLlxuICAgICAqXG4gICAgICovXG4gICAgYmluZEVtcHR5ICgpIHtcbiAgICAgICAgY29yZS5kb20uYm9keS5vbiggXCJjbGlja1wiLCBcIltocmVmXj0nIyddXCIsICggZSApID0IGUucHJldmVudERlZmF1bHQoKSApO1xuICAgIH0sXG5cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBjaGFuZ2VDbGFzc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBQYWdlQ29udHJvbGxlciBkYXRhIG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiByb3V0ZXJcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlIGRvY3VtZW50IGNsYXNzTmFtZSBzd2FwcGluZyBieSBwYWdlIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBjaGFuZ2VDbGFzcyAoIGRhdGEgKSB7XG5cbiAgICAgICAgaWYgKCB0aGlzLnZpZXcgKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSggYGlzLSR7dGhpcy52aWV3fS1wYWdlYCApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aWV3ID0gKGRhdGEucmVxdWVzdC5wYXJhbXMudWlkIHx8IGRhdGEucmVxdWVzdC5wYXJhbXMudmlld3x8IFwiaG9tZVwiKTtcblxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCggYGlzLSR7dGhpcy52aWV3fS1wYWdlYCApO1xuICAgIH0sXG5cblxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGNoYW5nZVBhZ2VPdXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgUGFnZUNvbnRyb2xsZXIgZGF0YSBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygcm91dGVyXG4gICAgICogQGRlc2NyaXB0aW9uIFRyaWdnZXIgdHJhbnNpdGlvbi1vdXQgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgY2hhbmdlUGFnZU91dCAoIGRhdGEgKSB7XG5cbiAgICAgICAgY29yZS5lbWl0dGVyLmZpcmUoXCJhcHAtLXRyYW5zaXRpb24tb3V0XCIpO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCggXCJpcy1yb3V0aW5nXCIsIFwiaXMtaW5hY3RpdmVcIiApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJ0cmFuc2l0aW9ucy1lbmFibGVkXCIpO1xuXG4gICAgICAgIGRvY3VtZW50LmJcblxuICAgICAgICB0aGlzLmRlc3Ryb3lDb250cm9sbGVycygpO1xuICAgIH0sXG5cblxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGNoYW5nZUNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgUGFnZUNvbnRyb2xsZXIgZGF0YSBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygcm91dGVyXG4gICAgICogQGRlc2NyaXB0aW9uIFN3YXAgdGhlIG5ldyBjb250ZW50IGludG8gdGhlIERPTS5cbiAgICAgKlxuICAgICAqL1xuICAgIGNoYW5nZUNvbnRlbnQgKCBkYXRhICkge1xuXG4gICAgICAgIGNvbnN0IGRvYyA9IHRoaXMucGFyc2VEb2MoIGRhdGEucmVzcG9uc2UgKTtcblxuICAgICAgICBjb3JlLmRvbS5tYWluWyAwIF0uaW5uZXJIVE1MID0gZG9jLmh0bWw7XG5cbiAgICAgICAgd2luZG93LnNjcm9sbFRvKCAwLCAwICk7XG5cbiAgICAgICAgY29yZS5lbWl0dGVyLmZpcmUoXCJhcHAtLXNjcm9sbC10ZWFyZG93blwiKTtcblxuICAgICAgICBjb3JlLmVtaXR0ZXIuZmlyZSggXCJhcHAtLWFuYWx5dGljcy1wdXNoXCIgKTtcblxuICAgICAgICB0aGlzLmNoYW5nZUNsYXNzKCBkYXRhICk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBjaGFuZ2VQYWdlSW5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgUGFnZUNvbnRyb2xsZXIgZGF0YSBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2Ygcm91dGVyXG4gICAgICogQGRlc2NyaXB0aW9uIFRyaWdnZXIgdHJhbnNpdGlvbi1pbiBhbmltYXRpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBjaGFuZ2VQYWdlSW4gKCAvKiBkYXRhICovICkge1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSggXCJpcy1yb3V0aW5nXCIsIFwiaXMtaW5hY3RpdmVcIiApO1xuICAgICAgICB0aGlzLmV4ZWNDb250cm9sbGVycygpO1xuXG4gICAgfSxcblxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAbWV0aG9kIGV4ZWNDb250cm9sbGVyc1xuICAgICAqIEBtZW1iZXJvZiByb3V0ZXJcbiAgICAgKiBAZGVzY3JpcHRpb24gUnVuIHBhZ2UgY29udHJvbGxlcnMuXG4gICAgICogQG5vdGVzIEludHJvLmpzIGxvb2tzIHdoZW4gYXBwIGludGlsYWl6ZXMsIGFuZCB3aGVuIHRvIGVtaXQgYXBwLS1leGVjLWFuaW1hdGlvbnNcbiAgICAgKiBAbm90ZXMgQW5pbWF0ZUNvbnRyb2xsZXIuanMgd2F0Y2hlcyBmb3IgdHJhbnNpdGlvbiBpbiB0byBleGVjIHRyYW5zaXRpb25JbigpXG4gICAgICpcbiAgICAgKi9cbiAgICBleGVjQ29udHJvbGxlcnMgKCkge1xuICAgICAgICB0aGlzLmltYWdlcyA9IGNvcmUuZG9tLm1haW4uZmluZCggY29yZS5jb25maWcubGF6eUltYWdlU2VsZWN0b3IgKTtcblxuXG4gICAgICAgIHRoaXMuaW1hZ2VDb250cm9sbGVyID0gbmV3IEltYWdlQ29udHJvbGxlciggdGhpcy5pbWFnZXMgKTtcbiAgICAgICAgdGhpcy5pbWFnZUNvbnRyb2xsZXIub24oIFwicHJlbG9hZGVkXCIsICgpID0IHtcblxuICAgICAgICAgIHRoaXMuYW5pbXMgPSBjb3JlLmRvbS5tYWluLmZpbmQoIGNvcmUuY29uZmlnLmFuaW1TZWxlY3RvciApO1xuICAgICAgICAgIHRoaXMuYW5pbUNvbnRyb2xsZXIgPSBuZXcgQW5pbWF0ZUNvbnRyb2xsZXIoIHRoaXMuYW5pbXMgKTtcblxuICAgICAgICAgIGNvcmUuZW1pdHRlci5maXJlKCBcImFwcC0taW50cm8tdGVhcmRvd25cIiApO1xuICAgICAgICAgIGNvcmUuZW1pdHRlci5maXJlKCBcImFwcC0taW5pdC1pbWFnZS1ldmVudHNcIiApO1xuICAgICAgICAgIGNvcmUuZW1pdHRlci5maXJlKCBcImFwcC0tcmVzaXplLWRlYm91bmNlZFwiICk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pbWFnZUNvbnRyb2xsZXIub24oXCJsYXp5bG9hZGVkXCIsICgpID0IHtcbiAgICAgICAgICBjb3JlLmVtaXR0ZXIuZmlyZSggXCJhcHAtLWluaXQtaW1hZ2UtZXZlbnRzXCIgKTtcbiAgICAgICAgICBjb3JlLmVtaXR0ZXIuZmlyZSggXCJhcHAtLXJlc2l6ZS1kZWJvdW5jZWRcIiApO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLk1vZHVsZUNvbnRyb2xsZXIgPSBuZXcgTW9kdWxlQ29udHJvbGxlcigpO1xuXG4gICAgICAgIGNvcmUuZW1pdHRlci5maXJlKCBcImFwcC0taW5pdFwiKTtcbiAgICAgICAgY29yZS5lbWl0dGVyLmZpcmUoIFwiYXBwLS1pbml0LXNjcm9sbFwiICk7XG4gICAgICAgIGNvcmUuZW1pdHRlci5maXJlKCBcImFwcC0taW5pdC1tZWRpYVwiICk7XG5cbiAgICB9LFxuICAgIFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQG1ldGhvZCBkZXN0cm95Q29udHJvbGxlcnNcbiAgICAgKiBAbWVtYmVyb2Ygcm91dGVyXG4gICAgICogQGRlc2NyaXB0aW9uIEtpbGwgcGFnZSBjb250cm9sbGVycy5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3lDb250cm9sbGVycyAoKSB7XG4gICAgICAgIGlmICggdGhpcy5pbWFnZUNvbnRyb2xsZXIgKSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmltYWdlQ29udHJvbGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRoaXMuYW5pbUNvbnRyb2xsZXIgKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1Db250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbUNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRXhwb3J0XG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGRlZmF1bHQgcm91dGVyO1xuIl0sIm5hbWVzIjpbIiQiLCJQYWdlQ29udHJvbGxlciIsIkltYWdlQ29udHJvbGxlciIsIkFuaW1hdGVDb250cm9sbGVyIiwiTW9kdWxlQ29udHJvbGxlciIsImNvcmUiLCJyb3V0ZXIiLCJpbml0IiwicGFnZUNsYXNzIiwicGFnZUR1cmF0aW9uIiwiY29uZmlnIiwiZGVmYXVsdER1cmF0aW9uIiwiYmluZEVtcHR5IiwiaW5pdFBhZ2VzIiwicm91dGUiLCJwYXRoIiwiY29udHJvbGxlciIsImdldFJvdXRlciIsInRyaWdnZXIiLCJwdXNoIiwiY2IiLCJyb3V0ZVNpbGVudGx5IiwidXRpbCIsIm5vb3AiLCJ0cmFuc2l0aW9uVGltZSIsInJvdXRlck9wdGlvbnMiLCJoaXN0b3J5T3B0aW9ucyIsInJvdXRlcyIsIm9uIiwiY2hhbmdlUGFnZU91dCIsImJpbmQiLCJjaGFuZ2VDb250ZW50IiwiY2hhbmdlUGFnZUluIiwiaW5pdFBhZ2UiLCJkYXRhIiwiY2hhbmdlQ2xhc3MiLCJleGVjQ29udHJvbGxlcnMiLCJwYXJzZURvYyIsImh0bWwiLCJkb2MiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJtYWluIiwiaW5uZXJIVE1MIiwiZmluZCIsIm1haW5TZWxlY3RvciIsInRpdGxlIiwiaW5uZXJUZXh0IiwiZG9tIiwiYm9keSIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInZpZXciLCJkb2N1bWVudEVsZW1lbnQiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJjb25jYXQiLCJyZXF1ZXN0IiwicGFyYW1zIiwidWlkIiwiYWRkIiwiZW1pdHRlciIsImZpcmUiLCJiIiwiZGVzdHJveUNvbnRyb2xsZXJzIiwicmVzcG9uc2UiLCJ3aW5kb3ciLCJzY3JvbGxUbyIsIl90aGlzIiwiaW1hZ2VzIiwibGF6eUltYWdlU2VsZWN0b3IiLCJpbWFnZUNvbnRyb2xsZXIiLCJhbmltcyIsImFuaW1TZWxlY3RvciIsImFuaW1Db250cm9sbGVyIiwiZGVzdHJveSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/router.js\n");

/***/ }),

/***/ "./node_modules/gsap/Draggable.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/Draggable.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Draggable: () => (/* binding */ Draggable),\n/* harmony export */   \"default\": () => (/* binding */ Draggable)\n/* harmony export */ });\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ \"./node_modules/gsap/utils/matrix.js\");\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/*!\n * Draggable 3.10.4\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n */\n\n/* eslint-disable */\n\n\nvar gsap,\n    _win,\n    _doc,\n    _docElement,\n    _body,\n    _tempDiv,\n    _placeholderDiv,\n    _coreInitted,\n    _checkPrefix,\n    _toArray,\n    _supportsPassive,\n    _isTouchDevice,\n    _touchEventLookup,\n    _dragCount,\n    _isMultiTouching,\n    _isAndroid,\n    InertiaPlugin,\n    _defaultCursor,\n    _supportsPointer,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _isUndefined = function _isUndefined(value) {\n  return typeof value === \"undefined\";\n},\n    _emptyFunc = function _emptyFunc() {\n  return false;\n},\n    _transformProp = \"transform\",\n    _transformOriginProp = \"transformOrigin\",\n    _round = function _round(value) {\n  return Math.round(value * 10000) / 10000;\n},\n    _isArray = Array.isArray,\n    _createElement = function _createElement(type, ns) {\n  var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n\n  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n},\n    _RAD2DEG = 180 / Math.PI,\n    _bigNum = 1e20,\n    _identityMatrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(),\n    _getTime = Date.now || function () {\n  return new Date().getTime();\n},\n    _renderQueue = [],\n    _lookup = {},\n    //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.\n_lookupCount = 0,\n    _clickableTagExp = /^(?:a|input|textarea|button|select)$/i,\n    _lastDragTime = 0,\n    _temp1 = {},\n    // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.\n_windowProxy = {},\n    //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.\n_copy = function _copy(obj, factor) {\n  var copy = {},\n      p;\n\n  for (p in obj) {\n    copy[p] = factor ? obj[p] * factor : obj[p];\n  }\n\n  return copy;\n},\n    _extend = function _extend(obj, defaults) {\n  for (var p in defaults) {\n    if (!(p in obj)) {\n      obj[p] = defaults[p];\n    }\n  }\n\n  return obj;\n},\n    _setTouchActionForAllDescendants = function _setTouchActionForAllDescendants(elements, value) {\n  var i = elements.length,\n      children;\n\n  while (i--) {\n    value ? elements[i].style.touchAction = value : elements[i].style.removeProperty(\"touch-action\");\n    children = elements[i].children;\n    children && children.length && _setTouchActionForAllDescendants(children, value);\n  }\n},\n    _renderQueueTick = function _renderQueueTick() {\n  return _renderQueue.forEach(function (func) {\n    return func();\n  });\n},\n    _addToRenderQueue = function _addToRenderQueue(func) {\n  _renderQueue.push(func);\n\n  if (_renderQueue.length === 1) {\n    gsap.ticker.add(_renderQueueTick);\n  }\n},\n    _renderQueueTimeout = function _renderQueueTimeout() {\n  return !_renderQueue.length && gsap.ticker.remove(_renderQueueTick);\n},\n    _removeFromRenderQueue = function _removeFromRenderQueue(func) {\n  var i = _renderQueue.length;\n\n  while (i--) {\n    if (_renderQueue[i] === func) {\n      _renderQueue.splice(i, 1);\n    }\n  }\n\n  gsap.to(_renderQueueTimeout, {\n    overwrite: true,\n    delay: 15,\n    duration: 0,\n    onComplete: _renderQueueTimeout,\n    data: \"_draggable\"\n  }); //remove the \"tick\" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    if (!(p in obj)) {\n      obj[p] = defaults[p];\n    }\n  }\n\n  return obj;\n},\n    _addListener = function _addListener(element, type, func, capture) {\n  if (element.addEventListener) {\n    var touchType = _touchEventLookup[type];\n    capture = capture || (_supportsPassive ? {\n      passive: false\n    } : null);\n    element.addEventListener(touchType || type, func, capture);\n    touchType && type !== touchType && element.addEventListener(type, func, capture); //some browsers actually support both, so must we. But pointer events cover all.\n  }\n},\n    _removeListener = function _removeListener(element, type, func) {\n  if (element.removeEventListener) {\n    var touchType = _touchEventLookup[type];\n    element.removeEventListener(touchType || type, func);\n    touchType && type !== touchType && element.removeEventListener(type, func);\n  }\n},\n    _preventDefault = function _preventDefault(event) {\n  event.preventDefault && event.preventDefault();\n  event.preventManipulation && event.preventManipulation(); //for some Microsoft browsers\n},\n    _hasTouchID = function _hasTouchID(list, ID) {\n  var i = list.length;\n\n  while (i--) {\n    if (list[i].identifier === ID) {\n      return true;\n    }\n  }\n},\n    _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd(event) {\n  _isMultiTouching = event.touches && _dragCount < event.touches.length;\n\n  _removeListener(event.target, \"touchend\", _onMultiTouchDocumentEnd);\n},\n    _onMultiTouchDocument = function _onMultiTouchDocument(event) {\n  _isMultiTouching = event.touches && _dragCount < event.touches.length;\n\n  _addListener(event.target, \"touchend\", _onMultiTouchDocumentEnd);\n},\n    _getDocScrollTop = function _getDocScrollTop(doc) {\n  return _win.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0;\n},\n    _getDocScrollLeft = function _getDocScrollLeft(doc) {\n  return _win.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;\n},\n    _addScrollListener = function _addScrollListener(e, callback) {\n  _addListener(e, \"scroll\", callback);\n\n  if (!_isRoot(e.parentNode)) {\n    _addScrollListener(e.parentNode, callback);\n  }\n},\n    _removeScrollListener = function _removeScrollListener(e, callback) {\n  _removeListener(e, \"scroll\", callback);\n\n  if (!_isRoot(e.parentNode)) {\n    _removeScrollListener(e.parentNode, callback);\n  }\n},\n    _isRoot = function _isRoot(e) {\n  return !!(!e || e === _docElement || e.nodeType === 9 || e === _doc.body || e === _win || !e.nodeType || !e.parentNode);\n},\n    _getMaxScroll = function _getMaxScroll(element, axis) {\n  var dim = axis === \"x\" ? \"Width\" : \"Height\",\n      scroll = \"scroll\"  dim,\n      client = \"client\"  dim;\n  return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], _body[scroll]) - (_win[\"inner\"  dim] || _docElement[client] || _body[client]) : element[scroll] - element[client]);\n},\n    _recordMaxScrolls = function _recordMaxScrolls(e, skipCurrent) {\n  //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.\n  var x = _getMaxScroll(e, \"x\"),\n      y = _getMaxScroll(e, \"y\");\n\n  if (_isRoot(e)) {\n    e = _windowProxy;\n  } else {\n    _recordMaxScrolls(e.parentNode, skipCurrent);\n  }\n\n  e._gsMaxScrollX = x;\n  e._gsMaxScrollY = y;\n\n  if (!skipCurrent) {\n    e._gsScrollX = e.scrollLeft || 0;\n    e._gsScrollY = e.scrollTop || 0;\n  }\n},\n    _setStyle = function _setStyle(element, property, value) {\n  var style = element.style;\n\n  if (!style) {\n    return;\n  }\n\n  if (_isUndefined(style[property])) {\n    property = _checkPrefix(property, element) || property;\n  }\n\n  if (value == null) {\n    style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n  } else {\n    style[property] = value;\n  }\n},\n    _getComputedStyle = function _getComputedStyle(element) {\n  return _win.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element);\n},\n    //the \"host\" stuff helps to accommodate ShadowDom objects.\n_tempRect = {},\n    //reuse to reduce garbage collection tasks\n_parseRect = function _parseRect(e) {\n  //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties\n  if (e === _win) {\n    _tempRect.left = _tempRect.top = 0;\n    _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _body.clientWidth || 0;\n    _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _body.clientHeight || 0;\n    return _tempRect;\n  }\n\n  var doc = e.ownerDocument || _doc,\n      r = !_isUndefined(e.pageX) ? {\n    left: e.pageX - _getDocScrollLeft(doc),\n    top: e.pageY - _getDocScrollTop(doc),\n    right: e.pageX - _getDocScrollLeft(doc)  1,\n    bottom: e.pageY - _getDocScrollTop(doc)  1\n  } : !e.nodeType && !_isUndefined(e.left) && !_isUndefined(e.top) ? e : _toArray(e)[0].getBoundingClientRect();\n\n  if (_isUndefined(r.right) && !_isUndefined(r.width)) {\n    r.right = r.left  r.width;\n    r.bottom = r.top  r.height;\n  } else if (_isUndefined(r.width)) {\n    //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.\n    r = {\n      width: r.right - r.left,\n      height: r.bottom - r.top,\n      right: r.right,\n      left: r.left,\n      bottom: r.bottom,\n      top: r.top\n    };\n  }\n\n  return r;\n},\n    _dispatchEvent = function _dispatchEvent(target, type, callbackName) {\n  var vars = target.vars,\n      callback = vars[callbackName],\n      listeners = target._listeners[type],\n      result;\n\n  if (_isFunction(callback)) {\n    result = callback.apply(vars.callbackScope || target, vars[callbackName  \"Params\"] || [target.pointerEvent]);\n  }\n\n  if (listeners && target.dispatchEvent(type) === false) {\n    result = false;\n  }\n\n  return result;\n},\n    _getBounds = function _getBounds(target, context) {\n  //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.\n  var e = _toArray(target)[0],\n      top,\n      left,\n      offset;\n\n  if (!e.nodeType && e !== _win) {\n    if (!_isUndefined(target.left)) {\n      offset = {\n        x: 0,\n        y: 0\n      }; //_getOffsetTransformOrigin(context); //the bounds should be relative to the origin\n\n      return {\n        left: target.left - offset.x,\n        top: target.top - offset.y,\n        width: target.width,\n        height: target.height\n      };\n    }\n\n    left = target.min || target.minX || target.minRotation || 0;\n    top = target.min || target.minY || 0;\n    return {\n      left: left,\n      top: top,\n      width: (target.max || target.maxX || target.maxRotation || 0) - left,\n      height: (target.max || target.maxY || 0) - top\n    };\n  }\n\n  return _getElementBounds(e, context);\n},\n    _point1 = {},\n    //we reuse to minimize garbage collection tasks.\n_getElementBounds = function _getElementBounds(element, context) {\n  context = _toArray(context)[0];\n  var isSVG = element.getBBox && element.ownerSVGElement,\n      doc = element.ownerDocument || _doc,\n      left,\n      right,\n      top,\n      bottom,\n      matrix,\n      p1,\n      p2,\n      p3,\n      p4,\n      bbox,\n      width,\n      height,\n      cs,\n      contextParent;\n\n  if (element === _win) {\n    top = _getDocScrollTop(doc);\n    left = _getDocScrollLeft(doc);\n    right = left  (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);\n    bottom = top  ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.\n  } else if (context === _win || _isUndefined(context)) {\n    return element.getBoundingClientRect();\n  } else {\n    left = top = 0;\n\n    if (isSVG) {\n      bbox = element.getBBox();\n      width = bbox.width;\n      height = bbox.height;\n    } else {\n      if (element.viewBox && (bbox = element.viewBox.baseVal)) {\n        left = bbox.x || 0;\n        top = bbox.y || 0;\n        width = bbox.width;\n        height = bbox.height;\n      }\n\n      if (!width) {\n        cs = _getComputedStyle(element);\n        bbox = cs.boxSizing === \"border-box\";\n        width = (parseFloat(cs.width) || element.clientWidth || 0)  (bbox ? 0 : parseFloat(cs.borderLeftWidth)  parseFloat(cs.borderRightWidth));\n        height = (parseFloat(cs.height) || element.clientHeight || 0)  (bbox ? 0 : parseFloat(cs.borderTopWidth)  parseFloat(cs.borderBottomWidth));\n      }\n    }\n\n    right = width;\n    bottom = height;\n  }\n\n  if (element === context) {\n    return {\n      left: left,\n      top: top,\n      width: right - left,\n      height: bottom - top\n    };\n  }\n\n  matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(context, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element));\n  p1 = matrix.apply({\n    x: left,\n    y: top\n  });\n  p2 = matrix.apply({\n    x: right,\n    y: top\n  });\n  p3 = matrix.apply({\n    x: right,\n    y: bottom\n  });\n  p4 = matrix.apply({\n    x: left,\n    y: bottom\n  });\n  left = Math.min(p1.x, p2.x, p3.x, p4.x);\n  top = Math.min(p1.y, p2.y, p3.y, p4.y);\n  contextParent = context.parentNode || {};\n  return {\n    left: left  (contextParent.scrollLeft || 0),\n    top: top  (contextParent.scrollTop || 0),\n    width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,\n    height: Math.max(p1.y, p2.y, p3.y, p4.y) - top\n  };\n},\n    _parseInertia = function _parseInertia(draggable, snap, max, min, factor, forceZeroVelocity) {\n  var vars = {},\n      a,\n      i,\n      l;\n\n  if (snap) {\n    if (factor !== 1 && snap instanceof Array) {\n      //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.\n      vars.end = a = [];\n      l = snap.length;\n\n      if (_isObject(snap[0])) {\n        //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we'll mess up the originals and the user may reuse it elsewhere.\n        for (i = 0; i < l; i) {\n          a[i] = _copy(snap[i], factor);\n        }\n      } else {\n        for (i = 0; i < l; i) {\n          a[i] = snap[i] * factor;\n        }\n      }\n\n      max = 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if \"snap:[-$('#menu').width(), 0]\" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.\n\n      min -= 1.1;\n    } else if (_isFunction(snap)) {\n      vars.end = function (value) {\n        var result = snap.call(draggable, value),\n            copy,\n            p;\n\n        if (factor !== 1) {\n          if (_isObject(result)) {\n            copy = {};\n\n            for (p in result) {\n              copy[p] = result[p] * factor;\n            }\n\n            result = copy;\n          } else {\n            result *= factor;\n          }\n        }\n\n        return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.\n      };\n    } else {\n      vars.end = snap;\n    }\n  }\n\n  if (max || max === 0) {\n    vars.max = max;\n  }\n\n  if (min || min === 0) {\n    vars.min = min;\n  }\n\n  if (forceZeroVelocity) {\n    vars.velocity = 0;\n  }\n\n  return vars;\n},\n    _isClickable = function _isClickable(element) {\n  //sometimes it's convenient to mark an element as clickable by adding a data-clickable=\"true\" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).\n  var data;\n  return !element || !element.getAttribute || element === _body ? false : (data = element.getAttribute(\"data-clickable\")) === \"true\" || data !== \"false\" && (element.onclick || _clickableTagExp.test(element.nodeName  \"\") || element.getAttribute(\"contentEditable\") === \"true\") ? true : _isClickable(element.parentNode);\n},\n    _setSelectable = function _setSelectable(elements, selectable) {\n  var i = elements.length,\n      e;\n\n  while (i--) {\n    e = elements[i];\n    e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;\n    gsap.set(e, {\n      lazy: true,\n      userSelect: selectable ? \"text\" : \"none\"\n    });\n  }\n},\n    _isFixed = function _isFixed(element) {\n  if (_getComputedStyle(element).position === \"fixed\") {\n    return true;\n  }\n\n  element = element.parentNode;\n\n  if (element && element.nodeType === 1) {\n    // avoid document fragments which will throw an error.\n    return _isFixed(element);\n  }\n},\n    _supports3D,\n    _addPaddingBR,\n    //The ScrollProxy class wraps an element's contents into another div (we call it \"content\") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.\nScrollProxy = function ScrollProxy(element, vars) {\n  element = gsap.utils.toArray(element)[0];\n  vars = vars || {};\n  var content = document.createElement(\"div\"),\n      style = content.style,\n      node = element.firstChild,\n      offsetTop = 0,\n      offsetLeft = 0,\n      prevTop = element.scrollTop,\n      prevLeft = element.scrollLeft,\n      scrollWidth = element.scrollWidth,\n      scrollHeight = element.scrollHeight,\n      extraPadRight = 0,\n      maxLeft = 0,\n      maxTop = 0,\n      elementWidth,\n      elementHeight,\n      contentHeight,\n      nextNode,\n      transformStart,\n      transformEnd;\n\n  if (_supports3D && vars.force3D !== false) {\n    transformStart = \"translate3d(\";\n    transformEnd = \"px,0px)\";\n  } else if (_transformProp) {\n    transformStart = \"translate(\";\n    transformEnd = \"px)\";\n  }\n\n  this.scrollTop = function (value, force) {\n    if (!arguments.length) {\n      return -this.top();\n    }\n\n    this.top(-value, force);\n  };\n\n  this.scrollLeft = function (value, force) {\n    if (!arguments.length) {\n      return -this.left();\n    }\n\n    this.left(-value, force);\n  };\n\n  this.left = function (value, force) {\n    if (!arguments.length) {\n      return -(element.scrollLeft  offsetLeft);\n    }\n\n    var dif = element.scrollLeft - prevLeft,\n        oldOffset = offsetLeft;\n\n    if ((dif > 2 || dif < -2) && !force) {\n      //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n      prevLeft = element.scrollLeft;\n      gsap.killTweensOf(this, {\n        left: 1,\n        scrollLeft: 1\n      });\n      this.left(-prevLeft);\n\n      if (vars.onKill) {\n        vars.onKill();\n      }\n\n      return;\n    }\n\n    value = -value; //invert because scrolling works in the opposite direction\n\n    if (value < 0) {\n      offsetLeft = value - 0.5 | 0;\n      value = 0;\n    } else if (value > maxLeft) {\n      offsetLeft = value - maxLeft | 0;\n      value = maxLeft;\n    } else {\n      offsetLeft = 0;\n    }\n\n    if (offsetLeft || oldOffset) {\n      if (!this._skip) {\n        style[_transformProp] = transformStart  -offsetLeft  \"px,\"  -offsetTop  transformEnd;\n      }\n\n      if (offsetLeft  extraPadRight >= 0) {\n        style.paddingRight = offsetLeft  extraPadRight  \"px\";\n      }\n    }\n\n    element.scrollLeft = value | 0;\n    prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjust the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.\n  };\n\n  this.top = function (value, force) {\n    if (!arguments.length) {\n      return -(element.scrollTop  offsetTop);\n    }\n\n    var dif = element.scrollTop - prevTop,\n        oldOffset = offsetTop;\n\n    if ((dif > 2 || dif < -2) && !force) {\n      //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n      prevTop = element.scrollTop;\n      gsap.killTweensOf(this, {\n        top: 1,\n        scrollTop: 1\n      });\n      this.top(-prevTop);\n\n      if (vars.onKill) {\n        vars.onKill();\n      }\n\n      return;\n    }\n\n    value = -value; //invert because scrolling works in the opposite direction\n\n    if (value < 0) {\n      offsetTop = value - 0.5 | 0;\n      value = 0;\n    } else if (value > maxTop) {\n      offsetTop = value - maxTop | 0;\n      value = maxTop;\n    } else {\n      offsetTop = 0;\n    }\n\n    if (offsetTop || oldOffset) {\n      if (!this._skip) {\n        style[_transformProp] = transformStart  -offsetLeft  \"px,\"  -offsetTop  transformEnd;\n      }\n    }\n\n    element.scrollTop = value | 0;\n    prevTop = element.scrollTop;\n  };\n\n  this.maxScrollTop = function () {\n    return maxTop;\n  };\n\n  this.maxScrollLeft = function () {\n    return maxLeft;\n  };\n\n  this.disable = function () {\n    node = content.firstChild;\n\n    while (node) {\n      nextNode = node.nextSibling;\n      element.appendChild(node);\n      node = nextNode;\n    }\n\n    if (element === content.parentNode) {\n      //in case disable() is called when it's already disabled.\n      element.removeChild(content);\n    }\n  };\n\n  this.enable = function () {\n    node = element.firstChild;\n\n    if (node === content) {\n      return;\n    }\n\n    while (node) {\n      nextNode = node.nextSibling;\n      content.appendChild(node);\n      node = nextNode;\n    }\n\n    element.appendChild(content);\n    this.calibrate();\n  };\n\n  this.calibrate = function (force) {\n    var widthMatches = element.clientWidth === elementWidth,\n        cs,\n        x,\n        y;\n    prevTop = element.scrollTop;\n    prevLeft = element.scrollLeft;\n\n    if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {\n      return; //no need to recalculate things if the width and height haven't changed.\n    }\n\n    if (offsetTop || offsetLeft) {\n      x = this.left();\n      y = this.top();\n      this.left(-element.scrollLeft);\n      this.top(-element.scrollTop);\n    }\n\n    cs = _getComputedStyle(element); //first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)\n\n    if (!widthMatches || force) {\n      style.display = \"block\";\n      style.width = \"auto\";\n      style.paddingRight = \"0px\";\n      extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth); //if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.\n\n      if (extraPadRight) {\n        extraPadRight = parseFloat(cs.paddingLeft)  (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);\n      }\n    }\n\n    style.display = \"inline-block\";\n    style.position = \"relative\";\n    style.overflow = \"visible\";\n    style.verticalAlign = \"top\";\n    style.boxSizing = \"content-box\";\n    style.width = \"100%\";\n    style.paddingRight = extraPadRight  \"px\"; //some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error\n\n    if (_addPaddingBR) {\n      style.paddingBottom = cs.paddingBottom;\n    }\n\n    elementWidth = element.clientWidth;\n    elementHeight = element.clientHeight;\n    scrollWidth = element.scrollWidth;\n    scrollHeight = element.scrollHeight;\n    maxLeft = element.scrollWidth - elementWidth;\n    maxTop = element.scrollHeight - elementHeight;\n    contentHeight = content.offsetHeight;\n    style.display = \"block\";\n\n    if (x || y) {\n      this.left(x);\n      this.top(y);\n    }\n  };\n\n  this.content = content;\n  this.element = element;\n  this._skip = false;\n  this.enable();\n},\n    _initCore = function _initCore(required) {\n  if (_windowExists() && document.body) {\n    var nav = window && window.navigator;\n    _win = window;\n    _doc = document;\n    _docElement = _doc.documentElement;\n    _body = _doc.body;\n    _tempDiv = _createElement(\"div\");\n    _supportsPointer = !!window.PointerEvent;\n    _placeholderDiv = _createElement(\"div\");\n    _placeholderDiv.style.cssText = \"visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab\";\n    _defaultCursor = _placeholderDiv.style.cursor === \"grab\" ? \"grab\" : \"move\";\n    _isAndroid = nav && nav.userAgent.toLowerCase().indexOf(\"android\") !== -1; //Android handles touch events in an odd way and it's virtually impossible to \"feature test\" so we resort to UA sniffing\n\n    _isTouchDevice = \"ontouchstart\" in _docElement && \"orientation\" in _win || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);\n\n    _addPaddingBR = function () {\n      //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).\n      var div = _createElement(\"div\"),\n          child = _createElement(\"div\"),\n          childStyle = child.style,\n          parent = _body,\n          val;\n\n      childStyle.display = \"inline-block\";\n      childStyle.position = \"relative\";\n      div.style.cssText = child.innerHTML = \"width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden\";\n      div.appendChild(child);\n      parent.appendChild(div);\n      val = child.offsetHeight  18 > div.scrollHeight; //div.scrollHeight should be child.offsetHeight  20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.\n\n      parent.removeChild(div);\n      return val;\n    }();\n\n    _touchEventLookup = function (types) {\n      //we create an object that makes it easy to translate touch event types into their \"pointer\" counterparts if we're in a browser that uses those instead. Like IE10 uses \"MSPointerDown\" instead of \"touchstart\", for example.\n      var standard = types.split(\",\"),\n          converted = (\"onpointerdown\" in _tempDiv ? \"pointerdown,pointermove,pointerup,pointercancel\" : \"onmspointerdown\" in _tempDiv ? \"MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel\" : types).split(\",\"),\n          obj = {},\n          i = 4;\n\n      while (--i > -1) {\n        obj[standard[i]] = converted[i];\n        obj[converted[i]] = standard[i];\n      } //to avoid problems in iOS 9, test to see if the browser supports the \"passive\" option on addEventListener().\n\n\n      try {\n        _docElement.addEventListener(\"test\", null, Object.defineProperty({}, \"passive\", {\n          get: function get() {\n            _supportsPassive = 1;\n          }\n        }));\n      } catch (e) {}\n\n      return obj;\n    }(\"touchstart,touchmove,touchend,touchcancel\");\n\n    _addListener(_doc, \"touchcancel\", _emptyFunc); //some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document. Very strange indeed.\n\n\n    _addListener(_win, \"touchmove\", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.\n\n\n    _body && _body.addEventListener(\"touchstart\", _emptyFunc); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n    _addListener(_doc, \"contextmenu\", function () {\n      for (var p in _lookup) {\n        if (_lookup[p].isPressed) {\n          _lookup[p].endDrag();\n        }\n      }\n    });\n\n    gsap = _coreInitted = _getGSAP();\n  }\n\n  if (gsap) {\n    InertiaPlugin = gsap.plugins.inertia;\n    _checkPrefix = gsap.utils.checkPrefix;\n    _transformProp = _checkPrefix(_transformProp);\n    _transformOriginProp = _checkPrefix(_transformOriginProp);\n    _toArray = gsap.utils.toArray;\n    _supports3D = !!_checkPrefix(\"perspective\");\n  } else if (required) {\n    console.warn(\"Please gsap.registerPlugin(Draggable)\");\n  }\n};\n\nvar EventDispatcher = /*#__PURE__*/function () {\n  function EventDispatcher(target) {\n    this._listeners = {};\n    this.target = target || this;\n  }\n\n  var _proto = EventDispatcher.prototype;\n\n  _proto.addEventListener = function addEventListener(type, callback) {\n    var list = this._listeners[type] || (this._listeners[type] = []);\n\n    if (!~list.indexOf(callback)) {\n      list.push(callback);\n    }\n  };\n\n  _proto.removeEventListener = function removeEventListener(type, callback) {\n    var list = this._listeners[type],\n        i = list && list.indexOf(callback) || -1;\n    i > -1 && list.splice(i, 1);\n  };\n\n  _proto.dispatchEvent = function dispatchEvent(type) {\n    var _this = this;\n\n    var result;\n    (this._listeners[type] || []).forEach(function (callback) {\n      return callback.call(_this, {\n        type: type,\n        target: _this.target\n      }) === false && (result = false);\n    });\n    return result; //if any of the callbacks return false, pass that along.\n  };\n\n  return EventDispatcher;\n}();\n\nvar Draggable = /*#__PURE__*/function (_EventDispatcher) {\n  _inheritsLoose(Draggable, _EventDispatcher);\n\n  function Draggable(target, vars) {\n    var _this2;\n\n    _this2 = _EventDispatcher.call(this) || this;\n    _coreInitted || _initCore(1);\n    target = _toArray(target)[0]; //in case the target is a selector object or selector text\n\n    if (!InertiaPlugin) {\n      InertiaPlugin = gsap.plugins.inertia;\n    }\n\n    _this2.vars = vars = _copy(vars || {});\n    _this2.target = target;\n    _this2.x = _this2.y = _this2.rotation = 0;\n    _this2.dragResistance = parseFloat(vars.dragResistance) || 0;\n    _this2.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;\n    _this2.lockAxis = vars.lockAxis;\n    _this2.autoScroll = vars.autoScroll || 0;\n    _this2.lockedAxis = null;\n    _this2.allowEventDefault = !!vars.allowEventDefault;\n    gsap.getProperty(target, \"x\"); // to ensure that transforms are instantiated.\n\n    var type = (vars.type || \"x,y\").toLowerCase(),\n        xyMode = ~type.indexOf(\"x\") || ~type.indexOf(\"y\"),\n        rotationMode = type.indexOf(\"rotation\") !== -1,\n        xProp = rotationMode ? \"rotation\" : xyMode ? \"x\" : \"left\",\n        yProp = xyMode ? \"y\" : \"top\",\n        allowX = !!(~type.indexOf(\"x\") || ~type.indexOf(\"left\") || type === \"scroll\"),\n        allowY = !!(~type.indexOf(\"y\") || ~type.indexOf(\"top\") || type === \"scroll\"),\n        minimumMovement = vars.minimumMovement || 2,\n        self = _assertThisInitialized(_this2),\n        triggers = _toArray(vars.trigger || vars.handle || target),\n        killProps = {},\n        dragEndTime = 0,\n        checkAutoScrollBounds = false,\n        autoScrollMarginTop = vars.autoScrollMarginTop || 40,\n        autoScrollMarginRight = vars.autoScrollMarginRight || 40,\n        autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,\n        autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,\n        isClickable = vars.clickableTest || _isClickable,\n        clickTime = 0,\n        gsCache = target._gsap || gsap.core.getCache(target),\n        isFixed = _isFixed(target),\n        getPropAsNum = function getPropAsNum(property, unit) {\n      return parseFloat(gsCache.get(target, property, unit));\n    },\n        ownerDoc = target.ownerDocument || _doc,\n        enabled,\n        scrollProxy,\n        startPointerX,\n        startPointerY,\n        startElementX,\n        startElementY,\n        hasBounds,\n        hasDragCallback,\n        hasMoveCallback,\n        maxX,\n        minX,\n        maxY,\n        minY,\n        touch,\n        touchID,\n        rotationOrigin,\n        dirty,\n        old,\n        snapX,\n        snapY,\n        snapXY,\n        isClicking,\n        touchEventTarget,\n        matrix,\n        interrupted,\n        allowNativeTouchScrolling,\n        touchDragAxis,\n        isDispatching,\n        clickDispatch,\n        trustedClickDispatch,\n        isPreventingDefault,\n        innerMatrix,\n        onContextMenu = function onContextMenu(e) {\n      //used to prevent long-touch from triggering a context menu.\n      // (self.isPressed && e.which < 2) && self.endDrag() // previously ended drag when context menu was triggered, but instead we should just stop propagation and prevent the default event behavior.\n      _preventDefault(e);\n\n      e.stopImmediatePropagation && e.stopImmediatePropagation();\n      return false;\n    },\n        //this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the \"mousemove\" or \"touchmove\" event handler which may get called many times inbetween refreshes.\n    render = function render(suppressEvents) {\n      if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {\n        var e = target,\n            autoScrollFactor = self.autoScroll * 15,\n            //multiplying by 15 just gives us a better \"feel\" speed-wise.\n        parent,\n            isRoot,\n            rect,\n            pointerX,\n            pointerY,\n            changeX,\n            changeY,\n            gap;\n        checkAutoScrollBounds = false;\n        _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n        _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n        pointerX = self.pointerX - _windowProxy.scrollLeft;\n        pointerY = self.pointerY - _windowProxy.scrollTop;\n\n        while (e && !isRoot) {\n          //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.\n          isRoot = _isRoot(e.parentNode);\n          parent = isRoot ? _windowProxy : e.parentNode;\n          rect = isRoot ? {\n            bottom: Math.max(_docElement.clientHeight, _win.innerHeight || 0),\n            right: Math.max(_docElement.clientWidth, _win.innerWidth || 0),\n            left: 0,\n            top: 0\n          } : parent.getBoundingClientRect();\n          changeX = changeY = 0;\n\n          if (allowY) {\n            gap = parent._gsMaxScrollY - parent.scrollTop;\n\n            if (gap < 0) {\n              changeY = gap;\n            } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {\n              checkAutoScrollBounds = true;\n              changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);\n            } else if (pointerY < rect.top  autoScrollMarginTop && parent.scrollTop) {\n              checkAutoScrollBounds = true;\n              changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);\n            }\n\n            if (changeY) {\n              parent.scrollTop = changeY;\n            }\n          }\n\n          if (allowX) {\n            gap = parent._gsMaxScrollX - parent.scrollLeft;\n\n            if (gap < 0) {\n              changeX = gap;\n            } else if (pointerX > rect.right - autoScrollMarginRight && gap) {\n              checkAutoScrollBounds = true;\n              changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);\n            } else if (pointerX < rect.left  autoScrollMarginLeft && parent.scrollLeft) {\n              checkAutoScrollBounds = true;\n              changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);\n            }\n\n            if (changeX) {\n              parent.scrollLeft = changeX;\n            }\n          }\n\n          if (isRoot && (changeX || changeY)) {\n            _win.scrollTo(parent.scrollLeft, parent.scrollTop);\n\n            setPointerPosition(self.pointerX  changeX, self.pointerY  changeY);\n          }\n\n          e = parent;\n        }\n      }\n\n      if (dirty) {\n        var x = self.x,\n            y = self.y;\n\n        if (rotationMode) {\n          self.deltaX = x - parseFloat(gsCache.rotation);\n          self.rotation = x;\n          gsCache.rotation = x  \"deg\";\n          gsCache.renderTransform(1, gsCache);\n        } else {\n          if (scrollProxy) {\n            if (allowY) {\n              self.deltaY = y - scrollProxy.top();\n              scrollProxy.top(y);\n            }\n\n            if (allowX) {\n              self.deltaX = x - scrollProxy.left();\n              scrollProxy.left(x);\n            }\n          } else if (xyMode) {\n            if (allowY) {\n              self.deltaY = y - parseFloat(gsCache.y);\n              gsCache.y = y  \"px\";\n            }\n\n            if (allowX) {\n              self.deltaX = x - parseFloat(gsCache.x);\n              gsCache.x = x  \"px\";\n            }\n\n            gsCache.renderTransform(1, gsCache);\n          } else {\n            if (allowY) {\n              self.deltaY = y - parseFloat(target.style.top || 0);\n              target.style.top = y  \"px\";\n            }\n\n            if (allowX) {\n              self.deltaX = x - parseFloat(target.style.left || 0);\n              target.style.left = x  \"px\";\n            }\n          }\n        }\n\n        if (hasDragCallback && !suppressEvents && !isDispatching) {\n          isDispatching = true; //in case onDrag has an update() call (avoid endless loop)\n\n          if (_dispatchEvent(self, \"drag\", \"onDrag\") === false) {\n            if (allowX) {\n              self.x -= self.deltaX;\n            }\n\n            if (allowY) {\n              self.y -= self.deltaY;\n            }\n\n            render(true);\n          }\n\n          isDispatching = false;\n        }\n      }\n\n      dirty = false;\n    },\n        //copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the InertiaPlugin tween in an onUpdate to ensure things are synced and snapped.\n    syncXY = function syncXY(skipOnUpdate, skipSnap) {\n      var x = self.x,\n          y = self.y,\n          snappedValue,\n          cs;\n\n      if (!target._gsap) {\n        //just in case the _gsap cache got wiped, like if the user called clearProps on the transform or something (very rare).\n        gsCache = gsap.core.getCache(target);\n      }\n\n      gsCache.uncache && gsap.getProperty(target, \"x\"); // trigger a re-cache\n\n      if (xyMode) {\n        self.x = parseFloat(gsCache.x);\n        self.y = parseFloat(gsCache.y);\n      } else if (rotationMode) {\n        self.x = self.rotation = parseFloat(gsCache.rotation);\n      } else if (scrollProxy) {\n        self.y = scrollProxy.top();\n        self.x = scrollProxy.left();\n      } else {\n        self.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;\n        self.x = parseFloat(target.style.left || (cs || {}).left) || 0;\n      }\n\n      if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {\n        if (snapXY) {\n          _temp1.x = self.x;\n          _temp1.y = self.y;\n          snappedValue = snapXY(_temp1);\n\n          if (snappedValue.x !== self.x) {\n            self.x = snappedValue.x;\n            dirty = true;\n          }\n\n          if (snappedValue.y !== self.y) {\n            self.y = snappedValue.y;\n            dirty = true;\n          }\n        }\n\n        if (snapX) {\n          snappedValue = snapX(self.x);\n\n          if (snappedValue !== self.x) {\n            self.x = snappedValue;\n\n            if (rotationMode) {\n              self.rotation = snappedValue;\n            }\n\n            dirty = true;\n          }\n        }\n\n        if (snapY) {\n          snappedValue = snapY(self.y);\n\n          if (snappedValue !== self.y) {\n            self.y = snappedValue;\n          }\n\n          dirty = true;\n        }\n      }\n\n      dirty && render(true);\n\n      if (!skipOnUpdate) {\n        self.deltaX = self.x - x;\n        self.deltaY = self.y - y;\n\n        _dispatchEvent(self, \"throwupdate\", \"onThrowUpdate\");\n      }\n    },\n        buildSnapFunc = function buildSnapFunc(snap, min, max, factor) {\n      if (min == null) {\n        min = -_bigNum;\n      }\n\n      if (max == null) {\n        max = _bigNum;\n      }\n\n      if (_isFunction(snap)) {\n        return function (n) {\n          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)\n\n          return snap.call(self, n > max ? max  (n - max) * edgeTolerance : n < min ? min  (n - min) * edgeTolerance : n) * factor;\n        };\n      }\n\n      if (_isArray(snap)) {\n        return function (n) {\n          var i = snap.length,\n              closest = 0,\n              absDif = _bigNum,\n              val,\n              dif;\n\n          while (--i > -1) {\n            val = snap[i];\n            dif = val - n;\n\n            if (dif < 0) {\n              dif = -dif;\n            }\n\n            if (dif < absDif && val >= min && val <= max) {\n              closest = i;\n              absDif = dif;\n            }\n          }\n\n          return snap[closest];\n        };\n      }\n\n      return isNaN(snap) ? function (n) {\n        return n;\n      } : function () {\n        return snap * factor;\n      };\n    },\n        buildPointSnapFunc = function buildPointSnapFunc(snap, minX, maxX, minY, maxY, radius, factor) {\n      radius = radius && radius < _bigNum ? radius * radius : _bigNum; //so we don't have to Math.sqrt() in the functions. Performance optimization.\n\n      if (_isFunction(snap)) {\n        return function (point) {\n          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,\n              x = point.x,\n              y = point.y,\n              result,\n              dx,\n              dy; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)\n\n          point.x = x = x > maxX ? maxX  (x - maxX) * edgeTolerance : x < minX ? minX  (x - minX) * edgeTolerance : x;\n          point.y = y = y > maxY ? maxY  (y - maxY) * edgeTolerance : y < minY ? minY  (y - minY) * edgeTolerance : y;\n          result = snap.call(self, point);\n\n          if (result !== point) {\n            point.x = result.x;\n            point.y = result.y;\n          }\n\n          if (factor !== 1) {\n            point.x *= factor;\n            point.y *= factor;\n          }\n\n          if (radius < _bigNum) {\n            dx = point.x - x;\n            dy = point.y - y;\n\n            if (dx * dx  dy * dy > radius) {\n              point.x = x;\n              point.y = y;\n            }\n          }\n\n          return point;\n        };\n      }\n\n      if (_isArray(snap)) {\n        return function (p) {\n          var i = snap.length,\n              closest = 0,\n              minDist = _bigNum,\n              x,\n              y,\n              point,\n              dist;\n\n          while (--i > -1) {\n            point = snap[i];\n            x = point.x - p.x;\n            y = point.y - p.y;\n            dist = x * x  y * y;\n\n            if (dist < minDist) {\n              closest = i;\n              minDist = dist;\n            }\n          }\n\n          return minDist <= radius ? snap[closest] : p;\n        };\n      }\n\n      return function (n) {\n        return n;\n      };\n    },\n        calculateBounds = function calculateBounds() {\n      var bounds, targetBounds, snap, snapIsRaw;\n      hasBounds = false;\n\n      if (scrollProxy) {\n        scrollProxy.calibrate();\n        self.minX = minX = -scrollProxy.maxScrollLeft();\n        self.minY = minY = -scrollProxy.maxScrollTop();\n        self.maxX = maxX = self.maxY = maxY = 0;\n        hasBounds = true;\n      } else if (!!vars.bounds) {\n        bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}\n\n        if (rotationMode) {\n          self.minX = minX = bounds.left;\n          self.maxX = maxX = bounds.left  bounds.width;\n          self.minY = minY = self.maxY = maxY = 0;\n        } else if (!_isUndefined(vars.bounds.maxX) || !_isUndefined(vars.bounds.maxY)) {\n          bounds = vars.bounds;\n          self.minX = minX = bounds.minX;\n          self.minY = minY = bounds.minY;\n          self.maxX = maxX = bounds.maxX;\n          self.maxY = maxY = bounds.maxY;\n        } else {\n          targetBounds = _getBounds(target, target.parentNode);\n          self.minX = minX = Math.round(getPropAsNum(xProp, \"px\")  bounds.left - targetBounds.left);\n          self.minY = minY = Math.round(getPropAsNum(yProp, \"px\")  bounds.top - targetBounds.top);\n          self.maxX = maxX = Math.round(minX  (bounds.width - targetBounds.width));\n          self.maxY = maxY = Math.round(minY  (bounds.height - targetBounds.height));\n        }\n\n        if (minX > maxX) {\n          self.minX = maxX;\n          self.maxX = maxX = minX;\n          minX = self.minX;\n        }\n\n        if (minY > maxY) {\n          self.minY = maxY;\n          self.maxY = maxY = minY;\n          minY = self.minY;\n        }\n\n        if (rotationMode) {\n          self.minRotation = minX;\n          self.maxRotation = maxX;\n        }\n\n        hasBounds = true;\n      }\n\n      if (vars.liveSnap) {\n        snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;\n        snapIsRaw = _isArray(snap) || _isFunction(snap);\n\n        if (rotationMode) {\n          snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);\n          snapY = null;\n        } else {\n          if (snap.points) {\n            snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);\n          } else {\n            if (allowX) {\n              snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);\n            }\n\n            if (allowY) {\n              snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);\n            }\n          }\n        }\n      }\n    },\n        onThrowComplete = function onThrowComplete() {\n      self.isThrowing = false;\n\n      _dispatchEvent(self, \"throwcomplete\", \"onThrowComplete\");\n    },\n        onThrowInterrupt = function onThrowInterrupt() {\n      self.isThrowing = false;\n    },\n        animate = function animate(inertia, forceZeroVelocity) {\n      var snap, snapIsRaw, tween, overshootTolerance;\n\n      if (inertia && InertiaPlugin) {\n        if (inertia === true) {\n          snap = vars.snap || vars.liveSnap || {};\n          snapIsRaw = _isArray(snap) || _isFunction(snap);\n          inertia = {\n            resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)\n          };\n\n          if (rotationMode) {\n            inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);\n          } else {\n            if (allowX) {\n              inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === \"x\");\n            }\n\n            if (allowY) {\n              inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === \"y\");\n            }\n\n            if (snap.points || _isArray(snap) && _isObject(snap[0])) {\n              inertia.linkedProps = xProp  \",\"  yProp;\n              inertia.radius = snap.radius; //note: we also disable liveSnapping while throwing if there's a \"radius\" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that \"skipSnap\" parameter is true for syncXY.\n            }\n          }\n        }\n\n        self.isThrowing = true;\n        overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance  0.2;\n\n        if (!inertia.duration) {\n          inertia.duration = {\n            max: Math.max(vars.minDuration || 0, \"maxDuration\" in vars ? vars.maxDuration : 2),\n            min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject(inertia) && inertia.resistance > 1000 ? 0 : 0.5,\n            overshoot: overshootTolerance\n          };\n        }\n\n        self.tween = tween = gsap.to(scrollProxy || target, {\n          inertia: inertia,\n          data: \"_draggable\",\n          onComplete: onThrowComplete,\n          onInterrupt: onThrowInterrupt,\n          onUpdate: vars.fastMode ? _dispatchEvent : syncXY,\n          onUpdateParams: vars.fastMode ? [self, \"onthrowupdate\", \"onThrowUpdate\"] : snap && snap.radius ? [false, true] : []\n        });\n\n        if (!vars.fastMode) {\n          if (scrollProxy) {\n            scrollProxy._skip = true; // Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n          }\n\n          tween.render(1e9, true, true); // force to the end. Remember, the duration will likely change upon initting because that's when InertiaPlugin calculates it.\n\n          syncXY(true, true);\n          self.endX = self.x;\n          self.endY = self.y;\n\n          if (rotationMode) {\n            self.endRotation = self.x;\n          }\n\n          tween.play(0);\n          syncXY(true, true);\n\n          if (scrollProxy) {\n            scrollProxy._skip = false; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n          }\n        }\n      } else if (hasBounds) {\n        self.applyBounds();\n      }\n    },\n        updateMatrix = function updateMatrix(shiftStart) {\n      var start = matrix,\n          p;\n      matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);\n\n      if (shiftStart && self.isPressed && !matrix.equals(start || new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D())) {\n        //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.\n        p = start.inverse().apply({\n          x: startPointerX,\n          y: startPointerY\n        });\n        matrix.apply(p, p);\n        startPointerX = p.x;\n        startPointerY = p.y;\n      }\n\n      if (matrix.equals(_identityMatrix)) {\n        //if there are no transforms, we can optimize performance by not factoring in the matrix\n        matrix = null;\n      }\n    },\n        recordStartPositions = function recordStartPositions() {\n      var edgeTolerance = 1 - self.edgeResistance,\n          offsetX = isFixed ? _getDocScrollLeft(ownerDoc) : 0,\n          offsetY = isFixed ? _getDocScrollTop(ownerDoc) : 0,\n          parsedOrigin,\n          x,\n          y;\n      updateMatrix(false);\n      _point1.x = self.pointerX - offsetX;\n      _point1.y = self.pointerY - offsetY;\n      matrix && matrix.apply(_point1, _point1);\n      startPointerX = _point1.x; //translate to local coordinate system\n\n      startPointerY = _point1.y;\n\n      if (dirty) {\n        setPointerPosition(self.pointerX, self.pointerY);\n        render(true);\n      }\n\n      innerMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target);\n\n      if (scrollProxy) {\n        calculateBounds();\n        startElementY = scrollProxy.top();\n        startElementX = scrollProxy.left();\n      } else {\n        //if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.\n        if (isTweening()) {\n          syncXY(true, true);\n          calculateBounds();\n        } else {\n          self.applyBounds();\n        }\n\n        if (rotationMode) {\n          parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp] || \"0 0\").split(\" \");\n          rotationOrigin = self.rotationOrigin = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target).apply({\n            x: parseFloat(parsedOrigin[0]) || 0,\n            y: parseFloat(parsedOrigin[1]) || 0\n          });\n          syncXY(true, true);\n          x = self.pointerX - rotationOrigin.x - offsetX;\n          y = rotationOrigin.y - self.pointerY  offsetY;\n          startElementX = self.x; //starting rotation (x always refers to rotation in type:\"rotation\", measured in degrees)\n\n          startElementY = self.y = Math.atan2(y, x) * _RAD2DEG;\n        } else {\n          //parent = !isFixed && target.parentNode;\n          //startScrollTop = parent ? parent.scrollTop || 0 : 0;\n          //startScrollLeft = parent ? parent.scrollLeft || 0 : 0;\n          startElementY = getPropAsNum(yProp, \"px\"); //record the starting top and left values so that we can just add the mouse's movement to them later.\n\n          startElementX = getPropAsNum(xProp, \"px\");\n        }\n      }\n\n      if (hasBounds && edgeTolerance) {\n        if (startElementX > maxX) {\n          startElementX = maxX  (startElementX - maxX) / edgeTolerance;\n        } else if (startElementX < minX) {\n          startElementX = minX - (minX - startElementX) / edgeTolerance;\n        }\n\n        if (!rotationMode) {\n          if (startElementY > maxY) {\n            startElementY = maxY  (startElementY - maxY) / edgeTolerance;\n          } else if (startElementY < minY) {\n            startElementY = minY - (minY - startElementY) / edgeTolerance;\n          }\n        }\n      }\n\n      self.startX = startElementX = _round(startElementX);\n      self.startY = startElementY = _round(startElementY);\n    },\n        isTweening = function isTweening() {\n      return self.tween && self.tween.isActive();\n    },\n        removePlaceholder = function removePlaceholder() {\n      if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {\n        //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.\n        _placeholderDiv.parentNode.removeChild(_placeholderDiv);\n      }\n    },\n        //called when the mouse is pressed (or touch starts)\n    onPress = function onPress(e, force) {\n      var i;\n\n      if (!enabled || self.isPressed || !e || (e.type === \"mousedown\" || e.type === \"pointerdown\") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {\n        //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick \"click\" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.\n        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchstart, pointerdown, mousedown. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n\n        return;\n      }\n\n      interrupted = isTweening();\n      self.pointerEvent = e;\n\n      if (_touchEventLookup[e.type]) {\n        //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.\n        touchEventTarget = ~e.type.indexOf(\"touch\") ? e.currentTarget || e.target : ownerDoc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be \"MSPointerDown\" or \"pointerdown\".\n\n        _addListener(touchEventTarget, \"touchend\", onRelease);\n\n        _addListener(touchEventTarget, \"touchmove\", onMove); // possible future change if PointerEvents are more standardized: https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture\n\n\n        _addListener(touchEventTarget, \"touchcancel\", onRelease);\n\n        _addListener(ownerDoc, \"touchstart\", _onMultiTouchDocument);\n      } else {\n        touchEventTarget = null;\n\n        _addListener(ownerDoc, \"mousemove\", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.\n\n      }\n\n      touchDragAxis = null;\n\n      if (!_supportsPointer || !touchEventTarget) {\n        _addListener(ownerDoc, \"mouseup\", onRelease);\n\n        e && e.target && _addListener(e.target, \"mouseup\", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable=\"true\"\n      }\n\n      isClicking = isClickable.call(self, e.target) && vars.dragClickables === false && !force;\n\n      if (isClicking) {\n        _addListener(e.target, \"change\", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a \"change\" event instead.\n\n\n        _dispatchEvent(self, \"pressInit\", \"onPressInit\");\n\n        _dispatchEvent(self, \"press\", \"onPress\");\n\n        _setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable=\"true\" (otherwise user couldn't drag to select text)\n\n\n        isPreventingDefault = false;\n        return;\n      }\n\n      allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? \"y\" : \"x\"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn't have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.\n\n      isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;\n\n      if (isPreventingDefault) {\n        _preventDefault(e);\n\n        _addListener(_win, \"touchforcechange\", _preventDefault); //works around safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n      }\n\n      if (e.changedTouches) {\n        //touch events store the data slightly differently\n        e = touch = e.changedTouches[0];\n        touchID = e.identifier;\n      } else if (e.pointerId) {\n        touchID = e.pointerId; //for some Microsoft browsers\n      } else {\n        touch = touchID = null;\n      }\n\n      _dragCount;\n\n      _addToRenderQueue(render); //causes the Draggable to render on each \"tick\" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)\n\n\n      startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove\n\n      startPointerX = self.pointerX = e.pageX;\n\n      _dispatchEvent(self, \"pressInit\", \"onPressInit\");\n\n      if (allowNativeTouchScrolling || self.autoScroll) {\n        _recordMaxScrolls(target.parentNode);\n      }\n\n      if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {\n        //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.\n        _placeholderDiv.style.width = target.parentNode.scrollWidth  \"px\";\n        target.parentNode.appendChild(_placeholderDiv);\n      }\n\n      recordStartPositions();\n      self.tween && self.tween.kill();\n      self.isThrowing = false;\n      gsap.killTweensOf(scrollProxy || target, killProps, true); //in case the user tries to drag it before the last tween is done.\n\n      scrollProxy && gsap.killTweensOf(target, {\n        scrollTo: 1\n      }, true); //just in case the original target's scroll position is being tweened somewhere else.\n\n      self.tween = self.lockedAxis = null;\n\n      if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {\n        target.style.zIndex = Draggable.zIndex;\n      }\n\n      self.isPressed = true;\n      hasDragCallback = !!(vars.onDrag || self._listeners.drag);\n      hasMoveCallback = !!(vars.onMove || self._listeners.move);\n\n      if (vars.cursor !== false || vars.activeCursor) {\n        i = triggers.length;\n\n        while (--i > -1) {\n          gsap.set(triggers[i], {\n            cursor: vars.activeCursor || vars.cursor || (_defaultCursor === \"grab\" ? \"grabbing\" : _defaultCursor)\n          });\n        }\n      }\n\n      _dispatchEvent(self, \"press\", \"onPress\");\n    },\n        //called every time the mouse/touch moves\n    onMove = function onMove(e) {\n      var originalEvent = e,\n          touches,\n          pointerX,\n          pointerY,\n          i,\n          dx,\n          dy;\n\n      if (!enabled || _isMultiTouching || !self.isPressed || !e) {\n        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchmove, pointermove, mousemove. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n\n        return;\n      }\n\n      self.pointerEvent = e;\n      touches = e.changedTouches;\n\n      if (touches) {\n        //touch events store the data slightly differently\n        e = touches[0];\n\n        if (e !== touch && e.identifier !== touchID) {\n          //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n          i = touches.length;\n\n          while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {} // Some Android devices dispatch a touchstart AND pointerdown initially, and then only pointermove thus the touchID may not match because it was grabbed from the touchstart event whereas the pointer event is the one that the browser dispatches for move, so if the event target matches this Draggable's target, let it through.\n\n\n          if (i < 0) {\n            return;\n          }\n        }\n      } else if (e.pointerId && touchID && e.pointerId !== touchID) {\n        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n        return;\n      }\n\n      if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {\n        //Android browsers force us to decide on the first \"touchmove\" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a \"touchcancel\" will be fired and then no \"touchmove\" or \"touchend\" will fire during the scrolling (no good).\n        _point1.x = e.pageX - (isFixed ? _getDocScrollLeft(ownerDoc) : 0);\n        _point1.y = e.pageY - (isFixed ? _getDocScrollTop(ownerDoc) : 0);\n        matrix && matrix.apply(_point1, _point1);\n        pointerX = _point1.x;\n        pointerY = _point1.y;\n        dx = Math.abs(pointerX - startPointerX);\n        dy = Math.abs(pointerY - startPointerY);\n\n        if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n          touchDragAxis = dx > dy && allowX ? \"x\" : \"y\";\n\n          if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {\n            _addListener(_win, \"touchforcechange\", _preventDefault); // prevents native touch scrolling from taking over if the user started dragging in the other direction in iOS Safari\n\n          }\n\n          if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {\n            self.lockedAxis = touchDragAxis === \"x\" ? \"y\" : \"x\";\n            _isFunction(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);\n          }\n\n          if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n            onRelease(originalEvent);\n            return;\n          }\n        }\n      }\n\n      if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {\n        _preventDefault(originalEvent);\n\n        isPreventingDefault = true;\n      } else if (isPreventingDefault) {\n        isPreventingDefault = false;\n      }\n\n      if (self.autoScroll) {\n        checkAutoScrollBounds = true;\n      }\n\n      setPointerPosition(e.pageX, e.pageY, hasMoveCallback);\n    },\n        setPointerPosition = function setPointerPosition(pointerX, pointerY, invokeOnMove) {\n      var dragTolerance = 1 - self.dragResistance,\n          edgeTolerance = 1 - self.edgeResistance,\n          prevPointerX = self.pointerX,\n          prevPointerY = self.pointerY,\n          prevStartElementY = startElementY,\n          prevX = self.x,\n          prevY = self.y,\n          prevEndX = self.endX,\n          prevEndY = self.endY,\n          prevEndRotation = self.endRotation,\n          prevDirty = dirty,\n          xChange,\n          yChange,\n          x,\n          y,\n          dif,\n          temp;\n      self.pointerX = pointerX;\n      self.pointerY = pointerY;\n\n      if (isFixed) {\n        pointerX -= _getDocScrollLeft(ownerDoc);\n        pointerY -= _getDocScrollTop(ownerDoc);\n      }\n\n      if (rotationMode) {\n        y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;\n        dif = self.y - y;\n\n        if (dif > 180) {\n          startElementY -= 360;\n          self.y = y;\n        } else if (dif < -180) {\n          startElementY = 360;\n          self.y = y;\n        }\n\n        if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {\n          self.y = y;\n          x = startElementX  (startElementY - y) * dragTolerance;\n        } else {\n          x = startElementX;\n        }\n      } else {\n        if (matrix) {\n          temp = pointerX * matrix.a  pointerY * matrix.c  matrix.e;\n          pointerY = pointerX * matrix.b  pointerY * matrix.d  matrix.f;\n          pointerX = temp;\n        }\n\n        yChange = pointerY - startPointerY;\n        xChange = pointerX - startPointerX;\n\n        if (yChange < minimumMovement && yChange > -minimumMovement) {\n          yChange = 0;\n        }\n\n        if (xChange < minimumMovement && xChange > -minimumMovement) {\n          xChange = 0;\n        }\n\n        if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {\n          temp = self.lockedAxis;\n\n          if (!temp) {\n            self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? \"y\" : allowY ? \"x\" : null;\n\n            if (temp && _isFunction(self.vars.onLockAxis)) {\n              self.vars.onLockAxis.call(self, self.pointerEvent);\n            }\n          }\n\n          if (temp === \"y\") {\n            yChange = 0;\n          } else if (temp === \"x\") {\n            xChange = 0;\n          }\n        }\n\n        x = _round(startElementX  xChange * dragTolerance);\n        y = _round(startElementY  yChange * dragTolerance);\n      }\n\n      if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {\n        if (snapXY) {\n          _temp1.x = x;\n          _temp1.y = y;\n          temp = snapXY(_temp1);\n          x = _round(temp.x);\n          y = _round(temp.y);\n        }\n\n        if (snapX) {\n          x = _round(snapX(x));\n        }\n\n        if (snapY) {\n          y = _round(snapY(y));\n        }\n      }\n\n      if (hasBounds) {\n        if (x > maxX) {\n          x = maxX  Math.round((x - maxX) * edgeTolerance);\n        } else if (x < minX) {\n          x = minX  Math.round((x - minX) * edgeTolerance);\n        }\n\n        if (!rotationMode) {\n          if (y > maxY) {\n            y = Math.round(maxY  (y - maxY) * edgeTolerance);\n          } else if (y < minY) {\n            y = Math.round(minY  (y - minY) * edgeTolerance);\n          }\n        }\n      }\n\n      if (self.x !== x || self.y !== y && !rotationMode) {\n        if (rotationMode) {\n          self.endRotation = self.x = self.endX = x;\n          dirty = true;\n        } else {\n          if (allowY) {\n            self.y = self.endY = y;\n            dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a \"tick\" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)\n          }\n\n          if (allowX) {\n            self.x = self.endX = x;\n            dirty = true;\n          }\n        }\n\n        if (!invokeOnMove || _dispatchEvent(self, \"move\", \"onMove\") !== false) {\n          if (!self.isDragging && self.isPressed) {\n            self.isDragging = true;\n\n            _dispatchEvent(self, \"dragstart\", \"onDragStart\");\n          }\n        } else {\n          //revert because the onMove returned false!\n          self.pointerX = prevPointerX;\n          self.pointerY = prevPointerY;\n          startElementY = prevStartElementY;\n          self.x = prevX;\n          self.y = prevY;\n          self.endX = prevEndX;\n          self.endY = prevEndY;\n          self.endRotation = prevEndRotation;\n          dirty = prevDirty;\n        }\n      }\n    },\n        //called when the mouse/touch is released\n    onRelease = function onRelease(e, force) {\n      if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {\n        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)\n        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchend, pointerup, mouseup. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n\n        return;\n      }\n\n      self.isPressed = false;\n      var originalEvent = e,\n          wasDragging = self.isDragging,\n          isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2),\n          placeholderDelayedCall = gsap.delayedCall(0.001, removePlaceholder),\n          touches,\n          i,\n          syntheticEvent,\n          eventTarget,\n          syntheticClick;\n\n      if (touchEventTarget) {\n        _removeListener(touchEventTarget, \"touchend\", onRelease);\n\n        _removeListener(touchEventTarget, \"touchmove\", onMove);\n\n        _removeListener(touchEventTarget, \"touchcancel\", onRelease);\n\n        _removeListener(ownerDoc, \"touchstart\", _onMultiTouchDocument);\n      } else {\n        _removeListener(ownerDoc, \"mousemove\", onMove);\n      }\n\n      _removeListener(_win, \"touchforcechange\", _preventDefault);\n\n      if (!_supportsPointer || !touchEventTarget) {\n        _removeListener(ownerDoc, \"mouseup\", onRelease);\n\n        e && e.target && _removeListener(e.target, \"mouseup\", onRelease);\n      }\n\n      dirty = false;\n\n      if (wasDragging) {\n        dragEndTime = _lastDragTime = _getTime();\n        self.isDragging = false;\n      }\n\n      if (isClicking && !isContextMenuRelease) {\n        if (e) {\n          _removeListener(e.target, \"change\", onRelease);\n\n          self.pointerEvent = originalEvent;\n        }\n\n        _setSelectable(triggers, false);\n\n        _dispatchEvent(self, \"release\", \"onRelease\");\n\n        _dispatchEvent(self, \"click\", \"onClick\");\n\n        isClicking = false;\n        return;\n      }\n\n      _removeFromRenderQueue(render);\n\n      i = triggers.length;\n\n      while (--i > -1) {\n        _setStyle(triggers[i], \"cursor\", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));\n      }\n\n      _dragCount--;\n\n      if (e) {\n        touches = e.changedTouches;\n\n        if (touches) {\n          //touch events store the data slightly differently\n          e = touches[0];\n\n          if (e !== touch && e.identifier !== touchID) {\n            //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)\n            i = touches.length;\n\n            while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {}\n\n            if (i < 0) {\n              return;\n            }\n          }\n        }\n\n        self.pointerEvent = originalEvent;\n        self.pointerX = e.pageX;\n        self.pointerY = e.pageY;\n      }\n\n      if (isContextMenuRelease && originalEvent) {\n        _preventDefault(originalEvent);\n\n        isPreventingDefault = true;\n\n        _dispatchEvent(self, \"release\", \"onRelease\");\n      } else if (originalEvent && !wasDragging) {\n        isPreventingDefault = false;\n\n        if (interrupted && (vars.snap || vars.bounds)) {\n          //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)\n          animate(vars.inertia || vars.throwProps);\n        }\n\n        _dispatchEvent(self, \"release\", \"onRelease\");\n\n        if ((!_isAndroid || originalEvent.type !== \"touchmove\") && originalEvent.type.indexOf(\"cancel\") === -1) {\n          //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a \"click\".\n          _dispatchEvent(self, \"click\", \"onClick\");\n\n          if (_getTime() - clickTime < 300) {\n            _dispatchEvent(self, \"doubleclick\", \"onDoubleClick\");\n          }\n\n          eventTarget = originalEvent.target || target; //old IE uses srcElement\n\n          clickTime = _getTime();\n\n          syntheticClick = function syntheticClick() {\n            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n            if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {\n              if (eventTarget.click) {\n                //some browsers (like mobile Safari) don't properly trigger the click event\n                eventTarget.click();\n              } else if (ownerDoc.createEvent) {\n                syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);\n                eventTarget.dispatchEvent(syntheticEvent);\n              }\n            }\n          };\n\n          if (!_isAndroid && !originalEvent.defaultPrevented) {\n            //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.\n            gsap.delayedCall(0.05, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the \"click\" event with \"capture\" false which solved the video-click-to-play issue, but it would allow the \"click\" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click. Don't fire it too fast (like 0.00001) because we want to give the native event a chance to fire first as it's \"trusted\".\n          }\n        }\n      } else {\n        animate(vars.inertia || vars.throwProps); //will skip if inertia/throwProps isn't defined or InertiaPlugin isn't loaded.\n\n        if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {\n          isPreventingDefault = true;\n\n          _preventDefault(originalEvent);\n        } else {\n          isPreventingDefault = false;\n        }\n\n        _dispatchEvent(self, \"release\", \"onRelease\");\n      }\n\n      isTweening() && placeholderDelayedCall.duration(self.tween.duration()); //sync the timing so that the placeholder DIV gets\n\n      wasDragging && _dispatchEvent(self, \"dragend\", \"onDragEnd\");\n      return true;\n    },\n        updateScroll = function updateScroll(e) {\n      if (e && self.isDragging && !scrollProxy) {\n        var parent = e.target || target.parentNode,\n            deltaX = parent.scrollLeft - parent._gsScrollX,\n            deltaY = parent.scrollTop - parent._gsScrollY;\n\n        if (deltaX || deltaY) {\n          if (matrix) {\n            startPointerX -= deltaX * matrix.a  deltaY * matrix.c;\n            startPointerY -= deltaY * matrix.d  deltaX * matrix.b;\n          } else {\n            startPointerX -= deltaX;\n            startPointerY -= deltaY;\n          }\n\n          parent._gsScrollX = deltaX;\n          parent._gsScrollY = deltaY;\n          setPointerPosition(self.pointerX, self.pointerY);\n        }\n      }\n    },\n        onClick = function onClick(e) {\n      //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.\n      var time = _getTime(),\n          recentlyClicked = time - clickTime < 100,\n          recentlyDragged = time - dragEndTime < 50,\n          alreadyDispatched = recentlyClicked && clickDispatch === clickTime,\n          defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented,\n          alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime,\n          trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched; //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic \"click\" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?\n\n\n      if ((alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {\n        e.stopImmediatePropagation();\n      }\n\n      if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {\n        //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)\n        if (trusted && alreadyDispatched) {\n          trustedClickDispatch = clickTime;\n        }\n\n        clickDispatch = clickTime;\n        return;\n      }\n\n      if (self.isPressed || recentlyDragged || recentlyClicked) {\n        if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {\n          _preventDefault(e);\n        }\n      }\n\n      if (!recentlyClicked && !recentlyDragged) {\n        // for script-triggered event dispatches, like element.click()\n        e && e.target && (self.pointerEvent = e);\n\n        _dispatchEvent(self, \"click\", \"onClick\");\n      }\n    },\n        localizePoint = function localizePoint(p) {\n      return matrix ? {\n        x: p.x * matrix.a  p.y * matrix.c  matrix.e,\n        y: p.x * matrix.b  p.y * matrix.d  matrix.f\n      } : {\n        x: p.x,\n        y: p.y\n      };\n    };\n\n    old = Draggable.get(target);\n    old && old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)\n    //give the user access to start/stop dragging...\n\n    _this2.startDrag = function (event, align) {\n      var r1, r2, p1, p2;\n      onPress(event || self.pointerEvent, true); //if the pointer isn't on top of the element, adjust things accordingly\n\n      if (align && !self.hitTest(event || self.pointerEvent)) {\n        r1 = _parseRect(event || self.pointerEvent);\n        r2 = _parseRect(target);\n        p1 = localizePoint({\n          x: r1.left  r1.width / 2,\n          y: r1.top  r1.height / 2\n        });\n        p2 = localizePoint({\n          x: r2.left  r2.width / 2,\n          y: r2.top  r2.height / 2\n        });\n        startPointerX -= p1.x - p2.x;\n        startPointerY -= p1.y - p2.y;\n      }\n\n      if (!self.isDragging) {\n        self.isDragging = true;\n\n        _dispatchEvent(self, \"dragstart\", \"onDragStart\");\n      }\n    };\n\n    _this2.drag = onMove;\n\n    _this2.endDrag = function (e) {\n      return onRelease(e || self.pointerEvent, true);\n    };\n\n    _this2.timeSinceDrag = function () {\n      return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;\n    };\n\n    _this2.timeSinceClick = function () {\n      return (_getTime() - clickTime) / 1000;\n    };\n\n    _this2.hitTest = function (target, threshold) {\n      return Draggable.hitTest(self.target, target, threshold);\n    };\n\n    _this2.getDirection = function (from, diagonalThreshold) {\n      //from can be \"start\" (default), \"velocity\", or an element\n      var mode = from === \"velocity\" && InertiaPlugin ? from : _isObject(from) && !rotationMode ? \"element\" : \"start\",\n          xChange,\n          yChange,\n          ratio,\n          direction,\n          r1,\n          r2;\n\n      if (mode === \"element\") {\n        r1 = _parseRect(self.target);\n        r2 = _parseRect(from);\n      }\n\n      xChange = mode === \"start\" ? self.x - startElementX : mode === \"velocity\" ? InertiaPlugin.getVelocity(target, xProp) : r1.left  r1.width / 2 - (r2.left  r2.width / 2);\n\n      if (rotationMode) {\n        return xChange < 0 ? \"counter-clockwise\" : \"clockwise\";\n      } else {\n        diagonalThreshold = diagonalThreshold || 2;\n        yChange = mode === \"start\" ? self.y - startElementY : mode === \"velocity\" ? InertiaPlugin.getVelocity(target, yProp) : r1.top  r1.height / 2 - (r2.top  r2.height / 2);\n        ratio = Math.abs(xChange / yChange);\n        direction = ratio < 1 / diagonalThreshold ? \"\" : xChange < 0 ? \"left\" : \"right\";\n\n        if (ratio < diagonalThreshold) {\n          if (direction !== \"\") {\n            direction = \"-\";\n          }\n\n          direction = yChange < 0 ? \"up\" : \"down\";\n        }\n      }\n\n      return direction;\n    };\n\n    _this2.applyBounds = function (newBounds, sticky) {\n      var x, y, forceZeroVelocity, e, parent, isRoot;\n\n      if (newBounds && vars.bounds !== newBounds) {\n        vars.bounds = newBounds;\n        return self.update(true, sticky);\n      }\n\n      syncXY(true);\n      calculateBounds();\n\n      if (hasBounds && !isTweening()) {\n        x = self.x;\n        y = self.y;\n\n        if (x > maxX) {\n          x = maxX;\n        } else if (x < minX) {\n          x = minX;\n        }\n\n        if (y > maxY) {\n          y = maxY;\n        } else if (y < minY) {\n          y = minY;\n        }\n\n        if (self.x !== x || self.y !== y) {\n          forceZeroVelocity = true;\n          self.x = self.endX = x;\n\n          if (rotationMode) {\n            self.endRotation = x;\n          } else {\n            self.y = self.endY = y;\n          }\n\n          dirty = true;\n          render(true);\n\n          if (self.autoScroll && !self.isDragging) {\n            _recordMaxScrolls(target.parentNode);\n\n            e = target;\n            _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n            _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n\n            while (e && !isRoot) {\n              //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.\n              isRoot = _isRoot(e.parentNode);\n              parent = isRoot ? _windowProxy : e.parentNode;\n\n              if (allowY && parent.scrollTop > parent._gsMaxScrollY) {\n                parent.scrollTop = parent._gsMaxScrollY;\n              }\n\n              if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {\n                parent.scrollLeft = parent._gsMaxScrollX;\n              }\n\n              e = parent;\n            }\n          }\n        }\n\n        if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {\n          animate(vars.inertia || vars.throwProps, forceZeroVelocity);\n        }\n      }\n\n      return self;\n    };\n\n    _this2.update = function (applyBounds, sticky, ignoreExternalChanges) {\n      if (sticky && self.isPressed) {\n        // in case the element was repositioned in the document flow, thus its x/y may be identical but its position is actually quite different.\n        var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target),\n            p = innerMatrix.apply({\n          x: self.x - startElementX,\n          y: self.y - startElementY\n        }),\n            m2 = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);\n        m2.apply({\n          x: m.e - p.x,\n          y: m.f - p.y\n        }, p);\n        self.x -= p.x - m2.e;\n        self.y -= p.y - m2.f;\n        render(true);\n        recordStartPositions();\n      }\n\n      var x = self.x,\n          y = self.y;\n      updateMatrix(!sticky);\n\n      if (applyBounds) {\n        self.applyBounds();\n      } else {\n        dirty && ignoreExternalChanges && render(true);\n        syncXY(true);\n      }\n\n      if (sticky) {\n        setPointerPosition(self.pointerX, self.pointerY);\n        dirty && render(true);\n      }\n\n      if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {\n        recordStartPositions();\n      }\n\n      if (self.autoScroll) {\n        _recordMaxScrolls(target.parentNode, self.isDragging);\n\n        checkAutoScrollBounds = self.isDragging;\n        render(true); //in case reparenting occurred.\n\n        _removeScrollListener(target, updateScroll);\n\n        _addScrollListener(target, updateScroll);\n      }\n\n      return self;\n    };\n\n    _this2.enable = function (type) {\n      var setVars = {\n        lazy: true\n      },\n          id,\n          i,\n          trigger;\n\n      if (vars.cursor !== false) {\n        setVars.cursor = vars.cursor || _defaultCursor;\n      }\n\n      if (gsap.utils.checkPrefix(\"touchCallout\")) {\n        setVars.touchCallout = \"none\";\n      }\n\n      if (type !== \"soft\") {\n        _setTouchActionForAllDescendants(triggers, allowX === allowY ? \"none\" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? \"manipulation\" : allowX ? \"pan-y\" : \"pan-x\"); // Some browsers like Internet Explorer will fire a pointercancel event when the user attempts to drag when touchAction is \"manipulate\" because it's perceived as a pan. If the element has scrollable content in only one direction, we should use pan-x or pan-y accordingly so that the pointercancel doesn't prevent dragging.\n\n\n        i = triggers.length;\n\n        while (--i > -1) {\n          trigger = triggers[i];\n          _supportsPointer || _addListener(trigger, \"mousedown\", onPress);\n\n          _addListener(trigger, \"touchstart\", onPress);\n\n          _addListener(trigger, \"click\", onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.\n\n\n          gsap.set(trigger, setVars);\n\n          if (trigger.getBBox && trigger.ownerSVGElement) {\n            // a bug in chrome doesn't respect touch-action on SVG elements - it only works if we set it on the parent SVG.\n            gsap.set(trigger.ownerSVGElement, {\n              touchAction: allowX === allowY ? \"none\" : vars.allowNativeTouchScrolling || vars.allowEventDefault ? \"manipulation\" : allowX ? \"pan-y\" : \"pan-x\"\n            });\n          }\n\n          vars.allowContextMenu || _addListener(trigger, \"contextmenu\", onContextMenu);\n        }\n\n        _setSelectable(triggers, false);\n      }\n\n      _addScrollListener(target, updateScroll);\n\n      enabled = true;\n\n      if (InertiaPlugin && type !== \"soft\") {\n        InertiaPlugin.track(scrollProxy || target, xyMode ? \"x,y\" : rotationMode ? \"rotation\" : \"top,left\");\n      }\n\n      target._gsDragID = id = \"d\"  _lookupCount;\n      _lookup[id] = self;\n\n      if (scrollProxy) {\n        scrollProxy.enable();\n        scrollProxy.element._gsDragID = id;\n      }\n\n      (vars.bounds || rotationMode) && recordStartPositions();\n      vars.bounds && self.applyBounds();\n      return self;\n    };\n\n    _this2.disable = function (type) {\n      var dragging = self.isDragging,\n          i = triggers.length,\n          trigger;\n\n      while (--i > -1) {\n        _setStyle(triggers[i], \"cursor\", null);\n      }\n\n      if (type !== \"soft\") {\n        _setTouchActionForAllDescendants(triggers, null);\n\n        i = triggers.length;\n\n        while (--i > -1) {\n          trigger = triggers[i];\n\n          _setStyle(trigger, \"touchCallout\", null);\n\n          _removeListener(trigger, \"mousedown\", onPress);\n\n          _removeListener(trigger, \"touchstart\", onPress);\n\n          _removeListener(trigger, \"click\", onClick);\n\n          _removeListener(trigger, \"contextmenu\", onContextMenu);\n        }\n\n        _setSelectable(triggers, true);\n\n        if (touchEventTarget) {\n          _removeListener(touchEventTarget, \"touchcancel\", onRelease);\n\n          _removeListener(touchEventTarget, \"touchend\", onRelease);\n\n          _removeListener(touchEventTarget, \"touchmove\", onMove);\n        }\n\n        _removeListener(ownerDoc, \"mouseup\", onRelease);\n\n        _removeListener(ownerDoc, \"mousemove\", onMove);\n      }\n\n      _removeScrollListener(target, updateScroll);\n\n      enabled = false;\n      InertiaPlugin && type !== \"soft\" && InertiaPlugin.untrack(scrollProxy || target, xyMode ? \"x,y\" : rotationMode ? \"rotation\" : \"top,left\");\n      scrollProxy && scrollProxy.disable();\n\n      _removeFromRenderQueue(render);\n\n      self.isDragging = self.isPressed = isClicking = false;\n      dragging && _dispatchEvent(self, \"dragend\", \"onDragEnd\");\n      return self;\n    };\n\n    _this2.enabled = function (value, type) {\n      return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;\n    };\n\n    _this2.kill = function () {\n      self.isThrowing = false;\n      self.tween && self.tween.kill();\n      self.disable();\n      gsap.set(triggers, {\n        clearProps: \"userSelect\"\n      });\n      delete _lookup[target._gsDragID];\n      return self;\n    };\n\n    if (~type.indexOf(\"scroll\")) {\n      scrollProxy = _this2.scrollProxy = new ScrollProxy(target, _extend({\n        onKill: function onKill() {\n          //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the \"mouseup\" properly when users drag the scrollbar of an element, so this works around that issue.\n          self.isPressed && onRelease(null);\n        }\n      }, vars)); //a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to \"hidden\" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)\n\n      target.style.overflowY = allowY && !_isTouchDevice ? \"auto\" : \"hidden\";\n      target.style.overflowX = allowX && !_isTouchDevice ? \"auto\" : \"hidden\";\n      target = scrollProxy.content;\n    }\n\n    if (rotationMode) {\n      killProps.rotation = 1;\n    } else {\n      if (allowX) {\n        killProps[xProp] = 1;\n      }\n\n      if (allowY) {\n        killProps[yProp] = 1;\n      }\n    }\n\n    gsCache.force3D = \"force3D\" in vars ? vars.force3D : true; //otherwise, normal dragging would be in 2D and then as soon as it's released and there's an inertia tween, it'd jump to 3D which can create an initial jump due to the work the browser must to do layerize it.\n\n    _this2.enable();\n\n    return _this2;\n  }\n\n  Draggable.register = function register(core) {\n    gsap = core;\n\n    _initCore();\n  };\n\n  Draggable.create = function create(targets, vars) {\n    _coreInitted || _initCore(true);\n    return _toArray(targets).map(function (target) {\n      return new Draggable(target, vars);\n    });\n  };\n\n  Draggable.get = function get(target) {\n    return _lookup[(_toArray(target)[0] || {})._gsDragID];\n  };\n\n  Draggable.timeSinceDrag = function timeSinceDrag() {\n    return (_getTime() - _lastDragTime) / 1000;\n  };\n\n  Draggable.hitTest = function hitTest(obj1, obj2, threshold) {\n    if (obj1 === obj2) {\n      return false;\n    }\n\n    var r1 = _parseRect(obj1),\n        r2 = _parseRect(obj2),\n        top = r1.top,\n        left = r1.left,\n        right = r1.right,\n        bottom = r1.bottom,\n        width = r1.width,\n        height = r1.height,\n        isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top,\n        overlap,\n        area,\n        isRatio;\n\n    if (isOutside || !threshold) {\n      return !isOutside;\n    }\n\n    isRatio = (threshold  \"\").indexOf(\"%\") !== -1;\n    threshold = parseFloat(threshold) || 0;\n    overlap = {\n      left: Math.max(left, r2.left),\n      top: Math.max(top, r2.top)\n    };\n    overlap.width = Math.min(right, r2.right) - overlap.left;\n    overlap.height = Math.min(bottom, r2.bottom) - overlap.top;\n\n    if (overlap.width < 0 || overlap.height < 0) {\n      return false;\n    }\n\n    if (isRatio) {\n      threshold *= 0.01;\n      area = overlap.width * overlap.height;\n      return area >= width * height * threshold || area >= r2.width * r2.height * threshold;\n    }\n\n    return overlap.width > threshold && overlap.height > threshold;\n  };\n\n  return Draggable;\n}(EventDispatcher);\n\n_setDefaults(Draggable.prototype, {\n  pointerX: 0,\n  pointerY: 0,\n  startX: 0,\n  startY: 0,\n  deltaX: 0,\n  deltaY: 0,\n  isDragging: false,\n  isPressed: false\n});\n\nDraggable.zIndex = 1000;\nDraggable.version = \"3.10.4\";\n_getGSAP() && gsap.registerPlugin(Draggable);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9EcmFnZ2FibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLGdEQUFnRCwwREFBMEQsMkNBQTJDOztBQUVySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDBKQUEwSjs7QUFFMUosaURBQWlEO0FBQ2pELENBQUM7QUFDRDtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFRO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ04sQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsNERBQTREO0FBQzVELENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLCtHQUErRztBQUMvRyxDQUFDO0FBQ0Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZEQUE2RCwrRUFBK0UseUNBQXlDLElBQUk7O0FBRXpMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUEseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQWU7O0FBRTlCLHNFQUFzRSxzREFBUTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUVBQWU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxpRUFBZTtBQUNoRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhGQUE4Rjs7QUFFOUY7O0FBRUEsNkRBQTZEOzs7QUFHN0Q7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUEscURBQXFEOztBQUVyRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVFQUF1RTtBQUN2RTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDs7O0FBR3JEOztBQUVBOztBQUVBLHdDQUF3Qzs7O0FBR3hDO0FBQ0E7QUFDQTs7QUFFQSx5TkFBeU47O0FBRXpOOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWlFOztBQUVqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrQkFBK0I7QUFDL0IsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDOzs7QUFHakMsK0NBQStDOztBQUUvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQSxPQUFPLFNBQVM7O0FBRWhCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdHQUFnRzs7O0FBR2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRTs7QUFFckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEOztBQUV4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxv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OztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sVUFBVTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQStEOztBQUUvRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2dzYXAvRHJhZ2dhYmxlLmpzP2RhZmIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiFcbiAqIERyYWdnYWJsZSAzLjEwLjRcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjIsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4LCBNYXRyaXgyRCB9IGZyb20gXCIuL3V0aWxzL21hdHJpeC5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX2JvZHksXG4gICAgX3RlbXBEaXYsXG4gICAgX3BsYWNlaG9sZGVyRGl2LFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfY2hlY2tQcmVmaXgsXG4gICAgX3RvQXJyYXksXG4gICAgX3N1cHBvcnRzUGFzc2l2ZSxcbiAgICBfaXNUb3VjaERldmljZSxcbiAgICBfdG91Y2hFdmVudExvb2t1cCxcbiAgICBfZHJhZ0NvdW50LFxuICAgIF9pc011bHRpVG91Y2hpbmcsXG4gICAgX2lzQW5kcm9pZCxcbiAgICBJbmVydGlhUGx1Z2luLFxuICAgIF9kZWZhdWx0Q3Vyc29yLFxuICAgIF9zdXBwb3J0c1BvaW50ZXIsXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzT2JqZWN0ID0gZnVuY3Rpb24gX2lzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59LFxuICAgIF9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIF9pc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYygpIHtcbiAgcmV0dXJuIGZhbHNlO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgIF9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwKSAvIDEwMDAwO1xufSxcbiAgICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCh0eXBlLCBucykge1xuICB2YXIgZSA9IF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMoKG5zIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKS5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgc2VydmVycyBzd2FwIGluIGh0dHBzIGZvciBodHRwIGluIHRoZSBuYW1lc3BhY2Ugd2hpY2ggY2FuIGJyZWFrIHRoaW5ncywgbWFraW5nIFwic3R5bGVcIiBpbmFjY2Vzc2libGUuXG5cbiAgcmV0dXJuIGUuc3R5bGUgPyBlIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgZW52aXJvbm1lbnRzIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHdoZW4gY3JlYXRlZCB3aXRoIGEgbmFtZXNwYWNlIGluIHdoaWNoIGNhc2Ugd2UgZGVmYXVsdCB0byB0aGUgc3RhbmRhcmQgY3JlYXRlRWxlbWVudCgpIHRvIHdvcmsgYXJvdW5kIHRoZSBpc3N1ZS4gQWxzbyBub3RlIHRoYXQgd2hlbiBHU0FQIGlzIGVtYmVkZGVkIGRpcmVjdGx5IGluc2lkZSBhbiBTVkcgZmlsZSwgY3JlYXRlRWxlbWVudCgpIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgc3R5bGUgb2JqZWN0IGluIEZpcmVmb3ggKHNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIwMjE1LXByb2JsZW0tdXNpbmctdHdlZW5tYXgtaW4tc3RhbmRhbG9uZS1zZWxmLWNvbnRhaW5pbmctc3ZnLWZpbGUtZXJyLWNhbm5vdC1zZXQtcHJvcGVydHktY3NzdGV4dC1vZi11bmRlZmluZWQvKS5cbn0sXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9iaWdOdW0gPSAxZTIwLFxuICAgIF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgyRCgpLFxuICAgIF9nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59LFxuICAgIF9yZW5kZXJRdWV1ZSA9IFtdLFxuICAgIF9sb29rdXAgPSB7fSxcbiAgICAvL3doZW4gYSBEcmFnZ2FibGUgaXMgY3JlYXRlZCwgdGhlIHRhcmdldCBnZXRzIGEgdW5pcXVlIF9nc0RyYWdJRCBwcm9wZXJ0eSB0aGF0IGFsbG93cyBnZXRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgRHJhZ2dhYmxlIGluc3RhbmNlIGZvciBxdWljayBsb29rdXBzIGluIERyYWdnYWJsZS5nZXQoKS4gVGhpcyBhdm9pZHMgY2lyY3VsYXIgcmVmZXJlbmNlcyB0aGF0IGNvdWxkIGNhdXNlIGdjIHByb2JsZW1zLlxuX2xvb2t1cENvdW50ID0gMCxcbiAgICBfY2xpY2thYmxlVGFnRXhwID0gL14oPzphfGlucHV0fHRleHRhcmVhfGJ1dHRvbnxzZWxlY3QpJC9pLFxuICAgIF9sYXN0RHJhZ1RpbWUgPSAwLFxuICAgIF90ZW1wMSA9IHt9LFxuICAgIC8vIGEgc2ltcGxlIG9iamVjdCB3ZSByZXVzZSBhbmQgcG9wdWxhdGUgKHVzdWFsbHkgeC95IHByb3BlcnRpZXMpIHRvIGNvbnNlcnZlIG1lbW9yeSBhbmQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbl93aW5kb3dQcm94eSA9IHt9LFxuICAgIC8vbWVtb3J5L3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAtIHdlIHJldXNlIHRoaXMgb2JqZWN0IGR1cmluZyBhdXRvU2Nyb2xsIHRvIHN0b3JlIHdpbmRvdy1yZWxhdGVkIGJvdW5kcy9vZmZzZXRzLlxuX2NvcHkgPSBmdW5jdGlvbiBfY29weShvYmosIGZhY3Rvcikge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgY29weVtwXSA9IGZhY3RvciA/IG9ialtwXSAqIGZhY3RvciA6IG9ialtwXTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfZXh0ZW5kID0gZnVuY3Rpb24gX2V4dGVuZChvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoIShwIGluIG9iaikpIHtcbiAgICAgIG9ialtwXSA9IGRlZmF1bHRzW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzID0gZnVuY3Rpb24gX3NldFRvdWNoQWN0aW9uRm9yQWxsRGVzY2VuZGFudHMoZWxlbWVudHMsIHZhbHVlKSB7XG4gIHZhciBpID0gZWxlbWVudHMubGVuZ3RoLFxuICAgICAgY2hpbGRyZW47XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHZhbHVlID8gZWxlbWVudHNbaV0uc3R5bGUudG91Y2hBY3Rpb24gPSB2YWx1ZSA6IGVsZW1lbnRzW2ldLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidG91Y2gtYWN0aW9uXCIpO1xuICAgIGNoaWxkcmVuID0gZWxlbWVudHNbaV0uY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoICYmIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKGNoaWxkcmVuLCB2YWx1ZSk7XG4gIH1cbn0sXG4gICAgX3JlbmRlclF1ZXVlVGljayA9IGZ1bmN0aW9uIF9yZW5kZXJRdWV1ZVRpY2soKSB7XG4gIHJldHVybiBfcmVuZGVyUXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jKCk7XG4gIH0pO1xufSxcbiAgICBfYWRkVG9SZW5kZXJRdWV1ZSA9IGZ1bmN0aW9uIF9hZGRUb1JlbmRlclF1ZXVlKGZ1bmMpIHtcbiAgX3JlbmRlclF1ZXVlLnB1c2goZnVuYyk7XG5cbiAgaWYgKF9yZW5kZXJRdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICBnc2FwLnRpY2tlci5hZGQoX3JlbmRlclF1ZXVlVGljayk7XG4gIH1cbn0sXG4gICAgX3JlbmRlclF1ZXVlVGltZW91dCA9IGZ1bmN0aW9uIF9yZW5kZXJRdWV1ZVRpbWVvdXQoKSB7XG4gIHJldHVybiAhX3JlbmRlclF1ZXVlLmxlbmd0aCAmJiBnc2FwLnRpY2tlci5yZW1vdmUoX3JlbmRlclF1ZXVlVGljayk7XG59LFxuICAgIF9yZW1vdmVGcm9tUmVuZGVyUXVldWUgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKGZ1bmMpIHtcbiAgdmFyIGkgPSBfcmVuZGVyUXVldWUubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoX3JlbmRlclF1ZXVlW2ldID09PSBmdW5jKSB7XG4gICAgICBfcmVuZGVyUXVldWUuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuXG4gIGdzYXAudG8oX3JlbmRlclF1ZXVlVGltZW91dCwge1xuICAgIG92ZXJ3cml0ZTogdHJ1ZSxcbiAgICBkZWxheTogMTUsXG4gICAgZHVyYXRpb246IDAsXG4gICAgb25Db21wbGV0ZTogX3JlbmRlclF1ZXVlVGltZW91dCxcbiAgICBkYXRhOiBcIl9kcmFnZ2FibGVcIlxuICB9KTsgLy9yZW1vdmUgdGhlIFwidGlja1wiIGxpc3RlbmVyIG9ubHkgYWZ0ZXIgdGhlIHJlbmRlciBxdWV1ZSBpcyBlbXB0eSBmb3IgMTUgc2Vjb25kcyAodG8gaW1wcm92ZSBwZXJmb3JtYW5jZSkuIEFkZGluZy9yZW1vdmluZyBpdCBjb25zdGFudGx5IGZvciBldmVyeSBjbGljay90b3VjaCB3b3VsZG4ndCBkZWxpdmVyIG9wdGltYWwgc3BlZWQsIGFuZCB3ZSBhbHNvIGRvbid0IHdhbnQgdGhlIHRpY2tlciB0byBrZWVwIGNhbGxpbmcgdGhlIHJlbmRlciBtZXRob2Qgd2hlbiB0aGluZ3MgYXJlIGlkbGUgZm9yIGxvbmcgcGVyaW9kcyBvZiB0aW1lICh3ZSB3YW50IHRvIGltcHJvdmUgYmF0dGVyeSBsaWZlIG9uIG1vYmlsZSBkZXZpY2VzKS5cbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIGlmICghKHAgaW4gb2JqKSkge1xuICAgICAgb2JqW3BdID0gZGVmYXVsdHNbcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHZhciB0b3VjaFR5cGUgPSBfdG91Y2hFdmVudExvb2t1cFt0eXBlXTtcbiAgICBjYXB0dXJlID0gY2FwdHVyZSB8fCAoX3N1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSA6IG51bGwpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaFR5cGUgfHwgdHlwZSwgZnVuYywgY2FwdHVyZSk7XG4gICAgdG91Y2hUeXBlICYmIHR5cGUgIT09IHRvdWNoVHlwZSAmJiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywgY2FwdHVyZSk7IC8vc29tZSBicm93c2VycyBhY3R1YWxseSBzdXBwb3J0IGJvdGgsIHNvIG11c3Qgd2UuIEJ1dCBwb2ludGVyIGV2ZW50cyBjb3ZlciBhbGwuXG4gIH1cbn0sXG4gICAgX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMpIHtcbiAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIHZhciB0b3VjaFR5cGUgPSBfdG91Y2hFdmVudExvb2t1cFt0eXBlXTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hUeXBlIHx8IHR5cGUsIGZ1bmMpO1xuICAgIHRvdWNoVHlwZSAmJiB0eXBlICE9PSB0b3VjaFR5cGUgJiYgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMpO1xuICB9XG59LFxuICAgIF9wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIF9wcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uICYmIGV2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24oKTsgLy9mb3Igc29tZSBNaWNyb3NvZnQgYnJvd3NlcnNcbn0sXG4gICAgX2hhc1RvdWNoSUQgPSBmdW5jdGlvbiBfaGFzVG91Y2hJRChsaXN0LCBJRCkge1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAobGlzdFtpXS5pZGVudGlmaWVyID09PSBJRCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59LFxuICAgIF9vbk11bHRpVG91Y2hEb2N1bWVudEVuZCA9IGZ1bmN0aW9uIF9vbk11bHRpVG91Y2hEb2N1bWVudEVuZChldmVudCkge1xuICBfaXNNdWx0aVRvdWNoaW5nID0gZXZlbnQudG91Y2hlcyAmJiBfZHJhZ0NvdW50IDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7XG5cbiAgX3JlbW92ZUxpc3RlbmVyKGV2ZW50LnRhcmdldCwgXCJ0b3VjaGVuZFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQpO1xufSxcbiAgICBfb25NdWx0aVRvdWNoRG9jdW1lbnQgPSBmdW5jdGlvbiBfb25NdWx0aVRvdWNoRG9jdW1lbnQoZXZlbnQpIHtcbiAgX2lzTXVsdGlUb3VjaGluZyA9IGV2ZW50LnRvdWNoZXMgJiYgX2RyYWdDb3VudCA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoO1xuXG4gIF9hZGRMaXN0ZW5lcihldmVudC50YXJnZXQsIFwidG91Y2hlbmRcIiwgX29uTXVsdGlUb3VjaERvY3VtZW50RW5kKTtcbn0sXG4gICAgX2dldERvY1Njcm9sbFRvcCA9IGZ1bmN0aW9uIF9nZXREb2NTY3JvbGxUb3AoZG9jKSB7XG4gIHJldHVybiBfd2luLnBhZ2VZT2Zmc2V0IHx8IGRvYy5zY3JvbGxUb3AgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jLmJvZHkuc2Nyb2xsVG9wIHx8IDA7XG59LFxuICAgIF9nZXREb2NTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbExlZnQoZG9jKSB7XG4gIHJldHVybiBfd2luLnBhZ2VYT2Zmc2V0IHx8IGRvYy5zY3JvbGxMZWZ0IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2MuYm9keS5zY3JvbGxMZWZ0IHx8IDA7XG59LFxuICAgIF9hZGRTY3JvbGxMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRTY3JvbGxMaXN0ZW5lcihlLCBjYWxsYmFjaykge1xuICBfYWRkTGlzdGVuZXIoZSwgXCJzY3JvbGxcIiwgY2FsbGJhY2spO1xuXG4gIGlmICghX2lzUm9vdChlLnBhcmVudE5vZGUpKSB7XG4gICAgX2FkZFNjcm9sbExpc3RlbmVyKGUucGFyZW50Tm9kZSwgY2FsbGJhY2spO1xuICB9XG59LFxuICAgIF9yZW1vdmVTY3JvbGxMaXN0ZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVTY3JvbGxMaXN0ZW5lcihlLCBjYWxsYmFjaykge1xuICBfcmVtb3ZlTGlzdGVuZXIoZSwgXCJzY3JvbGxcIiwgY2FsbGJhY2spO1xuXG4gIGlmICghX2lzUm9vdChlLnBhcmVudE5vZGUpKSB7XG4gICAgX3JlbW92ZVNjcm9sbExpc3RlbmVyKGUucGFyZW50Tm9kZSwgY2FsbGJhY2spO1xuICB9XG59LFxuICAgIF9pc1Jvb3QgPSBmdW5jdGlvbiBfaXNSb290KGUpIHtcbiAgcmV0dXJuICEhKCFlIHx8IGUgPT09IF9kb2NFbGVtZW50IHx8IGUubm9kZVR5cGUgPT09IDkgfHwgZSA9PT0gX2RvYy5ib2R5IHx8IGUgPT09IF93aW4gfHwgIWUubm9kZVR5cGUgfHwgIWUucGFyZW50Tm9kZSk7XG59LFxuICAgIF9nZXRNYXhTY3JvbGwgPSBmdW5jdGlvbiBfZ2V0TWF4U2Nyb2xsKGVsZW1lbnQsIGF4aXMpIHtcbiAgdmFyIGRpbSA9IGF4aXMgPT09IFwieFwiID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIixcbiAgICAgIHNjcm9sbCA9IFwic2Nyb2xsXCIgKyBkaW0sXG4gICAgICBjbGllbnQgPSBcImNsaWVudFwiICsgZGltO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgX2lzUm9vdChlbGVtZW50KSA/IE1hdGgubWF4KF9kb2NFbGVtZW50W3Njcm9sbF0sIF9ib2R5W3Njcm9sbF0pIC0gKF93aW5bXCJpbm5lclwiICsgZGltXSB8fCBfZG9jRWxlbWVudFtjbGllbnRdIHx8IF9ib2R5W2NsaWVudF0pIDogZWxlbWVudFtzY3JvbGxdIC0gZWxlbWVudFtjbGllbnRdKTtcbn0sXG4gICAgX3JlY29yZE1heFNjcm9sbHMgPSBmdW5jdGlvbiBfcmVjb3JkTWF4U2Nyb2xscyhlLCBza2lwQ3VycmVudCkge1xuICAvL3JlY29yZHMgX2dzTWF4U2Nyb2xsWCBhbmQgX2dzTWF4U2Nyb2xsWSBwcm9wZXJ0aWVzIGZvciB0aGUgZWxlbWVudCBhbmQgYWxsIGFuY2VzdG9ycyB1cCB0aGUgY2hhaW4gc28gdGhhdCB3ZSBjYW4gY2FwIGl0LCBvdGhlcndpc2UgZHJhZ2dpbmcgYmV5b25kIHRoZSBlZGdlcyB3aXRoIGF1dG9TY3JvbGwgb24gY2FuIGVuZGxlc3NseSBzY3JvbGwuXG4gIHZhciB4ID0gX2dldE1heFNjcm9sbChlLCBcInhcIiksXG4gICAgICB5ID0gX2dldE1heFNjcm9sbChlLCBcInlcIik7XG5cbiAgaWYgKF9pc1Jvb3QoZSkpIHtcbiAgICBlID0gX3dpbmRvd1Byb3h5O1xuICB9IGVsc2Uge1xuICAgIF9yZWNvcmRNYXhTY3JvbGxzKGUucGFyZW50Tm9kZSwgc2tpcEN1cnJlbnQpO1xuICB9XG5cbiAgZS5fZ3NNYXhTY3JvbGxYID0geDtcbiAgZS5fZ3NNYXhTY3JvbGxZID0geTtcblxuICBpZiAoIXNraXBDdXJyZW50KSB7XG4gICAgZS5fZ3NTY3JvbGxYID0gZS5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgZS5fZ3NTY3JvbGxZID0gZS5zY3JvbGxUb3AgfHwgMDtcbiAgfVxufSxcbiAgICBfc2V0U3R5bGUgPSBmdW5jdGlvbiBfc2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cbiAgaWYgKCFzdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChfaXNVbmRlZmluZWQoc3R5bGVbcHJvcGVydHldKSkge1xuICAgIHByb3BlcnR5ID0gX2NoZWNrUHJlZml4KHByb3BlcnR5LCBlbGVtZW50KSB8fCBwcm9wZXJ0eTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkgJiYgc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfVxufSxcbiAgICBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCA/IGVsZW1lbnQgOiBlbGVtZW50Lmhvc3QgfHwgKGVsZW1lbnQucGFyZW50Tm9kZSB8fCB7fSkuaG9zdCB8fCBlbGVtZW50KTtcbn0sXG4gICAgLy90aGUgXCJob3N0XCIgc3R1ZmYgaGVscHMgdG8gYWNjb21tb2RhdGUgU2hhZG93RG9tIG9iamVjdHMuXG5fdGVtcFJlY3QgPSB7fSxcbiAgICAvL3JldXNlIHRvIHJlZHVjZSBnYXJiYWdlIGNvbGxlY3Rpb24gdGFza3Ncbl9wYXJzZVJlY3QgPSBmdW5jdGlvbiBfcGFyc2VSZWN0KGUpIHtcbiAgLy9hY2NlcHRzIGEgRE9NIGVsZW1lbnQsIGEgbW91c2UgZXZlbnQsIG9yIGEgcmVjdGFuZ2xlIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZWN0YW5nbGUgd2l0aCBsZWZ0LCByaWdodCwgd2lkdGgsIGhlaWdodCwgdG9wLCBhbmQgYm90dG9tIHByb3BlcnRpZXNcbiAgaWYgKGUgPT09IF93aW4pIHtcbiAgICBfdGVtcFJlY3QubGVmdCA9IF90ZW1wUmVjdC50b3AgPSAwO1xuICAgIF90ZW1wUmVjdC53aWR0aCA9IF90ZW1wUmVjdC5yaWdodCA9IF9kb2NFbGVtZW50LmNsaWVudFdpZHRoIHx8IGUuaW5uZXJXaWR0aCB8fCBfYm9keS5jbGllbnRXaWR0aCB8fCAwO1xuICAgIF90ZW1wUmVjdC5oZWlnaHQgPSBfdGVtcFJlY3QuYm90dG9tID0gKGUuaW5uZXJIZWlnaHQgfHwgMCkgLSAyMCA8IF9kb2NFbGVtZW50LmNsaWVudEhlaWdodCA/IF9kb2NFbGVtZW50LmNsaWVudEhlaWdodCA6IGUuaW5uZXJIZWlnaHQgfHwgX2JvZHkuY2xpZW50SGVpZ2h0IHx8IDA7XG4gICAgcmV0dXJuIF90ZW1wUmVjdDtcbiAgfVxuXG4gIHZhciBkb2MgPSBlLm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcbiAgICAgIHIgPSAhX2lzVW5kZWZpbmVkKGUucGFnZVgpID8ge1xuICAgIGxlZnQ6IGUucGFnZVggLSBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpLFxuICAgIHRvcDogZS5wYWdlWSAtIF9nZXREb2NTY3JvbGxUb3AoZG9jKSxcbiAgICByaWdodDogZS5wYWdlWCAtIF9nZXREb2NTY3JvbGxMZWZ0KGRvYykgKyAxLFxuICAgIGJvdHRvbTogZS5wYWdlWSAtIF9nZXREb2NTY3JvbGxUb3AoZG9jKSArIDFcbiAgfSA6ICFlLm5vZGVUeXBlICYmICFfaXNVbmRlZmluZWQoZS5sZWZ0KSAmJiAhX2lzVW5kZWZpbmVkKGUudG9wKSA/IGUgOiBfdG9BcnJheShlKVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICBpZiAoX2lzVW5kZWZpbmVkKHIucmlnaHQpICYmICFfaXNVbmRlZmluZWQoci53aWR0aCkpIHtcbiAgICByLnJpZ2h0ID0gci5sZWZ0ICsgci53aWR0aDtcbiAgICByLmJvdHRvbSA9IHIudG9wICsgci5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAoX2lzVW5kZWZpbmVkKHIud2lkdGgpKSB7XG4gICAgLy9zb21lIGJyb3dzZXJzIGRvbid0IGluY2x1ZGUgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzLiBXZSBjYW4ndCBqdXN0IHNldCB0aGVtIGRpcmVjdGx5IG9uIHIgYmVjYXVzZSBzb21lIGJyb3dzZXJzIHRocm93IGVycm9ycywgc28gY3JlYXRlIGEgbmV3IGdlbmVyaWMgb2JqZWN0LlxuICAgIHIgPSB7XG4gICAgICB3aWR0aDogci5yaWdodCAtIHIubGVmdCxcbiAgICAgIGhlaWdodDogci5ib3R0b20gLSByLnRvcCxcbiAgICAgIHJpZ2h0OiByLnJpZ2h0LFxuICAgICAgbGVmdDogci5sZWZ0LFxuICAgICAgYm90dG9tOiByLmJvdHRvbSxcbiAgICAgIHRvcDogci50b3BcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHI7XG59LFxuICAgIF9kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gX2Rpc3BhdGNoRXZlbnQodGFyZ2V0LCB0eXBlLCBjYWxsYmFja05hbWUpIHtcbiAgdmFyIHZhcnMgPSB0YXJnZXQudmFycyxcbiAgICAgIGNhbGxiYWNrID0gdmFyc1tjYWxsYmFja05hbWVdLFxuICAgICAgbGlzdGVuZXJzID0gdGFyZ2V0Ll9saXN0ZW5lcnNbdHlwZV0sXG4gICAgICByZXN1bHQ7XG5cbiAgaWYgKF9pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgIHJlc3VsdCA9IGNhbGxiYWNrLmFwcGx5KHZhcnMuY2FsbGJhY2tTY29wZSB8fCB0YXJnZXQsIHZhcnNbY2FsbGJhY2tOYW1lICsgXCJQYXJhbXNcIl0gfHwgW3RhcmdldC5wb2ludGVyRXZlbnRdKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMgJiYgdGFyZ2V0LmRpc3BhdGNoRXZlbnQodHlwZSkgPT09IGZhbHNlKSB7XG4gICAgcmVzdWx0ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfZ2V0Qm91bmRzID0gZnVuY3Rpb24gX2dldEJvdW5kcyh0YXJnZXQsIGNvbnRleHQpIHtcbiAgLy9hY2NlcHRzIGFueSBvZiB0aGUgZm9sbG93aW5nOiBhIERPTSBlbGVtZW50LCBqUXVlcnkgb2JqZWN0LCBzZWxlY3RvciB0ZXh0LCBvciBhbiBvYmplY3QgZGVmaW5pbmcgYm91bmRzIGFzIHt0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHR9IG9yIHttaW5YLCBtYXhYLCBtaW5ZLCBtYXhZfS4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBhbmQgaGVpZ2h0IHByb3BlcnRpZXMuXG4gIHZhciBlID0gX3RvQXJyYXkodGFyZ2V0KVswXSxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBvZmZzZXQ7XG5cbiAgaWYgKCFlLm5vZGVUeXBlICYmIGUgIT09IF93aW4pIHtcbiAgICBpZiAoIV9pc1VuZGVmaW5lZCh0YXJnZXQubGVmdCkpIHtcbiAgICAgIG9mZnNldCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTsgLy9fZ2V0T2Zmc2V0VHJhbnNmb3JtT3JpZ2luKGNvbnRleHQpOyAvL3RoZSBib3VuZHMgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogdGFyZ2V0LmxlZnQgLSBvZmZzZXQueCxcbiAgICAgICAgdG9wOiB0YXJnZXQudG9wIC0gb2Zmc2V0LnksXG4gICAgICAgIHdpZHRoOiB0YXJnZXQud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGFyZ2V0LmhlaWdodFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZWZ0ID0gdGFyZ2V0Lm1pbiB8fCB0YXJnZXQubWluWCB8fCB0YXJnZXQubWluUm90YXRpb24gfHwgMDtcbiAgICB0b3AgPSB0YXJnZXQubWluIHx8IHRhcmdldC5taW5ZIHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHdpZHRoOiAodGFyZ2V0Lm1heCB8fCB0YXJnZXQubWF4WCB8fCB0YXJnZXQubWF4Um90YXRpb24gfHwgMCkgLSBsZWZ0LFxuICAgICAgaGVpZ2h0OiAodGFyZ2V0Lm1heCB8fCB0YXJnZXQubWF4WSB8fCAwKSAtIHRvcFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldEVsZW1lbnRCb3VuZHMoZSwgY29udGV4dCk7XG59LFxuICAgIF9wb2ludDEgPSB7fSxcbiAgICAvL3dlIHJldXNlIHRvIG1pbmltaXplIGdhcmJhZ2UgY29sbGVjdGlvbiB0YXNrcy5cbl9nZXRFbGVtZW50Qm91bmRzID0gZnVuY3Rpb24gX2dldEVsZW1lbnRCb3VuZHMoZWxlbWVudCwgY29udGV4dCkge1xuICBjb250ZXh0ID0gX3RvQXJyYXkoY29udGV4dClbMF07XG4gIHZhciBpc1NWRyA9IGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCxcbiAgICAgIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBfZG9jLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgYm90dG9tLFxuICAgICAgbWF0cml4LFxuICAgICAgcDEsXG4gICAgICBwMixcbiAgICAgIHAzLFxuICAgICAgcDQsXG4gICAgICBiYm94LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBjcyxcbiAgICAgIGNvbnRleHRQYXJlbnQ7XG5cbiAgaWYgKGVsZW1lbnQgPT09IF93aW4pIHtcbiAgICB0b3AgPSBfZ2V0RG9jU2Nyb2xsVG9wKGRvYyk7XG4gICAgbGVmdCA9IF9nZXREb2NTY3JvbGxMZWZ0KGRvYyk7XG4gICAgcmlnaHQgPSBsZWZ0ICsgKGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZWxlbWVudC5pbm5lcldpZHRoIHx8IGRvYy5ib2R5LmNsaWVudFdpZHRoIHx8IDApO1xuICAgIGJvdHRvbSA9IHRvcCArICgoZWxlbWVudC5pbm5lckhlaWdodCB8fCAwKSAtIDIwIDwgZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgPyBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IGVsZW1lbnQuaW5uZXJIZWlnaHQgfHwgZG9jLmJvZHkuY2xpZW50SGVpZ2h0IHx8IDApOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgaWdub3JlIGFic29sdXRlbHkgcG9zaXRpb25lZCBlbGVtZW50cywgYW5kIGNvbGxhcHNlIHRoZSBoZWlnaHQgb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgc28gaXQgY291bGQgYmUgOHB4LCBmb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUganVzdCBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZGl2LiBJbiB0aGF0IGNhc2UsIHdlIHVzZSB0aGUgaW5uZXJIZWlnaHQgdG8gcmVzb2x2ZSB0aGlzLlxuICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IF93aW4gfHwgX2lzVW5kZWZpbmVkKGNvbnRleHQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IHRvcCA9IDA7XG5cbiAgICBpZiAoaXNTVkcpIHtcbiAgICAgIGJib3ggPSBlbGVtZW50LmdldEJCb3goKTtcbiAgICAgIHdpZHRoID0gYmJveC53aWR0aDtcbiAgICAgIGhlaWdodCA9IGJib3guaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudC52aWV3Qm94ICYmIChiYm94ID0gZWxlbWVudC52aWV3Qm94LmJhc2VWYWwpKSB7XG4gICAgICAgIGxlZnQgPSBiYm94LnggfHwgMDtcbiAgICAgICAgdG9wID0gYmJveC55IHx8IDA7XG4gICAgICAgIHdpZHRoID0gYmJveC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gYmJveC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgICAgYmJveCA9IGNzLmJveFNpemluZyA9PT0gXCJib3JkZXItYm94XCI7XG4gICAgICAgIHdpZHRoID0gKHBhcnNlRmxvYXQoY3Mud2lkdGgpIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCkgKyAoYmJveCA/IDAgOiBwYXJzZUZsb2F0KGNzLmJvcmRlckxlZnRXaWR0aCkgKyBwYXJzZUZsb2F0KGNzLmJvcmRlclJpZ2h0V2lkdGgpKTtcbiAgICAgICAgaGVpZ2h0ID0gKHBhcnNlRmxvYXQoY3MuaGVpZ2h0KSB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCAwKSArIChiYm94ID8gMCA6IHBhcnNlRmxvYXQoY3MuYm9yZGVyVG9wV2lkdGgpICsgcGFyc2VGbG9hdChjcy5ib3JkZXJCb3R0b21XaWR0aCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJpZ2h0ID0gd2lkdGg7XG4gICAgYm90dG9tID0gaGVpZ2h0O1xuICB9XG5cbiAgaWYgKGVsZW1lbnQgPT09IGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wXG4gICAgfTtcbiAgfVxuXG4gIG1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChjb250ZXh0LCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZWxlbWVudCkpO1xuICBwMSA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogbGVmdCxcbiAgICB5OiB0b3BcbiAgfSk7XG4gIHAyID0gbWF0cml4LmFwcGx5KHtcbiAgICB4OiByaWdodCxcbiAgICB5OiB0b3BcbiAgfSk7XG4gIHAzID0gbWF0cml4LmFwcGx5KHtcbiAgICB4OiByaWdodCxcbiAgICB5OiBib3R0b21cbiAgfSk7XG4gIHA0ID0gbWF0cml4LmFwcGx5KHtcbiAgICB4OiBsZWZ0LFxuICAgIHk6IGJvdHRvbVxuICB9KTtcbiAgbGVmdCA9IE1hdGgubWluKHAxLngsIHAyLngsIHAzLngsIHA0LngpO1xuICB0b3AgPSBNYXRoLm1pbihwMS55LCBwMi55LCBwMy55LCBwNC55KTtcbiAgY29udGV4dFBhcmVudCA9IGNvbnRleHQucGFyZW50Tm9kZSB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0ICsgKGNvbnRleHRQYXJlbnQuc2Nyb2xsTGVmdCB8fCAwKSxcbiAgICB0b3A6IHRvcCArIChjb250ZXh0UGFyZW50LnNjcm9sbFRvcCB8fCAwKSxcbiAgICB3aWR0aDogTWF0aC5tYXgocDEueCwgcDIueCwgcDMueCwgcDQueCkgLSBsZWZ0LFxuICAgIGhlaWdodDogTWF0aC5tYXgocDEueSwgcDIueSwgcDMueSwgcDQueSkgLSB0b3BcbiAgfTtcbn0sXG4gICAgX3BhcnNlSW5lcnRpYSA9IGZ1bmN0aW9uIF9wYXJzZUluZXJ0aWEoZHJhZ2dhYmxlLCBzbmFwLCBtYXgsIG1pbiwgZmFjdG9yLCBmb3JjZVplcm9WZWxvY2l0eSkge1xuICB2YXIgdmFycyA9IHt9LFxuICAgICAgYSxcbiAgICAgIGksXG4gICAgICBsO1xuXG4gIGlmIChzbmFwKSB7XG4gICAgaWYgKGZhY3RvciAhPT0gMSAmJiBzbmFwIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIC8vc29tZSBkYXRhIG11c3QgYmUgYWx0ZXJlZCB0byBtYWtlIHNlbnNlLCBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhbiBhcnJheSBvZiByb3RhdGlvbmFsIHZhbHVlcyBpbiBkZWdyZWVzLCB3ZSBtdXN0IGNvbnZlcnQgaXQgdG8gcmFkaWFucy4gT3IgZm9yIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCwgd2UgaW52ZXJ0IHRoZSB2YWx1ZXMuXG4gICAgICB2YXJzLmVuZCA9IGEgPSBbXTtcbiAgICAgIGwgPSBzbmFwLmxlbmd0aDtcblxuICAgICAgaWYgKF9pc09iamVjdChzbmFwWzBdKSkge1xuICAgICAgICAvL2lmIHRoZSBhcnJheSBpcyBwb3B1bGF0ZWQgd2l0aCBvYmplY3RzLCBsaWtlIHBvaW50cyAoe3g6MTAwLCB5OjIwMH0pLCBtYWtlIGNvcGllcyBiZWZvcmUgbXVsdGlwbHlpbmcgYnkgdGhlIGZhY3Rvciwgb3RoZXJ3aXNlIHdlJ2xsIG1lc3MgdXAgdGhlIG9yaWdpbmFscyBhbmQgdGhlIHVzZXIgbWF5IHJldXNlIGl0IGVsc2V3aGVyZS5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFbaV0gPSBfY29weShzbmFwW2ldLCBmYWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgYVtpXSA9IHNuYXBbaV0gKiBmYWN0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF4ICs9IDEuMTsgLy9hbGxvdyAxLjEgcGl4ZWxzIG9mIHdpZ2dsZSByb29tIHdoZW4gc25hcHBpbmcgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgc29tZSBicm93c2VyIGluY29uc2lzdGVuY2llcyBpbiB0aGUgd2F5IGJvdW5kcyBhcmUgcmVwb3J0ZWQgd2hpY2ggY2FuIG1ha2UgdGhlbSByb3VnaGx5IGEgcGl4ZWwgb2ZmLiBGb3IgZXhhbXBsZSwgaWYgXCJzbmFwOlstJCgnI21lbnUnKS53aWR0aCgpLCAwXVwiIHdhcyBkZWZpbmVkIGFuZCAjbWVudSBoYWQgYSB3cmFwcGVyIHRoYXQgd2FzIHVzZWQgYXMgdGhlIGJvdW5kcywgc29tZSBicm93c2VycyB3b3VsZCBiZSBvbmUgcGl4ZWwgb2ZmLCBtYWtpbmcgdGhlIG1pbmltdW0gLTc1MiBmb3IgZXhhbXBsZSB3aGVuIHNuYXAgd2FzIFstNzUzLDBdLCB0aHVzIGluc3RlYWQgb2Ygc25hcHBpbmcgdG8gLTc1MywgaXQgd291bGQgc25hcCB0byAwIHNpbmNlIC03NTMgd2FzIGJlbG93IHRoZSBtaW5pbXVtLlxuXG4gICAgICBtaW4gLT0gMS4xO1xuICAgIH0gZWxzZSBpZiAoX2lzRnVuY3Rpb24oc25hcCkpIHtcbiAgICAgIHZhcnMuZW5kID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzbmFwLmNhbGwoZHJhZ2dhYmxlLCB2YWx1ZSksXG4gICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgcDtcblxuICAgICAgICBpZiAoZmFjdG9yICE9PSAxKSB7XG4gICAgICAgICAgaWYgKF9pc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICAgIGZvciAocCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgY29weVtwXSA9IHJlc3VsdFtwXSAqIGZhY3RvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gY29weTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICo9IGZhY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0OyAvL3dlIG5lZWQgdG8gZW5zdXJlIHRoYXQgd2UgY2FuIHNjb3BlIHRoZSBmdW5jdGlvbiBjYWxsIHRvIHRoZSBEcmFnZ2FibGUgaW5zdGFuY2UgaXRzZWxmIHNvIHRoYXQgdXNlcnMgY2FuIGFjY2VzcyBpbXBvcnRhbnQgdmFsdWVzIGxpa2UgbWF4WCwgbWluWCwgbWF4WSwgbWluWSwgeCwgYW5kIHkgZnJvbSB3aXRoaW4gdGhhdCBmdW5jdGlvbi5cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMuZW5kID0gc25hcDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4IHx8IG1heCA9PT0gMCkge1xuICAgIHZhcnMubWF4ID0gbWF4O1xuICB9XG5cbiAgaWYgKG1pbiB8fCBtaW4gPT09IDApIHtcbiAgICB2YXJzLm1pbiA9IG1pbjtcbiAgfVxuXG4gIGlmIChmb3JjZVplcm9WZWxvY2l0eSkge1xuICAgIHZhcnMudmVsb2NpdHkgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHZhcnM7XG59LFxuICAgIF9pc0NsaWNrYWJsZSA9IGZ1bmN0aW9uIF9pc0NsaWNrYWJsZShlbGVtZW50KSB7XG4gIC8vc29tZXRpbWVzIGl0J3MgY29udmVuaWVudCB0byBtYXJrIGFuIGVsZW1lbnQgYXMgY2xpY2thYmxlIGJ5IGFkZGluZyBhIGRhdGEtY2xpY2thYmxlPVwidHJ1ZVwiIGF0dHJpYnV0ZSAoaW4gd2hpY2ggY2FzZSB3ZSB3b24ndCBwcmV2ZW50RGVmYXVsdCgpIHRoZSBtb3VzZS90b3VjaCBldmVudCkuIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiB0aGUgZWxlbWVudCBpcyBhbiA8YT4sIDxpbnB1dD4sIG9yIDxidXR0b24IG9yIGhhcyBhbiBvbmNsaWNrIG9yIGhhcyB0aGUgZGF0YS1jbGlja2FibGUgb3IgY29udGVudEVkaXRhYmxlIGF0dHJpYnV0ZSBzZXQgdG8gdHJ1ZSAob3IgYW55IG9mIGl0cyBwYXJlbnQgZWxlbWVudHMpLlxuICB2YXIgZGF0YTtcbiAgcmV0dXJuICFlbGVtZW50IHx8ICFlbGVtZW50LmdldEF0dHJpYnV0ZSB8fCBlbGVtZW50ID09PSBfYm9keSA/IGZhbHNlIDogKGRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY2xpY2thYmxlXCIpKSA9PT0gXCJ0cnVlXCIgfHwgZGF0YSAhPT0gXCJmYWxzZVwiICYmIChlbGVtZW50Lm9uY2xpY2sgfHwgX2NsaWNrYWJsZVRhZ0V4cC50ZXN0KGVsZW1lbnQubm9kZU5hbWUgKyBcIlwiKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSA9PT0gXCJ0cnVlXCIpID8gdHJ1ZSA6IF9pc0NsaWNrYWJsZShlbGVtZW50LnBhcmVudE5vZGUpO1xufSxcbiAgICBfc2V0U2VsZWN0YWJsZSA9IGZ1bmN0aW9uIF9zZXRTZWxlY3RhYmxlKGVsZW1lbnRzLCBzZWxlY3RhYmxlKSB7XG4gIHZhciBpID0gZWxlbWVudHMubGVuZ3RoLFxuICAgICAgZTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgZSA9IGVsZW1lbnRzW2ldO1xuICAgIGUub25kcmFnc3RhcnQgPSBlLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gbnVsbCA6IF9lbXB0eUZ1bmM7XG4gICAgZ3NhcC5zZXQoZSwge1xuICAgICAgbGF6eTogdHJ1ZSxcbiAgICAgIHVzZXJTZWxlY3Q6IHNlbGVjdGFibGUgPyBcInRleHRcIiA6IFwibm9uZVwiXG4gICAgfSk7XG4gIH1cbn0sXG4gICAgX2lzRml4ZWQgPSBmdW5jdGlvbiBfaXNGaXhlZChlbGVtZW50KSB7XG4gIGlmIChfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAvLyBhdm9pZCBkb2N1bWVudCBmcmFnbWVudHMgd2hpY2ggd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXR1cm4gX2lzRml4ZWQoZWxlbWVudCk7XG4gIH1cbn0sXG4gICAgX3N1cHBvcnRzM0QsXG4gICAgX2FkZFBhZGRpbmdCUixcbiAgICAvL1RoZSBTY3JvbGxQcm94eSBjbGFzcyB3cmFwcyBhbiBlbGVtZW50J3MgY29udGVudHMgaW50byBhbm90aGVyIGRpdiAod2UgY2FsbCBpdCBcImNvbnRlbnRcIikgdGhhdCB3ZSBlaXRoZXIgYWRkIHBhZGRpbmcgd2hlbiBuZWNlc3Nhcnkgb3IgYXBwbHkgYSB0cmFuc2xhdGUzZCgpIHRyYW5zZm9ybSBpbiBvcmRlciB0byBvdmVyc2Nyb2xsIChzY3JvbGwgcGFzdCB0aGUgYm91bmRhcmllcykuIFRoaXMgYWxsb3dzIHVzIHRvIHNpbXBseSBzZXQgdGhlIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IChvciB0b3AvbGVmdCBmb3IgZWFzaWVyIHJldmVyc2UtYXhpcyBvcmllbnRhdGlvbiwgd2hpY2ggaXMgd2hhdCB3ZSBkbyBpbiBEcmFnZ2FibGUpIGFuZCBpdCdsbCBkbyBhbGwgdGhlIHdvcmsgZm9yIHVzLiBGb3IgZXhhbXBsZSwgaWYgd2UgdHJpZWQgc2V0dGluZyBzY3JvbGxUb3AgdG8gLTEwMCBvbiBhIG5vcm1hbCBET00gZWxlbWVudCwgaXQgd291bGRuJ3Qgd29yayAtIGl0J2QgbG9vayB0aGUgc2FtZSBhcyBzZXR0aW5nIGl0IHRvIDAsIGJ1dCBpZiB3ZSBzZXQgc2Nyb2xsVG9wIG9mIGEgU2Nyb2xsUHJveHkgdG8gLTEwMCwgaXQnbGwgZ2l2ZSB0aGUgY29ycmVjdCBhcHBlYXJhbmNlIGJ5IGVpdGhlciBzZXR0aW5nIHBhZGRpbmdUb3Agb2YgdGhlIHdyYXBwZXIgdG8gMTAwIG9yIGFwcGx5aW5nIGEgMTAwLXBpeGVsIHRyYW5zbGF0ZVkuXG5TY3JvbGxQcm94eSA9IGZ1bmN0aW9uIFNjcm9sbFByb3h5KGVsZW1lbnQsIHZhcnMpIHtcbiAgZWxlbWVudCA9IGdzYXAudXRpbHMudG9BcnJheShlbGVtZW50KVswXTtcbiAgdmFycyA9IHZhcnMgfHwge307XG4gIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIHN0eWxlID0gY29udGVudC5zdHlsZSxcbiAgICAgIG5vZGUgPSBlbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAgICBvZmZzZXRUb3AgPSAwLFxuICAgICAgb2Zmc2V0TGVmdCA9IDAsXG4gICAgICBwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICBwcmV2TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFdpZHRoID0gZWxlbWVudC5zY3JvbGxXaWR0aCxcbiAgICAgIHNjcm9sbEhlaWdodCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgZXh0cmFQYWRSaWdodCA9IDAsXG4gICAgICBtYXhMZWZ0ID0gMCxcbiAgICAgIG1heFRvcCA9IDAsXG4gICAgICBlbGVtZW50V2lkdGgsXG4gICAgICBlbGVtZW50SGVpZ2h0LFxuICAgICAgY29udGVudEhlaWdodCxcbiAgICAgIG5leHROb2RlLFxuICAgICAgdHJhbnNmb3JtU3RhcnQsXG4gICAgICB0cmFuc2Zvcm1FbmQ7XG5cbiAgaWYgKF9zdXBwb3J0czNEICYmIHZhcnMuZm9yY2UzRCAhPT0gZmFsc2UpIHtcbiAgICB0cmFuc2Zvcm1TdGFydCA9IFwidHJhbnNsYXRlM2QoXCI7XG4gICAgdHJhbnNmb3JtRW5kID0gXCJweCwwcHgpXCI7XG4gIH0gZWxzZSBpZiAoX3RyYW5zZm9ybVByb3ApIHtcbiAgICB0cmFuc2Zvcm1TdGFydCA9IFwidHJhbnNsYXRlKFwiO1xuICAgIHRyYW5zZm9ybUVuZCA9IFwicHgpXCI7XG4gIH1cblxuICB0aGlzLnNjcm9sbFRvcCA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtdGhpcy50b3AoKTtcbiAgICB9XG5cbiAgICB0aGlzLnRvcCgtdmFsdWUsIGZvcmNlKTtcbiAgfTtcblxuICB0aGlzLnNjcm9sbExlZnQgPSBmdW5jdGlvbiAodmFsdWUsIGZvcmNlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLXRoaXMubGVmdCgpO1xuICAgIH1cblxuICAgIHRoaXMubGVmdCgtdmFsdWUsIGZvcmNlKTtcbiAgfTtcblxuICB0aGlzLmxlZnQgPSBmdW5jdGlvbiAodmFsdWUsIGZvcmNlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLShlbGVtZW50LnNjcm9sbExlZnQgKyBvZmZzZXRMZWZ0KTtcbiAgICB9XG5cbiAgICB2YXIgZGlmID0gZWxlbWVudC5zY3JvbGxMZWZ0IC0gcHJldkxlZnQsXG4gICAgICAgIG9sZE9mZnNldCA9IG9mZnNldExlZnQ7XG5cbiAgICBpZiAoKGRpZiAIDIgfHwgZGlmIDwgLTIpICYmICFmb3JjZSkge1xuICAgICAgLy9pZiB0aGUgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgc2Nyb2xsYmFyIChvciBzb21ldGhpbmcgZWxzZSBzY3JvbGxzIGl0LCBsaWtlIHRoZSBtb3VzZSB3aGVlbCksIHdlIHNob3VsZCBraWxsIGFueSB0d2VlbnMgb2YgdGhlIFNjcm9sbFByb3h5LlxuICAgICAgcHJldkxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZih0aGlzLCB7XG4gICAgICAgIGxlZnQ6IDEsXG4gICAgICAgIHNjcm9sbExlZnQ6IDFcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sZWZ0KC1wcmV2TGVmdCk7XG5cbiAgICAgIGlmICh2YXJzLm9uS2lsbCkge1xuICAgICAgICB2YXJzLm9uS2lsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsdWUgPSAtdmFsdWU7IC8vaW52ZXJ0IGJlY2F1c2Ugc2Nyb2xsaW5nIHdvcmtzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cblxuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIG9mZnNldExlZnQgPSB2YWx1ZSAtIDAuNSB8IDA7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAIG1heExlZnQpIHtcbiAgICAgIG9mZnNldExlZnQgPSB2YWx1ZSAtIG1heExlZnQgfCAwO1xuICAgICAgdmFsdWUgPSBtYXhMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRMZWZ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0TGVmdCB8fCBvbGRPZmZzZXQpIHtcbiAgICAgIGlmICghdGhpcy5fc2tpcCkge1xuICAgICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1TdGFydCArIC1vZmZzZXRMZWZ0ICsgXCJweCxcIiArIC1vZmZzZXRUb3AgKyB0cmFuc2Zvcm1FbmQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvZmZzZXRMZWZ0ICsgZXh0cmFQYWRSaWdodCAPSAwKSB7XG4gICAgICAgIHN0eWxlLnBhZGRpbmdSaWdodCA9IG9mZnNldExlZnQgKyBleHRyYVBhZFJpZ2h0ICsgXCJweFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHZhbHVlIHwgMDtcbiAgICBwcmV2TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDsgLy9kb24ndCBtZXJnZSB0aGlzIHdpdGggdGhlIGxpbmUgYWJvdmUgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGFkanVzdCB0aGUgc2Nyb2xsTGVmdCBhZnRlciBpdCdzIHNldCwgc28gaW4gb3JkZXIgdG8gYmUgMTAwJSBhY2N1cmF0ZSBpbiB0cmFja2luZyBpdCwgd2UgbmVlZCB0byBhc2sgdGhlIGJyb3dzZXIgdG8gcmVwb3J0IGl0LlxuICB9O1xuXG4gIHRoaXMudG9wID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JjZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0oZWxlbWVudC5zY3JvbGxUb3AgKyBvZmZzZXRUb3ApO1xuICAgIH1cblxuICAgIHZhciBkaWYgPSBlbGVtZW50LnNjcm9sbFRvcCAtIHByZXZUb3AsXG4gICAgICAgIG9sZE9mZnNldCA9IG9mZnNldFRvcDtcblxuICAgIGlmICgoZGlmID4gMiB8fCBkaWYgPCAtMikgJiYgIWZvcmNlKSB7XG4gICAgICAvL2lmIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBzY3JvbGxiYXIgKG9yIHNvbWV0aGluZyBlbHNlIHNjcm9sbHMgaXQsIGxpa2UgdGhlIG1vdXNlIHdoZWVsKSwgd2Ugc2hvdWxkIGtpbGwgYW55IHR3ZWVucyBvZiB0aGUgU2Nyb2xsUHJveHkuXG4gICAgICBwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZih0aGlzLCB7XG4gICAgICAgIHRvcDogMSxcbiAgICAgICAgc2Nyb2xsVG9wOiAxXG4gICAgICB9KTtcbiAgICAgIHRoaXMudG9wKC1wcmV2VG9wKTtcblxuICAgICAgaWYgKHZhcnMub25LaWxsKSB7XG4gICAgICAgIHZhcnMub25LaWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IC12YWx1ZTsgLy9pbnZlcnQgYmVjYXVzZSBzY3JvbGxpbmcgd29ya3MgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuXG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgb2Zmc2V0VG9wID0gdmFsdWUgLSAwLjUgfCAwO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXhUb3ApIHtcbiAgICAgIG9mZnNldFRvcCA9IHZhbHVlIC0gbWF4VG9wIHwgMDtcbiAgICAgIHZhbHVlID0gbWF4VG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRUb3AgPSAwO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRUb3AgfHwgb2xkT2Zmc2V0KSB7XG4gICAgICBpZiAoIXRoaXMuX3NraXApIHtcbiAgICAgICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtU3RhcnQgKyAtb2Zmc2V0TGVmdCArIFwicHgsXCIgKyAtb2Zmc2V0VG9wICsgdHJhbnNmb3JtRW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gdmFsdWUgfCAwO1xuICAgIHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgfTtcblxuICB0aGlzLm1heFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWF4VG9wO1xuICB9O1xuXG4gIHRoaXMubWF4U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWF4TGVmdDtcbiAgfTtcblxuICB0aGlzLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgbm9kZSA9IG5leHROb2RlO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50ID09PSBjb250ZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIC8vaW4gY2FzZSBkaXNhYmxlKCkgaXMgY2FsbGVkIHdoZW4gaXQncyBhbHJlYWR5IGRpc2FibGVkLlxuICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChjb250ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZDtcblxuICAgIGlmIChub2RlID09PSBjb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG4gICAgfVxuXG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB0aGlzLmNhbGlicmF0ZSgpO1xuICB9O1xuXG4gIHRoaXMuY2FsaWJyYXRlID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgdmFyIHdpZHRoTWF0Y2hlcyA9IGVsZW1lbnQuY2xpZW50V2lkdGggPT09IGVsZW1lbnRXaWR0aCxcbiAgICAgICAgY3MsXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG4gICAgcHJldlRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuXG4gICAgaWYgKHdpZHRoTWF0Y2hlcyAmJiBlbGVtZW50LmNsaWVudEhlaWdodCA9PT0gZWxlbWVudEhlaWdodCAmJiBjb250ZW50Lm9mZnNldEhlaWdodCA9PT0gY29udGVudEhlaWdodCAmJiBzY3JvbGxXaWR0aCA9PT0gZWxlbWVudC5zY3JvbGxXaWR0aCAmJiBzY3JvbGxIZWlnaHQgPT09IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ICYmICFmb3JjZSkge1xuICAgICAgcmV0dXJuOyAvL25vIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhpbmdzIGlmIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGhhdmVuJ3QgY2hhbmdlZC5cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0VG9wIHx8IG9mZnNldExlZnQpIHtcbiAgICAgIHggPSB0aGlzLmxlZnQoKTtcbiAgICAgIHkgPSB0aGlzLnRvcCgpO1xuICAgICAgdGhpcy5sZWZ0KC1lbGVtZW50LnNjcm9sbExlZnQpO1xuICAgICAgdGhpcy50b3AoLWVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICB9XG5cbiAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpOyAvL2ZpcnN0LCB3ZSBuZWVkIHRvIHJlbW92ZSBhbnkgd2lkdGggY29uc3RyYWludHMgdG8gc2VlIGhvdyB0aGUgY29udGVudCBuYXR1cmFsbHkgZmxvd3Mgc28gdGhhdCB3ZSBjYW4gc2VlIGlmIGl0J3Mgd2lkZXIgdGhhbiB0aGUgY29udGFpbmluZyBlbGVtZW50LiBJZiBzbywgd2UndmUgZ290IHRvIHJlY29yZCB0aGUgYW1vdW50IG9mIG92ZXJhZ2Ugc28gdGhhdCB3ZSBjYW4gYXBwbHkgdGhhdCBhcyBwYWRkaW5nIGluIG9yZGVyIGZvciBicm93c2VycyB0byBjb3JyZWN0bHkgaGFuZGxlIHRoaW5ncy4gVGhlbiB3ZSBzd2l0Y2ggYmFjayB0byBhIHdpZHRoIG9mIDEwMCUgKHdpdGhvdXQgdGhhdCwgc29tZSBicm93c2VycyBkb24ndCBmbG93IHRoZSBjb250ZW50IGNvcnJlY3RseSlcblxuICAgIGlmICghd2lkdGhNYXRjaGVzIHx8IGZvcmNlKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgc3R5bGUud2lkdGggPSBcImF1dG9cIjtcbiAgICAgIHN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMHB4XCI7XG4gICAgICBleHRyYVBhZFJpZ2h0ID0gTWF0aC5tYXgoMCwgZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGgpOyAvL2lmIHRoZSBjb250ZW50IGlzIHdpZGVyIHRoYW4gdGhlIGNvbnRhaW5lciwgd2UgbmVlZCB0byBhZGQgdGhlIHBhZGRpbmdMZWZ0IGFuZCBwYWRkaW5nUmlnaHQgaW4gb3JkZXIgZm9yIHRoaW5ncyB0byBiZWhhdmUgY29ycmVjdGx5LlxuXG4gICAgICBpZiAoZXh0cmFQYWRSaWdodCkge1xuICAgICAgICBleHRyYVBhZFJpZ2h0ICs9IHBhcnNlRmxvYXQoY3MucGFkZGluZ0xlZnQpICsgKF9hZGRQYWRkaW5nQlIgPyBwYXJzZUZsb2F0KGNzLnBhZGRpbmdSaWdodCkgOiAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICBzdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICBzdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuICAgIHN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcInRvcFwiO1xuICAgIHN0eWxlLmJveFNpemluZyA9IFwiY29udGVudC1ib3hcIjtcbiAgICBzdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIHN0eWxlLnBhZGRpbmdSaWdodCA9IGV4dHJhUGFkUmlnaHQgKyBcInB4XCI7IC8vc29tZSBicm93c2VycyBuZWdsZWN0IHRvIGZhY3RvciBpbiB0aGUgYm90dG9tIHBhZGRpbmcgd2hlbiBjYWxjdWxhdGluZyB0aGUgc2Nyb2xsSGVpZ2h0LCBzbyB3ZSBuZWVkIHRvIGFkZCB0aGF0IHBhZGRpbmcgdG8gdGhlIGNvbnRlbnQgd2hlbiB0aGF0IGhhcHBlbnMuIEFsbG93IGEgMnB4IG1hcmdpbiBmb3IgZXJyb3JcblxuICAgIGlmIChfYWRkUGFkZGluZ0JSKSB7XG4gICAgICBzdHlsZS5wYWRkaW5nQm90dG9tID0gY3MucGFkZGluZ0JvdHRvbTtcbiAgICB9XG5cbiAgICBlbGVtZW50V2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGVsZW1lbnRIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICBzY3JvbGxXaWR0aCA9IGVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgc2Nyb2xsSGVpZ2h0ID0gZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgbWF4TGVmdCA9IGVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50V2lkdGg7XG4gICAgbWF4VG9wID0gZWxlbWVudC5zY3JvbGxIZWlnaHQgLSBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnRlbnRIZWlnaHQgPSBjb250ZW50Lm9mZnNldEhlaWdodDtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgaWYgKHggfHwgeSkge1xuICAgICAgdGhpcy5sZWZ0KHgpO1xuICAgICAgdGhpcy50b3AoeSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3NraXAgPSBmYWxzZTtcbiAgdGhpcy5lbmFibGUoKTtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKHJlcXVpcmVkKSB7XG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIHZhciBuYXYgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgICBfd2luID0gd2luZG93O1xuICAgIF9kb2MgPSBkb2N1bWVudDtcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgX3N1cHBvcnRzUG9pbnRlciA9ICEhd2luZG93LlBvaW50ZXJFdmVudDtcbiAgICBfcGxhY2Vob2xkZXJEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfcGxhY2Vob2xkZXJEaXYuc3R5bGUuY3NzVGV4dCA9IFwidmlzaWJpbGl0eTpoaWRkZW47aGVpZ2h0OjFweDt0b3A6LTFweDtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOnJlbGF0aXZlO2NsZWFyOmJvdGg7Y3Vyc29yOmdyYWJcIjtcbiAgICBfZGVmYXVsdEN1cnNvciA9IF9wbGFjZWhvbGRlckRpdi5zdHlsZS5jdXJzb3IgPT09IFwiZ3JhYlwiID8gXCJncmFiXCIgOiBcIm1vdmVcIjtcbiAgICBfaXNBbmRyb2lkID0gbmF2ICYmIG5hdi51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYW5kcm9pZFwiKSAhPT0gLTE7IC8vQW5kcm9pZCBoYW5kbGVzIHRvdWNoIGV2ZW50cyBpbiBhbiBvZGQgd2F5IGFuZCBpdCdzIHZpcnR1YWxseSBpbXBvc3NpYmxlIHRvIFwiZmVhdHVyZSB0ZXN0XCIgc28gd2UgcmVzb3J0IHRvIFVBIHNuaWZmaW5nXG5cbiAgICBfaXNUb3VjaERldmljZSA9IFwib250b3VjaHN0YXJ0XCIgaW4gX2RvY0VsZW1lbnQgJiYgXCJvcmllbnRhdGlvblwiIGluIF93aW4gfHwgbmF2ICYmIChuYXYuTWF4VG91Y2hQb2ludHMgPiAwIHx8IG5hdi5tc01heFRvdWNoUG9pbnRzID4gMCk7XG5cbiAgICBfYWRkUGFkZGluZ0JSID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy90aGlzIGZ1bmN0aW9uIGlzIGluIGNoYXJnZSBvZiBhbmFseXppbmcgYnJvd3NlciBiZWhhdmlvciByZWxhdGVkIHRvIHBhZGRpbmcuIEl0IHNldHMgdGhlIF9hZGRQYWRkaW5nQlIgdG8gdHJ1ZSBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IG5vcm1hbGx5IGZhY3RvciBpbiB0aGUgYm90dG9tIG9yIHJpZ2h0IHBhZGRpbmcgb24gdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBzY3JvbGxpbmcgYXJlYSwgYW5kIGl0IHNldHMgX2FkZFBhZGRpbmdMZWZ0IHRvIHRydWUgaWYgaXQncyBhIGJyb3dzZXIgdGhhdCByZXF1aXJlcyB0aGUgZXh0cmEgb2Zmc2V0IChvZmZzZXRMZWZ0KSB0byBiZSBhZGRlZCB0byB0aGUgcGFkZGluZ1JpZ2h0IChsaWtlIE9wZXJhKS5cbiAgICAgIHZhciBkaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICBjaGlsZCA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgIGNoaWxkU3R5bGUgPSBjaGlsZC5zdHlsZSxcbiAgICAgICAgICBwYXJlbnQgPSBfYm9keSxcbiAgICAgICAgICB2YWw7XG5cbiAgICAgIGNoaWxkU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICBjaGlsZFN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPSBjaGlsZC5pbm5lckhUTUwgPSBcIndpZHRoOjkwcHg7aGVpZ2h0OjQwcHg7cGFkZGluZzoxMHB4O292ZXJmbG93OmF1dG87dmlzaWJpbGl0eTpoaWRkZW5cIjtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIHZhbCA9IGNoaWxkLm9mZnNldEhlaWdodCArIDE4ID4gZGl2LnNjcm9sbEhlaWdodDsgLy9kaXYuc2Nyb2xsSGVpZ2h0IHNob3VsZCBiZSBjaGlsZC5vZmZzZXRIZWlnaHQgKyAyMCBiZWNhdXNlIG9mIHRoZSAxMHB4IG9mIHBhZGRpbmcgb24gZWFjaCBzaWRlLCBidXQgc29tZSBicm93c2VycyBpZ25vcmUgb25lIHNpZGUuIFdlIGFsbG93IGEgMnB4IG1hcmdpbiBvZiBlcnJvci5cblxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0oKTtcblxuICAgIF90b3VjaEV2ZW50TG9va3VwID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICAvL3dlIGNyZWF0ZSBhbiBvYmplY3QgdGhhdCBtYWtlcyBpdCBlYXN5IHRvIHRyYW5zbGF0ZSB0b3VjaCBldmVudCB0eXBlcyBpbnRvIHRoZWlyIFwicG9pbnRlclwiIGNvdW50ZXJwYXJ0cyBpZiB3ZSdyZSBpbiBhIGJyb3dzZXIgdGhhdCB1c2VzIHRob3NlIGluc3RlYWQuIExpa2UgSUUxMCB1c2VzIFwiTVNQb2ludGVyRG93blwiIGluc3RlYWQgb2YgXCJ0b3VjaHN0YXJ0XCIsIGZvciBleGFtcGxlLlxuICAgICAgdmFyIHN0YW5kYXJkID0gdHlwZXMuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgIGNvbnZlcnRlZCA9IChcIm9ucG9pbnRlcmRvd25cIiBpbiBfdGVtcERpdiA/IFwicG9pbnRlcmRvd24scG9pbnRlcm1vdmUscG9pbnRlcnVwLHBvaW50ZXJjYW5jZWxcIiA6IFwib25tc3BvaW50ZXJkb3duXCIgaW4gX3RlbXBEaXYgPyBcIk1TUG9pbnRlckRvd24sTVNQb2ludGVyTW92ZSxNU1BvaW50ZXJVcCxNU1BvaW50ZXJDYW5jZWxcIiA6IHR5cGVzKS5zcGxpdChcIixcIiksXG4gICAgICAgICAgb2JqID0ge30sXG4gICAgICAgICAgaSA9IDQ7XG5cbiAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICBvYmpbc3RhbmRhcmRbaV1dID0gY29udmVydGVkW2ldO1xuICAgICAgICBvYmpbY29udmVydGVkW2ldXSA9IHN0YW5kYXJkW2ldO1xuICAgICAgfSAvL3RvIGF2b2lkIHByb2JsZW1zIGluIGlPUyA5LCB0ZXN0IHRvIHNlZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgXCJwYXNzaXZlXCIgb3B0aW9uIG9uIGFkZEV2ZW50TGlzdGVuZXIoKS5cblxuXG4gICAgICB0cnkge1xuICAgICAgICBfZG9jRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBfc3VwcG9ydHNQYXNzaXZlID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfShcInRvdWNoc3RhcnQsdG91Y2htb3ZlLHRvdWNoZW5kLHRvdWNoY2FuY2VsXCIpO1xuXG4gICAgX2FkZExpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX2VtcHR5RnVuYyk7IC8vc29tZSBvbGRlciBBbmRyb2lkIGRldmljZXMgaW50ZXJtaXR0ZW50bHkgc3RvcCBkaXNwYXRjaGluZyBcInRvdWNobW92ZVwiIGV2ZW50cyBpZiB3ZSBkb24ndCBsaXN0ZW4gZm9yIFwidG91Y2hjYW5jZWxcIiBvbiB0aGUgZG9jdW1lbnQuIFZlcnkgc3RyYW5nZSBpbmRlZWQuXG5cblxuICAgIF9hZGRMaXN0ZW5lcihfd2luLCBcInRvdWNobW92ZVwiLCBfZW1wdHlGdW5jKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1Z3MgdGhhdCBzdGlsbCBhbGxvdyB0aGUgcGFnZSB0byBzY3JvbGwgZXZlbiB3aGVuIHdlIHByZXZlbnREZWZhdWx0KCkgb24gdGhlIHRvdWNobW92ZSBldmVudC5cblxuXG4gICAgX2JvZHkgJiYgX2JvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX2VtcHR5RnVuYyk7IC8vd29ya3MgYXJvdW5kIFNhZmFyaSBidWc6IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXG5cbiAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBwIGluIF9sb29rdXApIHtcbiAgICAgICAgaWYgKF9sb29rdXBbcF0uaXNQcmVzc2VkKSB7XG4gICAgICAgICAgX2xvb2t1cFtwXS5lbmREcmFnKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGdzYXAgPSBfY29yZUluaXR0ZWQgPSBfZ2V0R1NBUCgpO1xuICB9XG5cbiAgaWYgKGdzYXApIHtcbiAgICBJbmVydGlhUGx1Z2luID0gZ3NhcC5wbHVnaW5zLmluZXJ0aWE7XG4gICAgX2NoZWNrUHJlZml4ID0gZ3NhcC51dGlscy5jaGVja1ByZWZpeDtcbiAgICBfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1ByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfY2hlY2tQcmVmaXgoX3RyYW5zZm9ybU9yaWdpblByb3ApO1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcmVmaXgoXCJwZXJzcGVjdGl2ZVwiKTtcbiAgfSBlbHNlIGlmIChyZXF1aXJlZCkge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKERyYWdnYWJsZSlcIik7XG4gIH1cbn07XG5cbnZhciBFdmVudERpc3BhdGNoZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIodGFyZ2V0KSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8ICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG5cbiAgICBpZiAoIX5saXN0LmluZGV4T2YoY2FsbGJhY2spKSB7XG4gICAgICBsaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcbiAgICAgICAgaSA9IGxpc3QgJiYgbGlzdC5pbmRleE9mKGNhbGxiYWNrKSB8fCAtMTtcbiAgICBpID4gLTEgJiYgbGlzdC5zcGxpY2UoaSwgMSk7XG4gIH07XG5cbiAgX3Byb3RvLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHR5cGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICAodGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMsIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdGFyZ2V0OiBfdGhpcy50YXJnZXRcbiAgICAgIH0pID09PSBmYWxzZSAmJiAocmVzdWx0ID0gZmFsc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7IC8vaWYgYW55IG9mIHRoZSBjYWxsYmFja3MgcmV0dXJuIGZhbHNlLCBwYXNzIHRoYXQgYWxvbmcuXG4gIH07XG5cbiAgcmV0dXJuIEV2ZW50RGlzcGF0Y2hlcjtcbn0oKTtcblxuZXhwb3J0IHZhciBEcmFnZ2FibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudERpc3BhdGNoZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoRHJhZ2dhYmxlLCBfRXZlbnREaXNwYXRjaGVyKTtcblxuICBmdW5jdGlvbiBEcmFnZ2FibGUodGFyZ2V0LCB2YXJzKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF90aGlzMiA9IF9FdmVudERpc3BhdGNoZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoMSk7XG4gICAgdGFyZ2V0ID0gX3RvQXJyYXkodGFyZ2V0KVswXTsgLy9pbiBjYXNlIHRoZSB0YXJnZXQgaXMgYSBzZWxlY3RvciBvYmplY3Qgb3Igc2VsZWN0b3IgdGV4dFxuXG4gICAgaWYgKCFJbmVydGlhUGx1Z2luKSB7XG4gICAgICBJbmVydGlhUGx1Z2luID0gZ3NhcC5wbHVnaW5zLmluZXJ0aWE7XG4gICAgfVxuXG4gICAgX3RoaXMyLnZhcnMgPSB2YXJzID0gX2NvcHkodmFycyB8fCB7fSk7XG4gICAgX3RoaXMyLnRhcmdldCA9IHRhcmdldDtcbiAgICBfdGhpczIueCA9IF90aGlzMi55ID0gX3RoaXMyLnJvdGF0aW9uID0gMDtcbiAgICBfdGhpczIuZHJhZ1Jlc2lzdGFuY2UgPSBwYXJzZUZsb2F0KHZhcnMuZHJhZ1Jlc2lzdGFuY2UpIHx8IDA7XG4gICAgX3RoaXMyLmVkZ2VSZXNpc3RhbmNlID0gaXNOYU4odmFycy5lZGdlUmVzaXN0YW5jZSkgPyAxIDogcGFyc2VGbG9hdCh2YXJzLmVkZ2VSZXNpc3RhbmNlKSB8fCAwO1xuICAgIF90aGlzMi5sb2NrQXhpcyA9IHZhcnMubG9ja0F4aXM7XG4gICAgX3RoaXMyLmF1dG9TY3JvbGwgPSB2YXJzLmF1dG9TY3JvbGwgfHwgMDtcbiAgICBfdGhpczIubG9ja2VkQXhpcyA9IG51bGw7XG4gICAgX3RoaXMyLmFsbG93RXZlbnREZWZhdWx0ID0gISF2YXJzLmFsbG93RXZlbnREZWZhdWx0O1xuICAgIGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInhcIik7IC8vIHRvIGVuc3VyZSB0aGF0IHRyYW5zZm9ybXMgYXJlIGluc3RhbnRpYXRlZC5cblxuICAgIHZhciB0eXBlID0gKHZhcnMudHlwZSB8fCBcIngseVwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICB4eU1vZGUgPSBdHlwZS5pbmRleE9mKFwieFwiKSB8fCBdHlwZS5pbmRleE9mKFwieVwiKSxcbiAgICAgICAgcm90YXRpb25Nb2RlID0gdHlwZS5pbmRleE9mKFwicm90YXRpb25cIikgIT09IC0xLFxuICAgICAgICB4UHJvcCA9IHJvdGF0aW9uTW9kZSA/IFwicm90YXRpb25cIiA6IHh5TW9kZSA/IFwieFwiIDogXCJsZWZ0XCIsXG4gICAgICAgIHlQcm9wID0geHlNb2RlID8gXCJ5XCIgOiBcInRvcFwiLFxuICAgICAgICBhbGxvd1ggPSAhIShdHlwZS5pbmRleE9mKFwieFwiKSB8fCBdHlwZS5pbmRleE9mKFwibGVmdFwiKSB8fCB0eXBlID09PSBcInNjcm9sbFwiKSxcbiAgICAgICAgYWxsb3dZID0gISEofnR5cGUuaW5kZXhPZihcInlcIikgfHwgfnR5cGUuaW5kZXhPZihcInRvcFwiKSB8fCB0eXBlID09PSBcInNjcm9sbFwiKSxcbiAgICAgICAgbWluaW11bU1vdmVtZW50ID0gdmFycy5taW5pbXVtTW92ZW1lbnQgfHwgMixcbiAgICAgICAgc2VsZiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMyKSxcbiAgICAgICAgdHJpZ2dlcnMgPSBfdG9BcnJheSh2YXJzLnRyaWdnZXIgfHwgdmFycy5oYW5kbGUgfHwgdGFyZ2V0KSxcbiAgICAgICAga2lsbFByb3BzID0ge30sXG4gICAgICAgIGRyYWdFbmRUaW1lID0gMCxcbiAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gZmFsc2UsXG4gICAgICAgIGF1dG9TY3JvbGxNYXJnaW5Ub3AgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5Ub3AgfHwgNDAsXG4gICAgICAgIGF1dG9TY3JvbGxNYXJnaW5SaWdodCA9IHZhcnMuYXV0b1Njcm9sbE1hcmdpblJpZ2h0IHx8IDQwLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luQm90dG9tID0gdmFycy5hdXRvU2Nyb2xsTWFyZ2luQm90dG9tIHx8IDQwLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luTGVmdCA9IHZhcnMuYXV0b1Njcm9sbE1hcmdpbkxlZnQgfHwgNDAsXG4gICAgICAgIGlzQ2xpY2thYmxlID0gdmFycy5jbGlja2FibGVUZXN0IHx8IF9pc0NsaWNrYWJsZSxcbiAgICAgICAgY2xpY2tUaW1lID0gMCxcbiAgICAgICAgZ3NDYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgICAgaXNGaXhlZCA9IF9pc0ZpeGVkKHRhcmdldCksXG4gICAgICAgIGdldFByb3BBc051bSA9IGZ1bmN0aW9uIGdldFByb3BBc051bShwcm9wZXJ0eSwgdW5pdCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZ3NDYWNoZS5nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCkpO1xuICAgIH0sXG4gICAgICAgIG93bmVyRG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcbiAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgc2Nyb2xsUHJveHksXG4gICAgICAgIHN0YXJ0UG9pbnRlclgsXG4gICAgICAgIHN0YXJ0UG9pbnRlclksXG4gICAgICAgIHN0YXJ0RWxlbWVudFgsXG4gICAgICAgIHN0YXJ0RWxlbWVudFksXG4gICAgICAgIGhhc0JvdW5kcyxcbiAgICAgICAgaGFzRHJhZ0NhbGxiYWNrLFxuICAgICAgICBoYXNNb3ZlQ2FsbGJhY2ssXG4gICAgICAgIG1heFgsXG4gICAgICAgIG1pblgsXG4gICAgICAgIG1heFksXG4gICAgICAgIG1pblksXG4gICAgICAgIHRvdWNoLFxuICAgICAgICB0b3VjaElELFxuICAgICAgICByb3RhdGlvbk9yaWdpbixcbiAgICAgICAgZGlydHksXG4gICAgICAgIG9sZCxcbiAgICAgICAgc25hcFgsXG4gICAgICAgIHNuYXBZLFxuICAgICAgICBzbmFwWFksXG4gICAgICAgIGlzQ2xpY2tpbmcsXG4gICAgICAgIHRvdWNoRXZlbnRUYXJnZXQsXG4gICAgICAgIG1hdHJpeCxcbiAgICAgICAgaW50ZXJydXB0ZWQsXG4gICAgICAgIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcsXG4gICAgICAgIHRvdWNoRHJhZ0F4aXMsXG4gICAgICAgIGlzRGlzcGF0Y2hpbmcsXG4gICAgICAgIGNsaWNrRGlzcGF0Y2gsXG4gICAgICAgIHRydXN0ZWRDbGlja0Rpc3BhdGNoLFxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0LFxuICAgICAgICBpbm5lck1hdHJpeCxcbiAgICAgICAgb25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZSkge1xuICAgICAgLy91c2VkIHRvIHByZXZlbnQgbG9uZy10b3VjaCBmcm9tIHRyaWdnZXJpbmcgYSBjb250ZXh0IG1lbnUuXG4gICAgICAvLyAoc2VsZi5pc1ByZXNzZWQgJiYgZS53aGljaCA8IDIpICYmIHNlbGYuZW5kRHJhZygpIC8vIHByZXZpb3VzbHkgZW5kZWQgZHJhZyB3aGVuIGNvbnRleHQgbWVudSB3YXMgdHJpZ2dlcmVkLCBidXQgaW5zdGVhZCB3ZSBzaG91bGQganVzdCBzdG9wIHByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50IHRoZSBkZWZhdWx0IGV2ZW50IGJlaGF2aW9yLlxuICAgICAgX3ByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgICAgIC8vdGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgb24gZXZlcnkgdGljayBvZiBUd2VlbkxpdGUudGlja2VyIHdoaWNoIGFsbG93cyB1cyB0byBzeW5jaHJvbml6ZSB0aGUgcmVuZGVycyB0byB0aGUgY29yZSBlbmdpbmUgKHdoaWNoIGlzIHR5cGljYWxseSBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgZGlzcGxheSByZWZyZXNoIHZpYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiAtIGl0J3MgYmV0dGVyIHRoYW4gYXBwbHlpbmcgdGhlIHZhbHVlcyBpbnNpZGUgdGhlIFwibW91c2Vtb3ZlXCIgb3IgXCJ0b3VjaG1vdmVcIiBldmVudCBoYW5kbGVyIHdoaWNoIG1heSBnZXQgY2FsbGVkIG1hbnkgdGltZXMgaW5iZXR3ZWVuIHJlZnJlc2hlcy5cbiAgICByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIGlmIChzZWxmLmF1dG9TY3JvbGwgJiYgc2VsZi5pc0RyYWdnaW5nICYmIChjaGVja0F1dG9TY3JvbGxCb3VuZHMgfHwgZGlydHkpKSB7XG4gICAgICAgIHZhciBlID0gdGFyZ2V0LFxuICAgICAgICAgICAgYXV0b1Njcm9sbEZhY3RvciA9IHNlbGYuYXV0b1Njcm9sbCAqIDE1LFxuICAgICAgICAgICAgLy9tdWx0aXBseWluZyBieSAxNSBqdXN0IGdpdmVzIHVzIGEgYmV0dGVyIFwiZmVlbFwiIHNwZWVkLXdpc2UuXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGlzUm9vdCxcbiAgICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgICBwb2ludGVyWCxcbiAgICAgICAgICAgIHBvaW50ZXJZLFxuICAgICAgICAgICAgY2hhbmdlWCxcbiAgICAgICAgICAgIGNoYW5nZVksXG4gICAgICAgICAgICBnYXA7XG4gICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IGZhbHNlO1xuICAgICAgICBfd2luZG93UHJveHkuc2Nyb2xsVG9wID0gX3dpbi5wYWdlWU9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWU9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgIT0gbnVsbCA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBvd25lckRvYy5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgX3dpbmRvd1Byb3h5LnNjcm9sbExlZnQgPSBfd2luLnBhZ2VYT2Zmc2V0ICE9IG51bGwgPyBfd2luLnBhZ2VYT2Zmc2V0IDogb3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgIT0gbnVsbCA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IDogb3duZXJEb2MuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICBwb2ludGVyWCA9IHNlbGYucG9pbnRlclggLSBfd2luZG93UHJveHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgcG9pbnRlclkgPSBzZWxmLnBvaW50ZXJZIC0gX3dpbmRvd1Byb3h5LnNjcm9sbFRvcDtcblxuICAgICAgICB3aGlsZSAoZSAmJiAhaXNSb290KSB7XG4gICAgICAgICAgLy93YWxrIHVwIHRoZSBjaGFpbiBhbmQgc2Vuc2Ugd2hlcmV2ZXIgdGhlIHBvaW50ZXIgaXMgd2l0aGluIDQwcHggb2YgYW4gZWRnZSB0aGF0J3Mgc2Nyb2xsYWJsZS5cbiAgICAgICAgICBpc1Jvb3QgPSBfaXNSb290KGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgcGFyZW50ID0gaXNSb290ID8gX3dpbmRvd1Byb3h5IDogZS5wYXJlbnROb2RlO1xuICAgICAgICAgIHJlY3QgPSBpc1Jvb3QgPyB7XG4gICAgICAgICAgICBib3R0b206IE1hdGgubWF4KF9kb2NFbGVtZW50LmNsaWVudEhlaWdodCwgX3dpbi5pbm5lckhlaWdodCB8fCAwKSxcbiAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChfZG9jRWxlbWVudC5jbGllbnRXaWR0aCwgX3dpbi5pbm5lcldpZHRoIHx8IDApLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgIH0gOiBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgY2hhbmdlWCA9IGNoYW5nZVkgPSAwO1xuXG4gICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgZ2FwID0gcGFyZW50Ll9nc01heFNjcm9sbFkgLSBwYXJlbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICBpZiAoZ2FwIDwgMCkge1xuICAgICAgICAgICAgICBjaGFuZ2VZID0gZ2FwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyWSAIHJlY3QuYm90dG9tIC0gYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSAmJiBnYXApIHtcbiAgICAgICAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2hhbmdlWSA9IE1hdGgubWluKGdhcCwgYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgcmVjdC5ib3R0b20gLSBwb2ludGVyWSkgLyBhdXRvU2Nyb2xsTWFyZ2luQm90dG9tKSB8IDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyWSA8IHJlY3QudG9wICsgYXV0b1Njcm9sbE1hcmdpblRvcCAmJiBwYXJlbnQuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgIGNoYW5nZVkgPSAtTWF0aC5taW4ocGFyZW50LnNjcm9sbFRvcCwgYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgcG9pbnRlclkgLSByZWN0LnRvcCkgLyBhdXRvU2Nyb2xsTWFyZ2luVG9wKSB8IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlWSkge1xuICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsVG9wICs9IGNoYW5nZVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgZ2FwID0gcGFyZW50Ll9nc01heFNjcm9sbFggLSBwYXJlbnQuc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgICAgICAgY2hhbmdlWCA9IGdhcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclggPiByZWN0LnJpZ2h0IC0gYXV0b1Njcm9sbE1hcmdpblJpZ2h0ICYmIGdhcCkge1xuICAgICAgICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjaGFuZ2VYID0gTWF0aC5taW4oZ2FwLCBhdXRvU2Nyb2xsRmFjdG9yICogKDEgLSBNYXRoLm1heCgwLCByZWN0LnJpZ2h0IC0gcG9pbnRlclgpIC8gYXV0b1Njcm9sbE1hcmdpblJpZ2h0KSB8IDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyWCA8IHJlY3QubGVmdCArIGF1dG9TY3JvbGxNYXJnaW5MZWZ0ICYmIHBhcmVudC5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgIGNoYW5nZVggPSAtTWF0aC5taW4ocGFyZW50LnNjcm9sbExlZnQsIGF1dG9TY3JvbGxGYWN0b3IgKiAoMSAtIE1hdGgubWF4KDAsIHBvaW50ZXJYIC0gcmVjdC5sZWZ0KSAvIGF1dG9TY3JvbGxNYXJnaW5MZWZ0KSB8IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlWCkge1xuICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsTGVmdCArPSBjaGFuZ2VYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1Jvb3QgJiYgKGNoYW5nZVggfHwgY2hhbmdlWSkpIHtcbiAgICAgICAgICAgIF93aW4uc2Nyb2xsVG8ocGFyZW50LnNjcm9sbExlZnQsIHBhcmVudC5zY3JvbGxUb3ApO1xuXG4gICAgICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24oc2VsZi5wb2ludGVyWCArIGNoYW5nZVgsIHNlbGYucG9pbnRlclkgKyBjaGFuZ2VZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICB2YXIgeCA9IHNlbGYueCxcbiAgICAgICAgICAgIHkgPSBzZWxmLnk7XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgIHNlbGYuZGVsdGFYID0geCAtIHBhcnNlRmxvYXQoZ3NDYWNoZS5yb3RhdGlvbik7XG4gICAgICAgICAgc2VsZi5yb3RhdGlvbiA9IHg7XG4gICAgICAgICAgZ3NDYWNoZS5yb3RhdGlvbiA9IHggKyBcImRlZ1wiO1xuICAgICAgICAgIGdzQ2FjaGUucmVuZGVyVHJhbnNmb3JtKDEsIGdzQ2FjaGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWSA9IHkgLSBzY3JvbGxQcm94eS50b3AoKTtcbiAgICAgICAgICAgICAgc2Nyb2xsUHJveHkudG9wKHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFYID0geCAtIHNjcm9sbFByb3h5LmxlZnQoKTtcbiAgICAgICAgICAgICAgc2Nyb2xsUHJveHkubGVmdCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHh5TW9kZSkge1xuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWSA9IHkgLSBwYXJzZUZsb2F0KGdzQ2FjaGUueSk7XG4gICAgICAgICAgICAgIGdzQ2FjaGUueSA9IHkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVggPSB4IC0gcGFyc2VGbG9hdChnc0NhY2hlLngpO1xuICAgICAgICAgICAgICBnc0NhY2hlLnggPSB4ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnc0NhY2hlLnJlbmRlclRyYW5zZm9ybSgxLCBnc0NhY2hlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWSA9IHkgLSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS50b3AgfHwgMCk7XG4gICAgICAgICAgICAgIHRhcmdldC5zdHlsZS50b3AgPSB5ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFYID0geCAtIHBhcnNlRmxvYXQodGFyZ2V0LnN0eWxlLmxlZnQgfHwgMCk7XG4gICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5sZWZ0ID0geCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzRHJhZ0NhbGxiYWNrICYmICFzdXBwcmVzc0V2ZW50cyAmJiAhaXNEaXNwYXRjaGluZykge1xuICAgICAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlOyAvL2luIGNhc2Ugb25EcmFnIGhhcyBhbiB1cGRhdGUoKSBjYWxsIChhdm9pZCBlbmRsZXNzIGxvb3ApXG5cbiAgICAgICAgICBpZiAoX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkcmFnXCIsIFwib25EcmFnXCIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBzZWxmLnggLT0gc2VsZi5kZWx0YVg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi55IC09IHNlbGYuZGVsdGFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXIodHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpcnR5ID0gZmFsc2U7XG4gICAgfSxcbiAgICAgICAgLy9jb3BpZXMgdGhlIHgveSBmcm9tIHRoZSBlbGVtZW50ICh3aGV0aGVyIHRoYXQgYmUgdHJhbnNmb3JtcywgdG9wL2xlZnQsIG9yIFNjcm9sbFByb3h5J3MgdG9wL2xlZnQpIHRvIHRoZSBEcmFnZ2FibGUncyB4IGFuZCB5IChhbmQgcm90YXRpb24gaWYgbmVjZXNzYXJ5KSBwcm9wZXJ0aWVzIHNvIHRoYXQgdGhleSByZWZsZWN0IHJlYWxpdHkgYW5kIGl0IGFsc28gKG9wdGlvbmFsbHkpIGFwcGxpZXMgYW55IHNuYXBwaW5nIG5lY2Vzc2FyeS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBJbmVydGlhUGx1Z2luIHR3ZWVuIGluIGFuIG9uVXBkYXRlIHRvIGVuc3VyZSB0aGluZ3MgYXJlIHN5bmNlZCBhbmQgc25hcHBlZC5cbiAgICBzeW5jWFkgPSBmdW5jdGlvbiBzeW5jWFkoc2tpcE9uVXBkYXRlLCBza2lwU25hcCkge1xuICAgICAgdmFyIHggPSBzZWxmLngsXG4gICAgICAgICAgeSA9IHNlbGYueSxcbiAgICAgICAgICBzbmFwcGVkVmFsdWUsXG4gICAgICAgICAgY3M7XG5cbiAgICAgIGlmICghdGFyZ2V0Ll9nc2FwKSB7XG4gICAgICAgIC8vanVzdCBpbiBjYXNlIHRoZSBfZ3NhcCBjYWNoZSBnb3Qgd2lwZWQsIGxpa2UgaWYgdGhlIHVzZXIgY2FsbGVkIGNsZWFyUHJvcHMgb24gdGhlIHRyYW5zZm9ybSBvciBzb21ldGhpbmcgKHZlcnkgcmFyZSkuXG4gICAgICAgIGdzQ2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgZ3NDYWNoZS51bmNhY2hlICYmIGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInhcIik7IC8vIHRyaWdnZXIgYSByZS1jYWNoZVxuXG4gICAgICBpZiAoeHlNb2RlKSB7XG4gICAgICAgIHNlbGYueCA9IHBhcnNlRmxvYXQoZ3NDYWNoZS54KTtcbiAgICAgICAgc2VsZi55ID0gcGFyc2VGbG9hdChnc0NhY2hlLnkpO1xuICAgICAgfSBlbHNlIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgc2VsZi54ID0gc2VsZi5yb3RhdGlvbiA9IHBhcnNlRmxvYXQoZ3NDYWNoZS5yb3RhdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgIHNlbGYueSA9IHNjcm9sbFByb3h5LnRvcCgpO1xuICAgICAgICBzZWxmLnggPSBzY3JvbGxQcm94eS5sZWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnkgPSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS50b3AgfHwgKGNzID0gX2dldENvbXB1dGVkU3R5bGUodGFyZ2V0KSkgJiYgY3MudG9wKSB8fCAwO1xuICAgICAgICBzZWxmLnggPSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS5sZWZ0IHx8IChjcyB8fCB7fSkubGVmdCkgfHwgMDtcbiAgICAgIH1cblxuICAgICAgaWYgKChzbmFwWCB8fCBzbmFwWSB8fCBzbmFwWFkpICYmICFza2lwU25hcCAmJiAoc2VsZi5pc0RyYWdnaW5nIHx8IHNlbGYuaXNUaHJvd2luZykpIHtcbiAgICAgICAgaWYgKHNuYXBYWSkge1xuICAgICAgICAgIF90ZW1wMS54ID0gc2VsZi54O1xuICAgICAgICAgIF90ZW1wMS55ID0gc2VsZi55O1xuICAgICAgICAgIHNuYXBwZWRWYWx1ZSA9IHNuYXBYWShfdGVtcDEpO1xuXG4gICAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZS54ICE9PSBzZWxmLngpIHtcbiAgICAgICAgICAgIHNlbGYueCA9IHNuYXBwZWRWYWx1ZS54O1xuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzbmFwcGVkVmFsdWUueSAhPT0gc2VsZi55KSB7XG4gICAgICAgICAgICBzZWxmLnkgPSBzbmFwcGVkVmFsdWUueTtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFgpIHtcbiAgICAgICAgICBzbmFwcGVkVmFsdWUgPSBzbmFwWChzZWxmLngpO1xuXG4gICAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZSAhPT0gc2VsZi54KSB7XG4gICAgICAgICAgICBzZWxmLnggPSBzbmFwcGVkVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICAgICAgc2VsZi5yb3RhdGlvbiA9IHNuYXBwZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbmFwWSkge1xuICAgICAgICAgIHNuYXBwZWRWYWx1ZSA9IHNuYXBZKHNlbGYueSk7XG5cbiAgICAgICAgICBpZiAoc25hcHBlZFZhbHVlICE9PSBzZWxmLnkpIHtcbiAgICAgICAgICAgIHNlbGYueSA9IHNuYXBwZWRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlydHkgJiYgcmVuZGVyKHRydWUpO1xuXG4gICAgICBpZiAoIXNraXBPblVwZGF0ZSkge1xuICAgICAgICBzZWxmLmRlbHRhWCA9IHNlbGYueCAtIHg7XG4gICAgICAgIHNlbGYuZGVsdGFZID0gc2VsZi55IC0geTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInRocm93dXBkYXRlXCIsIFwib25UaHJvd1VwZGF0ZVwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBidWlsZFNuYXBGdW5jID0gZnVuY3Rpb24gYnVpbGRTbmFwRnVuYyhzbmFwLCBtaW4sIG1heCwgZmFjdG9yKSB7XG4gICAgICBpZiAobWluID09IG51bGwpIHtcbiAgICAgICAgbWluID0gLV9iaWdOdW07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgICBtYXggPSBfYmlnTnVtO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzRnVuY3Rpb24oc25hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgdmFyIGVkZ2VUb2xlcmFuY2UgPSAhc2VsZi5pc1ByZXNzZWQgPyAxIDogMSAtIHNlbGYuZWRnZVJlc2lzdGFuY2U7IC8vaWYgd2UncmUgdHdlZW5pbmcsIGRpc2FibGUgdGhlIGVkZ2VUb2xlcmFuY2UgYmVjYXVzZSBpdCdzIGFscmVhZHkgZmFjdG9yZWQgaW50byB0aGUgdHdlZW5pbmcgdmFsdWVzICh3ZSBkb24ndCB3YW50IHRvIGFwcGx5IGl0IG11bHRpcGxlIHRpbWVzKVxuXG4gICAgICAgICAgcmV0dXJuIHNuYXAuY2FsbChzZWxmLCBuID4gbWF4ID8gbWF4ICsgKG4gLSBtYXgpICogZWRnZVRvbGVyYW5jZSA6IG4gPCBtaW4gPyBtaW4gKyAobiAtIG1pbikgKiBlZGdlVG9sZXJhbmNlIDogbikgKiBmYWN0b3I7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNBcnJheShzbmFwKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICB2YXIgaSA9IHNuYXAubGVuZ3RoLFxuICAgICAgICAgICAgICBjbG9zZXN0ID0gMCxcbiAgICAgICAgICAgICAgYWJzRGlmID0gX2JpZ051bSxcbiAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICBkaWY7XG5cbiAgICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IHNuYXBbaV07XG4gICAgICAgICAgICBkaWYgPSB2YWwgLSBuO1xuXG4gICAgICAgICAgICBpZiAoZGlmIDwgMCkge1xuICAgICAgICAgICAgICBkaWYgPSAtZGlmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlmIDwgYWJzRGlmICYmIHZhbCAPSBtaW4gJiYgdmFsIDw9IG1heCkge1xuICAgICAgICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgICAgICAgICAgYWJzRGlmID0gZGlmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzbmFwW2Nsb3Nlc3RdO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNOYU4oc25hcCkgPyBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzbmFwICogZmFjdG9yO1xuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBidWlsZFBvaW50U25hcEZ1bmMgPSBmdW5jdGlvbiBidWlsZFBvaW50U25hcEZ1bmMoc25hcCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSwgcmFkaXVzLCBmYWN0b3IpIHtcbiAgICAgIHJhZGl1cyA9IHJhZGl1cyAmJiByYWRpdXMgPCBfYmlnTnVtID8gcmFkaXVzICogcmFkaXVzIDogX2JpZ051bTsgLy9zbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBmdW5jdGlvbnMuIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cblxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKHNuYXApKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICB2YXIgZWRnZVRvbGVyYW5jZSA9ICFzZWxmLmlzUHJlc3NlZCA/IDEgOiAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICAgICAgeCA9IHBvaW50LngsXG4gICAgICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICBkeTsgLy9pZiB3ZSdyZSB0d2VlbmluZywgZGlzYWJsZSB0aGUgZWRnZVRvbGVyYW5jZSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBmYWN0b3JlZCBpbnRvIHRoZSB0d2VlbmluZyB2YWx1ZXMgKHdlIGRvbid0IHdhbnQgdG8gYXBwbHkgaXQgbXVsdGlwbGUgdGltZXMpXG5cbiAgICAgICAgICBwb2ludC54ID0geCA9IHggPiBtYXhYID8gbWF4WCArICh4IC0gbWF4WCkgKiBlZGdlVG9sZXJhbmNlIDogeCA8IG1pblggPyBtaW5YICsgKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UgOiB4O1xuICAgICAgICAgIHBvaW50LnkgPSB5ID0geSAIG1heFkgPyBtYXhZICsgKHkgLSBtYXhZKSAqIGVkZ2VUb2xlcmFuY2UgOiB5IDwgbWluWSA/IG1pblkgKyAoeSAtIG1pblkpICogZWRnZVRvbGVyYW5jZSA6IHk7XG4gICAgICAgICAgcmVzdWx0ID0gc25hcC5jYWxsKHNlbGYsIHBvaW50KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludC54ID0gcmVzdWx0Lng7XG4gICAgICAgICAgICBwb2ludC55ID0gcmVzdWx0Lnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZhY3RvciAhPT0gMSkge1xuICAgICAgICAgICAgcG9pbnQueCAqPSBmYWN0b3I7XG4gICAgICAgICAgICBwb2ludC55ICo9IGZhY3RvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmFkaXVzIDwgX2JpZ051bSkge1xuICAgICAgICAgICAgZHggPSBwb2ludC54IC0geDtcbiAgICAgICAgICAgIGR5ID0gcG9pbnQueSAtIHk7XG5cbiAgICAgICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSAIHJhZGl1cykge1xuICAgICAgICAgICAgICBwb2ludC54ID0geDtcbiAgICAgICAgICAgICAgcG9pbnQueSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzQXJyYXkoc25hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgdmFyIGkgPSBzbmFwLmxlbmd0aCxcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBfYmlnTnVtLFxuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgZGlzdDtcblxuICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgICAgcG9pbnQgPSBzbmFwW2ldO1xuICAgICAgICAgICAgeCA9IHBvaW50LnggLSBwLng7XG4gICAgICAgICAgICB5ID0gcG9pbnQueSAtIHAueTtcbiAgICAgICAgICAgIGRpc3QgPSB4ICogeCArIHkgKiB5O1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtaW5EaXN0IDw9IHJhZGl1cyA/IHNuYXBbY2xvc2VzdF0gOiBwO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIGNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgIHZhciBib3VuZHMsIHRhcmdldEJvdW5kcywgc25hcCwgc25hcElzUmF3O1xuICAgICAgaGFzQm91bmRzID0gZmFsc2U7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzY3JvbGxQcm94eS5jYWxpYnJhdGUoKTtcbiAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IC1zY3JvbGxQcm94eS5tYXhTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHNlbGYubWluWSA9IG1pblkgPSAtc2Nyb2xsUHJveHkubWF4U2Nyb2xsVG9wKCk7XG4gICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBzZWxmLm1heFkgPSBtYXhZID0gMDtcbiAgICAgICAgaGFzQm91bmRzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoISF2YXJzLmJvdW5kcykge1xuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKHZhcnMuYm91bmRzLCB0YXJnZXQucGFyZW50Tm9kZSk7IC8vY291bGQgYmUgYSBzZWxlY3Rvci9qUXVlcnkgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQgb3IgYSBnZW5lcmljIG9iamVjdCBsaWtlIHt0b3A6MCwgbGVmdDoxMDAsIHdpZHRoOjEwMDAsIGhlaWdodDo4MDB9IG9yIHttaW5YOjEwMCwgbWF4WDoxMTAwLCBtaW5ZOjAsIG1heFk6ODAwfVxuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gYm91bmRzLmxlZnQ7XG4gICAgICAgICAgc2VsZi5tYXhYID0gbWF4WCA9IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoO1xuICAgICAgICAgIHNlbGYubWluWSA9IG1pblkgPSBzZWxmLm1heFkgPSBtYXhZID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICghX2lzVW5kZWZpbmVkKHZhcnMuYm91bmRzLm1heFgpIHx8ICFfaXNVbmRlZmluZWQodmFycy5ib3VuZHMubWF4WSkpIHtcbiAgICAgICAgICBib3VuZHMgPSB2YXJzLmJvdW5kcztcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gYm91bmRzLm1pblg7XG4gICAgICAgICAgc2VsZi5taW5ZID0gbWluWSA9IGJvdW5kcy5taW5ZO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBib3VuZHMubWF4WDtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gYm91bmRzLm1heFk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Qm91bmRzID0gX2dldEJvdW5kcyh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gTWF0aC5yb3VuZChnZXRQcm9wQXNOdW0oeFByb3AsIFwicHhcIikgKyBib3VuZHMubGVmdCAtIHRhcmdldEJvdW5kcy5sZWZ0KTtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtaW5ZID0gTWF0aC5yb3VuZChnZXRQcm9wQXNOdW0oeVByb3AsIFwicHhcIikgKyBib3VuZHMudG9wIC0gdGFyZ2V0Qm91bmRzLnRvcCk7XG4gICAgICAgICAgc2VsZi5tYXhYID0gbWF4WCA9IE1hdGgucm91bmQobWluWCArIChib3VuZHMud2lkdGggLSB0YXJnZXRCb3VuZHMud2lkdGgpKTtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gTWF0aC5yb3VuZChtaW5ZICsgKGJvdW5kcy5oZWlnaHQgLSB0YXJnZXRCb3VuZHMuaGVpZ2h0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWCAIG1heFgpIHtcbiAgICAgICAgICBzZWxmLm1pblggPSBtYXhYO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBtaW5YO1xuICAgICAgICAgIG1pblggPSBzZWxmLm1pblg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWSAIG1heFkpIHtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtYXhZO1xuICAgICAgICAgIHNlbGYubWF4WSA9IG1heFkgPSBtaW5ZO1xuICAgICAgICAgIG1pblkgPSBzZWxmLm1pblk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5taW5Sb3RhdGlvbiA9IG1pblg7XG4gICAgICAgICAgc2VsZi5tYXhSb3RhdGlvbiA9IG1heFg7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNCb3VuZHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFycy5saXZlU25hcCkge1xuICAgICAgICBzbmFwID0gdmFycy5saXZlU25hcCA9PT0gdHJ1ZSA/IHZhcnMuc25hcCB8fCB7fSA6IHZhcnMubGl2ZVNuYXA7XG4gICAgICAgIHNuYXBJc1JhdyA9IF9pc0FycmF5KHNuYXApIHx8IF9pc0Z1bmN0aW9uKHNuYXApO1xuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzbmFwWCA9IGJ1aWxkU25hcEZ1bmMoc25hcElzUmF3ID8gc25hcCA6IHNuYXAucm90YXRpb24sIG1pblgsIG1heFgsIDEpO1xuICAgICAgICAgIHNuYXBZID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc25hcC5wb2ludHMpIHtcbiAgICAgICAgICAgIHNuYXBYWSA9IGJ1aWxkUG9pbnRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC5wb2ludHMsIG1pblgsIG1heFgsIG1pblksIG1heFksIHNuYXAucmFkaXVzLCBzY3JvbGxQcm94eSA/IC0xIDogMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc25hcFggPSBidWlsZFNuYXBGdW5jKHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnggfHwgc25hcC5sZWZ0IHx8IHNuYXAuc2Nyb2xsTGVmdCwgbWluWCwgbWF4WCwgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNuYXBZID0gYnVpbGRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC55IHx8IHNuYXAudG9wIHx8IHNuYXAuc2Nyb2xsVG9wLCBtaW5ZLCBtYXhZLCBzY3JvbGxQcm94eSA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgb25UaHJvd0NvbXBsZXRlID0gZnVuY3Rpb24gb25UaHJvd0NvbXBsZXRlKCkge1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwidGhyb3djb21wbGV0ZVwiLCBcIm9uVGhyb3dDb21wbGV0ZVwiKTtcbiAgICB9LFxuICAgICAgICBvblRocm93SW50ZXJydXB0ID0gZnVuY3Rpb24gb25UaHJvd0ludGVycnVwdCgpIHtcbiAgICAgIHNlbGYuaXNUaHJvd2luZyA9IGZhbHNlO1xuICAgIH0sXG4gICAgICAgIGFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlKGluZXJ0aWEsIGZvcmNlWmVyb1ZlbG9jaXR5KSB7XG4gICAgICB2YXIgc25hcCwgc25hcElzUmF3LCB0d2Vlbiwgb3ZlcnNob290VG9sZXJhbmNlO1xuXG4gICAgICBpZiAoaW5lcnRpYSAmJiBJbmVydGlhUGx1Z2luKSB7XG4gICAgICAgIGlmIChpbmVydGlhID09PSB0cnVlKSB7XG4gICAgICAgICAgc25hcCA9IHZhcnMuc25hcCB8fCB2YXJzLmxpdmVTbmFwIHx8IHt9O1xuICAgICAgICAgIHNuYXBJc1JhdyA9IF9pc0FycmF5KHNuYXApIHx8IF9pc0Z1bmN0aW9uKHNuYXApO1xuICAgICAgICAgIGluZXJ0aWEgPSB7XG4gICAgICAgICAgICByZXNpc3RhbmNlOiAodmFycy50aHJvd1Jlc2lzdGFuY2UgfHwgdmFycy5yZXNpc3RhbmNlIHx8IDEwMDApIC8gKHJvdGF0aW9uTW9kZSA/IDEwIDogMSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgICAgaW5lcnRpYS5yb3RhdGlvbiA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucm90YXRpb24sIG1heFgsIG1pblgsIDEsIGZvcmNlWmVyb1ZlbG9jaXR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBpbmVydGlhW3hQcm9wXSA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzIHx8IHNuYXAueCB8fCBzbmFwLmxlZnQsIG1heFgsIG1pblgsIHNjcm9sbFByb3h5ID8gLTEgOiAxLCBmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmxvY2tlZEF4aXMgPT09IFwieFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBpbmVydGlhW3lQcm9wXSA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzIHx8IHNuYXAueSB8fCBzbmFwLnRvcCwgbWF4WSwgbWluWSwgc2Nyb2xsUHJveHkgPyAtMSA6IDEsIGZvcmNlWmVyb1ZlbG9jaXR5IHx8IHNlbGYubG9ja2VkQXhpcyA9PT0gXCJ5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcC5wb2ludHMgfHwgX2lzQXJyYXkoc25hcCkgJiYgX2lzT2JqZWN0KHNuYXBbMF0pKSB7XG4gICAgICAgICAgICAgIGluZXJ0aWEubGlua2VkUHJvcHMgPSB4UHJvcCArIFwiLFwiICsgeVByb3A7XG4gICAgICAgICAgICAgIGluZXJ0aWEucmFkaXVzID0gc25hcC5yYWRpdXM7IC8vbm90ZTogd2UgYWxzbyBkaXNhYmxlIGxpdmVTbmFwcGluZyB3aGlsZSB0aHJvd2luZyBpZiB0aGVyZSdzIGEgXCJyYWRpdXNcIiBkZWZpbmVkLCBvdGhlcndpc2UgaXQgbG9va3Mgd2VpcmQgdG8gaGF2ZSB0aGUgaXRlbSB0aHJvd24gcGFzdCBhIHNuYXBwaW5nIHBvaW50IGJ1dCBsaXZlLXNuYXBwaW5nIG1pZC10d2Vlbi4gV2UgZG8gdGhpcyBieSBhbHRlcmluZyB0aGUgb25VcGRhdGVQYXJhbXMgc28gdGhhdCBcInNraXBTbmFwXCIgcGFyYW1ldGVyIGlzIHRydWUgZm9yIHN5bmNYWS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmlzVGhyb3dpbmcgPSB0cnVlO1xuICAgICAgICBvdmVyc2hvb3RUb2xlcmFuY2UgPSAhaXNOYU4odmFycy5vdmVyc2hvb3RUb2xlcmFuY2UpID8gdmFycy5vdmVyc2hvb3RUb2xlcmFuY2UgOiB2YXJzLmVkZ2VSZXNpc3RhbmNlID09PSAxID8gMCA6IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlICsgMC4yO1xuXG4gICAgICAgIGlmICghaW5lcnRpYS5kdXJhdGlvbikge1xuICAgICAgICAgIGluZXJ0aWEuZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBtYXg6IE1hdGgubWF4KHZhcnMubWluRHVyYXRpb24gfHwgMCwgXCJtYXhEdXJhdGlvblwiIGluIHZhcnMgPyB2YXJzLm1heER1cmF0aW9uIDogMiksXG4gICAgICAgICAgICBtaW46ICFpc05hTih2YXJzLm1pbkR1cmF0aW9uKSA/IHZhcnMubWluRHVyYXRpb24gOiBvdmVyc2hvb3RUb2xlcmFuY2UgPT09IDAgfHwgX2lzT2JqZWN0KGluZXJ0aWEpICYmIGluZXJ0aWEucmVzaXN0YW5jZSAIDEwMDAgPyAwIDogMC41LFxuICAgICAgICAgICAgb3ZlcnNob290OiBvdmVyc2hvb3RUb2xlcmFuY2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi50d2VlbiA9IHR3ZWVuID0gZ3NhcC50byhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHtcbiAgICAgICAgICBpbmVydGlhOiBpbmVydGlhLFxuICAgICAgICAgIGRhdGE6IFwiX2RyYWdnYWJsZVwiLFxuICAgICAgICAgIG9uQ29tcGxldGU6IG9uVGhyb3dDb21wbGV0ZSxcbiAgICAgICAgICBvbkludGVycnVwdDogb25UaHJvd0ludGVycnVwdCxcbiAgICAgICAgICBvblVwZGF0ZTogdmFycy5mYXN0TW9kZSA/IF9kaXNwYXRjaEV2ZW50IDogc3luY1hZLFxuICAgICAgICAgIG9uVXBkYXRlUGFyYW1zOiB2YXJzLmZhc3RNb2RlID8gW3NlbGYsIFwib250aHJvd3VwZGF0ZVwiLCBcIm9uVGhyb3dVcGRhdGVcIl0gOiBzbmFwICYmIHNuYXAucmFkaXVzID8gW2ZhbHNlLCB0cnVlXSA6IFtdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdmFycy5mYXN0TW9kZSkge1xuICAgICAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICAgICAgc2Nyb2xsUHJveHkuX3NraXAgPSB0cnVlOyAvLyBNaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIGJ1ZyB0aGF0IGNhdXNlcyB0aGVtIHRvIGJyaWVmbHkgcmVuZGVyIHRoZSBwb3NpdGlvbiBpbmNvcnJlY3RseSAoaXQgZmxhc2hlcyB0byB0aGUgZW5kIHN0YXRlIHdoZW4gd2Ugc2VlaygpIHRoZSB0d2VlbiBldmVuIHRob3VnaCB3ZSBqdW1wIHJpZ2h0IGJhY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGlzIG9ubHkgc2VlbXMgdG8gaGFwcGVuIHdoZW4gd2UncmUgYWZmZWN0aW5nIGJvdGggdG9wIGFuZCBsZWZ0KSwgc28gd2Ugc2V0IGEgX3N1c3BlbmRUcmFuc2Zvcm1zIGZsYWcgdG8gcHJldmVudCBpdCBmcm9tIGFjdHVhbGx5IGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW4gdGhlIFNjcm9sbFByb3h5LlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHR3ZWVuLnJlbmRlcigxZTksIHRydWUsIHRydWUpOyAvLyBmb3JjZSB0byB0aGUgZW5kLiBSZW1lbWJlciwgdGhlIGR1cmF0aW9uIHdpbGwgbGlrZWx5IGNoYW5nZSB1cG9uIGluaXR0aW5nIGJlY2F1c2UgdGhhdCdzIHdoZW4gSW5lcnRpYVBsdWdpbiBjYWxjdWxhdGVzIGl0LlxuXG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuICAgICAgICAgIHNlbGYuZW5kWCA9IHNlbGYueDtcbiAgICAgICAgICBzZWxmLmVuZFkgPSBzZWxmLnk7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0gc2VsZi54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHR3ZWVuLnBsYXkoMCk7XG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgICAgICBzY3JvbGxQcm94eS5fc2tpcCA9IGZhbHNlOyAvL01pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgYnVnIHRoYXQgY2F1c2VzIHRoZW0gdG8gYnJpZWZseSByZW5kZXIgdGhlIHBvc2l0aW9uIGluY29ycmVjdGx5IChpdCBmbGFzaGVzIHRvIHRoZSBlbmQgc3RhdGUgd2hlbiB3ZSBzZWVrKCkgdGhlIHR3ZWVuIGV2ZW4gdGhvdWdoIHdlIGp1bXAgcmlnaHQgYmFjayB0byB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoaXMgb25seSBzZWVtcyB0byBoYXBwZW4gd2hlbiB3ZSdyZSBhZmZlY3RpbmcgYm90aCB0b3AgYW5kIGxlZnQpLCBzbyB3ZSBzZXQgYSBfc3VzcGVuZFRyYW5zZm9ybXMgZmxhZyB0byBwcmV2ZW50IGl0IGZyb20gYWN0dWFsbHkgYXBwbHlpbmcgdGhlIHZhbHVlcyBpbiB0aGUgU2Nyb2xsUHJveHkuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc0JvdW5kcykge1xuICAgICAgICBzZWxmLmFwcGx5Qm91bmRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgdXBkYXRlTWF0cml4ID0gZnVuY3Rpb24gdXBkYXRlTWF0cml4KHNoaWZ0U3RhcnQpIHtcbiAgICAgIHZhciBzdGFydCA9IG1hdHJpeCxcbiAgICAgICAgICBwO1xuICAgICAgbWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldC5wYXJlbnROb2RlLCB0cnVlKTtcblxuICAgICAgaWYgKHNoaWZ0U3RhcnQgJiYgc2VsZi5pc1ByZXNzZWQgJiYgIW1hdHJpeC5lcXVhbHMoc3RhcnQgfHwgbmV3IE1hdHJpeDJEKCkpKSB7XG4gICAgICAgIC8vaWYgdGhlIG1hdHJpeCBjaGFuZ2VzIFdISUxFIHRoZSBlbGVtZW50IGlzIHByZXNzZWQsIHdlIG11c3QgYWRqdXN0IHRoZSBzdGFydFBvaW50ZXJYIGFuZCBzdGFydFBvaW50ZXJZIGFjY29yZGluZ2x5LCBzbyB3ZSBpbnZlcnQgdGhlIG9yaWdpbmFsIG1hdHJpeCBhbmQgZmlndXJlIG91dCB3aGVyZSB0aGUgcG9pbnRlclggYW5kIHBvaW50ZXJZIHdlcmUgaW4gdGhlIGdsb2JhbCBzcGFjZSwgdGhlbiBhcHBseSB0aGUgbmV3IG1hdHJpeCB0byBnZXQgdGhlIHVwZGF0ZWQgY29vcmRpbmF0ZXMuXG4gICAgICAgIHAgPSBzdGFydC5pbnZlcnNlKCkuYXBwbHkoe1xuICAgICAgICAgIHg6IHN0YXJ0UG9pbnRlclgsXG4gICAgICAgICAgeTogc3RhcnRQb2ludGVyWVxuICAgICAgICB9KTtcbiAgICAgICAgbWF0cml4LmFwcGx5KHAsIHApO1xuICAgICAgICBzdGFydFBvaW50ZXJYID0gcC54O1xuICAgICAgICBzdGFydFBvaW50ZXJZID0gcC55O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0cml4LmVxdWFscyhfaWRlbnRpdHlNYXRyaXgpKSB7XG4gICAgICAgIC8vaWYgdGhlcmUgYXJlIG5vIHRyYW5zZm9ybXMsIHdlIGNhbiBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBieSBub3QgZmFjdG9yaW5nIGluIHRoZSBtYXRyaXhcbiAgICAgICAgbWF0cml4ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICByZWNvcmRTdGFydFBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJlY29yZFN0YXJ0UG9zaXRpb25zKCkge1xuICAgICAgdmFyIGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICBvZmZzZXRYID0gaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDAsXG4gICAgICAgICAgb2Zmc2V0WSA9IGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDAsXG4gICAgICAgICAgcGFyc2VkT3JpZ2luLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeTtcbiAgICAgIHVwZGF0ZU1hdHJpeChmYWxzZSk7XG4gICAgICBfcG9pbnQxLnggPSBzZWxmLnBvaW50ZXJYIC0gb2Zmc2V0WDtcbiAgICAgIF9wb2ludDEueSA9IHNlbGYucG9pbnRlclkgLSBvZmZzZXRZO1xuICAgICAgbWF0cml4ICYmIG1hdHJpeC5hcHBseShfcG9pbnQxLCBfcG9pbnQxKTtcbiAgICAgIHN0YXJ0UG9pbnRlclggPSBfcG9pbnQxLng7IC8vdHJhbnNsYXRlIHRvIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG5cbiAgICAgIHN0YXJ0UG9pbnRlclkgPSBfcG9pbnQxLnk7XG5cbiAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24oc2VsZi5wb2ludGVyWCwgc2VsZi5wb2ludGVyWSk7XG4gICAgICAgIHJlbmRlcih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaW5uZXJNYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgodGFyZ2V0KTtcblxuICAgICAgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgIGNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICBzdGFydEVsZW1lbnRZID0gc2Nyb2xsUHJveHkudG9wKCk7XG4gICAgICAgIHN0YXJ0RWxlbWVudFggPSBzY3JvbGxQcm94eS5sZWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2lmIHRoZSBlbGVtZW50IGlzIGluIHRoZSBwcm9jZXNzIG9mIHR3ZWVuaW5nLCBkb24ndCBmb3JjZSBzbmFwcGluZyB0byBvY2N1ciBiZWNhdXNlIGl0IGNvdWxkIG1ha2UgaXQganVtcC4gSW1hZ2luZSB0aGUgdXNlciB0aHJvd2luZywgdGhlbiBiZWZvcmUgaXQncyBkb25lLCBjbGlja2luZyBvbiB0aGUgZWxlbWVudCBpbiBpdHMgaW5iZXR3ZWVuIHN0YXRlLlxuICAgICAgICBpZiAoaXNUd2VlbmluZygpKSB7XG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuICAgICAgICAgIGNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBwYXJzZWRPcmlnaW4gPSB0YXJnZXQub3duZXJTVkdFbGVtZW50ID8gW2dzQ2FjaGUueE9yaWdpbiAtIHRhcmdldC5nZXRCQm94KCkueCwgZ3NDYWNoZS55T3JpZ2luIC0gdGFyZ2V0LmdldEJCb3goKS55XSA6IChfZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSB8fCBcIjAgMFwiKS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgcm90YXRpb25PcmlnaW4gPSBzZWxmLnJvdGF0aW9uT3JpZ2luID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldCkuYXBwbHkoe1xuICAgICAgICAgICAgeDogcGFyc2VGbG9hdChwYXJzZWRPcmlnaW5bMF0pIHx8IDAsXG4gICAgICAgICAgICB5OiBwYXJzZUZsb2F0KHBhcnNlZE9yaWdpblsxXSkgfHwgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN5bmNYWSh0cnVlLCB0cnVlKTtcbiAgICAgICAgICB4ID0gc2VsZi5wb2ludGVyWCAtIHJvdGF0aW9uT3JpZ2luLnggLSBvZmZzZXRYO1xuICAgICAgICAgIHkgPSByb3RhdGlvbk9yaWdpbi55IC0gc2VsZi5wb2ludGVyWSArIG9mZnNldFk7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WCA9IHNlbGYueDsgLy9zdGFydGluZyByb3RhdGlvbiAoeCBhbHdheXMgcmVmZXJzIHRvIHJvdGF0aW9uIGluIHR5cGU6XCJyb3RhdGlvblwiLCBtZWFzdXJlZCBpbiBkZWdyZWVzKVxuXG4gICAgICAgICAgc3RhcnRFbGVtZW50WSA9IHNlbGYueSA9IE1hdGguYXRhbjIoeSwgeCkgKiBfUkFEMkRFRztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL3BhcmVudCA9ICFpc0ZpeGVkICYmIHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgIC8vc3RhcnRTY3JvbGxUb3AgPSBwYXJlbnQgPyBwYXJlbnQuc2Nyb2xsVG9wIHx8IDAgOiAwO1xuICAgICAgICAgIC8vc3RhcnRTY3JvbGxMZWZ0ID0gcGFyZW50ID8gcGFyZW50LnNjcm9sbExlZnQgfHwgMCA6IDA7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSA9IGdldFByb3BBc051bSh5UHJvcCwgXCJweFwiKTsgLy9yZWNvcmQgdGhlIHN0YXJ0aW5nIHRvcCBhbmQgbGVmdCB2YWx1ZXMgc28gdGhhdCB3ZSBjYW4ganVzdCBhZGQgdGhlIG1vdXNlJ3MgbW92ZW1lbnQgdG8gdGhlbSBsYXRlci5cblxuICAgICAgICAgIHN0YXJ0RWxlbWVudFggPSBnZXRQcm9wQXNOdW0oeFByb3AsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0JvdW5kcyAmJiBlZGdlVG9sZXJhbmNlKSB7XG4gICAgICAgIGlmIChzdGFydEVsZW1lbnRYID4gbWF4WCkge1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFggPSBtYXhYICsgKHN0YXJ0RWxlbWVudFggLSBtYXhYKSAvIGVkZ2VUb2xlcmFuY2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRFbGVtZW50WCA8IG1pblgpIHtcbiAgICAgICAgICBzdGFydEVsZW1lbnRYID0gbWluWCAtIChtaW5YIC0gc3RhcnRFbGVtZW50WCkgLyBlZGdlVG9sZXJhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBpZiAoc3RhcnRFbGVtZW50WSAIG1heFkpIHtcbiAgICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBtYXhZICsgKHN0YXJ0RWxlbWVudFkgLSBtYXhZKSAvIGVkZ2VUb2xlcmFuY2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydEVsZW1lbnRZIDwgbWluWSkge1xuICAgICAgICAgICAgc3RhcnRFbGVtZW50WSA9IG1pblkgLSAobWluWSAtIHN0YXJ0RWxlbWVudFkpIC8gZWRnZVRvbGVyYW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5zdGFydFggPSBzdGFydEVsZW1lbnRYID0gX3JvdW5kKHN0YXJ0RWxlbWVudFgpO1xuICAgICAgc2VsZi5zdGFydFkgPSBzdGFydEVsZW1lbnRZID0gX3JvdW5kKHN0YXJ0RWxlbWVudFkpO1xuICAgIH0sXG4gICAgICAgIGlzVHdlZW5pbmcgPSBmdW5jdGlvbiBpc1R3ZWVuaW5nKCkge1xuICAgICAgcmV0dXJuIHNlbGYudHdlZW4gJiYgc2VsZi50d2Vlbi5pc0FjdGl2ZSgpO1xuICAgIH0sXG4gICAgICAgIHJlbW92ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gcmVtb3ZlUGxhY2Vob2xkZXIoKSB7XG4gICAgICBpZiAoX3BsYWNlaG9sZGVyRGl2LnBhcmVudE5vZGUgJiYgIWlzVHdlZW5pbmcoKSAmJiAhc2VsZi5pc0RyYWdnaW5nKSB7XG4gICAgICAgIC8vX3BsYWNlaG9sZGVyRGl2IGp1c3QgcHJvcHMgb3BlbiBhdXRvLXNjcm9sbGluZyBjb250YWluZXJzIHNvIHRoZXkgZG9uJ3QgY29sbGFwc2UgYXMgdGhlIHVzZXIgZHJhZ3MgbGVmdC91cC4gV2UgcmVtb3ZlIGl0IGFmdGVyIGRyYWdnaW5nIChhbmQgdGhyb3dpbmcsIGlmIG5lY2Vzc2FyeSkgZmluaXNoZXMuXG4gICAgICAgIF9wbGFjZWhvbGRlckRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9wbGFjZWhvbGRlckRpdik7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgd2hlbiB0aGUgbW91c2UgaXMgcHJlc3NlZCAob3IgdG91Y2ggc3RhcnRzKVxuICAgIG9uUHJlc3MgPSBmdW5jdGlvbiBvblByZXNzKGUsIGZvcmNlKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYgKCFlbmFibGVkIHx8IHNlbGYuaXNQcmVzc2VkIHx8ICFlIHx8IChlLnR5cGUgPT09IFwibW91c2Vkb3duXCIgfHwgZS50eXBlID09PSBcInBvaW50ZXJkb3duXCIpICYmICFmb3JjZSAmJiBfZ2V0VGltZSgpIC0gY2xpY2tUaW1lIDwgMzAgJiYgX3RvdWNoRXZlbnRMb29rdXBbc2VsZi5wb2ludGVyRXZlbnQudHlwZV0pIHtcbiAgICAgICAgLy93aGVuIHdlIERPTidUIHByZXZlbnREZWZhdWx0KCkgaW4gb3JkZXIgdG8gYWNjb21tb2RhdGUgdG91Y2gtc2Nyb2xsaW5nIGFuZCB0aGUgdXNlciBqdXN0IHRhcHMsIG1hbnkgYnJvd3NlcnMgYWxzbyBmaXJlIGEgbW91c2Vkb3duL21vdXNldXAgc2VxdWVuY2UgQUZURVIgdGhlIHRvdWNoc3RhcnQvdG91Y2hlbmQgc2VxdWVuY2UsIHRodXMgaXQnZCByZXN1bHQgaW4gdHdvIHF1aWNrIFwiY2xpY2tcIiBldmVudHMgYmVpbmcgZGlzcGF0Y2hlZC4gVGhpcyBsaW5lIHNlbnNlcyB0aGF0IGNvbmRpdGlvbiBhbmQgaGFsdHMgaXQgb24gdGhlIHN1YnNlcXVlbnQgbW91c2Vkb3duLlxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ICYmIGUgJiYgZW5hYmxlZCAmJiBfcHJldmVudERlZmF1bHQoZSk7IC8vIGluIHNvbWUgYnJvd3NlcnMsIHdlIG11c3QgbGlzdGVuIGZvciBtdWx0aXBsZSBldmVudCB0eXBlcyBsaWtlIHRvdWNoc3RhcnQsIHBvaW50ZXJkb3duLCBtb3VzZWRvd24uIFRoZSBmaXJzdCB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB3ZSByZWNvcmQgd2hldGhlciBvciBub3Qgd2UgX3ByZXZlbnREZWZhdWx0KCkgc28gdGhhdCBvbiBkdXBsaWNhdGUgY2FsbHMsIHdlIGNhbiBkbyB0aGUgc2FtZSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbnRlcnJ1cHRlZCA9IGlzVHdlZW5pbmcoKTtcbiAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gZTtcblxuICAgICAgaWYgKF90b3VjaEV2ZW50TG9va3VwW2UudHlwZV0pIHtcbiAgICAgICAgLy9ub3RlOiBvbiBpT1MsIEJPVEggdG91Y2htb3ZlIGFuZCBtb3VzZW1vdmUgYXJlIGRpc3BhdGNoZWQsIGJ1dCB0aGUgbW91c2Vtb3ZlIGhhcyBwYWdlWSBhbmQgcGFnZVggb2YgMCB3aGljaCB3b3VsZCBtZXNzIHVwIHRoZSBjYWxjdWxhdGlvbnMgYW5kIG5lZWRsZXNzbHkgaHVydCBwZXJmb3JtYW5jZS5cbiAgICAgICAgdG91Y2hFdmVudFRhcmdldCA9IH5lLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID8gZS5jdXJyZW50VGFyZ2V0IHx8IGUudGFyZ2V0IDogb3duZXJEb2M7IC8vcG9pbnRlci1iYXNlZCB0b3VjaGVzIChmb3IgTWljcm9zb2Z0IGJyb3dzZXJzKSBkb24ndCByZW1haW4gbG9ja2VkIHRvIHRoZSBvcmlnaW5hbCB0YXJnZXQgbGlrZSBvdGhlciBicm93c2Vycywgc28gd2UgbXVzdCB1c2UgdGhlIGRvY3VtZW50IGluc3RlYWQuIFRoZSBldmVudCB0eXBlIHdvdWxkIGJlIFwiTVNQb2ludGVyRG93blwiIG9yIFwicG9pbnRlcmRvd25cIi5cblxuICAgICAgICBfYWRkTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGVuZFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNobW92ZVwiLCBvbk1vdmUpOyAvLyBwb3NzaWJsZSBmdXR1cmUgY2hhbmdlIGlmIFBvaW50ZXJFdmVudHMgYXJlIG1vcmUgc3RhbmRhcmRpemVkOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9zZXRQb2ludGVyQ2FwdHVyZVxuXG5cbiAgICAgICAgX2FkZExpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwidG91Y2hzdGFydFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG91Y2hFdmVudFRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNlbW92ZVwiLCBvbk1vdmUpOyAvL2F0dGFjaCB0aGVzZSB0byB0aGUgZG9jdW1lbnQgaW5zdGVhZCBvZiB0aGUgYm94IGl0c2VsZiBzbyB0aGF0IGlmIHRoZSB1c2VyJ3MgbW91c2UgbW92ZXMgdG9vIHF1aWNrbHkgKGFuZCBvZmYgb2YgdGhlIGJveCksIHRoaW5ncyBzdGlsbCB3b3JrLlxuXG4gICAgICB9XG5cbiAgICAgIHRvdWNoRHJhZ0F4aXMgPSBudWxsO1xuXG4gICAgICBpZiAoIV9zdXBwb3J0c1BvaW50ZXIgfHwgIXRvdWNoRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNldXBcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBlICYmIGUudGFyZ2V0ICYmIF9hZGRMaXN0ZW5lcihlLnRhcmdldCwgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7IC8vd2UgYWxzbyBoYXZlIHRvIGxpc3RlbiBkaXJlY3RseSBvbiB0aGUgZWxlbWVudCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgZG9uJ3QgYnViYmxlIHVwIHRoZSBldmVudCB0byB0aGUgX2RvYyBvbiBlbGVtZW50cyB3aXRoIGNvbnRlbnRFZGl0YWJsZT1cInRydWVcIlxuICAgICAgfVxuXG4gICAgICBpc0NsaWNraW5nID0gaXNDbGlja2FibGUuY2FsbChzZWxmLCBlLnRhcmdldCkgJiYgdmFycy5kcmFnQ2xpY2thYmxlcyA9PT0gZmFsc2UgJiYgIWZvcmNlO1xuXG4gICAgICBpZiAoaXNDbGlja2luZykge1xuICAgICAgICBfYWRkTGlzdGVuZXIoZS50YXJnZXQsIFwiY2hhbmdlXCIsIG9uUmVsZWFzZSk7IC8vaW4gc29tZSBicm93c2Vycywgd2hlbiB5b3UgbW91c2Vkb3duIG9uIGEgPHNlbGVjdD4gZWxlbWVudCwgbm8gbW91c2V1cCBnZXRzIGRpc3BhdGNoZWQhIFNvIHdlIGxpc3RlbiBmb3IgYSBcImNoYW5nZVwiIGV2ZW50IGluc3RlYWQuXG5cblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInByZXNzSW5pdFwiLCBcIm9uUHJlc3NJbml0XCIpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NcIiwgXCJvblByZXNzXCIpO1xuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCB0cnVlKTsgLy9hY2NvbW1vZGF0ZXMgdGhpbmdzIGxpa2UgaW5wdXRzIGFuZCBlbGVtZW50cyB3aXRoIGNvbnRlbnRFZGl0YWJsZT1cInRydWVcIiAob3RoZXJ3aXNlIHVzZXIgY291bGRuJ3QgZHJhZyB0byBzZWxlY3QgdGV4dClcblxuXG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID0gIXRvdWNoRXZlbnRUYXJnZXQgfHwgYWxsb3dYID09PSBhbGxvd1kgfHwgc2VsZi52YXJzLmFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IGZhbHNlIHx8IHNlbGYudmFycy5hbGxvd0NvbnRleHRNZW51ICYmIGUgJiYgKGUuY3RybEtleSB8fCBlLndoaWNoID4gMikgPyBmYWxzZSA6IGFsbG93WCA/IFwieVwiIDogXCJ4XCI7IC8vbm90ZTogaW4gQ2hyb21lLCByaWdodC1jbGlja2luZyAoZm9yIGEgY29udGV4dCBtZW51KSBmaXJlcyBvblByZXNzIGFuZCBpdCBkb2Vzbid0IGhhdmUgdGhlIGV2ZW50LndoaWNoIHNldCBwcm9wZXJseSwgc28gd2UgbXVzdCBsb29rIGZvciBldmVudC5jdHJsS2V5LiBJZiB0aGUgdXNlciB3YW50cyB0byBhbGxvdyBjb250ZXh0IG1lbnVzIHdlIHNob3VsZCBvZiBjb3Vyc2Ugc2Vuc2UgaXQgaGVyZSBhbmQgbm90IGFsbG93IG5hdGl2ZSB0b3VjaCBzY3JvbGxpbmcuXG5cbiAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSAhYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyAmJiAhc2VsZi5hbGxvd0V2ZW50RGVmYXVsdDtcblxuICAgICAgaWYgKGlzUHJldmVudGluZ0RlZmF1bHQpIHtcbiAgICAgICAgX3ByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihfd2luLCBcInRvdWNoZm9yY2VjaGFuZ2VcIiwgX3ByZXZlbnREZWZhdWx0KTsgLy93b3JrcyBhcm91bmQgc2FmYXJpIGJ1ZzogaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMTQ1MC1kcmFnZ2FibGUtaW4taWZyYW1lLW9uLW1vYmlsZS1pcy1idWdneS9cblxuICAgICAgfVxuXG4gICAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICAvL3RvdWNoIGV2ZW50cyBzdG9yZSB0aGUgZGF0YSBzbGlnaHRseSBkaWZmZXJlbnRseVxuICAgICAgICBlID0gdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB0b3VjaElEID0gZS5pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJJZCkge1xuICAgICAgICB0b3VjaElEID0gZS5wb2ludGVySWQ7IC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3VjaCA9IHRvdWNoSUQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBfZHJhZ0NvdW50Kys7XG5cbiAgICAgIF9hZGRUb1JlbmRlclF1ZXVlKHJlbmRlcik7IC8vY2F1c2VzIHRoZSBEcmFnZ2FibGUgdG8gcmVuZGVyIG9uIGVhY2ggXCJ0aWNrXCIgb2YgVHdlZW5MaXRlLnRpY2tlciAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIC0gdXBkYXRpbmcgdmFsdWVzIGluIGEgbW91c2Vtb3ZlIGNhbiBjYXVzZSB0aGVtIHRvIGhhcHBlbiB0b28gZnJlcXVlbnRseSwgbGlrZSBtdWx0aXBsZSB0aW1lcyBiZXR3ZWVuIGZyYW1lIHJlZHJhd3Mgd2hpY2ggaXMgd2FzdGVmdWwsIGFuZCBpdCBhbHNvIHByZXZlbnRzIHZhbHVlcyBmcm9tIHVwZGF0aW5nIHByb3Blcmx5IGluIElFOClcblxuXG4gICAgICBzdGFydFBvaW50ZXJZID0gc2VsZi5wb2ludGVyWSA9IGUucGFnZVk7IC8vcmVjb3JkIHRoZSBzdGFydGluZyB4IGFuZCB5IHNvIHRoYXQgd2UgY2FuIGNhbGN1bGF0ZSB0aGUgbW92ZW1lbnQgZnJvbSB0aGUgb3JpZ2luYWwgaW4gX29uTW91c2VNb3ZlXG5cbiAgICAgIHN0YXJ0UG9pbnRlclggPSBzZWxmLnBvaW50ZXJYID0gZS5wYWdlWDtcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc0luaXRcIiwgXCJvblByZXNzSW5pdFwiKTtcblxuICAgICAgaWYgKGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgc2VsZi5hdXRvU2Nyb2xsKSB7XG4gICAgICAgIF9yZWNvcmRNYXhTY3JvbGxzKHRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldC5wYXJlbnROb2RlICYmIHNlbGYuYXV0b1Njcm9sbCAmJiAhc2Nyb2xsUHJveHkgJiYgIXJvdGF0aW9uTW9kZSAmJiB0YXJnZXQucGFyZW50Tm9kZS5fZ3NNYXhTY3JvbGxYICYmICFfcGxhY2Vob2xkZXJEaXYucGFyZW50Tm9kZSAmJiAhdGFyZ2V0LmdldEJCb3gpIHtcbiAgICAgICAgLy9hZGQgYSBwbGFjZWhvbGRlciBkaXYgdG8gcHJldmVudCB0aGUgcGFyZW50IGNvbnRhaW5lciBmcm9tIGNvbGxhcHNpbmcgd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgZWxlbWVudCBsZWZ0LlxuICAgICAgICBfcGxhY2Vob2xkZXJEaXYuc3R5bGUud2lkdGggPSB0YXJnZXQucGFyZW50Tm9kZS5zY3JvbGxXaWR0aCArIFwicHhcIjtcbiAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoX3BsYWNlaG9sZGVyRGl2KTtcbiAgICAgIH1cblxuICAgICAgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIHNlbGYudHdlZW4gJiYgc2VsZi50d2Vlbi5raWxsKCk7XG4gICAgICBzZWxmLmlzVGhyb3dpbmcgPSBmYWxzZTtcbiAgICAgIGdzYXAua2lsbFR3ZWVuc09mKHNjcm9sbFByb3h5IHx8IHRhcmdldCwga2lsbFByb3BzLCB0cnVlKTsgLy9pbiBjYXNlIHRoZSB1c2VyIHRyaWVzIHRvIGRyYWcgaXQgYmVmb3JlIHRoZSBsYXN0IHR3ZWVuIGlzIGRvbmUuXG5cbiAgICAgIHNjcm9sbFByb3h5ICYmIGdzYXAua2lsbFR3ZWVuc09mKHRhcmdldCwge1xuICAgICAgICBzY3JvbGxUbzogMVxuICAgICAgfSwgdHJ1ZSk7IC8vanVzdCBpbiBjYXNlIHRoZSBvcmlnaW5hbCB0YXJnZXQncyBzY3JvbGwgcG9zaXRpb24gaXMgYmVpbmcgdHdlZW5lZCBzb21ld2hlcmUgZWxzZS5cblxuICAgICAgc2VsZi50d2VlbiA9IHNlbGYubG9ja2VkQXhpcyA9IG51bGw7XG5cbiAgICAgIGlmICh2YXJzLnpJbmRleEJvb3N0IHx8ICFyb3RhdGlvbk1vZGUgJiYgIXNjcm9sbFByb3h5ICYmIHZhcnMuekluZGV4Qm9vc3QgIT09IGZhbHNlKSB7XG4gICAgICAgIHRhcmdldC5zdHlsZS56SW5kZXggPSBEcmFnZ2FibGUuekluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuaXNQcmVzc2VkID0gdHJ1ZTtcbiAgICAgIGhhc0RyYWdDYWxsYmFjayA9ICEhKHZhcnMub25EcmFnIHx8IHNlbGYuX2xpc3RlbmVycy5kcmFnKTtcbiAgICAgIGhhc01vdmVDYWxsYmFjayA9ICEhKHZhcnMub25Nb3ZlIHx8IHNlbGYuX2xpc3RlbmVycy5tb3ZlKTtcblxuICAgICAgaWYgKHZhcnMuY3Vyc29yICE9PSBmYWxzZSB8fCB2YXJzLmFjdGl2ZUN1cnNvcikge1xuICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgIGdzYXAuc2V0KHRyaWdnZXJzW2ldLCB7XG4gICAgICAgICAgICBjdXJzb3I6IHZhcnMuYWN0aXZlQ3Vyc29yIHx8IHZhcnMuY3Vyc29yIHx8IChfZGVmYXVsdEN1cnNvciA9PT0gXCJncmFiXCIgPyBcImdyYWJiaW5nXCIgOiBfZGVmYXVsdEN1cnNvcilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInByZXNzXCIsIFwib25QcmVzc1wiKTtcbiAgICB9LFxuICAgICAgICAvL2NhbGxlZCBldmVyeSB0aW1lIHRoZSBtb3VzZS90b3VjaCBtb3Zlc1xuICAgIG9uTW92ZSA9IGZ1bmN0aW9uIG9uTW92ZShlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGUsXG4gICAgICAgICAgdG91Y2hlcyxcbiAgICAgICAgICBwb2ludGVyWCxcbiAgICAgICAgICBwb2ludGVyWSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGR4LFxuICAgICAgICAgIGR5O1xuXG4gICAgICBpZiAoIWVuYWJsZWQgfHwgX2lzTXVsdGlUb3VjaGluZyB8fCAhc2VsZi5pc1ByZXNzZWQgfHwgIWUpIHtcbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCAmJiBlICYmIGVuYWJsZWQgJiYgX3ByZXZlbnREZWZhdWx0KGUpOyAvLyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBtdXN0IGxpc3RlbiBmb3IgbXVsdGlwbGUgZXZlbnQgdHlwZXMgbGlrZSB0b3VjaG1vdmUsIHBvaW50ZXJtb3ZlLCBtb3VzZW1vdmUuIFRoZSBmaXJzdCB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB3ZSByZWNvcmQgd2hldGhlciBvciBub3Qgd2UgX3ByZXZlbnREZWZhdWx0KCkgc28gdGhhdCBvbiBkdXBsaWNhdGUgY2FsbHMsIHdlIGNhbiBkbyB0aGUgc2FtZSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnBvaW50ZXJFdmVudCA9IGU7XG4gICAgICB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcblxuICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgLy90b3VjaCBldmVudHMgc3RvcmUgdGhlIGRhdGEgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgICAgICAgZSA9IHRvdWNoZXNbMF07XG5cbiAgICAgICAgaWYgKGUgIT09IHRvdWNoICYmIGUuaWRlbnRpZmllciAhPT0gdG91Y2hJRCkge1xuICAgICAgICAgIC8vVXN1YWxseSBjaGFuZ2VkVG91Y2hlc1swXSB3aWxsIGJlIHdoYXQgd2UncmUgbG9va2luZyBmb3IsIGJ1dCBpbiBjYXNlIGl0J3Mgbm90LCBsb29rIHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGFycmF5Li4uKGFuZCBBbmRyb2lkIGJyb3dzZXJzIGRvbid0IHJldXNlIHRoZSBldmVudCBsaWtlIGlPUylcbiAgICAgICAgICBpID0gdG91Y2hlcy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoLS1pID4gLTEgJiYgKGUgPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyICE9PSB0b3VjaElEICYmIGUudGFyZ2V0ICE9PSB0YXJnZXQpIHt9IC8vIFNvbWUgQW5kcm9pZCBkZXZpY2VzIGRpc3BhdGNoIGEgdG91Y2hzdGFydCBBTkQgcG9pbnRlcmRvd24gaW5pdGlhbGx5LCBhbmQgdGhlbiBvbmx5IHBvaW50ZXJtb3ZlIHRodXMgdGhlIHRvdWNoSUQgbWF5IG5vdCBtYXRjaCBiZWNhdXNlIGl0IHdhcyBncmFiYmVkIGZyb20gdGhlIHRvdWNoc3RhcnQgZXZlbnQgd2hlcmVhcyB0aGUgcG9pbnRlciBldmVudCBpcyB0aGUgb25lIHRoYXQgdGhlIGJyb3dzZXIgZGlzcGF0Y2hlcyBmb3IgbW92ZSwgc28gaWYgdGhlIGV2ZW50IHRhcmdldCBtYXRjaGVzIHRoaXMgRHJhZ2dhYmxlJ3MgdGFyZ2V0LCBsZXQgaXQgdGhyb3VnaC5cblxuXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUucG9pbnRlcklkICYmIHRvdWNoSUQgJiYgZS5wb2ludGVySWQgIT09IHRvdWNoSUQpIHtcbiAgICAgICAgLy9mb3Igc29tZSBNaWNyb3NvZnQgYnJvd3NlcnMsIHdlIG11c3QgYXR0YWNoIHRoZSBsaXN0ZW5lciB0byB0aGUgZG9jIHJhdGhlciB0aGFuIHRoZSB0cmlnZ2VyIHNvIHRoYXQgd2hlbiB0aGUgZmluZ2VyIG1vdmVzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgdHJpZ2dlciwgdGhpbmdzIHN0aWxsIHdvcmsuIFNvIGlmIHRoZSBldmVudCB3ZSdyZSByZWNlaXZpbmcgaGFzIGEgcG9pbnRlcklkIHRoYXQgZG9lc24ndCBtYXRjaCB0aGUgdG91Y2hJRCwgaWdub3JlIGl0IChmb3IgbXVsdGktdG91Y2gpXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvdWNoRXZlbnRUYXJnZXQgJiYgYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyAmJiAhdG91Y2hEcmFnQXhpcykge1xuICAgICAgICAvL0FuZHJvaWQgYnJvd3NlcnMgZm9yY2UgdXMgdG8gZGVjaWRlIG9uIHRoZSBmaXJzdCBcInRvdWNobW92ZVwiIGV2ZW50IGlmIHdlIHNob3VsZCBhbGxvdyB0aGUgZGVmYXVsdCAoc2Nyb2xsaW5nKSBiZWhhdmlvciBvciBwcmV2ZW50RGVmYXVsdCgpLiBPdGhlcndpc2UsIGEgXCJ0b3VjaGNhbmNlbFwiIHdpbGwgYmUgZmlyZWQgYW5kIHRoZW4gbm8gXCJ0b3VjaG1vdmVcIiBvciBcInRvdWNoZW5kXCIgd2lsbCBmaXJlIGR1cmluZyB0aGUgc2Nyb2xsaW5nIChubyBnb29kKS5cbiAgICAgICAgX3BvaW50MS54ID0gZS5wYWdlWCAtIChpc0ZpeGVkID8gX2dldERvY1Njcm9sbExlZnQob3duZXJEb2MpIDogMCk7XG4gICAgICAgIF9wb2ludDEueSA9IGUucGFnZVkgLSAoaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxUb3Aob3duZXJEb2MpIDogMCk7XG4gICAgICAgIG1hdHJpeCAmJiBtYXRyaXguYXBwbHkoX3BvaW50MSwgX3BvaW50MSk7XG4gICAgICAgIHBvaW50ZXJYID0gX3BvaW50MS54O1xuICAgICAgICBwb2ludGVyWSA9IF9wb2ludDEueTtcbiAgICAgICAgZHggPSBNYXRoLmFicyhwb2ludGVyWCAtIHN0YXJ0UG9pbnRlclgpO1xuICAgICAgICBkeSA9IE1hdGguYWJzKHBvaW50ZXJZIC0gc3RhcnRQb2ludGVyWSk7XG5cbiAgICAgICAgaWYgKGR4ICE9PSBkeSAmJiAoZHggPiBtaW5pbXVtTW92ZW1lbnQgfHwgZHkgPiBtaW5pbXVtTW92ZW1lbnQpIHx8IF9pc0FuZHJvaWQgJiYgYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyA9PT0gdG91Y2hEcmFnQXhpcykge1xuICAgICAgICAgIHRvdWNoRHJhZ0F4aXMgPSBkeCAIGR5ICYmIGFsbG93WCA/IFwieFwiIDogXCJ5XCI7XG5cbiAgICAgICAgICBpZiAoYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyAmJiB0b3VjaERyYWdBeGlzICE9PSBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaGZvcmNlY2hhbmdlXCIsIF9wcmV2ZW50RGVmYXVsdCk7IC8vIHByZXZlbnRzIG5hdGl2ZSB0b3VjaCBzY3JvbGxpbmcgZnJvbSB0YWtpbmcgb3ZlciBpZiB0aGUgdXNlciBzdGFydGVkIGRyYWdnaW5nIGluIHRoZSBvdGhlciBkaXJlY3Rpb24gaW4gaU9TIFNhZmFyaVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYudmFycy5sb2NrQXhpc09uVG91Y2hTY3JvbGwgIT09IGZhbHNlICYmIGFsbG93WCAmJiBhbGxvd1kpIHtcbiAgICAgICAgICAgIHNlbGYubG9ja2VkQXhpcyA9IHRvdWNoRHJhZ0F4aXMgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbiAgICAgICAgICAgIF9pc0Z1bmN0aW9uKHNlbGYudmFycy5vbkxvY2tBeGlzKSAmJiBzZWxmLnZhcnMub25Mb2NrQXhpcy5jYWxsKHNlbGYsIG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfaXNBbmRyb2lkICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IHRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgICAgIG9uUmVsZWFzZShvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLmFsbG93RXZlbnREZWZhdWx0ICYmICghYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyB8fCB0b3VjaERyYWdBeGlzICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgIT09IHRvdWNoRHJhZ0F4aXMpICYmIG9yaWdpbmFsRXZlbnQuY2FuY2VsYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3ByZXZlbnREZWZhdWx0KG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc1ByZXZlbnRpbmdEZWZhdWx0KSB7XG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuYXV0b1Njcm9sbCkge1xuICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzZXRQb2ludGVyUG9zaXRpb24oZS5wYWdlWCwgZS5wYWdlWSwgaGFzTW92ZUNhbGxiYWNrKTtcbiAgICB9LFxuICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24gPSBmdW5jdGlvbiBzZXRQb2ludGVyUG9zaXRpb24ocG9pbnRlclgsIHBvaW50ZXJZLCBpbnZva2VPbk1vdmUpIHtcbiAgICAgIHZhciBkcmFnVG9sZXJhbmNlID0gMSAtIHNlbGYuZHJhZ1Jlc2lzdGFuY2UsXG4gICAgICAgICAgZWRnZVRvbGVyYW5jZSA9IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlLFxuICAgICAgICAgIHByZXZQb2ludGVyWCA9IHNlbGYucG9pbnRlclgsXG4gICAgICAgICAgcHJldlBvaW50ZXJZID0gc2VsZi5wb2ludGVyWSxcbiAgICAgICAgICBwcmV2U3RhcnRFbGVtZW50WSA9IHN0YXJ0RWxlbWVudFksXG4gICAgICAgICAgcHJldlggPSBzZWxmLngsXG4gICAgICAgICAgcHJldlkgPSBzZWxmLnksXG4gICAgICAgICAgcHJldkVuZFggPSBzZWxmLmVuZFgsXG4gICAgICAgICAgcHJldkVuZFkgPSBzZWxmLmVuZFksXG4gICAgICAgICAgcHJldkVuZFJvdGF0aW9uID0gc2VsZi5lbmRSb3RhdGlvbixcbiAgICAgICAgICBwcmV2RGlydHkgPSBkaXJ0eSxcbiAgICAgICAgICB4Q2hhbmdlLFxuICAgICAgICAgIHlDaGFuZ2UsXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIGRpZixcbiAgICAgICAgICB0ZW1wO1xuICAgICAgc2VsZi5wb2ludGVyWCA9IHBvaW50ZXJYO1xuICAgICAgc2VsZi5wb2ludGVyWSA9IHBvaW50ZXJZO1xuXG4gICAgICBpZiAoaXNGaXhlZCkge1xuICAgICAgICBwb2ludGVyWCAtPSBfZ2V0RG9jU2Nyb2xsTGVmdChvd25lckRvYyk7XG4gICAgICAgIHBvaW50ZXJZIC09IF9nZXREb2NTY3JvbGxUb3Aob3duZXJEb2MpO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgIHkgPSBNYXRoLmF0YW4yKHJvdGF0aW9uT3JpZ2luLnkgLSBwb2ludGVyWSwgcG9pbnRlclggLSByb3RhdGlvbk9yaWdpbi54KSAqIF9SQUQyREVHO1xuICAgICAgICBkaWYgPSBzZWxmLnkgLSB5O1xuXG4gICAgICAgIGlmIChkaWYgPiAxODApIHtcbiAgICAgICAgICBzdGFydEVsZW1lbnRZIC09IDM2MDtcbiAgICAgICAgICBzZWxmLnkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKGRpZiA8IC0xODApIHtcbiAgICAgICAgICBzdGFydEVsZW1lbnRZICs9IDM2MDtcbiAgICAgICAgICBzZWxmLnkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYueCAhPT0gc3RhcnRFbGVtZW50WCB8fCBNYXRoLmFicyhzdGFydEVsZW1lbnRZIC0geSkgPiBtaW5pbXVtTW92ZW1lbnQpIHtcbiAgICAgICAgICBzZWxmLnkgPSB5O1xuICAgICAgICAgIHggPSBzdGFydEVsZW1lbnRYICsgKHN0YXJ0RWxlbWVudFkgLSB5KSAqIGRyYWdUb2xlcmFuY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHN0YXJ0RWxlbWVudFg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICB0ZW1wID0gcG9pbnRlclggKiBtYXRyaXguYSArIHBvaW50ZXJZICogbWF0cml4LmMgKyBtYXRyaXguZTtcbiAgICAgICAgICBwb2ludGVyWSA9IHBvaW50ZXJYICogbWF0cml4LmIgKyBwb2ludGVyWSAqIG1hdHJpeC5kICsgbWF0cml4LmY7XG4gICAgICAgICAgcG9pbnRlclggPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgeUNoYW5nZSA9IHBvaW50ZXJZIC0gc3RhcnRQb2ludGVyWTtcbiAgICAgICAgeENoYW5nZSA9IHBvaW50ZXJYIC0gc3RhcnRQb2ludGVyWDtcblxuICAgICAgICBpZiAoeUNoYW5nZSA8IG1pbmltdW1Nb3ZlbWVudCAmJiB5Q2hhbmdlID4gLW1pbmltdW1Nb3ZlbWVudCkge1xuICAgICAgICAgIHlDaGFuZ2UgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHhDaGFuZ2UgPCBtaW5pbXVtTW92ZW1lbnQgJiYgeENoYW5nZSAIC1taW5pbXVtTW92ZW1lbnQpIHtcbiAgICAgICAgICB4Q2hhbmdlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoc2VsZi5sb2NrQXhpcyB8fCBzZWxmLmxvY2tlZEF4aXMpICYmICh4Q2hhbmdlIHx8IHlDaGFuZ2UpKSB7XG4gICAgICAgICAgdGVtcCA9IHNlbGYubG9ja2VkQXhpcztcblxuICAgICAgICAgIGlmICghdGVtcCkge1xuICAgICAgICAgICAgc2VsZi5sb2NrZWRBeGlzID0gdGVtcCA9IGFsbG93WCAmJiBNYXRoLmFicyh4Q2hhbmdlKSAIE1hdGguYWJzKHlDaGFuZ2UpID8gXCJ5XCIgOiBhbGxvd1kgPyBcInhcIiA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0ZW1wICYmIF9pc0Z1bmN0aW9uKHNlbGYudmFycy5vbkxvY2tBeGlzKSkge1xuICAgICAgICAgICAgICBzZWxmLnZhcnMub25Mb2NrQXhpcy5jYWxsKHNlbGYsIHNlbGYucG9pbnRlckV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGVtcCA9PT0gXCJ5XCIpIHtcbiAgICAgICAgICAgIHlDaGFuZ2UgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGVtcCA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHhDaGFuZ2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBfcm91bmQoc3RhcnRFbGVtZW50WCArIHhDaGFuZ2UgKiBkcmFnVG9sZXJhbmNlKTtcbiAgICAgICAgeSA9IF9yb3VuZChzdGFydEVsZW1lbnRZICsgeUNoYW5nZSAqIGRyYWdUb2xlcmFuY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHNuYXBYIHx8IHNuYXBZIHx8IHNuYXBYWSkgJiYgKHNlbGYueCAhPT0geCB8fCBzZWxmLnkgIT09IHkgJiYgIXJvdGF0aW9uTW9kZSkpIHtcbiAgICAgICAgaWYgKHNuYXBYWSkge1xuICAgICAgICAgIF90ZW1wMS54ID0geDtcbiAgICAgICAgICBfdGVtcDEueSA9IHk7XG4gICAgICAgICAgdGVtcCA9IHNuYXBYWShfdGVtcDEpO1xuICAgICAgICAgIHggPSBfcm91bmQodGVtcC54KTtcbiAgICAgICAgICB5ID0gX3JvdW5kKHRlbXAueSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFgpIHtcbiAgICAgICAgICB4ID0gX3JvdW5kKHNuYXBYKHgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbmFwWSkge1xuICAgICAgICAgIHkgPSBfcm91bmQoc25hcFkoeSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNCb3VuZHMpIHtcbiAgICAgICAgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgICAgeCA9IG1heFggKyBNYXRoLnJvdW5kKCh4IC0gbWF4WCkgKiBlZGdlVG9sZXJhbmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh4IDwgbWluWCkge1xuICAgICAgICAgIHggPSBtaW5YICsgTWF0aC5yb3VuZCgoeCAtIG1pblgpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgIGlmICh5ID4gbWF4WSkge1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQobWF4WSArICh5IC0gbWF4WSkgKiBlZGdlVG9sZXJhbmNlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChtaW5ZICsgKHkgLSBtaW5ZKSAqIGVkZ2VUb2xlcmFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi54ICE9PSB4IHx8IHNlbGYueSAhPT0geSAmJiAhcm90YXRpb25Nb2RlKSB7XG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0gc2VsZi54ID0gc2VsZi5lbmRYID0geDtcbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgc2VsZi55ID0gc2VsZi5lbmRZID0geTtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTsgLy9hIGZsYWcgdGhhdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byByZW5kZXIgdGhlIHRhcmdldCBuZXh0IHRpbWUgdGhlIFR3ZWVuTGl0ZS50aWNrZXIgZGlzcGF0Y2hlcyBhIFwidGlja1wiIGV2ZW50ICh0eXBpY2FsbHkgb24gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIC0gdGhpcyBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAod2Ugc2hvdWxkbid0IHJlbmRlciBvbiBldmVyeSBtb3ZlIGJlY2F1c2Ugc29tZXRpbWVzIG1hbnkgbW92ZSBldmVudHMgY2FuIGdldCBkaXNwYXRjaGVkIGJldHdlZW4gc2NyZWVuIHJlZnJlc2hlcywgYW5kIHRoYXQnZCBiZSB3YXN0ZWZ1bCB0byByZW5kZXIgZXZlcnkgdGltZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICBzZWxmLnggPSBzZWxmLmVuZFggPSB4O1xuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW52b2tlT25Nb3ZlIHx8IF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwibW92ZVwiLCBcIm9uTW92ZVwiKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoIXNlbGYuaXNEcmFnZ2luZyAmJiBzZWxmLmlzUHJlc3NlZCkge1xuICAgICAgICAgICAgc2VsZi5pc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkcmFnc3RhcnRcIiwgXCJvbkRyYWdTdGFydFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9yZXZlcnQgYmVjYXVzZSB0aGUgb25Nb3ZlIHJldHVybmVkIGZhbHNlIVxuICAgICAgICAgIHNlbGYucG9pbnRlclggPSBwcmV2UG9pbnRlclg7XG4gICAgICAgICAgc2VsZi5wb2ludGVyWSA9IHByZXZQb2ludGVyWTtcbiAgICAgICAgICBzdGFydEVsZW1lbnRZID0gcHJldlN0YXJ0RWxlbWVudFk7XG4gICAgICAgICAgc2VsZi54ID0gcHJldlg7XG4gICAgICAgICAgc2VsZi55ID0gcHJldlk7XG4gICAgICAgICAgc2VsZi5lbmRYID0gcHJldkVuZFg7XG4gICAgICAgICAgc2VsZi5lbmRZID0gcHJldkVuZFk7XG4gICAgICAgICAgc2VsZi5lbmRSb3RhdGlvbiA9IHByZXZFbmRSb3RhdGlvbjtcbiAgICAgICAgICBkaXJ0eSA9IHByZXZEaXJ0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgICAgIC8vY2FsbGVkIHdoZW4gdGhlIG1vdXNlL3RvdWNoIGlzIHJlbGVhc2VkXG4gICAgb25SZWxlYXNlID0gZnVuY3Rpb24gb25SZWxlYXNlKGUsIGZvcmNlKSB7XG4gICAgICBpZiAoIWVuYWJsZWQgfHwgIXNlbGYuaXNQcmVzc2VkIHx8IGUgJiYgdG91Y2hJRCAhPSBudWxsICYmICFmb3JjZSAmJiAoZS5wb2ludGVySWQgJiYgZS5wb2ludGVySWQgIT09IHRvdWNoSUQgJiYgZS50YXJnZXQgIT09IHRhcmdldCB8fCBlLmNoYW5nZWRUb3VjaGVzICYmICFfaGFzVG91Y2hJRChlLmNoYW5nZWRUb3VjaGVzLCB0b3VjaElEKSkpIHtcbiAgICAgICAgLy9mb3Igc29tZSBNaWNyb3NvZnQgYnJvd3NlcnMsIHdlIG11c3QgYXR0YWNoIHRoZSBsaXN0ZW5lciB0byB0aGUgZG9jIHJhdGhlciB0aGFuIHRoZSB0cmlnZ2VyIHNvIHRoYXQgd2hlbiB0aGUgZmluZ2VyIG1vdmVzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgdHJpZ2dlciwgdGhpbmdzIHN0aWxsIHdvcmsuIFNvIGlmIHRoZSBldmVudCB3ZSdyZSByZWNlaXZpbmcgaGFzIGEgcG9pbnRlcklkIHRoYXQgZG9lc24ndCBtYXRjaCB0aGUgdG91Y2hJRCwgaWdub3JlIGl0IChmb3IgbXVsdGktdG91Y2gpXG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgJiYgZSAmJiBlbmFibGVkICYmIF9wcmV2ZW50RGVmYXVsdChlKTsgLy8gaW4gc29tZSBicm93c2Vycywgd2UgbXVzdCBsaXN0ZW4gZm9yIG11bHRpcGxlIGV2ZW50IHR5cGVzIGxpa2UgdG91Y2hlbmQsIHBvaW50ZXJ1cCwgbW91c2V1cC4gVGhlIGZpcnN0IHRpbWUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQsIHdlIHJlY29yZCB3aGV0aGVyIG9yIG5vdCB3ZSBfcHJldmVudERlZmF1bHQoKSBzbyB0aGF0IG9uIGR1cGxpY2F0ZSBjYWxscywgd2UgY2FuIGRvIHRoZSBzYW1lIGlmIG5lY2Vzc2FyeS5cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuaXNQcmVzc2VkID0gZmFsc2U7XG4gICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGUsXG4gICAgICAgICAgd2FzRHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmcsXG4gICAgICAgICAgaXNDb250ZXh0TWVudVJlbGVhc2UgPSBzZWxmLnZhcnMuYWxsb3dDb250ZXh0TWVudSAmJiBlICYmIChlLmN0cmxLZXkgfHwgZS53aGljaCAIDIpLFxuICAgICAgICAgIHBsYWNlaG9sZGVyRGVsYXllZENhbGwgPSBnc2FwLmRlbGF5ZWRDYWxsKDAuMDAxLCByZW1vdmVQbGFjZWhvbGRlciksXG4gICAgICAgICAgdG91Y2hlcyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHN5bnRoZXRpY0V2ZW50LFxuICAgICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICAgIHN5bnRoZXRpY0NsaWNrO1xuXG4gICAgICBpZiAodG91Y2hFdmVudFRhcmdldCkge1xuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGVuZFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNobW92ZVwiLCBvbk1vdmUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoY2FuY2VsXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcInRvdWNoc3RhcnRcIiwgX29uTXVsdGlUb3VjaERvY3VtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgIH1cblxuICAgICAgX3JlbW92ZUxpc3RlbmVyKF93aW4sIFwidG91Y2hmb3JjZWNoYW5nZVwiLCBfcHJldmVudERlZmF1bHQpO1xuXG4gICAgICBpZiAoIV9zdXBwb3J0c1BvaW50ZXIgfHwgIXRvdWNoRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNldXBcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBlICYmIGUudGFyZ2V0ICYmIF9yZW1vdmVMaXN0ZW5lcihlLnRhcmdldCwgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG4gICAgICB9XG5cbiAgICAgIGRpcnR5ID0gZmFsc2U7XG5cbiAgICAgIGlmICh3YXNEcmFnZ2luZykge1xuICAgICAgICBkcmFnRW5kVGltZSA9IF9sYXN0RHJhZ1RpbWUgPSBfZ2V0VGltZSgpO1xuICAgICAgICBzZWxmLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQ2xpY2tpbmcgJiYgIWlzQ29udGV4dE1lbnVSZWxlYXNlKSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKGUudGFyZ2V0LCBcImNoYW5nZVwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgICAgc2VsZi5wb2ludGVyRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIGZhbHNlKTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInJlbGVhc2VcIiwgXCJvblJlbGVhc2VcIik7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJjbGlja1wiLCBcIm9uQ2xpY2tcIik7XG5cbiAgICAgICAgaXNDbGlja2luZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF9yZW1vdmVGcm9tUmVuZGVyUXVldWUocmVuZGVyKTtcblxuICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKC0taSAIC0xKSB7XG4gICAgICAgIF9zZXRTdHlsZSh0cmlnZ2Vyc1tpXSwgXCJjdXJzb3JcIiwgdmFycy5jdXJzb3IgfHwgKHZhcnMuY3Vyc29yICE9PSBmYWxzZSA/IF9kZWZhdWx0Q3Vyc29yIDogbnVsbCkpO1xuICAgICAgfVxuXG4gICAgICBfZHJhZ0NvdW50LS07XG5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHRvdWNoZXMgPSBlLmNoYW5nZWRUb3VjaGVzO1xuXG4gICAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgICAgLy90b3VjaCBldmVudHMgc3RvcmUgdGhlIGRhdGEgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgICAgICAgICBlID0gdG91Y2hlc1swXTtcblxuICAgICAgICAgIGlmIChlICE9PSB0b3VjaCAmJiBlLmlkZW50aWZpZXIgIT09IHRvdWNoSUQpIHtcbiAgICAgICAgICAgIC8vVXN1YWxseSBjaGFuZ2VkVG91Y2hlc1swXSB3aWxsIGJlIHdoYXQgd2UncmUgbG9va2luZyBmb3IsIGJ1dCBpbiBjYXNlIGl0J3Mgbm90LCBsb29rIHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGFycmF5Li4uKGFuZCBBbmRyb2lkIGJyb3dzZXJzIGRvbid0IHJldXNlIHRoZSBldmVudCBsaWtlIGlPUylcbiAgICAgICAgICAgIGkgPSB0b3VjaGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKC0taSAIC0xICYmIChlID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0KSB7fVxuXG4gICAgICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG4gICAgICAgIHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDb250ZXh0TWVudVJlbGVhc2UgJiYgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbEV2ZW50ICYmICF3YXNEcmFnZ2luZykge1xuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGludGVycnVwdGVkICYmICh2YXJzLnNuYXAgfHwgdmFycy5ib3VuZHMpKSB7XG4gICAgICAgICAgLy9vdGhlcndpc2UsIGlmIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgb2JqZWN0IHdoaWxlIGl0J3MgYW5pbWF0aW5nIHRvIGEgc25hcHBlZCBwb3NpdGlvbiwgYW5kIHRoZW4gcmVsZWFzZXMgd2l0aG91dCBtb3ZpbmcgMyBwaXhlbHMsIGl0IHdpbGwganVzdCBzdGF5IHRoZXJlIChpdCBzaG91bGQgYW5pbWF0ZS9zbmFwKVxuICAgICAgICAgIGFuaW1hdGUodmFycy5pbmVydGlhIHx8IHZhcnMudGhyb3dQcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInJlbGVhc2VcIiwgXCJvblJlbGVhc2VcIik7XG5cbiAgICAgICAgaWYgKCghX2lzQW5kcm9pZCB8fCBvcmlnaW5hbEV2ZW50LnR5cGUgIT09IFwidG91Y2htb3ZlXCIpICYmIG9yaWdpbmFsRXZlbnQudHlwZS5pbmRleE9mKFwiY2FuY2VsXCIpID09PSAtMSkge1xuICAgICAgICAgIC8vdG8gYWNjb21tb2RhdGUgbmF0aXZlIHNjcm9sbGluZyBvbiBBbmRyb2lkIGRldmljZXMsIHdlIGhhdmUgdG8gaW1tZWRpYXRlbHkgY2FsbCBvblJlbGVhc2UoKSBvbiB0aGUgZmlyc3QgdG91Y2htb3ZlIGV2ZW50LCBidXQgdGhhdCBzaG91bGRuJ3QgdHJpZ2dlciBhIFwiY2xpY2tcIi5cbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImNsaWNrXCIsIFwib25DbGlja1wiKTtcblxuICAgICAgICAgIGlmIChfZ2V0VGltZSgpIC0gY2xpY2tUaW1lIDwgMzAwKSB7XG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRvdWJsZWNsaWNrXCIsIFwib25Eb3VibGVDbGlja1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBldmVudFRhcmdldCA9IG9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IHRhcmdldDsgLy9vbGQgSUUgdXNlcyBzcmNFbGVtZW50XG5cbiAgICAgICAgICBjbGlja1RpbWUgPSBfZ2V0VGltZSgpO1xuXG4gICAgICAgICAgc3ludGhldGljQ2xpY2sgPSBmdW5jdGlvbiBzeW50aGV0aWNDbGljaygpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgd29uJ3QgdHJ1c3Qgc2NyaXB0LWdlbmVyYXRlZCBjbGlja3MsIHNvIGlmIHRoZSB1c2VyIHRyaWVzIHRvIGNsaWNrIG9uIGEgdmlkZW8gdG8gcGxheSBpdCwgZm9yIGV4YW1wbGUsIGl0IHNpbXBseSB3b24ndCB3b3JrLiBTaW5jZSBhIHJlZ3VsYXIgXCJjbGlja1wiIGV2ZW50IHdpbGwgbW9zdCBsaWtlbHkgYmUgZ2VuZXJhdGVkIGFueXdheSAob25lIHRoYXQgaGFzIGl0cyBpc1RydXN0ZWQgZmxhZyBzZXQgdG8gdHJ1ZSksIHdlIG11c3Qgc2xpZ2h0bHkgZGVsYXkgb3VyIHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2sgc28gdGhhdCB0aGUgXCJyZWFsXCIvdHJ1c3RlZCBvbmUgaXMgcHJpb3JpdGl6ZWQuIFJlbWVtYmVyLCB3aGVuIHRoZXJlIGFyZSBkdXBsaWNhdGUgZXZlbnRzIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHdlIHN1cHByZXNzIGFsbCBidXQgdGhlIGZpcnN0IG9uZS4gU29tZSBicm93c2VycyBkb24ndCBldmVuIHRyaWdnZXIgdGhlIFwicmVhbFwiIG9uZSBhdCBhbGwsIHNvIG91ciBzeW50aGV0aWMgb25lIGlzIGEgc2FmZXR5IHZhbHZlIHRoYXQgZW5zdXJlcyB0aGF0IG5vIG1hdHRlciB3aGF0LCBhIGNsaWNrIGV2ZW50IGRvZXMgZ2V0IGRpc3BhdGNoZWQuXG4gICAgICAgICAgICBpZiAoY2xpY2tUaW1lICE9PSBjbGlja0Rpc3BhdGNoICYmIHNlbGYuZW5hYmxlZCgpICYmICFzZWxmLmlzUHJlc3NlZCAmJiAhb3JpZ2luYWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIGlmIChldmVudFRhcmdldC5jbGljaykge1xuICAgICAgICAgICAgICAgIC8vc29tZSBicm93c2VycyAobGlrZSBtb2JpbGUgU2FmYXJpKSBkb24ndCBwcm9wZXJseSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmNsaWNrKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3duZXJEb2MuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzeW50aGV0aWNFdmVudCA9IG93bmVyRG9jLmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLCBfd2luLCAxLCBzZWxmLnBvaW50ZXJFdmVudC5zY3JlZW5YLCBzZWxmLnBvaW50ZXJFdmVudC5zY3JlZW5ZLCBzZWxmLnBvaW50ZXJYLCBzZWxmLnBvaW50ZXJZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChzeW50aGV0aWNFdmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCFfaXNBbmRyb2lkICYmICFvcmlnaW5hbEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIC8vaU9TIFNhZmFyaSByZXF1aXJlcyB0aGUgc3ludGhldGljIGNsaWNrIHRvIGhhcHBlbiBpbW1lZGlhdGVseSBvciBlbHNlIGl0IHNpbXBseSB3b24ndCB3b3JrLCBidXQgQW5kcm9pZCBkb2Vzbid0IHBsYXkgbmljZS5cbiAgICAgICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC4wNSwgc3ludGhldGljQ2xpY2spOyAvL2luIGFkZGl0aW9uIHRvIHRoZSBpT1MgYnVnIHdvcmthcm91bmQsIHRoZXJlJ3MgYSBGaXJlZm94IGlzc3VlIHdpdGggY2xpY2tpbmcgb24gdGhpbmdzIGxpa2UgYSB2aWRlbyB0byBwbGF5LCBzbyB3ZSBtdXN0IGZha2UgYSBjbGljayBldmVudCBpbiBhIHNsaWdodGx5IGRlbGF5ZWQgZmFzaGlvbi4gUHJldmlvdXNseSwgd2UgbGlzdGVuZWQgZm9yIHRoZSBcImNsaWNrXCIgZXZlbnQgd2l0aCBcImNhcHR1cmVcIiBmYWxzZSB3aGljaCBzb2x2ZWQgdGhlIHZpZGVvLWNsaWNrLXRvLXBsYXkgaXNzdWUsIGJ1dCBpdCB3b3VsZCBhbGxvdyB0aGUgXCJjbGlja1wiIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQgdHdpY2UgbGlrZSBpZiB5b3Ugd2VyZSB1c2luZyBhIGpRdWVyeS5jbGljaygpIGJlY2F1c2UgdGhhdCB3YXMgaGFuZGxlZCBpbiB0aGUgY2FwdHVyZSBwaGFzZSwgdGh1cyB3ZSBoYWQgdG8gc3dpdGNoIHRvIHRoZSBjYXB0dXJlIHBoYXNlIHRvIGF2b2lkIHRoZSBkb3VibGUtZGlzcGF0Y2hpbmcsIGJ1dCBkbyB0aGUgZGVsYXllZCBzeW50aGV0aWMgY2xpY2suIERvbid0IGZpcmUgaXQgdG9vIGZhc3QgKGxpa2UgMC4wMDAwMSkgYmVjYXVzZSB3ZSB3YW50IHRvIGdpdmUgdGhlIG5hdGl2ZSBldmVudCBhIGNoYW5jZSB0byBmaXJlIGZpcnN0IGFzIGl0J3MgXCJ0cnVzdGVkXCIuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRlKHZhcnMuaW5lcnRpYSB8fCB2YXJzLnRocm93UHJvcHMpOyAvL3dpbGwgc2tpcCBpZiBpbmVydGlhL3Rocm93UHJvcHMgaXNuJ3QgZGVmaW5lZCBvciBJbmVydGlhUGx1Z2luIGlzbid0IGxvYWRlZC5cblxuICAgICAgICBpZiAoIXNlbGYuYWxsb3dFdmVudERlZmF1bHQgJiYgb3JpZ2luYWxFdmVudCAmJiAodmFycy5kcmFnQ2xpY2thYmxlcyAhPT0gZmFsc2UgfHwgIWlzQ2xpY2thYmxlLmNhbGwoc2VsZiwgb3JpZ2luYWxFdmVudC50YXJnZXQpKSAmJiB3YXNEcmFnZ2luZyAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSAmJiBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgICBfcHJldmVudERlZmF1bHQob3JpZ2luYWxFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuICAgICAgfVxuXG4gICAgICBpc1R3ZWVuaW5nKCkgJiYgcGxhY2Vob2xkZXJEZWxheWVkQ2FsbC5kdXJhdGlvbihzZWxmLnR3ZWVuLmR1cmF0aW9uKCkpOyAvL3N5bmMgdGhlIHRpbWluZyBzbyB0aGF0IHRoZSBwbGFjZWhvbGRlciBESVYgZ2V0c1xuXG4gICAgICB3YXNEcmFnZ2luZyAmJiBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdlbmRcIiwgXCJvbkRyYWdFbmRcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgICAgICB1cGRhdGVTY3JvbGwgPSBmdW5jdGlvbiB1cGRhdGVTY3JvbGwoZSkge1xuICAgICAgaWYgKGUgJiYgc2VsZi5pc0RyYWdnaW5nICYmICFzY3JvbGxQcm94eSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZS50YXJnZXQgfHwgdGFyZ2V0LnBhcmVudE5vZGUsXG4gICAgICAgICAgICBkZWx0YVggPSBwYXJlbnQuc2Nyb2xsTGVmdCAtIHBhcmVudC5fZ3NTY3JvbGxYLFxuICAgICAgICAgICAgZGVsdGFZID0gcGFyZW50LnNjcm9sbFRvcCAtIHBhcmVudC5fZ3NTY3JvbGxZO1xuXG4gICAgICAgIGlmIChkZWx0YVggfHwgZGVsdGFZKSB7XG4gICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWCAtPSBkZWx0YVggKiBtYXRyaXguYSArIGRlbHRhWSAqIG1hdHJpeC5jO1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWSAtPSBkZWx0YVkgKiBtYXRyaXguZCArIGRlbHRhWCAqIG1hdHJpeC5iO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFBvaW50ZXJYIC09IGRlbHRhWDtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnRlclkgLT0gZGVsdGFZO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudC5fZ3NTY3JvbGxYICs9IGRlbHRhWDtcbiAgICAgICAgICBwYXJlbnQuX2dzU2Nyb2xsWSArPSBkZWx0YVk7XG4gICAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgb25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgLy90aGlzIHdhcyBhIGh1Z2UgcGFpbiBpbiB0aGUgbmVjayB0byBhbGlnbiBhbGwgdGhlIHZhcmlvdXMgYnJvd3NlcnMgYW5kIHRoZWlyIGJlaGF2aW9ycy4gQ2hyb21lLCBGaXJlZm94LCBTYWZhcmksIE9wZXJhLCBBbmRyb2lkLCBhbmQgTWljcm9zb2Z0IEVkZ2UgYWxsIGhhbmRsZSBldmVudHMgZGlmZmVyZW50bHkhIFNvbWUgd2lsbCBvbmx5IHRyaWdnZXIgbmF0aXZlIGJlaGF2aW9yIChsaWtlIGNoZWNrYm94IHRvZ2dsaW5nKSBmcm9tIHRydXN0ZWQgZXZlbnRzLiBPdGhlcnMgZG9uJ3QgZXZlbiBzdXBwb3J0IGlzVHJ1c3RlZCwgYnV0IHJlcXVpcmUgMiBldmVudHMgdG8gZmxvdyB0aHJvdWdoIGJlZm9yZSB0cmlnZ2VyaW5nIG5hdGl2ZSBiZWhhdmlvci4gRWRnZSB0cmVhdHMgZXZlcnl0aGluZyBhcyB0cnVzdGVkIGJ1dCBhbHNvIG1hbmRhdGVzIHRoYXQgMiBmbG93IHRocm91Z2ggdG8gdHJpZ2dlciB0aGUgY29ycmVjdCBuYXRpdmUgYmVoYXZpb3IuXG4gICAgICB2YXIgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgICAgcmVjZW50bHlDbGlja2VkID0gdGltZSAtIGNsaWNrVGltZSA8IDEwMCxcbiAgICAgICAgICByZWNlbnRseURyYWdnZWQgPSB0aW1lIC0gZHJhZ0VuZFRpbWUgPCA1MCxcbiAgICAgICAgICBhbHJlYWR5RGlzcGF0Y2hlZCA9IHJlY2VudGx5Q2xpY2tlZCAmJiBjbGlja0Rpc3BhdGNoID09PSBjbGlja1RpbWUsXG4gICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IHNlbGYucG9pbnRlckV2ZW50ICYmIHNlbGYucG9pbnRlckV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgICAgICAgYWxyZWFkeURpc3BhdGNoZWRUcnVzdGVkID0gcmVjZW50bHlDbGlja2VkICYmIHRydXN0ZWRDbGlja0Rpc3BhdGNoID09PSBjbGlja1RpbWUsXG4gICAgICAgICAgdHJ1c3RlZCA9IGUuaXNUcnVzdGVkIHx8IGUuaXNUcnVzdGVkID09IG51bGwgJiYgcmVjZW50bHlDbGlja2VkICYmIGFscmVhZHlEaXNwYXRjaGVkOyAvL25vdGU6IFNhZmFyaSBkb2Vzbid0IHN1cHBvcnQgaXNUcnVzdGVkLCBhbmQgaXQgd29uJ3QgcHJvcGVybHkgZXhlY3V0ZSBuYXRpdmUgYmVoYXZpb3IgKGxpa2UgdG9nZ2xpbmcgY2hlY2tib3hlcykgb24gdGhlIGZpcnN0IHN5bnRoZXRpYyBcImNsaWNrXCIgZXZlbnQgLSB3ZSBtdXN0IHdhaXQgZm9yIHRoZSAybmQgYW5kIHRyZWF0IGl0IGFzIHRydXN0ZWQgKGJ1dCBzdG9wIHByb3BhZ2F0aW9uIGF0IHRoYXQgcG9pbnQpLiBDb25mdXNpbmcsIEkga25vdy4gRG9uJ3QgeW91IGxvdmUgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IGNoYWxsZW5nZXM/XG5cblxuICAgICAgaWYgKChhbHJlYWR5RGlzcGF0Y2hlZCB8fCByZWNlbnRseURyYWdnZWQgJiYgc2VsZi52YXJzLnN1cHByZXNzQ2xpY2tPbkRyYWcgIT09IGZhbHNlKSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjZW50bHlDbGlja2VkICYmICEoc2VsZi5wb2ludGVyRXZlbnQgJiYgc2VsZi5wb2ludGVyRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgJiYgKCFhbHJlYWR5RGlzcGF0Y2hlZCB8fCB0cnVzdGVkICYmICFhbHJlYWR5RGlzcGF0Y2hlZFRydXN0ZWQpKSB7XG4gICAgICAgIC8vbGV0IHRoZSBmaXJzdCBjbGljayBwYXNzIHRocm91Z2ggdW5oaW5kZXJlZC4gTGV0IHRoZSBuZXh0IG9uZSBvbmx5IGlmIGl0J3MgdHJ1c3RlZCwgdGhlbiBubyBtb3JlIChzdG9wIHF1aWNrLXN1Y2Nlc3Npb24gb25lcylcbiAgICAgICAgaWYgKHRydXN0ZWQgJiYgYWxyZWFkeURpc3BhdGNoZWQpIHtcbiAgICAgICAgICB0cnVzdGVkQ2xpY2tEaXNwYXRjaCA9IGNsaWNrVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaWNrRGlzcGF0Y2ggPSBjbGlja1RpbWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkIHx8IHJlY2VudGx5RHJhZ2dlZCB8fCByZWNlbnRseUNsaWNrZWQpIHtcbiAgICAgICAgaWYgKCF0cnVzdGVkIHx8ICFlLmRldGFpbCB8fCAhcmVjZW50bHlDbGlja2VkIHx8IGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICBfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWNlbnRseUNsaWNrZWQgJiYgIXJlY2VudGx5RHJhZ2dlZCkge1xuICAgICAgICAvLyBmb3Igc2NyaXB0LXRyaWdnZXJlZCBldmVudCBkaXNwYXRjaGVzLCBsaWtlIGVsZW1lbnQuY2xpY2soKVxuICAgICAgICBlICYmIGUudGFyZ2V0ICYmIChzZWxmLnBvaW50ZXJFdmVudCA9IGUpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGxvY2FsaXplUG9pbnQgPSBmdW5jdGlvbiBsb2NhbGl6ZVBvaW50KHApIHtcbiAgICAgIHJldHVybiBtYXRyaXggPyB7XG4gICAgICAgIHg6IHAueCAqIG1hdHJpeC5hICsgcC55ICogbWF0cml4LmMgKyBtYXRyaXguZSxcbiAgICAgICAgeTogcC54ICogbWF0cml4LmIgKyBwLnkgKiBtYXRyaXguZCArIG1hdHJpeC5mXG4gICAgICB9IDoge1xuICAgICAgICB4OiBwLngsXG4gICAgICAgIHk6IHAueVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgb2xkID0gRHJhZ2dhYmxlLmdldCh0YXJnZXQpO1xuICAgIG9sZCAmJiBvbGQua2lsbCgpOyAvLyBhdm9pZHMgZHVwbGljYXRlcyAoYW4gZWxlbWVudCBjYW4gb25seSBiZSBjb250cm9sbGVkIGJ5IG9uZSBEcmFnZ2FibGUpXG4gICAgLy9naXZlIHRoZSB1c2VyIGFjY2VzcyB0byBzdGFydC9zdG9wIGRyYWdnaW5nLi4uXG5cbiAgICBfdGhpczIuc3RhcnREcmFnID0gZnVuY3Rpb24gKGV2ZW50LCBhbGlnbikge1xuICAgICAgdmFyIHIxLCByMiwgcDEsIHAyO1xuICAgICAgb25QcmVzcyhldmVudCB8fCBzZWxmLnBvaW50ZXJFdmVudCwgdHJ1ZSk7IC8vaWYgdGhlIHBvaW50ZXIgaXNuJ3Qgb24gdG9wIG9mIHRoZSBlbGVtZW50LCBhZGp1c3QgdGhpbmdzIGFjY29yZGluZ2x5XG5cbiAgICAgIGlmIChhbGlnbiAmJiAhc2VsZi5oaXRUZXN0KGV2ZW50IHx8IHNlbGYucG9pbnRlckV2ZW50KSkge1xuICAgICAgICByMSA9IF9wYXJzZVJlY3QoZXZlbnQgfHwgc2VsZi5wb2ludGVyRXZlbnQpO1xuICAgICAgICByMiA9IF9wYXJzZVJlY3QodGFyZ2V0KTtcbiAgICAgICAgcDEgPSBsb2NhbGl6ZVBvaW50KHtcbiAgICAgICAgICB4OiByMS5sZWZ0ICsgcjEud2lkdGggLyAyLFxuICAgICAgICAgIHk6IHIxLnRvcCArIHIxLmhlaWdodCAvIDJcbiAgICAgICAgfSk7XG4gICAgICAgIHAyID0gbG9jYWxpemVQb2ludCh7XG4gICAgICAgICAgeDogcjIubGVmdCArIHIyLndpZHRoIC8gMixcbiAgICAgICAgICB5OiByMi50b3AgKyByMi5oZWlnaHQgLyAyXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydFBvaW50ZXJYIC09IHAxLnggLSBwMi54O1xuICAgICAgICBzdGFydFBvaW50ZXJZIC09IHAxLnkgLSBwMi55O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuaXNEcmFnZ2luZykge1xuICAgICAgICBzZWxmLmlzRHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ3N0YXJ0XCIsIFwib25EcmFnU3RhcnRcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzMi5kcmFnID0gb25Nb3ZlO1xuXG4gICAgX3RoaXMyLmVuZERyYWcgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIG9uUmVsZWFzZShlIHx8IHNlbGYucG9pbnRlckV2ZW50LCB0cnVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMyLnRpbWVTaW5jZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2VsZi5pc0RyYWdnaW5nID8gMCA6IChfZ2V0VGltZSgpIC0gZHJhZ0VuZFRpbWUpIC8gMTAwMDtcbiAgICB9O1xuXG4gICAgX3RoaXMyLnRpbWVTaW5jZUNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChfZ2V0VGltZSgpIC0gY2xpY2tUaW1lKSAvIDEwMDA7XG4gICAgfTtcblxuICAgIF90aGlzMi5oaXRUZXN0ID0gZnVuY3Rpb24gKHRhcmdldCwgdGhyZXNob2xkKSB7XG4gICAgICByZXR1cm4gRHJhZ2dhYmxlLmhpdFRlc3Qoc2VsZi50YXJnZXQsIHRhcmdldCwgdGhyZXNob2xkKTtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uIChmcm9tLCBkaWFnb25hbFRocmVzaG9sZCkge1xuICAgICAgLy9mcm9tIGNhbiBiZSBcInN0YXJ0XCIgKGRlZmF1bHQpLCBcInZlbG9jaXR5XCIsIG9yIGFuIGVsZW1lbnRcbiAgICAgIHZhciBtb2RlID0gZnJvbSA9PT0gXCJ2ZWxvY2l0eVwiICYmIEluZXJ0aWFQbHVnaW4gPyBmcm9tIDogX2lzT2JqZWN0KGZyb20pICYmICFyb3RhdGlvbk1vZGUgPyBcImVsZW1lbnRcIiA6IFwic3RhcnRcIixcbiAgICAgICAgICB4Q2hhbmdlLFxuICAgICAgICAgIHlDaGFuZ2UsXG4gICAgICAgICAgcmF0aW8sXG4gICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgIHIxLFxuICAgICAgICAgIHIyO1xuXG4gICAgICBpZiAobW9kZSA9PT0gXCJlbGVtZW50XCIpIHtcbiAgICAgICAgcjEgPSBfcGFyc2VSZWN0KHNlbGYudGFyZ2V0KTtcbiAgICAgICAgcjIgPSBfcGFyc2VSZWN0KGZyb20pO1xuICAgICAgfVxuXG4gICAgICB4Q2hhbmdlID0gbW9kZSA9PT0gXCJzdGFydFwiID8gc2VsZi54IC0gc3RhcnRFbGVtZW50WCA6IG1vZGUgPT09IFwidmVsb2NpdHlcIiA/IEluZXJ0aWFQbHVnaW4uZ2V0VmVsb2NpdHkodGFyZ2V0LCB4UHJvcCkgOiByMS5sZWZ0ICsgcjEud2lkdGggLyAyIC0gKHIyLmxlZnQgKyByMi53aWR0aCAvIDIpO1xuXG4gICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgIHJldHVybiB4Q2hhbmdlIDwgMCA/IFwiY291bnRlci1jbG9ja3dpc2VcIiA6IFwiY2xvY2t3aXNlXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWFnb25hbFRocmVzaG9sZCA9IGRpYWdvbmFsVGhyZXNob2xkIHx8IDI7XG4gICAgICAgIHlDaGFuZ2UgPSBtb2RlID09PSBcInN0YXJ0XCIgPyBzZWxmLnkgLSBzdGFydEVsZW1lbnRZIDogbW9kZSA9PT0gXCJ2ZWxvY2l0eVwiID8gSW5lcnRpYVBsdWdpbi5nZXRWZWxvY2l0eSh0YXJnZXQsIHlQcm9wKSA6IHIxLnRvcCArIHIxLmhlaWdodCAvIDIgLSAocjIudG9wICsgcjIuaGVpZ2h0IC8gMik7XG4gICAgICAgIHJhdGlvID0gTWF0aC5hYnMoeENoYW5nZSAvIHlDaGFuZ2UpO1xuICAgICAgICBkaXJlY3Rpb24gPSByYXRpbyA8IDEgLyBkaWFnb25hbFRocmVzaG9sZCA/IFwiXCIgOiB4Q2hhbmdlIDwgMCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuXG4gICAgICAgIGlmIChyYXRpbyA8IGRpYWdvbmFsVGhyZXNob2xkKSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgZGlyZWN0aW9uICs9IFwiLVwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpcmVjdGlvbiArPSB5Q2hhbmdlIDwgMCA/IFwidXBcIiA6IFwiZG93blwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfTtcblxuICAgIF90aGlzMi5hcHBseUJvdW5kcyA9IGZ1bmN0aW9uIChuZXdCb3VuZHMsIHN0aWNreSkge1xuICAgICAgdmFyIHgsIHksIGZvcmNlWmVyb1ZlbG9jaXR5LCBlLCBwYXJlbnQsIGlzUm9vdDtcblxuICAgICAgaWYgKG5ld0JvdW5kcyAmJiB2YXJzLmJvdW5kcyAhPT0gbmV3Qm91bmRzKSB7XG4gICAgICAgIHZhcnMuYm91bmRzID0gbmV3Qm91bmRzO1xuICAgICAgICByZXR1cm4gc2VsZi51cGRhdGUodHJ1ZSwgc3RpY2t5KTtcbiAgICAgIH1cblxuICAgICAgc3luY1hZKHRydWUpO1xuICAgICAgY2FsY3VsYXRlQm91bmRzKCk7XG5cbiAgICAgIGlmIChoYXNCb3VuZHMgJiYgIWlzVHdlZW5pbmcoKSkge1xuICAgICAgICB4ID0gc2VsZi54O1xuICAgICAgICB5ID0gc2VsZi55O1xuXG4gICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgIHggPSBtYXhYO1xuICAgICAgICB9IGVsc2UgaWYgKHggPCBtaW5YKSB7XG4gICAgICAgICAgeCA9IG1pblg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeSAIG1heFkpIHtcbiAgICAgICAgICB5ID0gbWF4WTtcbiAgICAgICAgfSBlbHNlIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgIHkgPSBtaW5ZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYueCAhPT0geCB8fCBzZWxmLnkgIT09IHkpIHtcbiAgICAgICAgICBmb3JjZVplcm9WZWxvY2l0eSA9IHRydWU7XG4gICAgICAgICAgc2VsZi54ID0gc2VsZi5lbmRYID0geDtcblxuICAgICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kUm90YXRpb24gPSB4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnkgPSBzZWxmLmVuZFkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICByZW5kZXIodHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoc2VsZi5hdXRvU2Nyb2xsICYmICFzZWxmLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIF9yZWNvcmRNYXhTY3JvbGxzKHRhcmdldC5wYXJlbnROb2RlKTtcblxuICAgICAgICAgICAgZSA9IHRhcmdldDtcbiAgICAgICAgICAgIF93aW5kb3dQcm94eS5zY3JvbGxUb3AgPSBfd2luLnBhZ2VZT2Zmc2V0ICE9IG51bGwgPyBfd2luLnBhZ2VZT2Zmc2V0IDogb3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCAhPSBudWxsID8gb3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgX3dpbmRvd1Byb3h5LnNjcm9sbExlZnQgPSBfd2luLnBhZ2VYT2Zmc2V0ICE9IG51bGwgPyBfd2luLnBhZ2VYT2Zmc2V0IDogb3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgIT0gbnVsbCA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IDogb3duZXJEb2MuYm9keS5zY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgICB3aGlsZSAoZSAmJiAhaXNSb290KSB7XG4gICAgICAgICAgICAgIC8vd2FsayB1cCB0aGUgY2hhaW4gYW5kIHNlbnNlIHdoZXJldmVyIHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdCBleGNlZWRzIHRoZSBtYXhpbXVtLlxuICAgICAgICAgICAgICBpc1Jvb3QgPSBfaXNSb290KGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgIHBhcmVudCA9IGlzUm9vdCA/IF93aW5kb3dQcm94eSA6IGUucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgICBpZiAoYWxsb3dZICYmIHBhcmVudC5zY3JvbGxUb3AgPiBwYXJlbnQuX2dzTWF4U2Nyb2xsWSkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5zY3JvbGxUb3AgPSBwYXJlbnQuX2dzTWF4U2Nyb2xsWTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhbGxvd1ggJiYgcGFyZW50LnNjcm9sbExlZnQgPiBwYXJlbnQuX2dzTWF4U2Nyb2xsWCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5zY3JvbGxMZWZ0ID0gcGFyZW50Ll9nc01heFNjcm9sbFg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLmlzVGhyb3dpbmcgJiYgKGZvcmNlWmVyb1ZlbG9jaXR5IHx8IHNlbGYuZW5kWCAIG1heFggfHwgc2VsZi5lbmRYIDwgbWluWCB8fCBzZWxmLmVuZFkgPiBtYXhZIHx8IHNlbGYuZW5kWSA8IG1pblkpKSB7XG4gICAgICAgICAgYW5pbWF0ZSh2YXJzLmluZXJ0aWEgfHwgdmFycy50aHJvd1Byb3BzLCBmb3JjZVplcm9WZWxvY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIF90aGlzMi51cGRhdGUgPSBmdW5jdGlvbiAoYXBwbHlCb3VuZHMsIHN0aWNreSwgaWdub3JlRXh0ZXJuYWxDaGFuZ2VzKSB7XG4gICAgICBpZiAoc3RpY2t5ICYmIHNlbGYuaXNQcmVzc2VkKSB7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIGVsZW1lbnQgd2FzIHJlcG9zaXRpb25lZCBpbiB0aGUgZG9jdW1lbnQgZmxvdywgdGh1cyBpdHMgeC95IG1heSBiZSBpZGVudGljYWwgYnV0IGl0cyBwb3NpdGlvbiBpcyBhY3R1YWxseSBxdWl0ZSBkaWZmZXJlbnQuXG4gICAgICAgIHZhciBtID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldCksXG4gICAgICAgICAgICBwID0gaW5uZXJNYXRyaXguYXBwbHkoe1xuICAgICAgICAgIHg6IHNlbGYueCAtIHN0YXJ0RWxlbWVudFgsXG4gICAgICAgICAgeTogc2VsZi55IC0gc3RhcnRFbGVtZW50WVxuICAgICAgICB9KSxcbiAgICAgICAgICAgIG0yID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldC5wYXJlbnROb2RlLCB0cnVlKTtcbiAgICAgICAgbTIuYXBwbHkoe1xuICAgICAgICAgIHg6IG0uZSAtIHAueCxcbiAgICAgICAgICB5OiBtLmYgLSBwLnlcbiAgICAgICAgfSwgcCk7XG4gICAgICAgIHNlbGYueCAtPSBwLnggLSBtMi5lO1xuICAgICAgICBzZWxmLnkgLT0gcC55IC0gbTIuZjtcbiAgICAgICAgcmVuZGVyKHRydWUpO1xuICAgICAgICByZWNvcmRTdGFydFBvc2l0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IHNlbGYueCxcbiAgICAgICAgICB5ID0gc2VsZi55O1xuICAgICAgdXBkYXRlTWF0cml4KCFzdGlja3kpO1xuXG4gICAgICBpZiAoYXBwbHlCb3VuZHMpIHtcbiAgICAgICAgc2VsZi5hcHBseUJvdW5kcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlydHkgJiYgaWdub3JlRXh0ZXJuYWxDaGFuZ2VzICYmIHJlbmRlcih0cnVlKTtcbiAgICAgICAgc3luY1hZKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RpY2t5KSB7XG4gICAgICAgIHNldFBvaW50ZXJQb3NpdGlvbihzZWxmLnBvaW50ZXJYLCBzZWxmLnBvaW50ZXJZKTtcbiAgICAgICAgZGlydHkgJiYgcmVuZGVyKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5pc1ByZXNzZWQgJiYgIXN0aWNreSAmJiAoYWxsb3dYICYmIE1hdGguYWJzKHggLSBzZWxmLngpID4gMC4wMSB8fCBhbGxvd1kgJiYgTWF0aC5hYnMoeSAtIHNlbGYueSkgPiAwLjAxICYmICFyb3RhdGlvbk1vZGUpKSB7XG4gICAgICAgIHJlY29yZFN0YXJ0UG9zaXRpb25zKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmF1dG9TY3JvbGwpIHtcbiAgICAgICAgX3JlY29yZE1heFNjcm9sbHModGFyZ2V0LnBhcmVudE5vZGUsIHNlbGYuaXNEcmFnZ2luZyk7XG5cbiAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gc2VsZi5pc0RyYWdnaW5nO1xuICAgICAgICByZW5kZXIodHJ1ZSk7IC8vaW4gY2FzZSByZXBhcmVudGluZyBvY2N1cnJlZC5cblxuICAgICAgICBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuXG4gICAgICAgIF9hZGRTY3JvbGxMaXN0ZW5lcih0YXJnZXQsIHVwZGF0ZVNjcm9sbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIuZW5hYmxlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBzZXRWYXJzID0ge1xuICAgICAgICBsYXp5OiB0cnVlXG4gICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGksXG4gICAgICAgICAgdHJpZ2dlcjtcblxuICAgICAgaWYgKHZhcnMuY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgICBzZXRWYXJzLmN1cnNvciA9IHZhcnMuY3Vyc29yIHx8IF9kZWZhdWx0Q3Vyc29yO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3NhcC51dGlscy5jaGVja1ByZWZpeChcInRvdWNoQ2FsbG91dFwiKSkge1xuICAgICAgICBzZXRWYXJzLnRvdWNoQ2FsbG91dCA9IFwibm9uZVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSAhPT0gXCJzb2Z0XCIpIHtcbiAgICAgICAgX3NldFRvdWNoQWN0aW9uRm9yQWxsRGVzY2VuZGFudHModHJpZ2dlcnMsIGFsbG93WCA9PT0gYWxsb3dZID8gXCJub25lXCIgOiB2YXJzLmFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgdGFyZ2V0LnNjcm9sbEhlaWdodCA9PT0gdGFyZ2V0LmNsaWVudEhlaWdodCA9PT0gKHRhcmdldC5zY3JvbGxXaWR0aCA9PT0gdGFyZ2V0LmNsaWVudEhlaWdodCkgfHwgdmFycy5hbGxvd0V2ZW50RGVmYXVsdCA/IFwibWFuaXB1bGF0aW9uXCIgOiBhbGxvd1ggPyBcInBhbi15XCIgOiBcInBhbi14XCIpOyAvLyBTb21lIGJyb3dzZXJzIGxpa2UgSW50ZXJuZXQgRXhwbG9yZXIgd2lsbCBmaXJlIGEgcG9pbnRlcmNhbmNlbCBldmVudCB3aGVuIHRoZSB1c2VyIGF0dGVtcHRzIHRvIGRyYWcgd2hlbiB0b3VjaEFjdGlvbiBpcyBcIm1hbmlwdWxhdGVcIiBiZWNhdXNlIGl0J3MgcGVyY2VpdmVkIGFzIGEgcGFuLiBJZiB0aGUgZWxlbWVudCBoYXMgc2Nyb2xsYWJsZSBjb250ZW50IGluIG9ubHkgb25lIGRpcmVjdGlvbiwgd2Ugc2hvdWxkIHVzZSBwYW4teCBvciBwYW4teSBhY2NvcmRpbmdseSBzbyB0aGF0IHRoZSBwb2ludGVyY2FuY2VsIGRvZXNuJ3QgcHJldmVudCBkcmFnZ2luZy5cblxuXG4gICAgICAgIGkgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKC0taSAIC0xKSB7XG4gICAgICAgICAgdHJpZ2dlciA9IHRyaWdnZXJzW2ldO1xuICAgICAgICAgIF9zdXBwb3J0c1BvaW50ZXIgfHwgX2FkZExpc3RlbmVyKHRyaWdnZXIsIFwibW91c2Vkb3duXCIsIG9uUHJlc3MpO1xuXG4gICAgICAgICAgX2FkZExpc3RlbmVyKHRyaWdnZXIsIFwidG91Y2hzdGFydFwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcImNsaWNrXCIsIG9uQ2xpY2ssIHRydWUpOyAvL25vdGU6IHVzZWQgdG8gcGFzcyB0cnVlIGZvciBjYXB0dXJlIGJ1dCBpdCBwcmV2ZW50ZWQgY2xpY2stdG8tcGxheS12aWRlbyBmdW5jdGlvbmFsaXR5IGluIEZpcmVmb3guXG5cblxuICAgICAgICAgIGdzYXAuc2V0KHRyaWdnZXIsIHNldFZhcnMpO1xuXG4gICAgICAgICAgaWYgKHRyaWdnZXIuZ2V0QkJveCAmJiB0cmlnZ2VyLm93bmVyU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gYSBidWcgaW4gY2hyb21lIGRvZXNuJ3QgcmVzcGVjdCB0b3VjaC1hY3Rpb24gb24gU1ZHIGVsZW1lbnRzIC0gaXQgb25seSB3b3JrcyBpZiB3ZSBzZXQgaXQgb24gdGhlIHBhcmVudCBTVkcuXG4gICAgICAgICAgICBnc2FwLnNldCh0cmlnZ2VyLm93bmVyU1ZHRWxlbWVudCwge1xuICAgICAgICAgICAgICB0b3VjaEFjdGlvbjogYWxsb3dYID09PSBhbGxvd1kgPyBcIm5vbmVcIiA6IHZhcnMuYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyB8fCB2YXJzLmFsbG93RXZlbnREZWZhdWx0ID8gXCJtYW5pcHVsYXRpb25cIiA6IGFsbG93WCA/IFwicGFuLXlcIiA6IFwicGFuLXhcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFycy5hbGxvd0NvbnRleHRNZW51IHx8IF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgX2FkZFNjcm9sbExpc3RlbmVyKHRhcmdldCwgdXBkYXRlU2Nyb2xsKTtcblxuICAgICAgZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgIGlmIChJbmVydGlhUGx1Z2luICYmIHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIEluZXJ0aWFQbHVnaW4udHJhY2soc2Nyb2xsUHJveHkgfHwgdGFyZ2V0LCB4eU1vZGUgPyBcIngseVwiIDogcm90YXRpb25Nb2RlID8gXCJyb3RhdGlvblwiIDogXCJ0b3AsbGVmdFwiKTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0Ll9nc0RyYWdJRCA9IGlkID0gXCJkXCIgKyBfbG9va3VwQ291bnQrKztcbiAgICAgIF9sb29rdXBbaWRdID0gc2VsZjtcblxuICAgICAgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgIHNjcm9sbFByb3h5LmVuYWJsZSgpO1xuICAgICAgICBzY3JvbGxQcm94eS5lbGVtZW50Ll9nc0RyYWdJRCA9IGlkO1xuICAgICAgfVxuXG4gICAgICAodmFycy5ib3VuZHMgfHwgcm90YXRpb25Nb2RlKSAmJiByZWNvcmRTdGFydFBvc2l0aW9ucygpO1xuICAgICAgdmFycy5ib3VuZHMgJiYgc2VsZi5hcHBseUJvdW5kcygpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIF90aGlzMi5kaXNhYmxlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBkcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZyxcbiAgICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoLFxuICAgICAgICAgIHRyaWdnZXI7XG5cbiAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICBfc2V0U3R5bGUodHJpZ2dlcnNbaV0sIFwiY3Vyc29yXCIsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSAhPT0gXCJzb2Z0XCIpIHtcbiAgICAgICAgX3NldFRvdWNoQWN0aW9uRm9yQWxsRGVzY2VuZGFudHModHJpZ2dlcnMsIG51bGwpO1xuXG4gICAgICAgIGkgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKC0taSAIC0xKSB7XG4gICAgICAgICAgdHJpZ2dlciA9IHRyaWdnZXJzW2ldO1xuXG4gICAgICAgICAgX3NldFN0eWxlKHRyaWdnZXIsIFwidG91Y2hDYWxsb3V0XCIsIG51bGwpO1xuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRyaWdnZXIsIFwibW91c2Vkb3duXCIsIG9uUHJlc3MpO1xuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRyaWdnZXIsIFwidG91Y2hzdGFydFwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcImNsaWNrXCIsIG9uQ2xpY2spO1xuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRyaWdnZXIsIFwiY29udGV4dG1lbnVcIiwgb25Db250ZXh0TWVudSk7XG4gICAgICAgIH1cblxuICAgICAgICBfc2V0U2VsZWN0YWJsZSh0cmlnZ2VycywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHRvdWNoRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGNhbmNlbFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hlbmRcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNobW92ZVwiLCBvbk1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNldXBcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2Vtb3ZlXCIsIG9uTW92ZSk7XG4gICAgICB9XG5cbiAgICAgIF9yZW1vdmVTY3JvbGxMaXN0ZW5lcih0YXJnZXQsIHVwZGF0ZVNjcm9sbCk7XG5cbiAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIEluZXJ0aWFQbHVnaW4gJiYgdHlwZSAhPT0gXCJzb2Z0XCIgJiYgSW5lcnRpYVBsdWdpbi51bnRyYWNrKHNjcm9sbFByb3h5IHx8IHRhcmdldCwgeHlNb2RlID8gXCJ4LHlcIiA6IHJvdGF0aW9uTW9kZSA/IFwicm90YXRpb25cIiA6IFwidG9wLGxlZnRcIik7XG4gICAgICBzY3JvbGxQcm94eSAmJiBzY3JvbGxQcm94eS5kaXNhYmxlKCk7XG5cbiAgICAgIF9yZW1vdmVGcm9tUmVuZGVyUXVldWUocmVuZGVyKTtcblxuICAgICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc1ByZXNzZWQgPSBpc0NsaWNraW5nID0gZmFsc2U7XG4gICAgICBkcmFnZ2luZyAmJiBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdlbmRcIiwgXCJvbkRyYWdFbmRcIik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmVuYWJsZWQgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdmFsdWUgPyBzZWxmLmVuYWJsZSh0eXBlKSA6IHNlbGYuZGlzYWJsZSh0eXBlKSA6IGVuYWJsZWQ7XG4gICAgfTtcblxuICAgIF90aGlzMi5raWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgc2VsZi5kaXNhYmxlKCk7XG4gICAgICBnc2FwLnNldCh0cmlnZ2Vycywge1xuICAgICAgICBjbGVhclByb3BzOiBcInVzZXJTZWxlY3RcIlxuICAgICAgfSk7XG4gICAgICBkZWxldGUgX2xvb2t1cFt0YXJnZXQuX2dzRHJhZ0lEXTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBpZiAofnR5cGUuaW5kZXhPZihcInNjcm9sbFwiKSkge1xuICAgICAgc2Nyb2xsUHJveHkgPSBfdGhpczIuc2Nyb2xsUHJveHkgPSBuZXcgU2Nyb2xsUHJveHkodGFyZ2V0LCBfZXh0ZW5kKHtcbiAgICAgICAgb25LaWxsOiBmdW5jdGlvbiBvbktpbGwoKSB7XG4gICAgICAgICAgLy9TY3JvbGxQcm94eSdzIG9uS2lsbCgpIGdldHMgY2FsbGVkIGlmL3doZW4gdGhlIFNjcm9sbFByb3h5IHNlbnNlcyB0aGF0IHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGUgc2Nyb2xsIHBvc2l0aW9uIG1hbnVhbGx5IChsaWtlIHVzaW5nIHRoZSBzY3JvbGxiYXIpLiBJRTkgZG9lc24ndCBmaXJlIHRoZSBcIm1vdXNldXBcIiBwcm9wZXJseSB3aGVuIHVzZXJzIGRyYWcgdGhlIHNjcm9sbGJhciBvZiBhbiBlbGVtZW50LCBzbyB0aGlzIHdvcmtzIGFyb3VuZCB0aGF0IGlzc3VlLlxuICAgICAgICAgIHNlbGYuaXNQcmVzc2VkICYmIG9uUmVsZWFzZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSwgdmFycykpOyAvL2EgYnVnIGluIG1hbnkgQW5kcm9pZCBkZXZpY2VzJyBzdG9jayBicm93c2VyIGNhdXNlcyBzY3JvbGxUb3AgdG8gZ2V0IGZvcmNlZCBiYWNrIHRvIDAgYWZ0ZXIgaXQgaXMgYWx0ZXJlZCB2aWEgSlMsIHNvIHdlIHNldCBvdmVyZmxvdyB0byBcImhpZGRlblwiIG9uIG1vYmlsZS90b3VjaCBkZXZpY2VzICh0aGV5IGhpZGUgdGhlIHNjcm9sbCBiYXIgYW55d2F5KS4gVGhhdCB3b3JrcyBhcm91bmQgdGhlIGJ1Zy4gKFRoaXMgYnVnIGlzIGRpc2N1c3NlZCBhdCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2FuZHJvaWQvaXNzdWVzL2RldGFpbD9pZD0xOTYyNSlcblxuICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93WSA9IGFsbG93WSAmJiAhX2lzVG91Y2hEZXZpY2UgPyBcImF1dG9cIiA6IFwiaGlkZGVuXCI7XG4gICAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3dYID0gYWxsb3dYICYmICFfaXNUb3VjaERldmljZSA/IFwiYXV0b1wiIDogXCJoaWRkZW5cIjtcbiAgICAgIHRhcmdldCA9IHNjcm9sbFByb3h5LmNvbnRlbnQ7XG4gICAgfVxuXG4gICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAga2lsbFByb3BzLnJvdGF0aW9uID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICBraWxsUHJvcHNbeFByb3BdID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICBraWxsUHJvcHNbeVByb3BdID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnc0NhY2hlLmZvcmNlM0QgPSBcImZvcmNlM0RcIiBpbiB2YXJzID8gdmFycy5mb3JjZTNEIDogdHJ1ZTsgLy9vdGhlcndpc2UsIG5vcm1hbCBkcmFnZ2luZyB3b3VsZCBiZSBpbiAyRCBhbmQgdGhlbiBhcyBzb29uIGFzIGl0J3MgcmVsZWFzZWQgYW5kIHRoZXJlJ3MgYW4gaW5lcnRpYSB0d2VlbiwgaXQnZCBqdW1wIHRvIDNEIHdoaWNoIGNhbiBjcmVhdGUgYW4gaW5pdGlhbCBqdW1wIGR1ZSB0byB0aGUgd29yayB0aGUgYnJvd3NlciBtdXN0IHRvIGRvIGxheWVyaXplIGl0LlxuXG4gICAgX3RoaXMyLmVuYWJsZSgpO1xuXG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIERyYWdnYWJsZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBnc2FwID0gY29yZTtcblxuICAgIF9pbml0Q29yZSgpO1xuICB9O1xuXG4gIERyYWdnYWJsZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUodGFyZ2V0cywgdmFycykge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUodHJ1ZSk7XG4gICAgcmV0dXJuIF90b0FycmF5KHRhcmdldHMpLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gbmV3IERyYWdnYWJsZSh0YXJnZXQsIHZhcnMpO1xuICAgIH0pO1xuICB9O1xuXG4gIERyYWdnYWJsZS5nZXQgPSBmdW5jdGlvbiBnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIF9sb29rdXBbKF90b0FycmF5KHRhcmdldClbMF0gfHwge30pLl9nc0RyYWdJRF07XG4gIH07XG5cbiAgRHJhZ2dhYmxlLnRpbWVTaW5jZURyYWcgPSBmdW5jdGlvbiB0aW1lU2luY2VEcmFnKCkge1xuICAgIHJldHVybiAoX2dldFRpbWUoKSAtIF9sYXN0RHJhZ1RpbWUpIC8gMTAwMDtcbiAgfTtcblxuICBEcmFnZ2FibGUuaGl0VGVzdCA9IGZ1bmN0aW9uIGhpdFRlc3Qob2JqMSwgb2JqMiwgdGhyZXNob2xkKSB7XG4gICAgaWYgKG9iajEgPT09IG9iajIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcjEgPSBfcGFyc2VSZWN0KG9iajEpLFxuICAgICAgICByMiA9IF9wYXJzZVJlY3Qob2JqMiksXG4gICAgICAgIHRvcCA9IHIxLnRvcCxcbiAgICAgICAgbGVmdCA9IHIxLmxlZnQsXG4gICAgICAgIHJpZ2h0ID0gcjEucmlnaHQsXG4gICAgICAgIGJvdHRvbSA9IHIxLmJvdHRvbSxcbiAgICAgICAgd2lkdGggPSByMS53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gcjEuaGVpZ2h0LFxuICAgICAgICBpc091dHNpZGUgPSByMi5sZWZ0ID4gcmlnaHQgfHwgcjIucmlnaHQgPCBsZWZ0IHx8IHIyLnRvcCAIGJvdHRvbSB8fCByMi5ib3R0b20gPCB0b3AsXG4gICAgICAgIG92ZXJsYXAsXG4gICAgICAgIGFyZWEsXG4gICAgICAgIGlzUmF0aW87XG5cbiAgICBpZiAoaXNPdXRzaWRlIHx8ICF0aHJlc2hvbGQpIHtcbiAgICAgIHJldHVybiAhaXNPdXRzaWRlO1xuICAgIH1cblxuICAgIGlzUmF0aW8gPSAodGhyZXNob2xkICsgXCJcIikuaW5kZXhPZihcIiVcIikgIT09IC0xO1xuICAgIHRocmVzaG9sZCA9IHBhcnNlRmxvYXQodGhyZXNob2xkKSB8fCAwO1xuICAgIG92ZXJsYXAgPSB7XG4gICAgICBsZWZ0OiBNYXRoLm1heChsZWZ0LCByMi5sZWZ0KSxcbiAgICAgIHRvcDogTWF0aC5tYXgodG9wLCByMi50b3ApXG4gICAgfTtcbiAgICBvdmVybGFwLndpZHRoID0gTWF0aC5taW4ocmlnaHQsIHIyLnJpZ2h0KSAtIG92ZXJsYXAubGVmdDtcbiAgICBvdmVybGFwLmhlaWdodCA9IE1hdGgubWluKGJvdHRvbSwgcjIuYm90dG9tKSAtIG92ZXJsYXAudG9wO1xuXG4gICAgaWYgKG92ZXJsYXAud2lkdGggPCAwIHx8IG92ZXJsYXAuaGVpZ2h0IDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc1JhdGlvKSB7XG4gICAgICB0aHJlc2hvbGQgKj0gMC4wMTtcbiAgICAgIGFyZWEgPSBvdmVybGFwLndpZHRoICogb3ZlcmxhcC5oZWlnaHQ7XG4gICAgICByZXR1cm4gYXJlYSAPSB3aWR0aCAqIGhlaWdodCAqIHRocmVzaG9sZCB8fCBhcmVhID49IHIyLndpZHRoICogcjIuaGVpZ2h0ICogdGhyZXNob2xkO1xuICAgIH1cblxuICAgIHJldHVybiBvdmVybGFwLndpZHRoID4gdGhyZXNob2xkICYmIG92ZXJsYXAuaGVpZ2h0ID4gdGhyZXNob2xkO1xuICB9O1xuXG4gIHJldHVybiBEcmFnZ2FibGU7XG59KEV2ZW50RGlzcGF0Y2hlcik7XG5cbl9zZXREZWZhdWx0cyhEcmFnZ2FibGUucHJvdG90eXBlLCB7XG4gIHBvaW50ZXJYOiAwLFxuICBwb2ludGVyWTogMCxcbiAgc3RhcnRYOiAwLFxuICBzdGFydFk6IDAsXG4gIGRlbHRhWDogMCxcbiAgZGVsdGFZOiAwLFxuICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgaXNQcmVzc2VkOiBmYWxzZVxufSk7XG5cbkRyYWdnYWJsZS56SW5kZXggPSAxMDAwO1xuRHJhZ2dhYmxlLnZlcnNpb24gPSBcIjMuMTAuNFwiO1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKERyYWdnYWJsZSk7XG5leHBvcnQgeyBEcmFnZ2FibGUgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/Draggable.js\n");

/***/ }),

/***/ "./node_modules/gsap/InertiaPlugin.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/InertiaPlugin.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InertiaPlugin: () => (/* binding */ InertiaPlugin),\n/* harmony export */   VelocityTracker: () => (/* reexport safe */ _utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__.VelocityTracker),\n/* harmony export */   \"default\": () => (/* binding */ InertiaPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/VelocityTracker.js */ \"./node_modules/gsap/utils/VelocityTracker.js\");\n/*!\n * InertiaPlugin 3.10.4\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar gsap,\n    _coreInitted,\n    _parseEase,\n    _toArray,\n    _power3,\n    _config,\n    _getUnit,\n    PropTween,\n    _getCache,\n    _checkPointRatio,\n    _clamp,\n    _processingVars,\n    _getTracker = _utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__.VelocityTracker.getByTarget,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === \"number\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _bonusValidated = 1,\n    //<name>InertiaPlugin</name>\n_isArray = Array.isArray,\n    _emptyFunc = function _emptyFunc(p) {\n  return p;\n},\n    _bigNum = 1e10,\n    _tinyNum = 1 / _bigNum,\n    _checkPoint = 0.05,\n    _round = function _round(value) {\n  return Math.round(value * 10000) / 10000;\n},\n    _extend = function _extend(obj, defaults, exclude) {\n  for (var p in defaults) {\n    if (!(p in obj) && p !== exclude) {\n      obj[p] = defaults[p];\n    }\n  }\n\n  return obj;\n},\n    _deepClone = function _deepClone(obj) {\n  var copy = {},\n      p,\n      v;\n\n  for (p in obj) {\n    copy[p] = _isObject(v = obj[p]) && !_isArray(v) ? _deepClone(v) : v;\n  }\n\n  return copy;\n},\n    _getClosest = function _getClosest(n, values, max, min, radius) {\n  var i = values.length,\n      closest = 0,\n      absDif = _bigNum,\n      val,\n      dif,\n      p,\n      dist;\n\n  if (_isObject(n)) {\n    while (i--) {\n      val = values[i];\n      dif = 0;\n\n      for (p in n) {\n        dist = val[p] - n[p];\n        dif = dist * dist;\n      }\n\n      if (dif < absDif) {\n        closest = i;\n        absDif = dif;\n      }\n    }\n\n    if ((radius || _bigNum) < _bigNum && radius < Math.sqrt(absDif)) {\n      return n;\n    }\n  } else {\n    while (i--) {\n      val = values[i];\n      dif = val - n;\n\n      if (dif < 0) {\n        dif = -dif;\n      }\n\n      if (dif < absDif && val >= min && val <= max) {\n        closest = i;\n        absDif = dif;\n      }\n    }\n  }\n\n  return values[closest];\n},\n    _parseEnd = function _parseEnd(curProp, end, max, min, name, radius, velocity) {\n  if (curProp.end === \"auto\") {\n    return curProp;\n  }\n\n  var endVar = curProp.end,\n      adjustedEnd,\n      p;\n  max = isNaN(max) ? _bigNum : max;\n  min = isNaN(min) ? -_bigNum : min;\n\n  if (_isObject(end)) {\n    //for objects, like {x, y} where they're linked and we must pass an object to the function or find the closest value in an array.\n    adjustedEnd = end.calculated ? end : (_isFunction(endVar) ? endVar(end, velocity) : _getClosest(end, endVar, max, min, radius)) || end;\n\n    if (!end.calculated) {\n      for (p in adjustedEnd) {\n        end[p] = adjustedEnd[p];\n      }\n\n      end.calculated = true;\n    }\n\n    adjustedEnd = adjustedEnd[name];\n  } else {\n    adjustedEnd = _isFunction(endVar) ? endVar(end, velocity) : _isArray(endVar) ? _getClosest(end, endVar, max, min, radius) : parseFloat(endVar);\n  }\n\n  if (adjustedEnd > max) {\n    adjustedEnd = max;\n  } else if (adjustedEnd < min) {\n    adjustedEnd = min;\n  }\n\n  return {\n    max: adjustedEnd,\n    min: adjustedEnd,\n    unitFactor: curProp.unitFactor\n  };\n},\n    _getNumOrDefault = function _getNumOrDefault(vars, property, defaultValue) {\n  return isNaN(vars[property]) ? defaultValue : vars[property];\n},\n    _calculateChange = function _calculateChange(velocity, duration) {\n  return duration * _checkPoint * velocity / _checkPointRatio;\n},\n    _calculateDuration = function _calculateDuration(start, end, velocity) {\n  return Math.abs((end - start) * _checkPointRatio / velocity / _checkPoint);\n},\n    _reservedProps = {\n  resistance: 1,\n  checkpoint: 1,\n  preventOvershoot: 1,\n  linkedProps: 1,\n  radius: 1,\n  duration: 1\n},\n    _processLinkedProps = function _processLinkedProps(target, vars, getVal, resistance) {\n  if (vars.linkedProps) {\n    //when there are linkedProps (typically \"x,y\" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we'll do later in the \"real\" loop.\n    var linkedPropNames = vars.linkedProps.split(\",\"),\n        linkedProps = {},\n        i,\n        p,\n        curProp,\n        curVelocity,\n        tracker,\n        curDuration;\n\n    for (i = 0; i < linkedPropNames.length; i) {\n      p = linkedPropNames[i];\n      curProp = vars[p];\n\n      if (curProp) {\n        if (_isNumber(curProp.velocity)) {\n          curVelocity = curProp.velocity;\n        } else {\n          tracker = tracker || _getTracker(target);\n          curVelocity = tracker && tracker.isTracking(p) ? tracker.get(p) : 0;\n        }\n\n        curDuration = Math.abs(curVelocity / _getNumOrDefault(curProp, \"resistance\", resistance));\n        linkedProps[p] = parseFloat(getVal(target, p))  _calculateChange(curVelocity, curDuration);\n      }\n    }\n\n    return linkedProps;\n  }\n},\n    _calculateTweenDuration = function _calculateTweenDuration(target, vars, maxDuration, minDuration, overshootTolerance, recordEnd) {\n  if (maxDuration === void 0) {\n    maxDuration = 10;\n  }\n\n  if (minDuration === void 0) {\n    minDuration = 0.2;\n  }\n\n  if (overshootTolerance === void 0) {\n    overshootTolerance = 1;\n  }\n\n  if (recordEnd === void 0) {\n    recordEnd = 0;\n  }\n\n  _isString(target) && (target = _toArray(target)[0]);\n\n  if (!target) {\n    return 0;\n  }\n\n  var duration = 0,\n      clippedDuration = _bigNum,\n      inertiaVars = vars.inertia || vars,\n      getVal = _getCache(target).get,\n      resistance = _getNumOrDefault(inertiaVars, \"resistance\", _config.resistance),\n      p,\n      curProp,\n      curDuration,\n      curVelocity,\n      curVal,\n      end,\n      curClippedDuration,\n      tracker,\n      unitFactor,\n      linkedProps; //when there are linkedProps (typically \"x,y\" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we'll do later in the \"real\" loop.\n\n\n  linkedProps = _processLinkedProps(target, inertiaVars, getVal, resistance);\n\n  for (p in inertiaVars) {\n    if (!_reservedProps[p]) {\n      curProp = inertiaVars[p];\n\n      if (!_isObject(curProp)) {\n        tracker = tracker || _getTracker(target);\n\n        if (tracker && tracker.isTracking(p)) {\n          curProp = _isNumber(curProp) ? {\n            velocity: curProp\n          } : {\n            velocity: tracker.get(p)\n          }; //if we're tracking this property, we should use the tracking velocity and then use the numeric value that was passed in as the min and max so that it tweens exactly there.\n        } else {\n          curVelocity = curProp || 0;\n          curDuration = Math.abs(curVelocity / resistance);\n        }\n      }\n\n      if (_isObject(curProp)) {\n        if (_isNumber(curProp.velocity)) {\n          curVelocity = curProp.velocity;\n        } else {\n          tracker = tracker || _getTracker(target);\n          curVelocity = tracker && tracker.isTracking(p) ? tracker.get(p) : 0;\n        }\n\n        curDuration = _clamp(minDuration, maxDuration, Math.abs(curVelocity / _getNumOrDefault(curProp, \"resistance\", resistance)));\n        curVal = parseFloat(getVal(target, p)) || 0;\n        end = curVal  _calculateChange(curVelocity, curDuration);\n\n        if (\"end\" in curProp) {\n          curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, inertiaVars.radius, curVelocity);\n\n          if (recordEnd) {\n            _processingVars === vars && (_processingVars = inertiaVars = _deepClone(vars));\n            inertiaVars[p] = _extend(curProp, inertiaVars[p], \"end\");\n          }\n        }\n\n        if (\"max\" in curProp && end > curProp.max  _tinyNum) {\n          unitFactor = curProp.unitFactor || _config.unitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.\n          //if the value is already exceeding the max or the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive. If the max and min match, it means we're animating to a particular value and we don't want to shorten the time unless the velocity is really slow. Example: a rotation where the start and natural end value are less than the snapping spot, but the natural end is pretty close to the snap.\n\n          curClippedDuration = curVal > curProp.max && curProp.min !== curProp.max || curVelocity * unitFactor > -15 && curVelocity * unitFactor < 45 ? minDuration  (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.max, curVelocity);\n\n          if (curClippedDuration  overshootTolerance < clippedDuration) {\n            clippedDuration = curClippedDuration  overshootTolerance;\n          }\n        } else if (\"min\" in curProp && end < curProp.min - _tinyNum) {\n          unitFactor = curProp.unitFactor || _config.unitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.\n          //if the value is already exceeding the min or if the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive.\n\n          curClippedDuration = curVal < curProp.min && curProp.min !== curProp.max || curVelocity * unitFactor > -45 && curVelocity * unitFactor < 15 ? minDuration  (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.min, curVelocity);\n\n          if (curClippedDuration  overshootTolerance < clippedDuration) {\n            clippedDuration = curClippedDuration  overshootTolerance;\n          }\n        }\n\n        curClippedDuration > duration && (duration = curClippedDuration);\n      }\n\n      curDuration > duration && (duration = curDuration);\n    }\n  }\n\n  duration > clippedDuration && (duration = clippedDuration);\n  return duration > maxDuration ? maxDuration : duration < minDuration ? minDuration : duration;\n},\n    _initCore = function _initCore() {\n  gsap = _getGSAP();\n\n  if (gsap) {\n    _parseEase = gsap.parseEase;\n    _toArray = gsap.utils.toArray;\n    _getUnit = gsap.utils.getUnit;\n    _getCache = gsap.core.getCache;\n    _clamp = gsap.utils.clamp;\n    _power3 = _parseEase(\"power3\");\n    _checkPointRatio = _power3(0.05);\n    PropTween = gsap.core.PropTween;\n    gsap.config({\n      resistance: 100,\n      unitFactors: {\n        time: 1000,\n        totalTime: 1000,\n        progress: 1000,\n        totalProgress: 1000\n      }\n    });\n    _config = gsap.config();\n    gsap.registerPlugin(_utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__.VelocityTracker);\n    _coreInitted = 1;\n  }\n};\n\nvar InertiaPlugin = {\n  version: \"3.10.4\",\n  name: \"inertia\",\n  register: function register(core) {\n    gsap = core;\n\n    _initCore();\n  },\n  init: function init(target, vars, tween, index, targets) {\n    _coreInitted || _initCore();\n\n    var tracker = _getTracker(target);\n\n    if (vars === \"auto\") {\n      if (!tracker) {\n        console.warn(\"No inertia tracking on \"  target  \". InertiaPlugin.track(target) first.\");\n        return;\n      }\n\n      vars = tracker.getAll();\n    }\n\n    this.target = target;\n    this.tween = tween;\n    _processingVars = vars; // gets swapped inside _calculateTweenDuration() if there's a function-based value encountered (to avoid double-calling it)\n\n    var cache = target._gsap,\n        getVal = cache.get,\n        dur = vars.duration,\n        durIsObj = _isObject(dur),\n        preventOvershoot = vars.preventOvershoot || durIsObj && dur.overshoot === 0,\n        resistance = _getNumOrDefault(vars, \"resistance\", _config.resistance),\n        duration = _isNumber(dur) ? dur : _calculateTweenDuration(target, vars, durIsObj && dur.max || 10, durIsObj && dur.min || 0.2, durIsObj && \"overshoot\" in dur ? dur.overshoot : preventOvershoot ? 0 : 1, true),\n        p,\n        curProp,\n        curVal,\n        unit,\n        velocity,\n        change1,\n        end,\n        change2,\n        linkedProps;\n\n    vars = _processingVars;\n    _processingVars = 0; //when there are linkedProps (typically \"x,y\" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we'll do later in the \"real\" loop.\n\n    linkedProps = _processLinkedProps(target, vars, getVal, resistance);\n\n    for (p in vars) {\n      if (!_reservedProps[p]) {\n        curProp = vars[p];\n        _isFunction(curProp) && (curProp = curProp(index, target, targets));\n\n        if (_isNumber(curProp)) {\n          velocity = curProp;\n        } else if (_isObject(curProp) && !isNaN(curProp.velocity)) {\n          velocity = curProp.velocity;\n        } else {\n          if (tracker && tracker.isTracking(p)) {\n            velocity = tracker.get(p);\n          } else {\n            console.warn(\"ERROR: No velocity was defined for \"  target  \" property: \"  p);\n          }\n        }\n\n        change1 = _calculateChange(velocity, duration);\n        change2 = 0;\n        curVal = getVal(target, p);\n        unit = _getUnit(curVal);\n        curVal = parseFloat(curVal);\n\n        if (_isObject(curProp)) {\n          end = curVal  change1;\n\n          if (\"end\" in curProp) {\n            curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, vars.radius, velocity);\n          }\n\n          if (\"max\" in curProp && curProp.max < end) {\n            if (preventOvershoot || curProp.preventOvershoot) {\n              change1 = curProp.max - curVal;\n            } else {\n              change2 = curProp.max - curVal - change1;\n            }\n          } else if (\"min\" in curProp && curProp.min > end) {\n            if (preventOvershoot || curProp.preventOvershoot) {\n              change1 = curProp.min - curVal;\n            } else {\n              change2 = curProp.min - curVal - change1;\n            }\n          }\n        }\n\n        this._props.push(p);\n\n        this._pt = new PropTween(this._pt, target, p, curVal, 0, _emptyFunc, 0, cache.set(target, p, this));\n        this._pt.u = unit || 0;\n        this._pt.c1 = change1;\n        this._pt.c2 = change2;\n      }\n    }\n\n    tween.duration(duration);\n    return _bonusValidated;\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt;\n    ratio = _power3(data.tween._time / data.tween._dur);\n\n    while (pt) {\n      pt.set(pt.t, pt.p, _round(pt.s  pt.c1 * ratio  pt.c2 * ratio * ratio)  pt.u, pt.d, ratio);\n      pt = pt._next;\n    }\n  }\n};\n\"track,untrack,isTracking,getVelocity,getByTarget\".split(\",\").forEach(function (name) {\n  return InertiaPlugin[name] = _utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__.VelocityTracker[name];\n});\n_getGSAP() && gsap.registerPlugin(InertiaPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QixzRUFBZTtBQUN2QztBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix3U0FBd1MsZUFBZTs7QUFFaFY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNFQUFlO0FBQzlDLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9nc2FwL0luZXJ0aWFQbHVnaW4uanM/MTZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEluZXJ0aWFQbHVnaW4gMy4xMC40XG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIyLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgVmVsb2NpdHlUcmFja2VyIH0gZnJvbSBcIi4vdXRpbHMvVmVsb2NpdHlUcmFja2VyLmpzXCI7XG5cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfcGFyc2VFYXNlLFxuICAgIF90b0FycmF5LFxuICAgIF9wb3dlcjMsXG4gICAgX2NvbmZpZyxcbiAgICBfZ2V0VW5pdCxcbiAgICBQcm9wVHdlZW4sXG4gICAgX2dldENhY2hlLFxuICAgIF9jaGVja1BvaW50UmF0aW8sXG4gICAgX2NsYW1wLFxuICAgIF9wcm9jZXNzaW5nVmFycyxcbiAgICBfZ2V0VHJhY2tlciA9IFZlbG9jaXR5VHJhY2tlci5nZXRCeVRhcmdldCxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9ib251c1ZhbGlkYXRlZCA9IDEsXG4gICAgLy88bmFtZT5JbmVydGlhUGx1Z2luPC9uYW1lPlxuX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIF9lbXB0eUZ1bmMgPSBmdW5jdGlvbiBfZW1wdHlGdW5jKHApIHtcbiAgcmV0dXJuIHA7XG59LFxuICAgIF9iaWdOdW0gPSAxZTEwLFxuICAgIF90aW55TnVtID0gMSAvIF9iaWdOdW0sXG4gICAgX2NoZWNrUG9pbnQgPSAwLjA1LFxuICAgIF9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwKSAvIDEwMDAwO1xufSxcbiAgICBfZXh0ZW5kID0gZnVuY3Rpb24gX2V4dGVuZChvYmosIGRlZmF1bHRzLCBleGNsdWRlKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoIShwIGluIG9iaikgJiYgcCAhPT0gZXhjbHVkZSkge1xuICAgICAgb2JqW3BdID0gZGVmYXVsdHNbcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX2RlZXBDbG9uZSA9IGZ1bmN0aW9uIF9kZWVwQ2xvbmUob2JqKSB7XG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwLFxuICAgICAgdjtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgY29weVtwXSA9IF9pc09iamVjdCh2ID0gb2JqW3BdKSAmJiAhX2lzQXJyYXkodikgPyBfZGVlcENsb25lKHYpIDogdjtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfZ2V0Q2xvc2VzdCA9IGZ1bmN0aW9uIF9nZXRDbG9zZXN0KG4sIHZhbHVlcywgbWF4LCBtaW4sIHJhZGl1cykge1xuICB2YXIgaSA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBjbG9zZXN0ID0gMCxcbiAgICAgIGFic0RpZiA9IF9iaWdOdW0sXG4gICAgICB2YWwsXG4gICAgICBkaWYsXG4gICAgICBwLFxuICAgICAgZGlzdDtcblxuICBpZiAoX2lzT2JqZWN0KG4pKSB7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gdmFsdWVzW2ldO1xuICAgICAgZGlmID0gMDtcblxuICAgICAgZm9yIChwIGluIG4pIHtcbiAgICAgICAgZGlzdCA9IHZhbFtwXSAtIG5bcF07XG4gICAgICAgIGRpZiArPSBkaXN0ICogZGlzdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZiA8IGFic0RpZikge1xuICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgICAgYWJzRGlmID0gZGlmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgocmFkaXVzIHx8IF9iaWdOdW0pIDwgX2JpZ051bSAmJiByYWRpdXMgPCBNYXRoLnNxcnQoYWJzRGlmKSkge1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHZhbHVlc1tpXTtcbiAgICAgIGRpZiA9IHZhbCAtIG47XG5cbiAgICAgIGlmIChkaWYgPCAwKSB7XG4gICAgICAgIGRpZiA9IC1kaWY7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWYgPCBhYnNEaWYgJiYgdmFsID49IG1pbiAmJiB2YWwgPD0gbWF4KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBpO1xuICAgICAgICBhYnNEaWYgPSBkaWY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlc1tjbG9zZXN0XTtcbn0sXG4gICAgX3BhcnNlRW5kID0gZnVuY3Rpb24gX3BhcnNlRW5kKGN1clByb3AsIGVuZCwgbWF4LCBtaW4sIG5hbWUsIHJhZGl1cywgdmVsb2NpdHkpIHtcbiAgaWYgKGN1clByb3AuZW5kID09PSBcImF1dG9cIikge1xuICAgIHJldHVybiBjdXJQcm9wO1xuICB9XG5cbiAgdmFyIGVuZFZhciA9IGN1clByb3AuZW5kLFxuICAgICAgYWRqdXN0ZWRFbmQsXG4gICAgICBwO1xuICBtYXggPSBpc05hTihtYXgpID8gX2JpZ051bSA6IG1heDtcbiAgbWluID0gaXNOYU4obWluKSA/IC1fYmlnTnVtIDogbWluO1xuXG4gIGlmIChfaXNPYmplY3QoZW5kKSkge1xuICAgIC8vZm9yIG9iamVjdHMsIGxpa2Uge3gsIHl9IHdoZXJlIHRoZXkncmUgbGlua2VkIGFuZCB3ZSBtdXN0IHBhc3MgYW4gb2JqZWN0IHRvIHRoZSBmdW5jdGlvbiBvciBmaW5kIHRoZSBjbG9zZXN0IHZhbHVlIGluIGFuIGFycmF5LlxuICAgIGFkanVzdGVkRW5kID0gZW5kLmNhbGN1bGF0ZWQgPyBlbmQgOiAoX2lzRnVuY3Rpb24oZW5kVmFyKSA/IGVuZFZhcihlbmQsIHZlbG9jaXR5KSA6IF9nZXRDbG9zZXN0KGVuZCwgZW5kVmFyLCBtYXgsIG1pbiwgcmFkaXVzKSkgfHwgZW5kO1xuXG4gICAgaWYgKCFlbmQuY2FsY3VsYXRlZCkge1xuICAgICAgZm9yIChwIGluIGFkanVzdGVkRW5kKSB7XG4gICAgICAgIGVuZFtwXSA9IGFkanVzdGVkRW5kW3BdO1xuICAgICAgfVxuXG4gICAgICBlbmQuY2FsY3VsYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgYWRqdXN0ZWRFbmQgPSBhZGp1c3RlZEVuZFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBhZGp1c3RlZEVuZCA9IF9pc0Z1bmN0aW9uKGVuZFZhcikgPyBlbmRWYXIoZW5kLCB2ZWxvY2l0eSkgOiBfaXNBcnJheShlbmRWYXIpID8gX2dldENsb3Nlc3QoZW5kLCBlbmRWYXIsIG1heCwgbWluLCByYWRpdXMpIDogcGFyc2VGbG9hdChlbmRWYXIpO1xuICB9XG5cbiAgaWYgKGFkanVzdGVkRW5kID4gbWF4KSB7XG4gICAgYWRqdXN0ZWRFbmQgPSBtYXg7XG4gIH0gZWxzZSBpZiAoYWRqdXN0ZWRFbmQgPCBtaW4pIHtcbiAgICBhZGp1c3RlZEVuZCA9IG1pbjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF4OiBhZGp1c3RlZEVuZCxcbiAgICBtaW46IGFkanVzdGVkRW5kLFxuICAgIHVuaXRGYWN0b3I6IGN1clByb3AudW5pdEZhY3RvclxuICB9O1xufSxcbiAgICBfZ2V0TnVtT3JEZWZhdWx0ID0gZnVuY3Rpb24gX2dldE51bU9yRGVmYXVsdCh2YXJzLCBwcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBpc05hTih2YXJzW3Byb3BlcnR5XSkgPyBkZWZhdWx0VmFsdWUgOiArdmFyc1twcm9wZXJ0eV07XG59LFxuICAgIF9jYWxjdWxhdGVDaGFuZ2UgPSBmdW5jdGlvbiBfY2FsY3VsYXRlQ2hhbmdlKHZlbG9jaXR5LCBkdXJhdGlvbikge1xuICByZXR1cm4gZHVyYXRpb24gKiBfY2hlY2tQb2ludCAqIHZlbG9jaXR5IC8gX2NoZWNrUG9pbnRSYXRpbztcbn0sXG4gICAgX2NhbGN1bGF0ZUR1cmF0aW9uID0gZnVuY3Rpb24gX2NhbGN1bGF0ZUR1cmF0aW9uKHN0YXJ0LCBlbmQsIHZlbG9jaXR5KSB7XG4gIHJldHVybiBNYXRoLmFicygoZW5kIC0gc3RhcnQpICogX2NoZWNrUG9pbnRSYXRpbyAvIHZlbG9jaXR5IC8gX2NoZWNrUG9pbnQpO1xufSxcbiAgICBfcmVzZXJ2ZWRQcm9wcyA9IHtcbiAgcmVzaXN0YW5jZTogMSxcbiAgY2hlY2twb2ludDogMSxcbiAgcHJldmVudE92ZXJzaG9vdDogMSxcbiAgbGlua2VkUHJvcHM6IDEsXG4gIHJhZGl1czogMSxcbiAgZHVyYXRpb246IDFcbn0sXG4gICAgX3Byb2Nlc3NMaW5rZWRQcm9wcyA9IGZ1bmN0aW9uIF9wcm9jZXNzTGlua2VkUHJvcHModGFyZ2V0LCB2YXJzLCBnZXRWYWwsIHJlc2lzdGFuY2UpIHtcbiAgaWYgKHZhcnMubGlua2VkUHJvcHMpIHtcbiAgICAvL3doZW4gdGhlcmUgYXJlIGxpbmtlZFByb3BzICh0eXBpY2FsbHkgXCJ4LHlcIiB3aGVyZSBzbmFwcGluZyBoYXMgdG8gZmFjdG9yIGluIG11bHRpcGxlIHByb3BlcnRpZXMsIHdlIG11c3QgZmlyc3QgcG9wdWxhdGUgYW4gb2JqZWN0IHdpdGggYWxsIG9mIHRob3NlIGVuZCB2YWx1ZXMsIHRoZW4gZmVlZCBpdCB0byB0aGUgZnVuY3Rpb24gdGhhdCBtYWtlIGFueSBuZWNlc3NhcnkgYWx0ZXJhdGlvbnMuIFNvIHRoZSBwb2ludCBvZiB0aGlzIGZpcnN0IGxvb3AgaXMgdG8gc2ltcGx5IGJ1aWxkIGFuIG9iamVjdCAobGlrZSB7eDoxMDAsIHk6MjA0LjV9KSBmb3IgZmVlZGluZyBpbnRvIHRoYXQgZnVuY3Rpb24gd2hpY2ggd2UnbGwgZG8gbGF0ZXIgaW4gdGhlIFwicmVhbFwiIGxvb3AuXG4gICAgdmFyIGxpbmtlZFByb3BOYW1lcyA9IHZhcnMubGlua2VkUHJvcHMuc3BsaXQoXCIsXCIpLFxuICAgICAgICBsaW5rZWRQcm9wcyA9IHt9LFxuICAgICAgICBpLFxuICAgICAgICBwLFxuICAgICAgICBjdXJQcm9wLFxuICAgICAgICBjdXJWZWxvY2l0eSxcbiAgICAgICAgdHJhY2tlcixcbiAgICAgICAgY3VyRHVyYXRpb247XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlua2VkUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwID0gbGlua2VkUHJvcE5hbWVzW2ldO1xuICAgICAgY3VyUHJvcCA9IHZhcnNbcF07XG5cbiAgICAgIGlmIChjdXJQcm9wKSB7XG4gICAgICAgIGlmIChfaXNOdW1iZXIoY3VyUHJvcC52ZWxvY2l0eSkpIHtcbiAgICAgICAgICBjdXJWZWxvY2l0eSA9IGN1clByb3AudmVsb2NpdHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhY2tlciA9IHRyYWNrZXIgfHwgX2dldFRyYWNrZXIodGFyZ2V0KTtcbiAgICAgICAgICBjdXJWZWxvY2l0eSA9IHRyYWNrZXIgJiYgdHJhY2tlci5pc1RyYWNraW5nKHApID8gdHJhY2tlci5nZXQocCkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyRHVyYXRpb24gPSBNYXRoLmFicyhjdXJWZWxvY2l0eSAvIF9nZXROdW1PckRlZmF1bHQoY3VyUHJvcCwgXCJyZXNpc3RhbmNlXCIsIHJlc2lzdGFuY2UpKTtcbiAgICAgICAgbGlua2VkUHJvcHNbcF0gPSBwYXJzZUZsb2F0KGdldFZhbCh0YXJnZXQsIHApKSArIF9jYWxjdWxhdGVDaGFuZ2UoY3VyVmVsb2NpdHksIGN1ckR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlua2VkUHJvcHM7XG4gIH1cbn0sXG4gICAgX2NhbGN1bGF0ZVR3ZWVuRHVyYXRpb24gPSBmdW5jdGlvbiBfY2FsY3VsYXRlVHdlZW5EdXJhdGlvbih0YXJnZXQsIHZhcnMsIG1heER1cmF0aW9uLCBtaW5EdXJhdGlvbiwgb3ZlcnNob290VG9sZXJhbmNlLCByZWNvcmRFbmQpIHtcbiAgaWYgKG1heER1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICBtYXhEdXJhdGlvbiA9IDEwO1xuICB9XG5cbiAgaWYgKG1pbkR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICBtaW5EdXJhdGlvbiA9IDAuMjtcbiAgfVxuXG4gIGlmIChvdmVyc2hvb3RUb2xlcmFuY2UgPT09IHZvaWQgMCkge1xuICAgIG92ZXJzaG9vdFRvbGVyYW5jZSA9IDE7XG4gIH1cblxuICBpZiAocmVjb3JkRW5kID09PSB2b2lkIDApIHtcbiAgICByZWNvcmRFbmQgPSAwO1xuICB9XG5cbiAgX2lzU3RyaW5nKHRhcmdldCkgJiYgKHRhcmdldCA9IF90b0FycmF5KHRhcmdldClbMF0pO1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgZHVyYXRpb24gPSAwLFxuICAgICAgY2xpcHBlZER1cmF0aW9uID0gX2JpZ051bSxcbiAgICAgIGluZXJ0aWFWYXJzID0gdmFycy5pbmVydGlhIHx8IHZhcnMsXG4gICAgICBnZXRWYWwgPSBfZ2V0Q2FjaGUodGFyZ2V0KS5nZXQsXG4gICAgICByZXNpc3RhbmNlID0gX2dldE51bU9yRGVmYXVsdChpbmVydGlhVmFycywgXCJyZXNpc3RhbmNlXCIsIF9jb25maWcucmVzaXN0YW5jZSksXG4gICAgICBwLFxuICAgICAgY3VyUHJvcCxcbiAgICAgIGN1ckR1cmF0aW9uLFxuICAgICAgY3VyVmVsb2NpdHksXG4gICAgICBjdXJWYWwsXG4gICAgICBlbmQsXG4gICAgICBjdXJDbGlwcGVkRHVyYXRpb24sXG4gICAgICB0cmFja2VyLFxuICAgICAgdW5pdEZhY3RvcixcbiAgICAgIGxpbmtlZFByb3BzOyAvL3doZW4gdGhlcmUgYXJlIGxpbmtlZFByb3BzICh0eXBpY2FsbHkgXCJ4LHlcIiB3aGVyZSBzbmFwcGluZyBoYXMgdG8gZmFjdG9yIGluIG11bHRpcGxlIHByb3BlcnRpZXMsIHdlIG11c3QgZmlyc3QgcG9wdWxhdGUgYW4gb2JqZWN0IHdpdGggYWxsIG9mIHRob3NlIGVuZCB2YWx1ZXMsIHRoZW4gZmVlZCBpdCB0byB0aGUgZnVuY3Rpb24gdGhhdCBtYWtlIGFueSBuZWNlc3NhcnkgYWx0ZXJhdGlvbnMuIFNvIHRoZSBwb2ludCBvZiB0aGlzIGZpcnN0IGxvb3AgaXMgdG8gc2ltcGx5IGJ1aWxkIGFuIG9iamVjdCAobGlrZSB7eDoxMDAsIHk6MjA0LjV9KSBmb3IgZmVlZGluZyBpbnRvIHRoYXQgZnVuY3Rpb24gd2hpY2ggd2UnbGwgZG8gbGF0ZXIgaW4gdGhlIFwicmVhbFwiIGxvb3AuXG5cblxuICBsaW5rZWRQcm9wcyA9IF9wcm9jZXNzTGlua2VkUHJvcHModGFyZ2V0LCBpbmVydGlhVmFycywgZ2V0VmFsLCByZXNpc3RhbmNlKTtcblxuICBmb3IgKHAgaW4gaW5lcnRpYVZhcnMpIHtcbiAgICBpZiAoIV9yZXNlcnZlZFByb3BzW3BdKSB7XG4gICAgICBjdXJQcm9wID0gaW5lcnRpYVZhcnNbcF07XG5cbiAgICAgIGlmICghX2lzT2JqZWN0KGN1clByb3ApKSB7XG4gICAgICAgIHRyYWNrZXIgPSB0cmFja2VyIHx8IF9nZXRUcmFja2VyKHRhcmdldCk7XG5cbiAgICAgICAgaWYgKHRyYWNrZXIgJiYgdHJhY2tlci5pc1RyYWNraW5nKHApKSB7XG4gICAgICAgICAgY3VyUHJvcCA9IF9pc051bWJlcihjdXJQcm9wKSA/IHtcbiAgICAgICAgICAgIHZlbG9jaXR5OiBjdXJQcm9wXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIHZlbG9jaXR5OiB0cmFja2VyLmdldChwKVxuICAgICAgICAgIH07IC8vaWYgd2UncmUgdHJhY2tpbmcgdGhpcyBwcm9wZXJ0eSwgd2Ugc2hvdWxkIHVzZSB0aGUgdHJhY2tpbmcgdmVsb2NpdHkgYW5kIHRoZW4gdXNlIHRoZSBudW1lcmljIHZhbHVlIHRoYXQgd2FzIHBhc3NlZCBpbiBhcyB0aGUgbWluIGFuZCBtYXggc28gdGhhdCBpdCB0d2VlbnMgZXhhY3RseSB0aGVyZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJWZWxvY2l0eSA9ICtjdXJQcm9wIHx8IDA7XG4gICAgICAgICAgY3VyRHVyYXRpb24gPSBNYXRoLmFicyhjdXJWZWxvY2l0eSAvIHJlc2lzdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNPYmplY3QoY3VyUHJvcCkpIHtcbiAgICAgICAgaWYgKF9pc051bWJlcihjdXJQcm9wLnZlbG9jaXR5KSkge1xuICAgICAgICAgIGN1clZlbG9jaXR5ID0gY3VyUHJvcC52ZWxvY2l0eTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2tlciB8fCBfZ2V0VHJhY2tlcih0YXJnZXQpO1xuICAgICAgICAgIGN1clZlbG9jaXR5ID0gdHJhY2tlciAmJiB0cmFja2VyLmlzVHJhY2tpbmcocCkgPyB0cmFja2VyLmdldChwKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJEdXJhdGlvbiA9IF9jbGFtcChtaW5EdXJhdGlvbiwgbWF4RHVyYXRpb24sIE1hdGguYWJzKGN1clZlbG9jaXR5IC8gX2dldE51bU9yRGVmYXVsdChjdXJQcm9wLCBcInJlc2lzdGFuY2VcIiwgcmVzaXN0YW5jZSkpKTtcbiAgICAgICAgY3VyVmFsID0gcGFyc2VGbG9hdChnZXRWYWwodGFyZ2V0LCBwKSkgfHwgMDtcbiAgICAgICAgZW5kID0gY3VyVmFsICsgX2NhbGN1bGF0ZUNoYW5nZShjdXJWZWxvY2l0eSwgY3VyRHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChcImVuZFwiIGluIGN1clByb3ApIHtcbiAgICAgICAgICBjdXJQcm9wID0gX3BhcnNlRW5kKGN1clByb3AsIGxpbmtlZFByb3BzICYmIHAgaW4gbGlua2VkUHJvcHMgPyBsaW5rZWRQcm9wcyA6IGVuZCwgY3VyUHJvcC5tYXgsIGN1clByb3AubWluLCBwLCBpbmVydGlhVmFycy5yYWRpdXMsIGN1clZlbG9jaXR5KTtcblxuICAgICAgICAgIGlmIChyZWNvcmRFbmQpIHtcbiAgICAgICAgICAgIF9wcm9jZXNzaW5nVmFycyA9PT0gdmFycyAmJiAoX3Byb2Nlc3NpbmdWYXJzID0gaW5lcnRpYVZhcnMgPSBfZGVlcENsb25lKHZhcnMpKTtcbiAgICAgICAgICAgIGluZXJ0aWFWYXJzW3BdID0gX2V4dGVuZChjdXJQcm9wLCBpbmVydGlhVmFyc1twXSwgXCJlbmRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwibWF4XCIgaW4gY3VyUHJvcCAmJiBlbmQgPiArY3VyUHJvcC5tYXggKyBfdGlueU51bSkge1xuICAgICAgICAgIHVuaXRGYWN0b3IgPSBjdXJQcm9wLnVuaXRGYWN0b3IgfHwgX2NvbmZpZy51bml0RmFjdG9yc1twXSB8fCAxOyAvL3NvbWUgdmFsdWVzIGFyZSBtZWFzdXJlZCBpbiBzcGVjaWFsIHVuaXRzIGxpa2UgcmFkaWFucyBpbiB3aGljaCBjYXNlIG91ciB0aHJlc2hvbGRzIG5lZWQgdG8gYmUgYWRqdXN0ZWQgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgLy9pZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBleGNlZWRpbmcgdGhlIG1heCBvciB0aGUgdmVsb2NpdHkgaXMgdG9vIGxvdywgdGhlIGR1cmF0aW9uIGNhbiBlbmQgdXAgYmVpbmcgdW5jb21mb3J0YWJseSBsb25nIGJ1dCBpbiBtb3N0IHNpdHVhdGlvbnMsIHVzZXJzIHdhbnQgdGhlIHNuYXBwaW5nIHRvIG9jY3VyIHJlbGF0aXZlbHkgcXVpY2tseSAoMC43NSBzZWNvbmRzKSwgc28gd2UgaW1wbGVtZW50IGEgY2FwIGhlcmUgdG8gbWFrZSB0aGluZ3MgbW9yZSBpbnR1aXRpdmUuIElmIHRoZSBtYXggYW5kIG1pbiBtYXRjaCwgaXQgbWVhbnMgd2UncmUgYW5pbWF0aW5nIHRvIGEgcGFydGljdWxhciB2YWx1ZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBzaG9ydGVuIHRoZSB0aW1lIHVubGVzcyB0aGUgdmVsb2NpdHkgaXMgcmVhbGx5IHNsb3cuIEV4YW1wbGU6IGEgcm90YXRpb24gd2hlcmUgdGhlIHN0YXJ0IGFuZCBuYXR1cmFsIGVuZCB2YWx1ZSBhcmUgbGVzcyB0aGFuIHRoZSBzbmFwcGluZyBzcG90LCBidXQgdGhlIG5hdHVyYWwgZW5kIGlzIHByZXR0eSBjbG9zZSB0byB0aGUgc25hcC5cblxuICAgICAgICAgIGN1ckNsaXBwZWREdXJhdGlvbiA9IGN1clZhbCAIGN1clByb3AubWF4ICYmIGN1clByb3AubWluICE9PSBjdXJQcm9wLm1heCB8fCBjdXJWZWxvY2l0eSAqIHVuaXRGYWN0b3IgPiAtMTUgJiYgY3VyVmVsb2NpdHkgKiB1bml0RmFjdG9yIDwgNDUgPyBtaW5EdXJhdGlvbiArIChtYXhEdXJhdGlvbiAtIG1pbkR1cmF0aW9uKSAqIDAuMSA6IF9jYWxjdWxhdGVEdXJhdGlvbihjdXJWYWwsIGN1clByb3AubWF4LCBjdXJWZWxvY2l0eSk7XG5cbiAgICAgICAgICBpZiAoY3VyQ2xpcHBlZER1cmF0aW9uICsgb3ZlcnNob290VG9sZXJhbmNlIDwgY2xpcHBlZER1cmF0aW9uKSB7XG4gICAgICAgICAgICBjbGlwcGVkRHVyYXRpb24gPSBjdXJDbGlwcGVkRHVyYXRpb24gKyBvdmVyc2hvb3RUb2xlcmFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFwibWluXCIgaW4gY3VyUHJvcCAmJiBlbmQgPCArY3VyUHJvcC5taW4gLSBfdGlueU51bSkge1xuICAgICAgICAgIHVuaXRGYWN0b3IgPSBjdXJQcm9wLnVuaXRGYWN0b3IgfHwgX2NvbmZpZy51bml0RmFjdG9yc1twXSB8fCAxOyAvL3NvbWUgdmFsdWVzIGFyZSBtZWFzdXJlZCBpbiBzcGVjaWFsIHVuaXRzIGxpa2UgcmFkaWFucyBpbiB3aGljaCBjYXNlIG91ciB0aHJlc2hvbGRzIG5lZWQgdG8gYmUgYWRqdXN0ZWQgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgLy9pZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSBleGNlZWRpbmcgdGhlIG1pbiBvciBpZiB0aGUgdmVsb2NpdHkgaXMgdG9vIGxvdywgdGhlIGR1cmF0aW9uIGNhbiBlbmQgdXAgYmVpbmcgdW5jb21mb3J0YWJseSBsb25nIGJ1dCBpbiBtb3N0IHNpdHVhdGlvbnMsIHVzZXJzIHdhbnQgdGhlIHNuYXBwaW5nIHRvIG9jY3VyIHJlbGF0aXZlbHkgcXVpY2tseSAoMC43NSBzZWNvbmRzKSwgc28gd2UgaW1wbGVtZW50IGEgY2FwIGhlcmUgdG8gbWFrZSB0aGluZ3MgbW9yZSBpbnR1aXRpdmUuXG5cbiAgICAgICAgICBjdXJDbGlwcGVkRHVyYXRpb24gPSBjdXJWYWwgPCBjdXJQcm9wLm1pbiAmJiBjdXJQcm9wLm1pbiAhPT0gY3VyUHJvcC5tYXggfHwgY3VyVmVsb2NpdHkgKiB1bml0RmFjdG9yID4gLTQ1ICYmIGN1clZlbG9jaXR5ICogdW5pdEZhY3RvciA8IDE1ID8gbWluRHVyYXRpb24gKyAobWF4RHVyYXRpb24gLSBtaW5EdXJhdGlvbikgKiAwLjEgOiBfY2FsY3VsYXRlRHVyYXRpb24oY3VyVmFsLCBjdXJQcm9wLm1pbiwgY3VyVmVsb2NpdHkpO1xuXG4gICAgICAgICAgaWYgKGN1ckNsaXBwZWREdXJhdGlvbiArIG92ZXJzaG9vdFRvbGVyYW5jZSA8IGNsaXBwZWREdXJhdGlvbikge1xuICAgICAgICAgICAgY2xpcHBlZER1cmF0aW9uID0gY3VyQ2xpcHBlZER1cmF0aW9uICsgb3ZlcnNob290VG9sZXJhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1ckNsaXBwZWREdXJhdGlvbiAIGR1cmF0aW9uICYmIChkdXJhdGlvbiA9IGN1ckNsaXBwZWREdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGN1ckR1cmF0aW9uID4gZHVyYXRpb24gJiYgKGR1cmF0aW9uID0gY3VyRHVyYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGR1cmF0aW9uID4gY2xpcHBlZER1cmF0aW9uICYmIChkdXJhdGlvbiA9IGNsaXBwZWREdXJhdGlvbik7XG4gIHJldHVybiBkdXJhdGlvbiAIG1heER1cmF0aW9uID8gbWF4RHVyYXRpb24gOiBkdXJhdGlvbiA8IG1pbkR1cmF0aW9uID8gbWluRHVyYXRpb24gOiBkdXJhdGlvbjtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBnc2FwID0gX2dldEdTQVAoKTtcblxuICBpZiAoZ3NhcCkge1xuICAgIF9wYXJzZUVhc2UgPSBnc2FwLnBhcnNlRWFzZTtcbiAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcbiAgICBfZ2V0VW5pdCA9IGdzYXAudXRpbHMuZ2V0VW5pdDtcbiAgICBfZ2V0Q2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGU7XG4gICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcbiAgICBfcG93ZXIzID0gX3BhcnNlRWFzZShcInBvd2VyM1wiKTtcbiAgICBfY2hlY2tQb2ludFJhdGlvID0gX3Bvd2VyMygwLjA1KTtcbiAgICBQcm9wVHdlZW4gPSBnc2FwLmNvcmUuUHJvcFR3ZWVuO1xuICAgIGdzYXAuY29uZmlnKHtcbiAgICAgIHJlc2lzdGFuY2U6IDEwMCxcbiAgICAgIHVuaXRGYWN0b3JzOiB7XG4gICAgICAgIHRpbWU6IDEwMDAsXG4gICAgICAgIHRvdGFsVGltZTogMTAwMCxcbiAgICAgICAgcHJvZ3Jlc3M6IDEwMDAsXG4gICAgICAgIHRvdGFsUHJvZ3Jlc3M6IDEwMDBcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfY29uZmlnID0gZ3NhcC5jb25maWcoKTtcbiAgICBnc2FwLnJlZ2lzdGVyUGx1Z2luKFZlbG9jaXR5VHJhY2tlcik7XG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBJbmVydGlhUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTAuNFwiLFxuICBuYW1lOiBcImluZXJ0aWFcIixcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBnc2FwID0gY29yZTtcblxuICAgIF9pbml0Q29yZSgpO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gICAgdmFyIHRyYWNrZXIgPSBfZ2V0VHJhY2tlcih0YXJnZXQpO1xuXG4gICAgaWYgKHZhcnMgPT09IFwiYXV0b1wiKSB7XG4gICAgICBpZiAoIXRyYWNrZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gaW5lcnRpYSB0cmFja2luZyBvbiBcIiArIHRhcmdldCArIFwiLiBJbmVydGlhUGx1Z2luLnRyYWNrKHRhcmdldCkgZmlyc3QuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhcnMgPSB0cmFja2VyLmdldEFsbCgpO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcbiAgICBfcHJvY2Vzc2luZ1ZhcnMgPSB2YXJzOyAvLyBnZXRzIHN3YXBwZWQgaW5zaWRlIF9jYWxjdWxhdGVUd2VlbkR1cmF0aW9uKCkgaWYgdGhlcmUncyBhIGZ1bmN0aW9uLWJhc2VkIHZhbHVlIGVuY291bnRlcmVkICh0byBhdm9pZCBkb3VibGUtY2FsbGluZyBpdClcblxuICAgIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgZ2V0VmFsID0gY2FjaGUuZ2V0LFxuICAgICAgICBkdXIgPSB2YXJzLmR1cmF0aW9uLFxuICAgICAgICBkdXJJc09iaiA9IF9pc09iamVjdChkdXIpLFxuICAgICAgICBwcmV2ZW50T3ZlcnNob290ID0gdmFycy5wcmV2ZW50T3ZlcnNob290IHx8IGR1cklzT2JqICYmIGR1ci5vdmVyc2hvb3QgPT09IDAsXG4gICAgICAgIHJlc2lzdGFuY2UgPSBfZ2V0TnVtT3JEZWZhdWx0KHZhcnMsIFwicmVzaXN0YW5jZVwiLCBfY29uZmlnLnJlc2lzdGFuY2UpLFxuICAgICAgICBkdXJhdGlvbiA9IF9pc051bWJlcihkdXIpID8gZHVyIDogX2NhbGN1bGF0ZVR3ZWVuRHVyYXRpb24odGFyZ2V0LCB2YXJzLCBkdXJJc09iaiAmJiBkdXIubWF4IHx8IDEwLCBkdXJJc09iaiAmJiBkdXIubWluIHx8IDAuMiwgZHVySXNPYmogJiYgXCJvdmVyc2hvb3RcIiBpbiBkdXIgPyArZHVyLm92ZXJzaG9vdCA6IHByZXZlbnRPdmVyc2hvb3QgPyAwIDogMSwgdHJ1ZSksXG4gICAgICAgIHAsXG4gICAgICAgIGN1clByb3AsXG4gICAgICAgIGN1clZhbCxcbiAgICAgICAgdW5pdCxcbiAgICAgICAgdmVsb2NpdHksXG4gICAgICAgIGNoYW5nZTEsXG4gICAgICAgIGVuZCxcbiAgICAgICAgY2hhbmdlMixcbiAgICAgICAgbGlua2VkUHJvcHM7XG5cbiAgICB2YXJzID0gX3Byb2Nlc3NpbmdWYXJzO1xuICAgIF9wcm9jZXNzaW5nVmFycyA9IDA7IC8vd2hlbiB0aGVyZSBhcmUgbGlua2VkUHJvcHMgKHR5cGljYWxseSBcIngseVwiIHdoZXJlIHNuYXBwaW5nIGhhcyB0byBmYWN0b3IgaW4gbXVsdGlwbGUgcHJvcGVydGllcywgd2UgbXVzdCBmaXJzdCBwb3B1bGF0ZSBhbiBvYmplY3Qgd2l0aCBhbGwgb2YgdGhvc2UgZW5kIHZhbHVlcywgdGhlbiBmZWVkIGl0IHRvIHRoZSBmdW5jdGlvbiB0aGF0IG1ha2UgYW55IG5lY2Vzc2FyeSBhbHRlcmF0aW9ucy4gU28gdGhlIHBvaW50IG9mIHRoaXMgZmlyc3QgbG9vcCBpcyB0byBzaW1wbHkgYnVpbGQgYW4gb2JqZWN0IChsaWtlIHt4OjEwMCwgeToyMDQuNX0pIGZvciBmZWVkaW5nIGludG8gdGhhdCBmdW5jdGlvbiB3aGljaCB3ZSdsbCBkbyBsYXRlciBpbiB0aGUgXCJyZWFsXCIgbG9vcC5cblxuICAgIGxpbmtlZFByb3BzID0gX3Byb2Nlc3NMaW5rZWRQcm9wcyh0YXJnZXQsIHZhcnMsIGdldFZhbCwgcmVzaXN0YW5jZSk7XG5cbiAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgaWYgKCFfcmVzZXJ2ZWRQcm9wc1twXSkge1xuICAgICAgICBjdXJQcm9wID0gdmFyc1twXTtcbiAgICAgICAgX2lzRnVuY3Rpb24oY3VyUHJvcCkgJiYgKGN1clByb3AgPSBjdXJQcm9wKGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKTtcblxuICAgICAgICBpZiAoX2lzTnVtYmVyKGN1clByb3ApKSB7XG4gICAgICAgICAgdmVsb2NpdHkgPSBjdXJQcm9wO1xuICAgICAgICB9IGVsc2UgaWYgKF9pc09iamVjdChjdXJQcm9wKSAmJiAhaXNOYU4oY3VyUHJvcC52ZWxvY2l0eSkpIHtcbiAgICAgICAgICB2ZWxvY2l0eSA9ICtjdXJQcm9wLnZlbG9jaXR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0cmFja2VyICYmIHRyYWNrZXIuaXNUcmFja2luZyhwKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSB0cmFja2VyLmdldChwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRVJST1I6IE5vIHZlbG9jaXR5IHdhcyBkZWZpbmVkIGZvciBcIiArIHRhcmdldCArIFwiIHByb3BlcnR5OiBcIiArIHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZTEgPSBfY2FsY3VsYXRlQ2hhbmdlKHZlbG9jaXR5LCBkdXJhdGlvbik7XG4gICAgICAgIGNoYW5nZTIgPSAwO1xuICAgICAgICBjdXJWYWwgPSBnZXRWYWwodGFyZ2V0LCBwKTtcbiAgICAgICAgdW5pdCA9IF9nZXRVbml0KGN1clZhbCk7XG4gICAgICAgIGN1clZhbCA9IHBhcnNlRmxvYXQoY3VyVmFsKTtcblxuICAgICAgICBpZiAoX2lzT2JqZWN0KGN1clByb3ApKSB7XG4gICAgICAgICAgZW5kID0gY3VyVmFsICsgY2hhbmdlMTtcblxuICAgICAgICAgIGlmIChcImVuZFwiIGluIGN1clByb3ApIHtcbiAgICAgICAgICAgIGN1clByb3AgPSBfcGFyc2VFbmQoY3VyUHJvcCwgbGlua2VkUHJvcHMgJiYgcCBpbiBsaW5rZWRQcm9wcyA/IGxpbmtlZFByb3BzIDogZW5kLCBjdXJQcm9wLm1heCwgY3VyUHJvcC5taW4sIHAsIHZhcnMucmFkaXVzLCB2ZWxvY2l0eSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFwibWF4XCIgaW4gY3VyUHJvcCAmJiArY3VyUHJvcC5tYXggPCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50T3ZlcnNob290IHx8IGN1clByb3AucHJldmVudE92ZXJzaG9vdCkge1xuICAgICAgICAgICAgICBjaGFuZ2UxID0gY3VyUHJvcC5tYXggLSBjdXJWYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGFuZ2UyID0gY3VyUHJvcC5tYXggLSBjdXJWYWwgLSBjaGFuZ2UxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoXCJtaW5cIiBpbiBjdXJQcm9wICYmICtjdXJQcm9wLm1pbiAIGVuZCkge1xuICAgICAgICAgICAgaWYgKHByZXZlbnRPdmVyc2hvb3QgfHwgY3VyUHJvcC5wcmV2ZW50T3ZlcnNob290KSB7XG4gICAgICAgICAgICAgIGNoYW5nZTEgPSBjdXJQcm9wLm1pbiAtIGN1clZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoYW5nZTIgPSBjdXJQcm9wLm1pbiAtIGN1clZhbCAtIGNoYW5nZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcblxuICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcCwgY3VyVmFsLCAwLCBfZW1wdHlGdW5jLCAwLCBjYWNoZS5zZXQodGFyZ2V0LCBwLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuX3B0LnUgPSB1bml0IHx8IDA7XG4gICAgICAgIHRoaXMuX3B0LmMxID0gY2hhbmdlMTtcbiAgICAgICAgdGhpcy5fcHQuYzIgPSBjaGFuZ2UyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHR3ZWVuLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gX2JvbnVzVmFsaWRhdGVkO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0O1xuICAgIHJhdGlvID0gX3Bvd2VyMyhkYXRhLnR3ZWVuLl90aW1lIC8gZGF0YS50d2Vlbi5fZHVyKTtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQuc2V0KHB0LnQsIHB0LnAsIF9yb3VuZChwdC5zICsgcHQuYzEgKiByYXRpbyArIHB0LmMyICogcmF0aW8gKiByYXRpbykgKyBwdC51LCBwdC5kLCByYXRpbyk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cbiAgfVxufTtcblwidHJhY2ssdW50cmFjayxpc1RyYWNraW5nLGdldFZlbG9jaXR5LGdldEJ5VGFyZ2V0XCIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIEluZXJ0aWFQbHVnaW5bbmFtZV0gPSBWZWxvY2l0eVRyYWNrZXJbbmFtZV07XG59KTtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihJbmVydGlhUGx1Z2luKTtcbmV4cG9ydCB7IEluZXJ0aWFQbHVnaW4gYXMgZGVmYXVsdCwgVmVsb2NpdHlUcmFja2VyIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/InertiaPlugin.js\n");

/***/ }),

/***/ "./node_modules/gsap/Observer.js":
/*!***************************************!*\
  !*** ./node_modules/gsap/Observer.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observer: () => (/* binding */ Observer),\n/* harmony export */   _getProxyProp: () => (/* binding */ _getProxyProp),\n/* harmony export */   _getScrollFunc: () => (/* binding */ _getScrollFunc),\n/* harmony export */   _getTarget: () => (/* binding */ _getTarget),\n/* harmony export */   _getVelocityProp: () => (/* binding */ _getVelocityProp),\n/* harmony export */   _horizontal: () => (/* binding */ _horizontal),\n/* harmony export */   _isViewport: () => (/* binding */ _isViewport),\n/* harmony export */   _proxies: () => (/* binding */ _proxies),\n/* harmony export */   _scrollers: () => (/* binding */ _scrollers),\n/* harmony export */   _vertical: () => (/* binding */ _vertical),\n/* harmony export */   \"default\": () => (/* binding */ Observer)\n/* harmony export */ });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*!\n * Observer 3.10.4\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _clamp,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _isTouch,\n    _pointerType,\n    ScrollTrigger,\n    _root,\n    _normalizer,\n    _eventTypes,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _passThrough = function _passThrough(p) {\n  return p;\n},\n    _startup = 1,\n    _observers = [],\n    _scrollers = [],\n    _proxies = [],\n    _getTime = Date.now,\n    _bridge = function _bridge(name, value) {\n  return value;\n},\n    _integrate = function _integrate() {\n  var core = ScrollTrigger.core,\n      data = core.bridge || {},\n      scrollers = core._scrollers,\n      proxies = core._proxies;\n  scrollers.push.apply(scrollers, _scrollers);\n  proxies.push.apply(proxies, _proxies);\n  _scrollers = scrollers;\n  _proxies = proxies;\n\n  _bridge = function _bridge(name, value) {\n    return data[name](value);\n  };\n},\n    _getProxyProp = function _getProxyProp(element, property) {\n  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element)  1][property];\n},\n    _isViewport = function _isViewport(el) {\n  return !!~_root.indexOf(el);\n},\n    _addListener = function _addListener(element, type, func, nonPassive, capture) {\n  return element.addEventListener(type, func, {\n    passive: !nonPassive,\n    capture: !!capture\n  });\n},\n    _removeListener = function _removeListener(element, type, func, capture) {\n  return element.removeEventListener(type, func, !!capture);\n},\n    _scrollLeft = \"scrollLeft\",\n    _scrollTop = \"scrollTop\",\n    _onScroll = function _onScroll() {\n  return _normalizer && _normalizer.isPressed || _scrollers.cache;\n},\n    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {\n  var cachingFunc = function cachingFunc(value) {\n    // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\n    if (value || value === 0) {\n      _startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\n\n      var isNormalizing = _normalizer && _normalizer.isPressed;\n      value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\n\n      f(value);\n      cachingFunc.cacheID = _scrollers.cache;\n      isNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\n    } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\n      cachingFunc.cacheID = _scrollers.cache;\n      cachingFunc.v = f();\n    }\n\n    return cachingFunc.v  cachingFunc.offset;\n  };\n\n  cachingFunc.offset = 0;\n  return f && cachingFunc;\n},\n    _horizontal = {\n  s: _scrollLeft,\n  p: \"left\",\n  p2: \"Left\",\n  os: \"right\",\n  os2: \"Right\",\n  d: \"width\",\n  d2: \"Width\",\n  a: \"x\",\n  sc: _scrollCacheFunc(function (value) {\n    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n  })\n},\n    _vertical = {\n  s: _scrollTop,\n  p: \"top\",\n  p2: \"Top\",\n  os: \"bottom\",\n  os2: \"Bottom\",\n  d: \"height\",\n  d2: \"Height\",\n  a: \"y\",\n  op: _horizontal,\n  sc: _scrollCacheFunc(function (value) {\n    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n  })\n},\n    _getTarget = function _getTarget(t) {\n  return gsap.utils.toArray(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null);\n},\n    _getScrollFunc = function _getScrollFunc(element, _ref) {\n  var s = _ref.s,\n      sc = _ref.sc;\n\n  // we store the scroller functions in a alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n  var i = _scrollers.indexOf(element),\n      offset = sc === _vertical.sc ? 1 : 2;\n\n  !~i && (i = _scrollers.push(element) - 1);\n  return _scrollers[i  offset] || (_scrollers[i  offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {\n    return arguments.length ? element[s] = value : element[s];\n  })));\n},\n    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {\n  var v1 = value,\n      v2 = value,\n      t1 = _getTime(),\n      t2 = t1,\n      min = minTimeRefresh || 50,\n      dropToZeroTime = Math.max(500, min * 3),\n      update = function update(value, force) {\n    var t = _getTime();\n\n    if (force || t - t1 > min) {\n      v2 = v1;\n      v1 = value;\n      t2 = t1;\n      t1 = t;\n    } else if (useDelta) {\n      v1 = value;\n    } else {\n      // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\n      v1 = v2  (value - v2) / (t - t2) * (t1 - t2);\n    }\n  },\n      reset = function reset() {\n    v2 = v1 = useDelta ? 0 : v1;\n    t2 = t1 = 0;\n  },\n      getVelocity = function getVelocity(latestValue) {\n    var tOld = t2,\n        vOld = v2,\n        t = _getTime();\n\n    (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n    return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1  (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\n  };\n\n  return {\n    update: update,\n    reset: reset,\n    getVelocity: getVelocity\n  };\n},\n    _getEvent = function _getEvent(e, preventDefault) {\n  preventDefault && !e._gsapAllow && e.preventDefault();\n  return e.changedTouches ? e.changedTouches[0] : e;\n},\n    _getAbsoluteMax = function _getAbsoluteMax(a) {\n  var max = Math.max.apply(Math, a),\n      min = Math.min.apply(Math, a);\n  return Math.abs(max) >= Math.abs(min) ? max : min;\n},\n    _setScrollTrigger = function _setScrollTrigger() {\n  ScrollTrigger = gsap.core.globals().ScrollTrigger;\n  ScrollTrigger && ScrollTrigger.core && _integrate();\n},\n    _initCore = function _initCore(core) {\n  gsap = core || _getGSAP();\n\n  if (gsap && typeof document !== \"undefined\" && document.body) {\n    _win = window;\n    _doc = document;\n    _docEl = _doc.documentElement;\n    _body = _doc.body;\n    _root = [_win, _doc, _docEl, _body];\n    _clamp = gsap.utils.clamp;\n    _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n\n    _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\n    _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n    setTimeout(function () {\n      return _startup = 0;\n    }, 500);\n\n    _setScrollTrigger();\n\n    _coreInitted = 1;\n  }\n\n  return _coreInitted;\n};\n\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\nvar Observer = /*#__PURE__*/function () {\n  function Observer(vars) {\n    this.init(vars);\n  }\n\n  var _proto = Observer.prototype;\n\n  _proto.init = function init(vars) {\n    _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n    ScrollTrigger || _setScrollTrigger();\n    var tolerance = vars.tolerance,\n        dragMinimum = vars.dragMinimum,\n        type = vars.type,\n        target = vars.target,\n        lineHeight = vars.lineHeight,\n        debounce = vars.debounce,\n        preventDefault = vars.preventDefault,\n        onStop = vars.onStop,\n        onStopDelay = vars.onStopDelay,\n        ignore = vars.ignore,\n        wheelSpeed = vars.wheelSpeed,\n        event = vars.event,\n        onDragStart = vars.onDragStart,\n        onDragEnd = vars.onDragEnd,\n        onDrag = vars.onDrag,\n        onPress = vars.onPress,\n        onRelease = vars.onRelease,\n        onRight = vars.onRight,\n        onLeft = vars.onLeft,\n        onUp = vars.onUp,\n        onDown = vars.onDown,\n        onChangeX = vars.onChangeX,\n        onChangeY = vars.onChangeY,\n        onChange = vars.onChange,\n        onToggleX = vars.onToggleX,\n        onToggleY = vars.onToggleY,\n        onHover = vars.onHover,\n        onHoverEnd = vars.onHoverEnd,\n        onMove = vars.onMove,\n        ignoreCheck = vars.ignoreCheck,\n        isNormalizer = vars.isNormalizer,\n        onGestureStart = vars.onGestureStart,\n        onGestureEnd = vars.onGestureEnd,\n        onWheel = vars.onWheel,\n        onEnable = vars.onEnable,\n        onDisable = vars.onDisable,\n        onClick = vars.onClick,\n        scrollSpeed = vars.scrollSpeed,\n        capture = vars.capture,\n        allowClicks = vars.allowClicks,\n        lockAxis = vars.lockAxis,\n        onLockAxis = vars.onLockAxis;\n    this.target = target = _getTarget(target) || _docEl;\n    this.vars = vars;\n    ignore && (ignore = gsap.utils.toArray(ignore));\n    tolerance = tolerance || 0;\n    dragMinimum = dragMinimum || 0;\n    wheelSpeed = wheelSpeed || 1;\n    scrollSpeed = scrollSpeed || 1;\n    type = type || \"wheel,touch,pointer\";\n    debounce = debounce !== false;\n    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\n\n    var id,\n        onStopDelayedCall,\n        dragged,\n        moved,\n        wheeled,\n        locked,\n        axis,\n        self = this,\n        prevDeltaX = 0,\n        prevDeltaY = 0,\n        scrollFuncX = _getScrollFunc(target, _horizontal),\n        scrollFuncY = _getScrollFunc(target, _vertical),\n        scrollX = scrollFuncX(),\n        scrollY = scrollFuncY(),\n        limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\",\n        // for devices that accommodate mouse events and touch events, we need to distinguish.\n    isViewport = _isViewport(target),\n        ownerDoc = target.ownerDocument || _doc,\n        deltaX = [0, 0, 0],\n        // wheel, scroll, pointer/touch\n    deltaY = [0, 0, 0],\n        onClickTime = 0,\n        clickCapture = function clickCapture() {\n      return onClickTime = _getTime();\n    },\n        _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {\n      return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);\n    },\n        onStopFunc = function onStopFunc() {\n      self._vx.reset();\n\n      self._vy.reset();\n\n      onStopDelayedCall.pause();\n      onStop && onStop(self);\n    },\n        update = function update() {\n      var dx = self.deltaX = _getAbsoluteMax(deltaX),\n          dy = self.deltaY = _getAbsoluteMax(deltaY),\n          changedX = Math.abs(dx) >= tolerance,\n          changedY = Math.abs(dy) >= tolerance;\n\n      onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\n\n      if (changedX) {\n        onRight && self.deltaX > 0 && onRight(self);\n        onLeft && self.deltaX < 0 && onLeft(self);\n        onChangeX && onChangeX(self);\n        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\n        prevDeltaX = self.deltaX;\n        deltaX[0] = deltaX[1] = deltaX[2] = 0;\n      }\n\n      if (changedY) {\n        onDown && self.deltaY > 0 && onDown(self);\n        onUp && self.deltaY < 0 && onUp(self);\n        onChangeY && onChangeY(self);\n        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\n        prevDeltaY = self.deltaY;\n        deltaY[0] = deltaY[1] = deltaY[2] = 0;\n      }\n\n      if (moved || dragged) {\n        onMove && onMove(self);\n        onLockAxis && locked && onLockAxis(self);\n\n        if (dragged) {\n          onDrag(self);\n          dragged = false;\n        }\n\n        moved = locked = false;\n      }\n\n      if (wheeled) {\n        onWheel(self);\n        wheeled = false;\n      }\n\n      id = 0;\n    },\n        onDelta = function onDelta(x, y, index) {\n      deltaX[index] = x;\n      deltaY[index] = y;\n\n      self._vx.update(x);\n\n      self._vy.update(y);\n\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\n    },\n        onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {\n      if (axis !== \"y\") {\n        deltaX[2] = x;\n\n        self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\n\n      }\n\n      if (axis !== \"x\") {\n        deltaY[2] = y;\n\n        self._vy.update(y, true);\n      }\n\n      if (lockAxis && !axis) {\n        self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n        locked = true;\n      }\n\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\n    },\n        _onDrag = function _onDrag(e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n\n      e = _getEvent(e, preventDefault);\n      var x = e.clientX,\n          y = e.clientY,\n          dx = x - self.x,\n          dy = y - self.y,\n          isDragging = self.isDragging;\n      self.x = x;\n      self.y = y;\n\n      if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {\n        onDrag && (dragged = true);\n        isDragging || (self.isDragging = true);\n        onTouchOrPointerDelta(dx, dy);\n        isDragging || onDragStart && onDragStart(self);\n      }\n    },\n        _onPress = self.onPress = function (e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n\n      self.axis = axis = null;\n      onStopDelayedCall.pause();\n      self.isPressed = true;\n      e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\n\n      prevDeltaX = prevDeltaY = 0;\n      self.startX = self.x = e.clientX;\n      self.startY = self.y = e.clientY;\n\n      self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\n\n\n      self._vy.reset();\n\n      _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);\n\n      self.deltaX = self.deltaY = 0;\n      onPress && onPress(self);\n    },\n        _onRelease = function _onRelease(e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n\n      _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n\n      var wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),\n          // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\n      eventData = _getEvent(e);\n\n      if (!wasDragging) {\n        self._vx.reset();\n\n        self._vy.reset();\n\n        if (preventDefault && allowClicks) {\n          gsap.delayedCall(0.08, function () {\n            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n              if (e.target.click) {\n                //some browsers (like mobile Safari) don't properly trigger the click event\n                e.target.click();\n              } else if (ownerDoc.createEvent) {\n                var syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n                e.target.dispatchEvent(syntheticEvent);\n              }\n            }\n          });\n        }\n      }\n\n      self.isDragging = self.isGesturing = self.isPressed = false;\n      onStop && !isNormalizer && onStopDelayedCall.restart(true);\n      onDragEnd && wasDragging && onDragEnd(self);\n      onRelease && onRelease(self, wasDragging);\n    },\n        _onGestureStart = function _onGestureStart(e) {\n      return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);\n    },\n        _onGestureEnd = function _onGestureEnd() {\n      return (self.isGesturing = false) || onGestureEnd(self);\n    },\n        onScroll = function onScroll(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n\n      var x = scrollFuncX(),\n          y = scrollFuncY();\n      onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n      scrollX = x;\n      scrollY = y;\n      onStop && onStopDelayedCall.restart(true);\n    },\n        _onWheel = function _onWheel(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n\n      e = _getEvent(e, preventDefault);\n      onWheel && (wheeled = true);\n      var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n      onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n      onStop && !isNormalizer && onStopDelayedCall.restart(true);\n    },\n        _onMove = function _onMove(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n\n      var x = e.clientX,\n          y = e.clientY,\n          dx = x - self.x,\n          dy = y - self.y;\n      self.x = x;\n      self.y = y;\n      moved = true;\n      (dx || dy) && onTouchOrPointerDelta(dx, dy);\n    },\n        _onHover = function _onHover(e) {\n      self.event = e;\n      onHover(self);\n    },\n        _onHoverEnd = function _onHoverEnd(e) {\n      self.event = e;\n      onHoverEnd(self);\n    },\n        _onClick = function _onClick(e) {\n      return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\n    };\n\n    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n    self.deltaX = self.deltaY = 0;\n    self._vx = _getVelocityProp(0, 50, true);\n    self._vy = _getVelocityProp(0, 50, true);\n    self.scrollX = scrollFuncX;\n    self.scrollY = scrollFuncY;\n    self.isDragging = self.isGesturing = self.isPressed = false;\n\n    self.enable = function (e) {\n      if (!self.isEnabled) {\n        _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n\n        type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, preventDefault, capture);\n        type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, preventDefault, capture);\n\n        if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\n          _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);\n\n          _addListener(ownerDoc, _eventTypes[2], _onRelease);\n\n          _addListener(ownerDoc, _eventTypes[3], _onRelease);\n\n          allowClicks && _addListener(target, \"click\", clickCapture, false, true);\n          onClick && _addListener(target, \"click\", _onClick);\n          onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n          onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n          onHover && _addListener(target, _pointerType  \"enter\", _onHover);\n          onHoverEnd && _addListener(target, _pointerType  \"leave\", _onHoverEnd);\n          onMove && _addListener(target, _pointerType  \"move\", _onMove);\n        }\n\n        self.isEnabled = true;\n        e && e.type && _onPress(e);\n        onEnable && onEnable(self);\n      }\n\n      return self;\n    };\n\n    self.disable = function () {\n      if (self.isEnabled) {\n        // only remove the _onScroll listener if there aren't any others that rely on the functionality.\n        _observers.filter(function (o) {\n          return o !== self && _isViewport(o.target);\n        }).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n\n        if (self.isPressed) {\n          self._vx.reset();\n\n          self._vy.reset();\n\n          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n        }\n\n        _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n\n        _removeListener(target, \"wheel\", _onWheel, capture);\n\n        _removeListener(target, _eventTypes[0], _onPress, capture);\n\n        _removeListener(ownerDoc, _eventTypes[2], _onRelease);\n\n        _removeListener(ownerDoc, _eventTypes[3], _onRelease);\n\n        _removeListener(target, \"click\", clickCapture, true);\n\n        _removeListener(target, \"click\", _onClick);\n\n        _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n\n        _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n\n        _removeListener(target, _pointerType  \"enter\", _onHover);\n\n        _removeListener(target, _pointerType  \"leave\", _onHoverEnd);\n\n        _removeListener(target, _pointerType  \"move\", _onMove);\n\n        self.isEnabled = self.isPressed = self.isDragging = false;\n        onDisable && onDisable(self);\n      }\n    };\n\n    self.kill = function () {\n      self.disable();\n\n      var i = _observers.indexOf(self);\n\n      i >= 0 && _observers.splice(i, 1);\n      _normalizer === self && (_normalizer = 0);\n    };\n\n    _observers.push(self);\n\n    isNormalizer && _isViewport(target) && (_normalizer = self);\n    self.enable(event);\n  };\n\n  _createClass(Observer, [{\n    key: \"velocityX\",\n    get: function get() {\n      return this._vx.getVelocity();\n    }\n  }, {\n    key: \"velocityY\",\n    get: function get() {\n      return this._vy.getVelocity();\n    }\n  }]);\n\n  return Observer;\n}();\nObserver.version = \"3.10.4\";\n\nObserver.create = function (vars) {\n  return new Observer(vars);\n};\n\nObserver.register = _initCore;\n\nObserver.getAll = function () {\n  return _observers.slice();\n};\n\nObserver.getById = function (id) {\n  return _observers.filter(function (o) {\n    return o.vars.id === id;\n  })[0];\n};\n\n_getGSAP() && gsap.registerPlugin(Observer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9PYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQSw2RkFBNkY7O0FBRTdGO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGOztBQUU1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7O0FBR3hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvZ3NhcC9PYnNlcnZlci5qcz82NmMzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyohXG4gKiBPYnNlcnZlciAzLjEwLjRcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjIsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2NsYW1wLFxuICAgIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWwsXG4gICAgX2JvZHksXG4gICAgX2lzVG91Y2gsXG4gICAgX3BvaW50ZXJUeXBlLFxuICAgIFNjcm9sbFRyaWdnZXIsXG4gICAgX3Jvb3QsXG4gICAgX25vcm1hbGl6ZXIsXG4gICAgX2V2ZW50VHlwZXMsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uIF9wYXNzVGhyb3VnaChwKSB7XG4gIHJldHVybiBwO1xufSxcbiAgICBfc3RhcnR1cCA9IDEsXG4gICAgX29ic2VydmVycyA9IFtdLFxuICAgIF9zY3JvbGxlcnMgPSBbXSxcbiAgICBfcHJveGllcyA9IFtdLFxuICAgIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgX2JyaWRnZSA9IGZ1bmN0aW9uIF9icmlkZ2UobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufSxcbiAgICBfaW50ZWdyYXRlID0gZnVuY3Rpb24gX2ludGVncmF0ZSgpIHtcbiAgdmFyIGNvcmUgPSBTY3JvbGxUcmlnZ2VyLmNvcmUsXG4gICAgICBkYXRhID0gY29yZS5icmlkZ2UgfHwge30sXG4gICAgICBzY3JvbGxlcnMgPSBjb3JlLl9zY3JvbGxlcnMsXG4gICAgICBwcm94aWVzID0gY29yZS5fcHJveGllcztcbiAgc2Nyb2xsZXJzLnB1c2guYXBwbHkoc2Nyb2xsZXJzLCBfc2Nyb2xsZXJzKTtcbiAgcHJveGllcy5wdXNoLmFwcGx5KHByb3hpZXMsIF9wcm94aWVzKTtcbiAgX3Njcm9sbGVycyA9IHNjcm9sbGVycztcbiAgX3Byb3hpZXMgPSBwcm94aWVzO1xuXG4gIF9icmlkZ2UgPSBmdW5jdGlvbiBfYnJpZGdlKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGRhdGFbbmFtZV0odmFsdWUpO1xuICB9O1xufSxcbiAgICBfZ2V0UHJveHlQcm9wID0gZnVuY3Rpb24gX2dldFByb3h5UHJvcChlbGVtZW50LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gfl9wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgJiYgX3Byb3hpZXNbX3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSArIDFdW3Byb3BlcnR5XTtcbn0sXG4gICAgX2lzVmlld3BvcnQgPSBmdW5jdGlvbiBfaXNWaWV3cG9ydChlbCkge1xuICByZXR1cm4gISFX3Jvb3QuaW5kZXhPZihlbCk7XG59LFxuICAgIF9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBub25QYXNzaXZlLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywge1xuICAgIHBhc3NpdmU6ICFub25QYXNzaXZlLFxuICAgIGNhcHR1cmU6ICEhY2FwdHVyZVxuICB9KTtcbn0sXG4gICAgX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCAhIWNhcHR1cmUpO1xufSxcbiAgICBfc2Nyb2xsTGVmdCA9IFwic2Nyb2xsTGVmdFwiLFxuICAgIF9zY3JvbGxUb3AgPSBcInNjcm9sbFRvcFwiLFxuICAgIF9vblNjcm9sbCA9IGZ1bmN0aW9uIF9vblNjcm9sbCgpIHtcbiAgcmV0dXJuIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmlzUHJlc3NlZCB8fCBfc2Nyb2xsZXJzLmNhY2hlKys7XG59LFxuICAgIF9zY3JvbGxDYWNoZUZ1bmMgPSBmdW5jdGlvbiBfc2Nyb2xsQ2FjaGVGdW5jKGYsIGRvTm90Q2FjaGUpIHtcbiAgdmFyIGNhY2hpbmdGdW5jID0gZnVuY3Rpb24gY2FjaGluZ0Z1bmModmFsdWUpIHtcbiAgICAvLyBzaW5jZSByZWFkaW5nIHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdC9wYWdlT2Zmc2V0WS9wYWdlT2Zmc2V0WCBjYW4gdHJpZ2dlciBhIGxheW91dCwgdGhpcyBmdW5jdGlvbiBhbGxvd3MgdXMgdG8gY2FjaGUgdGhlIHZhbHVlIHNvIGl0IG9ubHkgZ2V0cyByZWFkIGZyZXNoIGFmdGVyIGEgXCJzY3JvbGxcIiBldmVudCBmaXJlcyAob3Igd2hpbGUgd2UncmUgcmVmcmVzaGluZyBiZWNhdXNlIHRoYXQgY2FuIGxlbmd0aGVuIHRoZSBwYWdlIGFuZCBhbHRlciB0aGUgc2Nyb2xsIHBvc2l0aW9uKS4gd2hlbiBcInNvZnRcIiBpcyB0cnVlLCB0aGF0IG1lYW5zIGRvbid0IGFjdHVhbGx5IHNldCB0aGUgc2Nyb2xsLCBidXQgY2FjaGUgdGhlIG5ldyB2YWx1ZSBpbnN0ZWFkICh1c2VmdWwgaW4gU2Nyb2xsU21vb3RoZXIpXG4gICAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICBfc3RhcnR1cCAmJiAoX3dpbi5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIik7IC8vIG90aGVyd2lzZSB0aGUgbmV3IHBvc2l0aW9uIHdpbGwgZ2V0IG92ZXJ3cml0dGVuIGJ5IHRoZSBicm93c2VyIG9ubG9hZC5cblxuICAgICAgdmFyIGlzTm9ybWFsaXppbmcgPSBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5pc1ByZXNzZWQ7XG4gICAgICB2YWx1ZSA9IGNhY2hpbmdGdW5jLnYgPSBNYXRoLnJvdW5kKHZhbHVlKSB8fCAoX25vcm1hbGl6ZXIgJiYgX25vcm1hbGl6ZXIuaU9TID8gMSA6IDApOyAvL1RPRE86IGlPUyBCdWc6IGlmIHlvdSBhbGxvdyBpdCB0byBnbyB0byAwLCBTYWZhcmkgY2FuIHN0YXJ0IHRvIHJlcG9ydCBzdXBlciBzdHJhbmdlICh3aWxkbHkgaW5hY2N1cmF0ZSkgdG91Y2ggcG9zaXRpb25zIVxuXG4gICAgICBmKHZhbHVlKTtcbiAgICAgIGNhY2hpbmdGdW5jLmNhY2hlSUQgPSBfc2Nyb2xsZXJzLmNhY2hlO1xuICAgICAgaXNOb3JtYWxpemluZyAmJiBfYnJpZGdlKFwic3NcIiwgdmFsdWUpOyAvLyBzZXQgc2Nyb2xsIChub3RpZnkgU2Nyb2xsVHJpZ2dlciBzbyBpdCBjYW4gZGlzcGF0Y2ggYSBcInNjcm9sbFN0YXJ0XCIgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gICAgfSBlbHNlIGlmIChkb05vdENhY2hlIHx8IF9zY3JvbGxlcnMuY2FjaGUgIT09IGNhY2hpbmdGdW5jLmNhY2hlSUQgfHwgX2JyaWRnZShcInJlZlwiKSkge1xuICAgICAgY2FjaGluZ0Z1bmMuY2FjaGVJRCA9IF9zY3JvbGxlcnMuY2FjaGU7XG4gICAgICBjYWNoaW5nRnVuYy52ID0gZigpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoaW5nRnVuYy52ICsgY2FjaGluZ0Z1bmMub2Zmc2V0O1xuICB9O1xuXG4gIGNhY2hpbmdGdW5jLm9mZnNldCA9IDA7XG4gIHJldHVybiBmICYmIGNhY2hpbmdGdW5jO1xufSxcbiAgICBfaG9yaXpvbnRhbCA9IHtcbiAgczogX3Njcm9sbExlZnQsXG4gIHA6IFwibGVmdFwiLFxuICBwMjogXCJMZWZ0XCIsXG4gIG9zOiBcInJpZ2h0XCIsXG4gIG9zMjogXCJSaWdodFwiLFxuICBkOiBcIndpZHRoXCIsXG4gIGQyOiBcIldpZHRoXCIsXG4gIGE6IFwieFwiLFxuICBzYzogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF93aW4uc2Nyb2xsVG8odmFsdWUsIF92ZXJ0aWNhbC5zYygpKSA6IF93aW4ucGFnZVhPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsTGVmdF0gfHwgX2RvY0VsW19zY3JvbGxMZWZ0XSB8fCBfYm9keVtfc2Nyb2xsTGVmdF0gfHwgMDtcbiAgfSlcbn0sXG4gICAgX3ZlcnRpY2FsID0ge1xuICBzOiBfc2Nyb2xsVG9wLFxuICBwOiBcInRvcFwiLFxuICBwMjogXCJUb3BcIixcbiAgb3M6IFwiYm90dG9tXCIsXG4gIG9zMjogXCJCb3R0b21cIixcbiAgZDogXCJoZWlnaHRcIixcbiAgZDI6IFwiSGVpZ2h0XCIsXG4gIGE6IFwieVwiLFxuICBvcDogX2hvcml6b250YWwsXG4gIHNjOiBfc2Nyb2xsQ2FjaGVGdW5jKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3dpbi5zY3JvbGxUbyhfaG9yaXpvbnRhbC5zYygpLCB2YWx1ZSkgOiBfd2luLnBhZ2VZT2Zmc2V0IHx8IF9kb2NbX3Njcm9sbFRvcF0gfHwgX2RvY0VsW19zY3JvbGxUb3BdIHx8IF9ib2R5W19zY3JvbGxUb3BdIHx8IDA7XG4gIH0pXG59LFxuICAgIF9nZXRUYXJnZXQgPSBmdW5jdGlvbiBfZ2V0VGFyZ2V0KHQpIHtcbiAgcmV0dXJuIGdzYXAudXRpbHMudG9BcnJheSh0KVswXSB8fCAodHlwZW9mIHQgPT09IFwic3RyaW5nXCIgJiYgZ3NhcC5jb25maWcoKS5udWxsVGFyZ2V0V2FybiAhPT0gZmFsc2UgPyBjb25zb2xlLndhcm4oXCJFbGVtZW50IG5vdCBmb3VuZDpcIiwgdCkgOiBudWxsKTtcbn0sXG4gICAgX2dldFNjcm9sbEZ1bmMgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsRnVuYyhlbGVtZW50LCBfcmVmKSB7XG4gIHZhciBzID0gX3JlZi5zLFxuICAgICAgc2MgPSBfcmVmLnNjO1xuXG4gIC8vIHdlIHN0b3JlIHRoZSBzY3JvbGxlciBmdW5jdGlvbnMgaW4gYSBhbHRlcm5hdGluZyBzZXF1ZW5jZWQgQXJyYXkgbGlrZSBbZWxlbWVudCwgdmVydGljYWxTY3JvbGxGdW5jLCBob3Jpem9udGFsU2Nyb2xsRnVuYywgLi4uXSBzbyB0aGF0IHdlIGNhbiBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHBlcmZvcm1hbmNlLCBhbmQgd2UgYWxzbyByZWNvcmQgdGhlIGxhc3QgcG9zaXRpb24gYXMgYSBcIi5yZWNcIiBwcm9wZXJ0eSBpbiBvcmRlciB0byByZXZlcnQgdG8gdGhhdCBhZnRlciByZWZyZXNoaW5nIHRvIGVuc3VyZSB0aGluZ3MgZG9uJ3Qgc2hpZnQgYXJvdW5kLlxuICB2YXIgaSA9IF9zY3JvbGxlcnMuaW5kZXhPZihlbGVtZW50KSxcbiAgICAgIG9mZnNldCA9IHNjID09PSBfdmVydGljYWwuc2MgPyAxIDogMjtcblxuICAhfmkgJiYgKGkgPSBfc2Nyb2xsZXJzLnB1c2goZWxlbWVudCkgLSAxKTtcbiAgcmV0dXJuIF9zY3JvbGxlcnNbaSArIG9mZnNldF0gfHwgKF9zY3JvbGxlcnNbaSArIG9mZnNldF0gPSBfc2Nyb2xsQ2FjaGVGdW5jKF9nZXRQcm94eVByb3AoZWxlbWVudCwgcyksIHRydWUpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/IHNjIDogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGVsZW1lbnRbc10gPSB2YWx1ZSA6IGVsZW1lbnRbc107XG4gIH0pKSk7XG59LFxuICAgIF9nZXRWZWxvY2l0eVByb3AgPSBmdW5jdGlvbiBfZ2V0VmVsb2NpdHlQcm9wKHZhbHVlLCBtaW5UaW1lUmVmcmVzaCwgdXNlRGVsdGEpIHtcbiAgdmFyIHYxID0gdmFsdWUsXG4gICAgICB2MiA9IHZhbHVlLFxuICAgICAgdDEgPSBfZ2V0VGltZSgpLFxuICAgICAgdDIgPSB0MSxcbiAgICAgIG1pbiA9IG1pblRpbWVSZWZyZXNoIHx8IDUwLFxuICAgICAgZHJvcFRvWmVyb1RpbWUgPSBNYXRoLm1heCg1MDAsIG1pbiAqIDMpLFxuICAgICAgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHZhbHVlLCBmb3JjZSkge1xuICAgIHZhciB0ID0gX2dldFRpbWUoKTtcblxuICAgIGlmIChmb3JjZSB8fCB0IC0gdDEgPiBtaW4pIHtcbiAgICAgIHYyID0gdjE7XG4gICAgICB2MSA9IHZhbHVlO1xuICAgICAgdDIgPSB0MTtcbiAgICAgIHQxID0gdDtcbiAgICB9IGVsc2UgaWYgKHVzZURlbHRhKSB7XG4gICAgICB2MSArPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90IHRvdGFsbHkgbmVjZXNzYXJ5LCBidXQgbWFrZXMgaXQgYSBiaXQgbW9yZSBhY2N1cmF0ZSBieSBhZGp1c3RpbmcgdGhlIHYxIHZhbHVlIGFjY29yZGluZyB0byB0aGUgbmV3IHNsb3BlLiBUaGlzIHdheSB3ZSdyZSBub3QganVzdCBpZ25vcmluZyB0aGUgaW5jb21pbmcgZGF0YS4gUmVtb3ZpbmcgZm9yIG5vdyBiZWNhdXNlIGl0IGRvZXNuJ3Qgc2VlbSB0byBtYWtlIG11Y2ggcHJhY3RpY2FsIGRpZmZlcmVuY2UgYW5kIGl0J3MgcHJvYmFibHkgbm90IHdvcnRoIHRoZSBrYi5cbiAgICAgIHYxID0gdjIgKyAodmFsdWUgLSB2MikgLyAodCAtIHQyKSAqICh0MSAtIHQyKTtcbiAgICB9XG4gIH0sXG4gICAgICByZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHYyID0gdjEgPSB1c2VEZWx0YSA/IDAgOiB2MTtcbiAgICB0MiA9IHQxID0gMDtcbiAgfSxcbiAgICAgIGdldFZlbG9jaXR5ID0gZnVuY3Rpb24gZ2V0VmVsb2NpdHkobGF0ZXN0VmFsdWUpIHtcbiAgICB2YXIgdE9sZCA9IHQyLFxuICAgICAgICB2T2xkID0gdjIsXG4gICAgICAgIHQgPSBfZ2V0VGltZSgpO1xuXG4gICAgKGxhdGVzdFZhbHVlIHx8IGxhdGVzdFZhbHVlID09PSAwKSAmJiBsYXRlc3RWYWx1ZSAhPT0gdjEgJiYgdXBkYXRlKGxhdGVzdFZhbHVlKTtcbiAgICByZXR1cm4gdDEgPT09IHQyIHx8IHQgLSB0MiAIGRyb3BUb1plcm9UaW1lID8gMCA6ICh2MSArICh1c2VEZWx0YSA/IHZPbGQgOiAtdk9sZCkpIC8gKCh1c2VEZWx0YSA/IHQgOiB0MSkgLSB0T2xkKSAqIDEwMDA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICByZXNldDogcmVzZXQsXG4gICAgZ2V0VmVsb2NpdHk6IGdldFZlbG9jaXR5XG4gIH07XG59LFxuICAgIF9nZXRFdmVudCA9IGZ1bmN0aW9uIF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCkge1xuICBwcmV2ZW50RGVmYXVsdCAmJiAhZS5fZ3NhcEFsbG93ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgcmV0dXJuIGUuY2hhbmdlZFRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZTtcbn0sXG4gICAgX2dldEFic29sdXRlTWF4ID0gZnVuY3Rpb24gX2dldEFic29sdXRlTWF4KGEpIHtcbiAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGEpLFxuICAgICAgbWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgYSk7XG4gIHJldHVybiBNYXRoLmFicyhtYXgpID49IE1hdGguYWJzKG1pbikgPyBtYXggOiBtaW47XG59LFxuICAgIF9zZXRTY3JvbGxUcmlnZ2VyID0gZnVuY3Rpb24gX3NldFNjcm9sbFRyaWdnZXIoKSB7XG4gIFNjcm9sbFRyaWdnZXIgPSBnc2FwLmNvcmUuZ2xvYmFscygpLlNjcm9sbFRyaWdnZXI7XG4gIFNjcm9sbFRyaWdnZXIgJiYgU2Nyb2xsVHJpZ2dlci5jb3JlICYmIF9pbnRlZ3JhdGUoKTtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKGNvcmUpIHtcbiAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICBpZiAoZ3NhcCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuICAgIF9yb290ID0gW193aW4sIF9kb2MsIF9kb2NFbCwgX2JvZHldO1xuICAgIF9jbGFtcCA9IGdzYXAudXRpbHMuY2xhbXA7XG4gICAgX3BvaW50ZXJUeXBlID0gXCJvbnBvaW50ZXJlbnRlclwiIGluIF9ib2R5ID8gXCJwb2ludGVyXCIgOiBcIm1vdXNlXCI7IC8vIGlzVG91Y2ggaXMgMCBpZiBubyB0b3VjaCwgMSBpZiBPTkxZIHRvdWNoLCBhbmQgMiBpZiBpdCBjYW4gYWNjb21tb2RhdGUgdG91Y2ggYnV0IGFsc28gb3RoZXIgdHlwZXMgbGlrZSBtb3VzZS9wb2ludGVyLlxuXG4gICAgX2lzVG91Y2ggPSBPYnNlcnZlci5pc1RvdWNoID0gX3dpbi5tYXRjaE1lZGlhICYmIF93aW4ubWF0Y2hNZWRpYShcIihob3Zlcjogbm9uZSksIChwb2ludGVyOiBjb2Fyc2UpXCIpLm1hdGNoZXMgPyAxIDogXCJvbnRvdWNoc3RhcnRcIiBpbiBfd2luIHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyAIDAgfHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwID8gMiA6IDA7XG4gICAgX2V2ZW50VHlwZXMgPSBPYnNlcnZlci5ldmVudFR5cGVzID0gKFwib250b3VjaHN0YXJ0XCIgaW4gX2RvY0VsID8gXCJ0b3VjaHN0YXJ0LHRvdWNobW92ZSx0b3VjaGNhbmNlbCx0b3VjaGVuZFwiIDogIShcIm9ucG9pbnRlcmRvd25cIiBpbiBfZG9jRWwpID8gXCJtb3VzZWRvd24sbW91c2Vtb3ZlLG1vdXNldXAsbW91c2V1cFwiIDogXCJwb2ludGVyZG93bixwb2ludGVybW92ZSxwb2ludGVyY2FuY2VsLHBvaW50ZXJ1cFwiKS5zcGxpdChcIixcIik7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3N0YXJ0dXAgPSAwO1xuICAgIH0sIDUwMCk7XG5cbiAgICBfc2V0U2Nyb2xsVHJpZ2dlcigpO1xuXG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxuXG4gIHJldHVybiBfY29yZUluaXR0ZWQ7XG59O1xuXG5faG9yaXpvbnRhbC5vcCA9IF92ZXJ0aWNhbDtcbl9zY3JvbGxlcnMuY2FjaGUgPSAwO1xuZXhwb3J0IHZhciBPYnNlcnZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmVyKHZhcnMpIHtcbiAgICB0aGlzLmluaXQodmFycyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh2YXJzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZShnc2FwKSB8fCBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihPYnNlcnZlcilcIik7XG4gICAgU2Nyb2xsVHJpZ2dlciB8fCBfc2V0U2Nyb2xsVHJpZ2dlcigpO1xuICAgIHZhciB0b2xlcmFuY2UgPSB2YXJzLnRvbGVyYW5jZSxcbiAgICAgICAgZHJhZ01pbmltdW0gPSB2YXJzLmRyYWdNaW5pbXVtLFxuICAgICAgICB0eXBlID0gdmFycy50eXBlLFxuICAgICAgICB0YXJnZXQgPSB2YXJzLnRhcmdldCxcbiAgICAgICAgbGluZUhlaWdodCA9IHZhcnMubGluZUhlaWdodCxcbiAgICAgICAgZGVib3VuY2UgPSB2YXJzLmRlYm91bmNlLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHZhcnMucHJldmVudERlZmF1bHQsXG4gICAgICAgIG9uU3RvcCA9IHZhcnMub25TdG9wLFxuICAgICAgICBvblN0b3BEZWxheSA9IHZhcnMub25TdG9wRGVsYXksXG4gICAgICAgIGlnbm9yZSA9IHZhcnMuaWdub3JlLFxuICAgICAgICB3aGVlbFNwZWVkID0gdmFycy53aGVlbFNwZWVkLFxuICAgICAgICBldmVudCA9IHZhcnMuZXZlbnQsXG4gICAgICAgIG9uRHJhZ1N0YXJ0ID0gdmFycy5vbkRyYWdTdGFydCxcbiAgICAgICAgb25EcmFnRW5kID0gdmFycy5vbkRyYWdFbmQsXG4gICAgICAgIG9uRHJhZyA9IHZhcnMub25EcmFnLFxuICAgICAgICBvblByZXNzID0gdmFycy5vblByZXNzLFxuICAgICAgICBvblJlbGVhc2UgPSB2YXJzLm9uUmVsZWFzZSxcbiAgICAgICAgb25SaWdodCA9IHZhcnMub25SaWdodCxcbiAgICAgICAgb25MZWZ0ID0gdmFycy5vbkxlZnQsXG4gICAgICAgIG9uVXAgPSB2YXJzLm9uVXAsXG4gICAgICAgIG9uRG93biA9IHZhcnMub25Eb3duLFxuICAgICAgICBvbkNoYW5nZVggPSB2YXJzLm9uQ2hhbmdlWCxcbiAgICAgICAgb25DaGFuZ2VZID0gdmFycy5vbkNoYW5nZVksXG4gICAgICAgIG9uQ2hhbmdlID0gdmFycy5vbkNoYW5nZSxcbiAgICAgICAgb25Ub2dnbGVYID0gdmFycy5vblRvZ2dsZVgsXG4gICAgICAgIG9uVG9nZ2xlWSA9IHZhcnMub25Ub2dnbGVZLFxuICAgICAgICBvbkhvdmVyID0gdmFycy5vbkhvdmVyLFxuICAgICAgICBvbkhvdmVyRW5kID0gdmFycy5vbkhvdmVyRW5kLFxuICAgICAgICBvbk1vdmUgPSB2YXJzLm9uTW92ZSxcbiAgICAgICAgaWdub3JlQ2hlY2sgPSB2YXJzLmlnbm9yZUNoZWNrLFxuICAgICAgICBpc05vcm1hbGl6ZXIgPSB2YXJzLmlzTm9ybWFsaXplcixcbiAgICAgICAgb25HZXN0dXJlU3RhcnQgPSB2YXJzLm9uR2VzdHVyZVN0YXJ0LFxuICAgICAgICBvbkdlc3R1cmVFbmQgPSB2YXJzLm9uR2VzdHVyZUVuZCxcbiAgICAgICAgb25XaGVlbCA9IHZhcnMub25XaGVlbCxcbiAgICAgICAgb25FbmFibGUgPSB2YXJzLm9uRW5hYmxlLFxuICAgICAgICBvbkRpc2FibGUgPSB2YXJzLm9uRGlzYWJsZSxcbiAgICAgICAgb25DbGljayA9IHZhcnMub25DbGljayxcbiAgICAgICAgc2Nyb2xsU3BlZWQgPSB2YXJzLnNjcm9sbFNwZWVkLFxuICAgICAgICBjYXB0dXJlID0gdmFycy5jYXB0dXJlLFxuICAgICAgICBhbGxvd0NsaWNrcyA9IHZhcnMuYWxsb3dDbGlja3MsXG4gICAgICAgIGxvY2tBeGlzID0gdmFycy5sb2NrQXhpcyxcbiAgICAgICAgb25Mb2NrQXhpcyA9IHZhcnMub25Mb2NrQXhpcztcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldCA9IF9nZXRUYXJnZXQodGFyZ2V0KSB8fCBfZG9jRWw7XG4gICAgdGhpcy52YXJzID0gdmFycztcbiAgICBpZ25vcmUgJiYgKGlnbm9yZSA9IGdzYXAudXRpbHMudG9BcnJheShpZ25vcmUpKTtcbiAgICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMDtcbiAgICBkcmFnTWluaW11bSA9IGRyYWdNaW5pbXVtIHx8IDA7XG4gICAgd2hlZWxTcGVlZCA9IHdoZWVsU3BlZWQgfHwgMTtcbiAgICBzY3JvbGxTcGVlZCA9IHNjcm9sbFNwZWVkIHx8IDE7XG4gICAgdHlwZSA9IHR5cGUgfHwgXCJ3aGVlbCx0b3VjaCxwb2ludGVyXCI7XG4gICAgZGVib3VuY2UgPSBkZWJvdW5jZSAhPT0gZmFsc2U7XG4gICAgbGluZUhlaWdodCB8fCAobGluZUhlaWdodCA9IHBhcnNlRmxvYXQoX3dpbi5nZXRDb21wdXRlZFN0eWxlKF9ib2R5KS5saW5lSGVpZ2h0KSB8fCAyMik7IC8vIG5vdGU6IGJyb3dzZXIgbWF5IHJlcG9ydCBcIm5vcm1hbFwiLCBzbyBkZWZhdWx0IHRvIDIyLlxuXG4gICAgdmFyIGlkLFxuICAgICAgICBvblN0b3BEZWxheWVkQ2FsbCxcbiAgICAgICAgZHJhZ2dlZCxcbiAgICAgICAgbW92ZWQsXG4gICAgICAgIHdoZWVsZWQsXG4gICAgICAgIGxvY2tlZCxcbiAgICAgICAgYXhpcyxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHByZXZEZWx0YVggPSAwLFxuICAgICAgICBwcmV2RGVsdGFZID0gMCxcbiAgICAgICAgc2Nyb2xsRnVuY1ggPSBfZ2V0U2Nyb2xsRnVuYyh0YXJnZXQsIF9ob3Jpem9udGFsKSxcbiAgICAgICAgc2Nyb2xsRnVuY1kgPSBfZ2V0U2Nyb2xsRnVuYyh0YXJnZXQsIF92ZXJ0aWNhbCksXG4gICAgICAgIHNjcm9sbFggPSBzY3JvbGxGdW5jWCgpLFxuICAgICAgICBzY3JvbGxZID0gc2Nyb2xsRnVuY1koKSxcbiAgICAgICAgbGltaXRUb1RvdWNoID0gfnR5cGUuaW5kZXhPZihcInRvdWNoXCIpICYmICFdHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSAmJiBfZXZlbnRUeXBlc1swXSA9PT0gXCJwb2ludGVyZG93blwiLFxuICAgICAgICAvLyBmb3IgZGV2aWNlcyB0aGF0IGFjY29tbW9kYXRlIG1vdXNlIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLCB3ZSBuZWVkIHRvIGRpc3Rpbmd1aXNoLlxuICAgIGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydCh0YXJnZXQpLFxuICAgICAgICBvd25lckRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50IHx8IF9kb2MsXG4gICAgICAgIGRlbHRhWCA9IFswLCAwLCAwXSxcbiAgICAgICAgLy8gd2hlZWwsIHNjcm9sbCwgcG9pbnRlci90b3VjaFxuICAgIGRlbHRhWSA9IFswLCAwLCAwXSxcbiAgICAgICAgb25DbGlja1RpbWUgPSAwLFxuICAgICAgICBjbGlja0NhcHR1cmUgPSBmdW5jdGlvbiBjbGlja0NhcHR1cmUoKSB7XG4gICAgICByZXR1cm4gb25DbGlja1RpbWUgPSBfZ2V0VGltZSgpO1xuICAgIH0sXG4gICAgICAgIF9pZ25vcmVDaGVjayA9IGZ1bmN0aW9uIF9pZ25vcmVDaGVjayhlLCBpc1BvaW50ZXJPclRvdWNoKSB7XG4gICAgICByZXR1cm4gKHNlbGYuZXZlbnQgPSBlKSAmJiBpZ25vcmUgJiYgfmlnbm9yZS5pbmRleE9mKGUudGFyZ2V0KSB8fCBpc1BvaW50ZXJPclRvdWNoICYmIGxpbWl0VG9Ub3VjaCAmJiBlLnBvaW50ZXJUeXBlICE9PSBcInRvdWNoXCIgfHwgaWdub3JlQ2hlY2sgJiYgaWdub3JlQ2hlY2soZSwgaXNQb2ludGVyT3JUb3VjaCk7XG4gICAgfSxcbiAgICAgICAgb25TdG9wRnVuYyA9IGZ1bmN0aW9uIG9uU3RvcEZ1bmMoKSB7XG4gICAgICBzZWxmLl92eC5yZXNldCgpO1xuXG4gICAgICBzZWxmLl92eS5yZXNldCgpO1xuXG4gICAgICBvblN0b3BEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgb25TdG9wICYmIG9uU3RvcChzZWxmKTtcbiAgICB9LFxuICAgICAgICB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgZHggPSBzZWxmLmRlbHRhWCA9IF9nZXRBYnNvbHV0ZU1heChkZWx0YVgpLFxuICAgICAgICAgIGR5ID0gc2VsZi5kZWx0YVkgPSBfZ2V0QWJzb2x1dGVNYXgoZGVsdGFZKSxcbiAgICAgICAgICBjaGFuZ2VkWCA9IE1hdGguYWJzKGR4KSAPSB0b2xlcmFuY2UsXG4gICAgICAgICAgY2hhbmdlZFkgPSBNYXRoLmFicyhkeSkgPj0gdG9sZXJhbmNlO1xuXG4gICAgICBvbkNoYW5nZSAmJiAoY2hhbmdlZFggfHwgY2hhbmdlZFkpICYmIG9uQ2hhbmdlKHNlbGYsIGR4LCBkeSwgZGVsdGFYLCBkZWx0YVkpOyAvLyBpbiBTY3JvbGxUcmlnZ2VyLm5vcm1hbGl6ZVNjcm9sbCgpLCB3ZSBuZWVkIHRvIGtub3cgaWYgaXQgd2FzIHRvdWNoL3BvaW50ZXIgc28gd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIGRlbHRhWC9kZWx0YVkgQXJyYXlzIGJlZm9yZSB3ZSBjbGVhciB0aGVtIG91dC5cblxuICAgICAgaWYgKGNoYW5nZWRYKSB7XG4gICAgICAgIG9uUmlnaHQgJiYgc2VsZi5kZWx0YVggPiAwICYmIG9uUmlnaHQoc2VsZik7XG4gICAgICAgIG9uTGVmdCAmJiBzZWxmLmRlbHRhWCA8IDAgJiYgb25MZWZ0KHNlbGYpO1xuICAgICAgICBvbkNoYW5nZVggJiYgb25DaGFuZ2VYKHNlbGYpO1xuICAgICAgICBvblRvZ2dsZVggJiYgc2VsZi5kZWx0YVggPCAwICE9PSBwcmV2RGVsdGFYIDwgMCAmJiBvblRvZ2dsZVgoc2VsZik7XG4gICAgICAgIHByZXZEZWx0YVggPSBzZWxmLmRlbHRhWDtcbiAgICAgICAgZGVsdGFYWzBdID0gZGVsdGFYWzFdID0gZGVsdGFYWzJdID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWRZKSB7XG4gICAgICAgIG9uRG93biAmJiBzZWxmLmRlbHRhWSAIDAgJiYgb25Eb3duKHNlbGYpO1xuICAgICAgICBvblVwICYmIHNlbGYuZGVsdGFZIDwgMCAmJiBvblVwKHNlbGYpO1xuICAgICAgICBvbkNoYW5nZVkgJiYgb25DaGFuZ2VZKHNlbGYpO1xuICAgICAgICBvblRvZ2dsZVkgJiYgc2VsZi5kZWx0YVkgPCAwICE9PSBwcmV2RGVsdGFZIDwgMCAmJiBvblRvZ2dsZVkoc2VsZik7XG4gICAgICAgIHByZXZEZWx0YVkgPSBzZWxmLmRlbHRhWTtcbiAgICAgICAgZGVsdGFZWzBdID0gZGVsdGFZWzFdID0gZGVsdGFZWzJdID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vdmVkIHx8IGRyYWdnZWQpIHtcbiAgICAgICAgb25Nb3ZlICYmIG9uTW92ZShzZWxmKTtcbiAgICAgICAgb25Mb2NrQXhpcyAmJiBsb2NrZWQgJiYgb25Mb2NrQXhpcyhzZWxmKTtcblxuICAgICAgICBpZiAoZHJhZ2dlZCkge1xuICAgICAgICAgIG9uRHJhZyhzZWxmKTtcbiAgICAgICAgICBkcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBtb3ZlZCA9IGxvY2tlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAod2hlZWxlZCkge1xuICAgICAgICBvbldoZWVsKHNlbGYpO1xuICAgICAgICB3aGVlbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlkID0gMDtcbiAgICB9LFxuICAgICAgICBvbkRlbHRhID0gZnVuY3Rpb24gb25EZWx0YSh4LCB5LCBpbmRleCkge1xuICAgICAgZGVsdGFYW2luZGV4XSArPSB4O1xuICAgICAgZGVsdGFZW2luZGV4XSArPSB5O1xuXG4gICAgICBzZWxmLl92eC51cGRhdGUoeCk7XG5cbiAgICAgIHNlbGYuX3Z5LnVwZGF0ZSh5KTtcblxuICAgICAgZGVib3VuY2UgPyBpZCB8fCAoaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKSkgOiB1cGRhdGUoKTtcbiAgICB9LFxuICAgICAgICBvblRvdWNoT3JQb2ludGVyRGVsdGEgPSBmdW5jdGlvbiBvblRvdWNoT3JQb2ludGVyRGVsdGEoeCwgeSkge1xuICAgICAgaWYgKGF4aXMgIT09IFwieVwiKSB7XG4gICAgICAgIGRlbHRhWFsyXSArPSB4O1xuXG4gICAgICAgIHNlbGYuX3Z4LnVwZGF0ZSh4LCB0cnVlKTsgLy8gdXBkYXRlIHRoZSB2ZWxvY2l0eSBhcyBmcmVxdWVudGx5IGFzIHBvc3NpYmxlIGluc3RlYWQgb2YgaW4gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBzbyB0aGF0IHZlcnkgcXVpY2sgdG91Y2gtc2Nyb2xscyAoZmxpY2tzKSBmZWVsIG5hdHVyYWwuIElmIGl0J3MgdGhlIG1vdXNlL3RvdWNoL3BvaW50ZXIsIGZvcmNlIGl0IHNvIHRoYXQgd2UgZ2V0IHNuYXBweS9hY2N1cmF0ZSBtb21lbnR1bSBzY3JvbGwuXG5cbiAgICAgIH1cblxuICAgICAgaWYgKGF4aXMgIT09IFwieFwiKSB7XG4gICAgICAgIGRlbHRhWVsyXSArPSB5O1xuXG4gICAgICAgIHNlbGYuX3Z5LnVwZGF0ZSh5LCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2tBeGlzICYmICFheGlzKSB7XG4gICAgICAgIHNlbGYuYXhpcyA9IGF4aXMgPSBNYXRoLmFicyh4KSAIE1hdGguYWJzKHkpID8gXCJ4XCIgOiBcInlcIjtcbiAgICAgICAgbG9ja2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZGVib3VuY2UgPyBpZCB8fCAoaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKSkgOiB1cGRhdGUoKTtcbiAgICB9LFxuICAgICAgICBfb25EcmFnID0gZnVuY3Rpb24gX29uRHJhZyhlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZSA9IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICB5ID0gZS5jbGllbnRZLFxuICAgICAgICAgIGR4ID0geCAtIHNlbGYueCxcbiAgICAgICAgICBkeSA9IHkgLSBzZWxmLnksXG4gICAgICAgICAgaXNEcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZztcbiAgICAgIHNlbGYueCA9IHg7XG4gICAgICBzZWxmLnkgPSB5O1xuXG4gICAgICBpZiAoaXNEcmFnZ2luZyB8fCBNYXRoLmFicyhzZWxmLnN0YXJ0WCAtIHgpID49IGRyYWdNaW5pbXVtIHx8IE1hdGguYWJzKHNlbGYuc3RhcnRZIC0geSkgPj0gZHJhZ01pbmltdW0pIHtcbiAgICAgICAgb25EcmFnICYmIChkcmFnZ2VkID0gdHJ1ZSk7XG4gICAgICAgIGlzRHJhZ2dpbmcgfHwgKHNlbGYuaXNEcmFnZ2luZyA9IHRydWUpO1xuICAgICAgICBvblRvdWNoT3JQb2ludGVyRGVsdGEoZHgsIGR5KTtcbiAgICAgICAgaXNEcmFnZ2luZyB8fCBvbkRyYWdTdGFydCAmJiBvbkRyYWdTdGFydChzZWxmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBfb25QcmVzcyA9IHNlbGYub25QcmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5heGlzID0gYXhpcyA9IG51bGw7XG4gICAgICBvblN0b3BEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgc2VsZi5pc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgZSA9IF9nZXRFdmVudChlKTsgLy8gbm90ZTogbWF5IG5lZWQgdG8gcHJldmVudERlZmF1bHQoPykgV29uJ3Qgc2lkZS1zY3JvbGwgb24gaU9TIFNhZmFyaSBpZiB3ZSBkbywgdGhvdWdoLlxuXG4gICAgICBwcmV2RGVsdGFYID0gcHJldkRlbHRhWSA9IDA7XG4gICAgICBzZWxmLnN0YXJ0WCA9IHNlbGYueCA9IGUuY2xpZW50WDtcbiAgICAgIHNlbGYuc3RhcnRZID0gc2VsZi55ID0gZS5jbGllbnRZO1xuXG4gICAgICBzZWxmLl92eC5yZXNldCgpOyAvLyBvdGhlcndpc2UgdGhlIHQyIG1heSBiZSBzdGFsZSBpZiB0aGUgdXNlciB0b3VjaGVzIGFuZCBmbGlja3Mgc3VwZXIgZmFzdCBhbmQgcmVsZWFzZXMgaW4gbGVzcyB0aGFuIDIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRpY2tzLCBjYXVzaW5nIHZlbG9jaXR5IHRvIGJlIDAuXG5cblxuICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgX2FkZExpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgcHJldmVudERlZmF1bHQsIHRydWUpO1xuXG4gICAgICBzZWxmLmRlbHRhWCA9IHNlbGYuZGVsdGFZID0gMDtcbiAgICAgIG9uUHJlc3MgJiYgb25QcmVzcyhzZWxmKTtcbiAgICB9LFxuICAgICAgICBfb25SZWxlYXNlID0gZnVuY3Rpb24gX29uUmVsZWFzZShlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3JlbW92ZUxpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgdHJ1ZSk7XG5cbiAgICAgIHZhciB3YXNEcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZyAmJiAoTWF0aC5hYnMoc2VsZi54IC0gc2VsZi5zdGFydFgpID4gMyB8fCBNYXRoLmFicyhzZWxmLnkgLSBzZWxmLnN0YXJ0WSkgPiAzKSxcbiAgICAgICAgICAvLyBzb21lIHRvdWNoIGRldmljZXMgbmVlZCBzb21lIHdpZ2dsZSByb29tIGluIHRlcm1zIG9mIHNlbnNpbmcgY2xpY2tzIC0gdGhlIGZpbmdlciBtYXkgbW92ZSBhIGZldyBwaXhlbHMuXG4gICAgICBldmVudERhdGEgPSBfZ2V0RXZlbnQoZSk7XG5cbiAgICAgIGlmICghd2FzRHJhZ2dpbmcpIHtcbiAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcblxuICAgICAgICBzZWxmLl92eS5yZXNldCgpO1xuXG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCAmJiBhbGxvd0NsaWNrcykge1xuICAgICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC4wOCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB3b24ndCB0cnVzdCBzY3JpcHQtZ2VuZXJhdGVkIGNsaWNrcywgc28gaWYgdGhlIHVzZXIgdHJpZXMgdG8gY2xpY2sgb24gYSB2aWRlbyB0byBwbGF5IGl0LCBmb3IgZXhhbXBsZSwgaXQgc2ltcGx5IHdvbid0IHdvcmsuIFNpbmNlIGEgcmVndWxhciBcImNsaWNrXCIgZXZlbnQgd2lsbCBtb3N0IGxpa2VseSBiZSBnZW5lcmF0ZWQgYW55d2F5IChvbmUgdGhhdCBoYXMgaXRzIGlzVHJ1c3RlZCBmbGFnIHNldCB0byB0cnVlKSwgd2UgbXVzdCBzbGlnaHRseSBkZWxheSBvdXIgc2NyaXB0LWdlbmVyYXRlZCBjbGljayBzbyB0aGF0IHRoZSBcInJlYWxcIi90cnVzdGVkIG9uZSBpcyBwcmlvcml0aXplZC4gUmVtZW1iZXIsIHdoZW4gdGhlcmUgYXJlIGR1cGxpY2F0ZSBldmVudHMgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgd2Ugc3VwcHJlc3MgYWxsIGJ1dCB0aGUgZmlyc3Qgb25lLiBTb21lIGJyb3dzZXJzIGRvbid0IGV2ZW4gdHJpZ2dlciB0aGUgXCJyZWFsXCIgb25lIGF0IGFsbCwgc28gb3VyIHN5bnRoZXRpYyBvbmUgaXMgYSBzYWZldHkgdmFsdmUgdGhhdCBlbnN1cmVzIHRoYXQgbm8gbWF0dGVyIHdoYXQsIGEgY2xpY2sgZXZlbnQgZG9lcyBnZXQgZGlzcGF0Y2hlZC5cbiAgICAgICAgICAgIGlmIChfZ2V0VGltZSgpIC0gb25DbGlja1RpbWUgPiAzMDAgJiYgIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICBpZiAoZS50YXJnZXQuY2xpY2spIHtcbiAgICAgICAgICAgICAgICAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgbW9iaWxlIFNhZmFyaSkgZG9uJ3QgcHJvcGVybHkgdHJpZ2dlciB0aGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5jbGljaygpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG93bmVyRG9jLmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gb3duZXJEb2MuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgICAgICBzeW50aGV0aWNFdmVudC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsIHRydWUsIHRydWUsIF93aW4sIDEsIGV2ZW50RGF0YS5zY3JlZW5YLCBldmVudERhdGEuc2NyZWVuWSwgZXZlbnREYXRhLmNsaWVudFgsIGV2ZW50RGF0YS5jbGllbnRZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzeW50aGV0aWNFdmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLmlzRHJhZ2dpbmcgPSBzZWxmLmlzR2VzdHVyaW5nID0gc2VsZi5pc1ByZXNzZWQgPSBmYWxzZTtcbiAgICAgIG9uU3RvcCAmJiAhaXNOb3JtYWxpemVyICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICBvbkRyYWdFbmQgJiYgd2FzRHJhZ2dpbmcgJiYgb25EcmFnRW5kKHNlbGYpO1xuICAgICAgb25SZWxlYXNlICYmIG9uUmVsZWFzZShzZWxmLCB3YXNEcmFnZ2luZyk7XG4gICAgfSxcbiAgICAgICAgX29uR2VzdHVyZVN0YXJ0ID0gZnVuY3Rpb24gX29uR2VzdHVyZVN0YXJ0KGUpIHtcbiAgICAgIHJldHVybiBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCAIDEgJiYgKHNlbGYuaXNHZXN0dXJpbmcgPSB0cnVlKSAmJiBvbkdlc3R1cmVTdGFydChlLCBzZWxmLmlzRHJhZ2dpbmcpO1xuICAgIH0sXG4gICAgICAgIF9vbkdlc3R1cmVFbmQgPSBmdW5jdGlvbiBfb25HZXN0dXJlRW5kKCkge1xuICAgICAgcmV0dXJuIChzZWxmLmlzR2VzdHVyaW5nID0gZmFsc2UpIHx8IG9uR2VzdHVyZUVuZChzZWxmKTtcbiAgICB9LFxuICAgICAgICBvblNjcm9sbCA9IGZ1bmN0aW9uIG9uU2Nyb2xsKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IHNjcm9sbEZ1bmNYKCksXG4gICAgICAgICAgeSA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgICBvbkRlbHRhKCh4IC0gc2Nyb2xsWCkgKiBzY3JvbGxTcGVlZCwgKHkgLSBzY3JvbGxZKSAqIHNjcm9sbFNwZWVkLCAxKTtcbiAgICAgIHNjcm9sbFggPSB4O1xuICAgICAgc2Nyb2xsWSA9IHk7XG4gICAgICBvblN0b3AgJiYgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICB9LFxuICAgICAgICBfb25XaGVlbCA9IGZ1bmN0aW9uIF9vbldoZWVsKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlID0gX2dldEV2ZW50KGUsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgIG9uV2hlZWwgJiYgKHdoZWVsZWQgPSB0cnVlKTtcbiAgICAgIHZhciBtdWx0aXBsaWVyID0gKGUuZGVsdGFNb2RlID09PSAxID8gbGluZUhlaWdodCA6IGUuZGVsdGFNb2RlID09PSAyID8gX3dpbi5pbm5lckhlaWdodCA6IDEpICogd2hlZWxTcGVlZDtcbiAgICAgIG9uRGVsdGEoZS5kZWx0YVggKiBtdWx0aXBsaWVyLCBlLmRlbHRhWSAqIG11bHRpcGxpZXIsIDApO1xuICAgICAgb25TdG9wICYmICFpc05vcm1hbGl6ZXIgJiYgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICB9LFxuICAgICAgICBfb25Nb3ZlID0gZnVuY3Rpb24gX29uTW92ZShlKSB7XG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBlLmNsaWVudFgsXG4gICAgICAgICAgeSA9IGUuY2xpZW50WSxcbiAgICAgICAgICBkeCA9IHggLSBzZWxmLngsXG4gICAgICAgICAgZHkgPSB5IC0gc2VsZi55O1xuICAgICAgc2VsZi54ID0geDtcbiAgICAgIHNlbGYueSA9IHk7XG4gICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAoZHggfHwgZHkpICYmIG9uVG91Y2hPclBvaW50ZXJEZWx0YShkeCwgZHkpO1xuICAgIH0sXG4gICAgICAgIF9vbkhvdmVyID0gZnVuY3Rpb24gX29uSG92ZXIoZSkge1xuICAgICAgc2VsZi5ldmVudCA9IGU7XG4gICAgICBvbkhvdmVyKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vbkhvdmVyRW5kID0gZnVuY3Rpb24gX29uSG92ZXJFbmQoZSkge1xuICAgICAgc2VsZi5ldmVudCA9IGU7XG4gICAgICBvbkhvdmVyRW5kKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vbkNsaWNrID0gZnVuY3Rpb24gX29uQ2xpY2soZSkge1xuICAgICAgcmV0dXJuIF9pZ25vcmVDaGVjayhlKSB8fCBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpICYmIG9uQ2xpY2soc2VsZik7XG4gICAgfTtcblxuICAgIG9uU3RvcERlbGF5ZWRDYWxsID0gc2VsZi5fZGMgPSBnc2FwLmRlbGF5ZWRDYWxsKG9uU3RvcERlbGF5IHx8IDAuMjUsIG9uU3RvcEZ1bmMpLnBhdXNlKCk7XG4gICAgc2VsZi5kZWx0YVggPSBzZWxmLmRlbHRhWSA9IDA7XG4gICAgc2VsZi5fdnggPSBfZ2V0VmVsb2NpdHlQcm9wKDAsIDUwLCB0cnVlKTtcbiAgICBzZWxmLl92eSA9IF9nZXRWZWxvY2l0eVByb3AoMCwgNTAsIHRydWUpO1xuICAgIHNlbGYuc2Nyb2xsWCA9IHNjcm9sbEZ1bmNYO1xuICAgIHNlbGYuc2Nyb2xsWSA9IHNjcm9sbEZ1bmNZO1xuICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNHZXN0dXJpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuXG4gICAgc2VsZi5lbmFibGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFzZWxmLmlzRW5hYmxlZCkge1xuICAgICAgICBfYWRkTGlzdGVuZXIoaXNWaWV3cG9ydCA/IG93bmVyRG9jIDogdGFyZ2V0LCBcInNjcm9sbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgICAgIHR5cGUuaW5kZXhPZihcInNjcm9sbFwiKSAPSAwICYmIF9hZGRMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIG9uU2Nyb2xsLCBwcmV2ZW50RGVmYXVsdCwgY2FwdHVyZSk7XG4gICAgICAgIHR5cGUuaW5kZXhPZihcIndoZWVsXCIpID49IDAgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJ3aGVlbFwiLCBfb25XaGVlbCwgcHJldmVudERlZmF1bHQsIGNhcHR1cmUpO1xuXG4gICAgICAgIGlmICh0eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSAPSAwICYmIF9pc1RvdWNoIHx8IHR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgPj0gMCkge1xuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9ldmVudFR5cGVzWzBdLCBfb25QcmVzcywgcHJldmVudERlZmF1bHQsIGNhcHR1cmUpO1xuXG4gICAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBfZXZlbnRUeXBlc1syXSwgX29uUmVsZWFzZSk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzNdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICAgIGFsbG93Q2xpY2tzICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIFwiY2xpY2tcIiwgY2xpY2tDYXB0dXJlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgb25DbGljayAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIF9vbkNsaWNrKTtcbiAgICAgICAgICBvbkdlc3R1cmVTdGFydCAmJiBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZXN0YXJ0XCIsIF9vbkdlc3R1cmVTdGFydCk7XG4gICAgICAgICAgb25HZXN0dXJlRW5kICYmIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlZW5kXCIsIF9vbkdlc3R1cmVFbmQpO1xuICAgICAgICAgIG9uSG92ZXIgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJlbnRlclwiLCBfb25Ib3Zlcik7XG4gICAgICAgICAgb25Ib3ZlckVuZCAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcImxlYXZlXCIsIF9vbkhvdmVyRW5kKTtcbiAgICAgICAgICBvbk1vdmUgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJtb3ZlXCIsIF9vbk1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICBlICYmIGUudHlwZSAmJiBfb25QcmVzcyhlKTtcbiAgICAgICAgb25FbmFibGUgJiYgb25FbmFibGUoc2VsZik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBzZWxmLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5pc0VuYWJsZWQpIHtcbiAgICAgICAgLy8gb25seSByZW1vdmUgdGhlIF9vblNjcm9sbCBsaXN0ZW5lciBpZiB0aGVyZSBhcmVuJ3QgYW55IG90aGVycyB0aGF0IHJlbHkgb24gdGhlIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgIF9vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgcmV0dXJuIG8gIT09IHNlbGYgJiYgX2lzVmlld3BvcnQoby50YXJnZXQpO1xuICAgICAgICB9KS5sZW5ndGggfHwgX3JlbW92ZUxpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblxuICAgICAgICBpZiAoc2VsZi5pc1ByZXNzZWQpIHtcbiAgICAgICAgICBzZWxmLl92eC5yZXNldCgpO1xuXG4gICAgICAgICAgc2VsZi5fdnkucmVzZXQoKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihpc05vcm1hbGl6ZXIgPyB0YXJnZXQgOiBvd25lckRvYywgX2V2ZW50VHlwZXNbMV0sIF9vbkRyYWcsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgb25TY3JvbGwsIGNhcHR1cmUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIFwid2hlZWxcIiwgX29uV2hlZWwsIGNhcHR1cmUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIF9ldmVudFR5cGVzWzBdLCBfb25QcmVzcywgY2FwdHVyZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBfZXZlbnRUeXBlc1syXSwgX29uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBfZXZlbnRUeXBlc1szXSwgX29uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBjbGlja0NhcHR1cmUsIHRydWUpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIFwiY2xpY2tcIiwgX29uQ2xpY2spO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlc3RhcnRcIiwgX29uR2VzdHVyZVN0YXJ0KTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZWVuZFwiLCBfb25HZXN0dXJlRW5kKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcImVudGVyXCIsIF9vbkhvdmVyKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcImxlYXZlXCIsIF9vbkhvdmVyRW5kKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcIm1vdmVcIiwgX29uTW92ZSk7XG5cbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBzZWxmLmlzUHJlc3NlZCA9IHNlbGYuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBvbkRpc2FibGUgJiYgb25EaXNhYmxlKHNlbGYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmtpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmRpc2FibGUoKTtcblxuICAgICAgdmFyIGkgPSBfb2JzZXJ2ZXJzLmluZGV4T2Yoc2VsZik7XG5cbiAgICAgIGkgPj0gMCAmJiBfb2JzZXJ2ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIF9ub3JtYWxpemVyID09PSBzZWxmICYmIChfbm9ybWFsaXplciA9IDApO1xuICAgIH07XG5cbiAgICBfb2JzZXJ2ZXJzLnB1c2goc2VsZik7XG5cbiAgICBpc05vcm1hbGl6ZXIgJiYgX2lzVmlld3BvcnQodGFyZ2V0KSAmJiAoX25vcm1hbGl6ZXIgPSBzZWxmKTtcbiAgICBzZWxmLmVuYWJsZShldmVudCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmVyLCBbe1xuICAgIGtleTogXCJ2ZWxvY2l0eVhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92eC5nZXRWZWxvY2l0eSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2ZWxvY2l0eVlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92eS5nZXRWZWxvY2l0eSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZlcjtcbn0oKTtcbk9ic2VydmVyLnZlcnNpb24gPSBcIjMuMTAuNFwiO1xuXG5PYnNlcnZlci5jcmVhdGUgPSBmdW5jdGlvbiAodmFycykge1xuICByZXR1cm4gbmV3IE9ic2VydmVyKHZhcnMpO1xufTtcblxuT2JzZXJ2ZXIucmVnaXN0ZXIgPSBfaW5pdENvcmU7XG5cbk9ic2VydmVyLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9vYnNlcnZlcnMuc2xpY2UoKTtcbn07XG5cbk9ic2VydmVyLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIF9vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8udmFycy5pZCA9PT0gaWQ7XG4gIH0pWzBdO1xufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKE9ic2VydmVyKTtcbmV4cG9ydCB7IE9ic2VydmVyIGFzIGRlZmF1bHQsIF9pc1ZpZXdwb3J0LCBfc2Nyb2xsZXJzLCBfZ2V0U2Nyb2xsRnVuYywgX2dldFByb3h5UHJvcCwgX3Byb3hpZXMsIF9nZXRWZWxvY2l0eVByb3AsIF92ZXJ0aWNhbCwgX2hvcml6b250YWwsIF9nZXRUYXJnZXQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/Observer.js\n");

/***/ }),

/***/ "./node_modules/gsap/ScrollSmoother.js":
/*!*********************************************!*\
  !*** ./node_modules/gsap/ScrollSmoother.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollSmoother: () => (/* binding */ ScrollSmoother),\n/* harmony export */   \"default\": () => (/* binding */ ScrollSmoother)\n/* harmony export */ });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*!\n * ScrollSmoother 3.10.4\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _root,\n    _toArray,\n    _clamp,\n    ScrollTrigger,\n    _mainInstance,\n    _expo,\n    _getVelocityProp,\n    _inputObserver,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _bonusValidated = 1,\n    //<name>ScrollSmoother</name>\n_isViewport = function _isViewport(e) {\n  return !!~_root.indexOf(e);\n},\n    _getTime = Date.now,\n    _round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _autoDistance = function _autoDistance(el, progress) {\n  // for calculating the distance (and offset) for elements with speed: \"auto\". Progress is for if it's \"above the fold\" (negative start position), so we can crop as little as possible.\n  var parent = el.parentNode || _docEl,\n      b1 = el.getBoundingClientRect(),\n      b2 = parent.getBoundingClientRect(),\n      gapTop = b2.top - b1.top,\n      gapBottom = b2.bottom - b1.bottom,\n      change = (Math.abs(gapTop) > Math.abs(gapBottom) ? gapTop : gapBottom) / (1 - progress),\n      offset = -change * progress,\n      ratio,\n      extraChange;\n\n  if (change > 0) {\n    // if the image starts at the BOTTOM of the container, adjust things so that it shows as much of the image as possible while still covering.\n    ratio = b2.height / (_win.innerHeight  b2.height);\n    extraChange = ratio === 0.5 ? b2.height * 2 : Math.min(b2.height, -change * ratio / (2 * ratio - 1)) * 2;\n    offset = -extraChange / 2; // whatever the offset, we must double that in the opposite direction to compensate.\n\n    change = extraChange;\n  }\n\n  return {\n    change: change,\n    offset: offset\n  };\n},\n    _wrap = function _wrap(el) {\n  var wrapper = _doc.querySelector(\".ScrollSmoother-wrapper\"); // some frameworks load multiple times, so one already exists, just use that to avoid duplicates\n\n\n  if (!wrapper) {\n    wrapper = _doc.createElement(\"div\");\n    wrapper.classList.add(\"ScrollSmoother-wrapper\");\n    el.parentNode.insertBefore(wrapper, el);\n    wrapper.appendChild(el);\n  }\n\n  return wrapper;\n};\n\nvar ScrollSmoother = /*#__PURE__*/function () {\n  function ScrollSmoother(vars) {\n    var _this = this;\n\n    _coreInitted || ScrollSmoother.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollSmoother)\");\n    vars = this.vars = vars || {};\n    _mainInstance && _mainInstance.kill();\n    _mainInstance = this;\n\n    var _vars = vars,\n        smoothTouch = _vars.smoothTouch,\n        _onUpdate = _vars.onUpdate,\n        onStop = _vars.onStop,\n        smooth = _vars.smooth,\n        onFocusIn = _vars.onFocusIn,\n        normalizeScroll = _vars.normalizeScroll,\n        content,\n        wrapper,\n        height,\n        mainST,\n        effects,\n        sections,\n        intervalID,\n        wrapperCSS,\n        contentCSS,\n        paused,\n        pausedNormalizer,\n        recordedRefreshScroll,\n        scrollFunc = ScrollTrigger.getScrollFunc(_win),\n        smoothDuration = ScrollTrigger.isTouch === 1 ? smoothTouch === true ? 0.8 : parseFloat(smoothTouch) || 0 : smooth === 0 || smooth === false ? 0 : parseFloat(smooth) || 0.8,\n        currentY = 0,\n        delta = 0,\n        startupPhase = 1,\n        tracker = _getVelocityProp(0),\n        updateVelocity = function updateVelocity() {\n      return tracker.update(-currentY);\n    },\n        scroll = {\n      y: 0\n    },\n        removeScroll = function removeScroll() {\n      return content.style.overflow = \"visible\";\n    },\n        isProxyScrolling,\n        killScrub = function killScrub(trigger) {\n      trigger.update(); // it's possible that it hasn't been synchronized with the actual scroll position yet, like if it's later in the _triggers Array. If it was already updated, it'll skip the processing anyway.\n\n      var scrub = trigger.getTween();\n\n      if (scrub) {\n        scrub.pause();\n        scrub._time = scrub._dur; // force the playhead to completion without rendering just so that when it resumes, it doesn't jump back in the .resetTo().\n\n        scrub._tTime = scrub._tDur;\n      }\n\n      isProxyScrolling = false;\n      trigger.animation.progress(trigger.progress, true);\n    },\n        render = function render(y, force) {\n      if (y !== currentY && !paused || force) {\n        smoothDuration && (content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \"  y  \", 0, 1)\"); //smoothDuration && (content.style.transform = \"translateY(\"  y  \"px)\"); // NOTE: when we used matrix3d() or set will-change: transform, it performed noticeably worse on iOS counter-intuitively!\n\n        delta = y - currentY;\n        currentY = y;\n        ScrollTrigger.isUpdating || ScrollTrigger.update();\n      }\n    },\n        scrollTop = function scrollTop(value) {\n      if (arguments.length) {\n        paused ? currentY = -value : render(-value);\n        scroll.y = -value; // don't use currentY because we must accurately track the delta variable (in render() method)\n\n        isProxyScrolling = true; // otherwise, if snapping was applied (or anything that attempted to SET the scroll proxy's scroll position), we'd set the scroll here which would then (on the next tick) update the content tween/ScrollTrigger which would try to smoothly animate to that new value, thus the scrub tween would impede the progress. So we use this flag to respond accordingly in the ScrollTrigger's onUpdate and effectively force the scrub to its end immediately.\n\n        scrollFunc(value);\n        return this;\n      }\n\n      return -currentY - scrollFunc.offset;\n    },\n        lastFocusElement,\n        _onFocusIn = function _onFocusIn(e) {\n      // when the focus changes, make sure that element is on-screen\n      wrapper.scrollTop = 0;\n\n      if (onFocusIn && onFocusIn(_this, e) === false) {\n        return;\n      }\n\n      ScrollTrigger.isInViewport(e.target) || e.target === lastFocusElement || _this.scrollTo(e.target, false, \"center center\");\n      lastFocusElement = e.target;\n    },\n        adjustParallaxPosition = function adjustParallaxPosition(triggers, createdAfterEffectWasApplied) {\n      var pins, start, dif, markers;\n      effects.forEach(function (st) {\n        pins = st.pins;\n        markers = st.markers;\n        triggers.forEach(function (trig) {\n          if ((trig.trigger === st.trigger || trig.pinnedContainer === st.trigger) && st !== trig) {\n            start = trig.start;\n            dif = (start - st.start - st.offset) / st.ratio - (start - st.start); // createdAfterEffectWasApplied && (dif -= (gsap.getProperty(st.trigger, \"y\") - st.startY) / st.ratio); // the effect applied a y offset, so if the ScrollTrigger was created after that, it'll be based on that position so we must compensate. Later we added code to ScrollTrigger to roll back in this situation anyway, so this isn't necessary. Saving it in case a situation arises where it comes in handy.\n\n            pins.forEach(function (p) {\n              return dif -= p.distance / st.ratio - p.distance;\n            });\n            trig.setPositions(start  dif, trig.end  dif);\n            trig.markerStart && markers.push(gsap.quickSetter([trig.markerStart, trig.markerEnd], \"y\", \"px\"));\n\n            if (trig.pin && trig.end > 0) {\n              dif = trig.end - trig.start;\n              pins.push({\n                start: trig.start,\n                end: trig.end,\n                distance: dif,\n                trig: trig\n              });\n              st.setPositions(st.start, st.end  dif);\n              st.vars.onRefresh(st);\n            }\n          }\n        });\n      });\n    },\n        onRefresh = function onRefresh() {\n      removeScroll();\n      requestAnimationFrame(removeScroll);\n\n      if (effects) {\n        // adjust all the effect start/end positions including any pins!\n        effects.forEach(function (st) {\n          var start = st.start,\n              end = st.auto ? Math.min(ScrollTrigger.maxScroll(st.scroller), st.end) : start  (st.end - start) / st.ratio,\n              offset = (end - st.end) / 2; // we split the difference so that it reaches its natural position in the MIDDLE of the viewport\n\n          start -= offset;\n          end -= offset;\n          st.offset = offset || 0.0001; // we assign at least a tiny value because we check in the onUpdate for .offset being set in order to apply values.\n\n          st.pins.length = 0;\n          st.setPositions(Math.min(start, end), Math.max(start, end));\n          st.vars.onRefresh(st);\n        });\n        adjustParallaxPosition(ScrollTrigger.sort());\n      }\n\n      tracker.reset();\n    },\n        restoreEffects = function restoreEffects() {\n      return effects && effects.forEach(function (st) {\n        return st.vars.onRefresh(st);\n      });\n    },\n        revertEffects = function revertEffects() {\n      effects && effects.forEach(function (st) {\n        return st.vars.onRefreshInit(st);\n      });\n      return restoreEffects;\n    },\n        effectValueGetter = function effectValueGetter(name, value, index, el) {\n      return function () {\n        var v = typeof value === \"function\" ? value(index, el) : value;\n        v || v === 0 || (v = el.getAttribute(\"data-\"  name) || (name === \"speed\" ? 1 : 0));\n        el.setAttribute(\"data-\"  name, v);\n        return v === \"auto\" ? v : parseFloat(v);\n      };\n    },\n        createEffect = function createEffect(el, speed, lag, index) {\n      var getSpeed = effectValueGetter(\"speed\", speed, index, el),\n          getLag = effectValueGetter(\"lag\", lag, index, el),\n          startY = gsap.getProperty(el, \"y\"),\n          cache = el._gsap,\n          ratio,\n          st,\n          autoSpeed,\n          scrub,\n          progressOffset,\n          yOffset,\n          initDynamicValues = function initDynamicValues() {\n        speed = getSpeed();\n        lag = getLag();\n        ratio = parseFloat(speed) || 1;\n        autoSpeed = speed === \"auto\";\n        progressOffset = autoSpeed ? 0 : 0.5;\n        scrub && scrub.kill();\n        scrub = lag && gsap.to(el, {\n          ease: _expo,\n          overwrite: false,\n          y: \"=0\",\n          duration: lag\n        });\n\n        if (st) {\n          st.ratio = ratio;\n          st.autoSpeed = autoSpeed;\n        }\n      },\n          revert = function revert() {\n        cache.y = startY  \"px\";\n        cache.renderTransform(1);\n        initDynamicValues();\n      },\n          pins = [],\n          markers = [],\n          change = 0,\n          updateChange = function updateChange(self) {\n        if (autoSpeed) {\n          revert();\n\n          var auto = _autoDistance(el, _clamp(0, 1, -self.start / (self.end - self.start)));\n\n          change = auto.change;\n          yOffset = auto.offset;\n        } else {\n          change = (self.end - self.start) * (1 - ratio);\n          yOffset = 0;\n        }\n\n        pins.forEach(function (p) {\n          return change -= p.distance * (1 - ratio);\n        });\n        self.vars.onUpdate(self);\n        scrub && scrub.progress(1);\n      };\n\n      initDynamicValues();\n\n      if (ratio !== 1 || autoSpeed || scrub) {\n        st = ScrollTrigger.create({\n          trigger: autoSpeed ? el.parentNode : el,\n          scroller: wrapper,\n          scrub: true,\n          refreshPriority: -999,\n          // must update AFTER any other ScrollTrigger pins\n          onRefreshInit: revert,\n          onRefresh: updateChange,\n          onKill: function onKill(self) {\n            var i = effects.indexOf(self);\n            i >= 0 && effects.splice(i, 1);\n            revert();\n          },\n          onUpdate: function onUpdate(self) {\n            var y = startY  change * (self.progress - progressOffset),\n                i = pins.length,\n                extraY = 0,\n                pin,\n                scrollY,\n                end;\n\n            if (self.offset) {\n              // wait until the effects are adjusted.\n              if (i) {\n                // pinning must be handled in a special way because when pinned, slope changes to 1.\n                scrollY = -currentY; // -scroll.y;\n\n                end = self.end;\n\n                while (i--) {\n                  pin = pins[i];\n\n                  if (pin.trig.isActive || scrollY >= pin.start && scrollY <= pin.end) {\n                    // currently pinned so no need to set anything\n                    if (scrub) {\n                      pin.trig.progress = pin.trig.direction < 0 ? 0.001 : -0.001; // just to make absolutely sure that it renders (if the progress didn't change, it'll skip)\n\n                      pin.trig.update(0, 0, 1);\n                      scrub.resetTo(\"y\", parseFloat(cache.y), -delta, true);\n                      startupPhase && scrub.progress(1);\n                    }\n\n                    return;\n                  }\n\n                  scrollY > pin.end && (extraY = pin.distance);\n                  end -= pin.distance;\n                }\n\n                y = startY  extraY  change * ((gsap.utils.clamp(self.start, self.end, scrollY) - self.start - extraY) / (end - self.start) - progressOffset);\n              }\n\n              y = _round(y  yOffset);\n              markers.length && !autoSpeed && markers.forEach(function (setter) {\n                return setter(y - extraY);\n              });\n\n              if (scrub) {\n                scrub.resetTo(\"y\", y, -delta, true);\n                startupPhase && scrub.progress(1);\n              } else {\n                cache.y = y  \"px\";\n                cache.renderTransform(1);\n              }\n            }\n          }\n        });\n        updateChange(st);\n        gsap.core.getCache(st.trigger).stRevert = revertEffects; // if user calls ScrollSmoother.create() with effects and THEN creates a ScrollTrigger on the same trigger element, the effect would throw off the start/end positions thus we needed a way to revert things when creating a new ScrollTrigger in that scenario, so we use this stRevert property of the GSCache inside ScrollTrigger.\n\n        st.startY = startY;\n        st.pins = pins;\n        st.markers = markers;\n        st.ratio = ratio;\n        st.autoSpeed = autoSpeed;\n        el.style.willChange = \"transform\";\n      }\n\n      return st;\n    };\n\n    ScrollTrigger.addEventListener(\"refresh\", onRefresh);\n    gsap.delayedCall(0.5, function () {\n      return startupPhase = 0;\n    });\n    this.scrollTop = scrollTop;\n\n    this.scrollTo = function (target, smooth, position) {\n      var p = gsap.utils.clamp(0, ScrollTrigger.maxScroll(_win), isNaN(target) ? _this.offset(target, position) : target);\n      !smooth ? scrollTop(p) : paused ? gsap.to(_this, {\n        duration: smoothDuration,\n        scrollTop: p,\n        overwrite: \"auto\",\n        ease: _expo\n      }) : scrollFunc(p);\n    };\n\n    this.offset = function (target, position) {\n      target = _toArray(target)[0];\n      var cssText = target.style.cssText,\n          // because if there's an effect applied, we revert(). We need to restore.\n      st = ScrollTrigger.create({\n        trigger: target,\n        start: position || \"top top\"\n      }),\n          y;\n      effects && adjustParallaxPosition([st], true);\n      y = st.start;\n      st.kill(false);\n      target.style.cssText = cssText;\n      gsap.core.getCache(target).uncache = 1;\n      return y;\n    };\n\n    function refreshHeight() {\n      height = content.clientHeight;\n      content.style.overflow = \"visible\";\n      _body.style.height = height  \"px\";\n      return height - _win.innerHeight;\n    }\n\n    this.content = function (element) {\n      if (arguments.length) {\n        var newContent = _toArray(element || \"#smooth-content\")[0] || _body.children[0];\n\n        if (newContent !== content) {\n          content = newContent;\n          contentCSS = content.getAttribute(\"style\") || \"\";\n          gsap.set(content, {\n            overflow: \"visible\",\n            width: \"100%\",\n            boxSizing: \"border-box\"\n          });\n        }\n\n        return this;\n      }\n\n      return content;\n    };\n\n    this.wrapper = function (element) {\n      if (arguments.length) {\n        wrapper = _toArray(element || \"#smooth-wrapper\")[0] || _wrap(content);\n        wrapperCSS = wrapper.getAttribute(\"style\") || \"\";\n        refreshHeight();\n        gsap.set(wrapper, smoothDuration ? {\n          overflow: \"hidden\",\n          position: \"fixed\",\n          height: \"100%\",\n          width: \"100%\",\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0\n        } : {\n          overflow: \"visible\",\n          position: \"relative\",\n          width: \"100%\",\n          height: \"auto\",\n          top: \"auto\",\n          bottom: \"auto\",\n          left: \"auto\",\n          right: \"auto\"\n        });\n        return this;\n      }\n\n      return wrapper;\n    };\n\n    this.effects = function (targets, config) {\n      var _effects;\n\n      effects || (effects = []);\n\n      if (!targets) {\n        return effects.slice(0);\n      }\n\n      targets = _toArray(targets);\n      targets.forEach(function (target) {\n        var i = effects.length;\n\n        while (i--) {\n          if (effects[i].trigger === target) {\n            effects[i].kill();\n            effects.splice(i, 1);\n          }\n        }\n      });\n      config = config || {};\n      var _config = config,\n          speed = _config.speed,\n          lag = _config.lag,\n          effectsToAdd = [],\n          i,\n          st;\n\n      for (i = 0; i < targets.length; i) {\n        st = createEffect(targets[i], speed, lag, i);\n        st && effectsToAdd.push(st);\n      }\n\n      (_effects = effects).push.apply(_effects, effectsToAdd);\n\n      return effectsToAdd;\n    };\n\n    this.sections = function (targets, config) {\n      var _sections;\n\n      sections || (sections = []);\n\n      if (!targets) {\n        return sections.slice(0);\n      }\n\n      var newSections = _toArray(targets).map(function (el) {\n        return ScrollTrigger.create({\n          trigger: el,\n          start: \"top 120%\",\n          end: \"bottom -20%\",\n          onToggle: function onToggle(self) {\n            el.style.opacity = self.isActive ? \"1\" : \"0\";\n            el.style.pointerEvents = self.isActive ? \"all\" : \"none\";\n          }\n        });\n      });\n\n      config && config.add ? (_sections = sections).push.apply(_sections, newSections) : sections = newSections.slice(0);\n      return newSections;\n    };\n\n    this.content(vars.content);\n    this.wrapper(vars.wrapper);\n\n    this.render = function (y) {\n      return render(y || y === 0 ? y : currentY);\n    };\n\n    this.getVelocity = function () {\n      return tracker.getVelocity(-currentY);\n    };\n\n    ScrollTrigger.scrollerProxy(wrapper, {\n      scrollTop: scrollTop,\n      scrollHeight: function scrollHeight() {\n        return refreshHeight() && _body.scrollHeight;\n      },\n      fixedMarkers: vars.fixedMarkers !== false && !!smoothDuration,\n      content: content,\n      getBoundingClientRect: function getBoundingClientRect() {\n        return {\n          top: 0,\n          left: 0,\n          width: _win.innerWidth,\n          height: _win.innerHeight\n        };\n      }\n    });\n    ScrollTrigger.defaults({\n      scroller: wrapper\n    });\n    var existingScrollTriggers = ScrollTrigger.getAll().filter(function (st) {\n      return st.scroller === _win || st.scroller === wrapper;\n    });\n    existingScrollTriggers.forEach(function (st) {\n      return st.revert(true);\n    }); // in case it's in an environment like React where child components that have ScrollTriggers instantiate BEFORE the parent that does ScrollSmoother.create(...);\n\n    mainST = ScrollTrigger.create({\n      animation: gsap.to(scroll, {\n        y: function y() {\n          return -refreshHeight();\n        },\n        ease: \"none\",\n        data: \"ScrollSmoother\",\n        duration: 100,\n        // for added precision\n        onUpdate: function onUpdate() {\n          var force = isProxyScrolling;\n\n          if (force) {\n            scroll.y = currentY;\n            killScrub(mainST);\n          }\n\n          render(scroll.y, force);\n          updateVelocity();\n          _onUpdate && !paused && _onUpdate(_this);\n        }\n      }),\n      onRefreshInit: function onRefreshInit() {\n        recordedRefreshScroll = currentY;\n        scroll.y = wrapper.scrollTop = 0; // set wrapper.scrollTop to 0 because in some very rare situations, the browser will auto-set that, like if there's a hash in the link or changing focus to an off-screen input\n      },\n      id: \"ScrollSmoother\",\n      scroller: _win,\n      invalidateOnRefresh: true,\n      start: 0,\n      refreshPriority: -9999,\n      // because all other pins, etc. should be calculated first before this figures out the height of the body. BUT this should also update FIRST so that the scroll position on the proxy is up-to-date when all the ScrollTriggers calculate their progress! -9999 is a special number that ScrollTrigger looks for to handle in this way.\n      end: refreshHeight,\n      onScrubComplete: function onScrubComplete() {\n        tracker.reset();\n        onStop && onStop(_this);\n      },\n      scrub: smoothDuration || true,\n      onRefresh: function onRefresh(self) {\n        killScrub(self);\n        scroll.y = -scrollFunc();\n        render(scroll.y);\n        startupPhase || self.animation.progress(gsap.utils.clamp(0, 1, recordedRefreshScroll / -self.end));\n      }\n    });\n\n    this.smooth = function (value) {\n      smoothDuration = value;\n      return arguments.length ? mainST.scrubDuration(value) : mainST.getTween() ? mainST.getTween().duration() : 0;\n    };\n\n    mainST.getTween() && (mainST.getTween().vars.ease = vars.ease || _expo);\n    this.scrollTrigger = mainST;\n    vars.effects && this.effects(vars.effects === true ? \"[data-speed], [data-lag]\" : vars.effects, {});\n    vars.sections && this.sections(vars.sections === true ? \"[data-section]\" : vars.sections);\n    existingScrollTriggers.forEach(function (st) {\n      st.vars.scroller = wrapper;\n      st.init(st.vars, st.animation);\n    });\n\n    this.paused = function (value, allowNestedScroll) {\n      if (arguments.length) {\n        if (!!paused !== value) {\n          if (value) {\n            // pause\n            mainST.getTween() && mainST.getTween().pause();\n            scrollFunc(-currentY);\n            tracker.reset();\n            pausedNormalizer = ScrollTrigger.normalizeScroll();\n            pausedNormalizer && pausedNormalizer.disable(); // otherwise the normalizer would try to scroll the page on things like wheel events.\n\n            paused = ScrollTrigger.observe({\n              preventDefault: true,\n              type: \"wheel,touch,scroll\",\n              debounce: false,\n              allowClicks: true,\n              onChangeY: function onChangeY() {\n                return scrollTop(-currentY);\n              } // refuse to scroll\n\n            });\n            paused.nested = _inputObserver(_docEl, \"wheel,touch,scroll\", true, allowNestedScroll !== false); // allow nested scrolling, like modals\n          } else {\n            // resume\n            paused.nested.kill();\n            paused.kill();\n            paused = 0;\n            pausedNormalizer && pausedNormalizer.enable();\n            mainST.progress = (-currentY - mainST.start) / (mainST.end - mainST.start);\n            killScrub(mainST);\n          }\n        }\n\n        return this;\n      }\n\n      return !!paused;\n    };\n\n    this.kill = function () {\n      _this.paused(false);\n\n      killScrub(mainST);\n      mainST.kill();\n      var triggers = (effects || []).concat(sections || []),\n          i = triggers.length;\n\n      while (i--) {\n        // make sure we go backwards because the onKill() will effects.splice(index, 1) and we don't want to skip\n        triggers[i].kill();\n      }\n\n      ScrollTrigger.scrollerProxy(wrapper);\n      ScrollTrigger.removeEventListener(\"refresh\", onRefresh);\n\n      _body.style.removeProperty(\"height\");\n\n      wrapper.style.cssText = wrapperCSS;\n      content.style.cssText = contentCSS;\n      var defaults = ScrollTrigger.defaults({});\n      defaults && defaults.scroller === wrapper && ScrollTrigger.defaults({\n        scroller: _win\n      });\n      _this.normalizer && ScrollTrigger.normalizeScroll(false);\n      clearInterval(intervalID);\n      _mainInstance = null;\n\n      _win.removeEventListener(\"focusin\", _onFocusIn);\n    };\n\n    this.refresh = function (soft, force) {\n      return mainST.refresh(soft, force);\n    };\n\n    if (normalizeScroll) {\n      this.normalizer = ScrollTrigger.normalizeScroll(normalizeScroll === true ? {\n        debounce: true,\n        content: content\n      } : normalizeScroll);\n    }\n\n    ScrollTrigger.config(vars); // in case user passes in ignoreMobileResize for example\n\n    \"overscrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n      overscrollBehavior: \"none\"\n    });\n    \"scrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n      scrollBehavior: \"auto\"\n    }); // if the user hits the tab key (or whatever) to shift focus to an element that's off-screen, center that element.\n\n    _win.addEventListener(\"focusin\", _onFocusIn);\n\n    intervalID = setInterval(updateVelocity, 250);\n    _doc.readyState === \"loading\" || requestAnimationFrame(function () {\n      return ScrollTrigger.refresh();\n    });\n  }\n\n  ScrollSmoother.register = function register(core) {\n    if (!_coreInitted) {\n      gsap = core || _getGSAP();\n\n      if (_windowExists() && window.document) {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n      }\n\n      if (gsap) {\n        _toArray = gsap.utils.toArray;\n        _clamp = gsap.utils.clamp;\n        _expo = gsap.parseEase(\"expo\");\n        ScrollTrigger = gsap.core.globals().ScrollTrigger;\n        gsap.core.globals(\"ScrollSmoother\", ScrollSmoother); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n        //\tgsap.ticker.lagSmoothing(50, 100); // generally people don't want things to jump (honoring smoothness over time is better with smooth scrolling)\n\n        if (_body && ScrollTrigger) {\n          _root = [_win, _doc, _docEl, _body];\n          _getVelocityProp = ScrollTrigger.core._getVelocityProp;\n          _inputObserver = ScrollTrigger.core._inputObserver;\n          ScrollSmoother.refresh = ScrollTrigger.refresh;\n          _coreInitted = 1;\n        }\n      }\n    }\n\n    return _coreInitted;\n  };\n\n  _createClass(ScrollSmoother, [{\n    key: \"progress\",\n    get: function get() {\n      return this.scrollTrigger.animation._time / 100;\n    }\n  }]);\n\n  return ScrollSmoother;\n}();\nScrollSmoother.version = \"3.10.4\";\n\nScrollSmoother.create = function (vars) {\n  return _mainInstance && vars && _mainInstance.content() === _toArray(vars.content)[0] ? _mainInstance : new ScrollSmoother(vars);\n};\n\nScrollSmoother.get = function () {\n  return _mainInstance;\n};\n\n_getGSAP() && gsap.registerPlugin(ScrollSmoother);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxTbW9vdGhlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLCtEQUErRDs7O0FBRy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEhB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QUE2RztBQUM3RyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9nc2FwL1Njcm9sbFNtb290aGVyLmpzPzRhNTUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKiFcbiAqIFNjcm9sbFNtb290aGVyIDMuMTAuNFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsLFxuICAgIF9ib2R5LFxuICAgIF9yb290LFxuICAgIF90b0FycmF5LFxuICAgIF9jbGFtcCxcbiAgICBTY3JvbGxUcmlnZ2VyLFxuICAgIF9tYWluSW5zdGFuY2UsXG4gICAgX2V4cG8sXG4gICAgX2dldFZlbG9jaXR5UHJvcCxcbiAgICBfaW5wdXRPYnNlcnZlcixcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9ib251c1ZhbGlkYXRlZCA9IDEsXG4gICAgLy88bmFtZT5TY3JvbGxTbW9vdGhlcjwvbmFtZT5cbl9pc1ZpZXdwb3J0ID0gZnVuY3Rpb24gX2lzVmlld3BvcnQoZSkge1xuICByZXR1cm4gISFX3Jvb3QuaW5kZXhPZihlKTtcbn0sXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF9hdXRvRGlzdGFuY2UgPSBmdW5jdGlvbiBfYXV0b0Rpc3RhbmNlKGVsLCBwcm9ncmVzcykge1xuICAvLyBmb3IgY2FsY3VsYXRpbmcgdGhlIGRpc3RhbmNlIChhbmQgb2Zmc2V0KSBmb3IgZWxlbWVudHMgd2l0aCBzcGVlZDogXCJhdXRvXCIuIFByb2dyZXNzIGlzIGZvciBpZiBpdCdzIFwiYWJvdmUgdGhlIGZvbGRcIiAobmVnYXRpdmUgc3RhcnQgcG9zaXRpb24pLCBzbyB3ZSBjYW4gY3JvcCBhcyBsaXR0bGUgYXMgcG9zc2libGUuXG4gIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlIHx8IF9kb2NFbCxcbiAgICAgIGIxID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBiMiA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGdhcFRvcCA9IGIyLnRvcCAtIGIxLnRvcCxcbiAgICAgIGdhcEJvdHRvbSA9IGIyLmJvdHRvbSAtIGIxLmJvdHRvbSxcbiAgICAgIGNoYW5nZSA9IChNYXRoLmFicyhnYXBUb3ApID4gTWF0aC5hYnMoZ2FwQm90dG9tKSA/IGdhcFRvcCA6IGdhcEJvdHRvbSkgLyAoMSAtIHByb2dyZXNzKSxcbiAgICAgIG9mZnNldCA9IC1jaGFuZ2UgKiBwcm9ncmVzcyxcbiAgICAgIHJhdGlvLFxuICAgICAgZXh0cmFDaGFuZ2U7XG5cbiAgaWYgKGNoYW5nZSAIDApIHtcbiAgICAvLyBpZiB0aGUgaW1hZ2Ugc3RhcnRzIGF0IHRoZSBCT1RUT00gb2YgdGhlIGNvbnRhaW5lciwgYWRqdXN0IHRoaW5ncyBzbyB0aGF0IGl0IHNob3dzIGFzIG11Y2ggb2YgdGhlIGltYWdlIGFzIHBvc3NpYmxlIHdoaWxlIHN0aWxsIGNvdmVyaW5nLlxuICAgIHJhdGlvID0gYjIuaGVpZ2h0IC8gKF93aW4uaW5uZXJIZWlnaHQgKyBiMi5oZWlnaHQpO1xuICAgIGV4dHJhQ2hhbmdlID0gcmF0aW8gPT09IDAuNSA/IGIyLmhlaWdodCAqIDIgOiBNYXRoLm1pbihiMi5oZWlnaHQsIC1jaGFuZ2UgKiByYXRpbyAvICgyICogcmF0aW8gLSAxKSkgKiAyO1xuICAgIG9mZnNldCArPSAtZXh0cmFDaGFuZ2UgLyAyOyAvLyB3aGF0ZXZlciB0aGUgb2Zmc2V0LCB3ZSBtdXN0IGRvdWJsZSB0aGF0IGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gdG8gY29tcGVuc2F0ZS5cblxuICAgIGNoYW5nZSArPSBleHRyYUNoYW5nZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2hhbmdlOiBjaGFuZ2UsXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfTtcbn0sXG4gICAgX3dyYXAgPSBmdW5jdGlvbiBfd3JhcChlbCkge1xuICB2YXIgd3JhcHBlciA9IF9kb2MucXVlcnlTZWxlY3RvcihcIi5TY3JvbGxTbW9vdGhlci13cmFwcGVyXCIpOyAvLyBzb21lIGZyYW1ld29ya3MgbG9hZCBtdWx0aXBsZSB0aW1lcywgc28gb25lIGFscmVhZHkgZXhpc3RzLCBqdXN0IHVzZSB0aGF0IHRvIGF2b2lkIGR1cGxpY2F0ZXNcblxuXG4gIGlmICghd3JhcHBlcikge1xuICAgIHdyYXBwZXIgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKFwiU2Nyb2xsU21vb3RoZXItd3JhcHBlclwiKTtcbiAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBlbCk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChlbCk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlcjtcbn07XG5cbmV4cG9ydCB2YXIgU2Nyb2xsU21vb3RoZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY3JvbGxTbW9vdGhlcih2YXJzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxTbW9vdGhlci5yZWdpc3Rlcihnc2FwKSB8fCBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxTbW9vdGhlcilcIik7XG4gICAgdmFycyA9IHRoaXMudmFycyA9IHZhcnMgfHwge307XG4gICAgX21haW5JbnN0YW5jZSAmJiBfbWFpbkluc3RhbmNlLmtpbGwoKTtcbiAgICBfbWFpbkluc3RhbmNlID0gdGhpcztcblxuICAgIHZhciBfdmFycyA9IHZhcnMsXG4gICAgICAgIHNtb290aFRvdWNoID0gX3ZhcnMuc21vb3RoVG91Y2gsXG4gICAgICAgIF9vblVwZGF0ZSA9IF92YXJzLm9uVXBkYXRlLFxuICAgICAgICBvblN0b3AgPSBfdmFycy5vblN0b3AsXG4gICAgICAgIHNtb290aCA9IF92YXJzLnNtb290aCxcbiAgICAgICAgb25Gb2N1c0luID0gX3ZhcnMub25Gb2N1c0luLFxuICAgICAgICBub3JtYWxpemVTY3JvbGwgPSBfdmFycy5ub3JtYWxpemVTY3JvbGwsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIHdyYXBwZXIsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgbWFpblNULFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBzZWN0aW9ucyxcbiAgICAgICAgaW50ZXJ2YWxJRCxcbiAgICAgICAgd3JhcHBlckNTUyxcbiAgICAgICAgY29udGVudENTUyxcbiAgICAgICAgcGF1c2VkLFxuICAgICAgICBwYXVzZWROb3JtYWxpemVyLFxuICAgICAgICByZWNvcmRlZFJlZnJlc2hTY3JvbGwsXG4gICAgICAgIHNjcm9sbEZ1bmMgPSBTY3JvbGxUcmlnZ2VyLmdldFNjcm9sbEZ1bmMoX3dpbiksXG4gICAgICAgIHNtb290aER1cmF0aW9uID0gU2Nyb2xsVHJpZ2dlci5pc1RvdWNoID09PSAxID8gc21vb3RoVG91Y2ggPT09IHRydWUgPyAwLjggOiBwYXJzZUZsb2F0KHNtb290aFRvdWNoKSB8fCAwIDogc21vb3RoID09PSAwIHx8IHNtb290aCA9PT0gZmFsc2UgPyAwIDogcGFyc2VGbG9hdChzbW9vdGgpIHx8IDAuOCxcbiAgICAgICAgY3VycmVudFkgPSAwLFxuICAgICAgICBkZWx0YSA9IDAsXG4gICAgICAgIHN0YXJ0dXBQaGFzZSA9IDEsXG4gICAgICAgIHRyYWNrZXIgPSBfZ2V0VmVsb2NpdHlQcm9wKDApLFxuICAgICAgICB1cGRhdGVWZWxvY2l0eSA9IGZ1bmN0aW9uIHVwZGF0ZVZlbG9jaXR5KCkge1xuICAgICAgcmV0dXJuIHRyYWNrZXIudXBkYXRlKC1jdXJyZW50WSk7XG4gICAgfSxcbiAgICAgICAgc2Nyb2xsID0ge1xuICAgICAgeTogMFxuICAgIH0sXG4gICAgICAgIHJlbW92ZVNjcm9sbCA9IGZ1bmN0aW9uIHJlbW92ZVNjcm9sbCgpIHtcbiAgICAgIHJldHVybiBjb250ZW50LnN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XG4gICAgfSxcbiAgICAgICAgaXNQcm94eVNjcm9sbGluZyxcbiAgICAgICAga2lsbFNjcnViID0gZnVuY3Rpb24ga2lsbFNjcnViKHRyaWdnZXIpIHtcbiAgICAgIHRyaWdnZXIudXBkYXRlKCk7IC8vIGl0J3MgcG9zc2libGUgdGhhdCBpdCBoYXNuJ3QgYmVlbiBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgYWN0dWFsIHNjcm9sbCBwb3NpdGlvbiB5ZXQsIGxpa2UgaWYgaXQncyBsYXRlciBpbiB0aGUgX3RyaWdnZXJzIEFycmF5LiBJZiBpdCB3YXMgYWxyZWFkeSB1cGRhdGVkLCBpdCdsbCBza2lwIHRoZSBwcm9jZXNzaW5nIGFueXdheS5cblxuICAgICAgdmFyIHNjcnViID0gdHJpZ2dlci5nZXRUd2VlbigpO1xuXG4gICAgICBpZiAoc2NydWIpIHtcbiAgICAgICAgc2NydWIucGF1c2UoKTtcbiAgICAgICAgc2NydWIuX3RpbWUgPSBzY3J1Yi5fZHVyOyAvLyBmb3JjZSB0aGUgcGxheWhlYWQgdG8gY29tcGxldGlvbiB3aXRob3V0IHJlbmRlcmluZyBqdXN0IHNvIHRoYXQgd2hlbiBpdCByZXN1bWVzLCBpdCBkb2Vzbid0IGp1bXAgYmFjayBpbiB0aGUgLnJlc2V0VG8oKS5cblxuICAgICAgICBzY3J1Yi5fdFRpbWUgPSBzY3J1Yi5fdER1cjtcbiAgICAgIH1cblxuICAgICAgaXNQcm94eVNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgdHJpZ2dlci5hbmltYXRpb24ucHJvZ3Jlc3ModHJpZ2dlci5wcm9ncmVzcywgdHJ1ZSk7XG4gICAgfSxcbiAgICAgICAgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHksIGZvcmNlKSB7XG4gICAgICBpZiAoeSAhPT0gY3VycmVudFkgJiYgIXBhdXNlZCB8fCBmb3JjZSkge1xuICAgICAgICBzbW9vdGhEdXJhdGlvbiAmJiAoY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBcIm1hdHJpeDNkKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIFwiICsgeSArIFwiLCAwLCAxKVwiKTsgLy9zbW9vdGhEdXJhdGlvbiAmJiAoY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVkoXCIgKyB5ICsgXCJweClcIik7IC8vIE5PVEU6IHdoZW4gd2UgdXNlZCBtYXRyaXgzZCgpIG9yIHNldCB3aWxsLWNoYW5nZTogdHJhbnNmb3JtLCBpdCBwZXJmb3JtZWQgbm90aWNlYWJseSB3b3JzZSBvbiBpT1MgY291bnRlci1pbnR1aXRpdmVseSFcblxuICAgICAgICBkZWx0YSA9IHkgLSBjdXJyZW50WTtcbiAgICAgICAgY3VycmVudFkgPSB5O1xuICAgICAgICBTY3JvbGxUcmlnZ2VyLmlzVXBkYXRpbmcgfHwgU2Nyb2xsVHJpZ2dlci51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBzY3JvbGxUb3AgPSBmdW5jdGlvbiBzY3JvbGxUb3AodmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHBhdXNlZCA/IGN1cnJlbnRZID0gLXZhbHVlIDogcmVuZGVyKC12YWx1ZSk7XG4gICAgICAgIHNjcm9sbC55ID0gLXZhbHVlOyAvLyBkb24ndCB1c2UgY3VycmVudFkgYmVjYXVzZSB3ZSBtdXN0IGFjY3VyYXRlbHkgdHJhY2sgdGhlIGRlbHRhIHZhcmlhYmxlIChpbiByZW5kZXIoKSBtZXRob2QpXG5cbiAgICAgICAgaXNQcm94eVNjcm9sbGluZyA9IHRydWU7IC8vIG90aGVyd2lzZSwgaWYgc25hcHBpbmcgd2FzIGFwcGxpZWQgKG9yIGFueXRoaW5nIHRoYXQgYXR0ZW1wdGVkIHRvIFNFVCB0aGUgc2Nyb2xsIHByb3h5J3Mgc2Nyb2xsIHBvc2l0aW9uKSwgd2UnZCBzZXQgdGhlIHNjcm9sbCBoZXJlIHdoaWNoIHdvdWxkIHRoZW4gKG9uIHRoZSBuZXh0IHRpY2spIHVwZGF0ZSB0aGUgY29udGVudCB0d2Vlbi9TY3JvbGxUcmlnZ2VyIHdoaWNoIHdvdWxkIHRyeSB0byBzbW9vdGhseSBhbmltYXRlIHRvIHRoYXQgbmV3IHZhbHVlLCB0aHVzIHRoZSBzY3J1YiB0d2VlbiB3b3VsZCBpbXBlZGUgdGhlIHByb2dyZXNzLiBTbyB3ZSB1c2UgdGhpcyBmbGFnIHRvIHJlc3BvbmQgYWNjb3JkaW5nbHkgaW4gdGhlIFNjcm9sbFRyaWdnZXIncyBvblVwZGF0ZSBhbmQgZWZmZWN0aXZlbHkgZm9yY2UgdGhlIHNjcnViIHRvIGl0cyBlbmQgaW1tZWRpYXRlbHkuXG5cbiAgICAgICAgc2Nyb2xsRnVuYyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLWN1cnJlbnRZIC0gc2Nyb2xsRnVuYy5vZmZzZXQ7XG4gICAgfSxcbiAgICAgICAgbGFzdEZvY3VzRWxlbWVudCxcbiAgICAgICAgX29uRm9jdXNJbiA9IGZ1bmN0aW9uIF9vbkZvY3VzSW4oZSkge1xuICAgICAgLy8gd2hlbiB0aGUgZm9jdXMgY2hhbmdlcywgbWFrZSBzdXJlIHRoYXQgZWxlbWVudCBpcyBvbi1zY3JlZW5cbiAgICAgIHdyYXBwZXIuc2Nyb2xsVG9wID0gMDtcblxuICAgICAgaWYgKG9uRm9jdXNJbiAmJiBvbkZvY3VzSW4oX3RoaXMsIGUpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIFNjcm9sbFRyaWdnZXIuaXNJblZpZXdwb3J0KGUudGFyZ2V0KSB8fCBlLnRhcmdldCA9PT0gbGFzdEZvY3VzRWxlbWVudCB8fCBfdGhpcy5zY3JvbGxUbyhlLnRhcmdldCwgZmFsc2UsIFwiY2VudGVyIGNlbnRlclwiKTtcbiAgICAgIGxhc3RGb2N1c0VsZW1lbnQgPSBlLnRhcmdldDtcbiAgICB9LFxuICAgICAgICBhZGp1c3RQYXJhbGxheFBvc2l0aW9uID0gZnVuY3Rpb24gYWRqdXN0UGFyYWxsYXhQb3NpdGlvbih0cmlnZ2VycywgY3JlYXRlZEFmdGVyRWZmZWN0V2FzQXBwbGllZCkge1xuICAgICAgdmFyIHBpbnMsIHN0YXJ0LCBkaWYsIG1hcmtlcnM7XG4gICAgICBlZmZlY3RzLmZvckVhY2goZnVuY3Rpb24gKHN0KSB7XG4gICAgICAgIHBpbnMgPSBzdC5waW5zO1xuICAgICAgICBtYXJrZXJzID0gc3QubWFya2VycztcbiAgICAgICAgdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZykge1xuICAgICAgICAgIGlmICgodHJpZy50cmlnZ2VyID09PSBzdC50cmlnZ2VyIHx8IHRyaWcucGlubmVkQ29udGFpbmVyID09PSBzdC50cmlnZ2VyKSAmJiBzdCAhPT0gdHJpZykge1xuICAgICAgICAgICAgc3RhcnQgPSB0cmlnLnN0YXJ0O1xuICAgICAgICAgICAgZGlmID0gKHN0YXJ0IC0gc3Quc3RhcnQgLSBzdC5vZmZzZXQpIC8gc3QucmF0aW8gLSAoc3RhcnQgLSBzdC5zdGFydCk7IC8vIGNyZWF0ZWRBZnRlckVmZmVjdFdhc0FwcGxpZWQgJiYgKGRpZiAtPSAoZ3NhcC5nZXRQcm9wZXJ0eShzdC50cmlnZ2VyLCBcInlcIikgLSBzdC5zdGFydFkpIC8gc3QucmF0aW8pOyAvLyB0aGUgZWZmZWN0IGFwcGxpZWQgYSB5IG9mZnNldCwgc28gaWYgdGhlIFNjcm9sbFRyaWdnZXIgd2FzIGNyZWF0ZWQgYWZ0ZXIgdGhhdCwgaXQnbGwgYmUgYmFzZWQgb24gdGhhdCBwb3NpdGlvbiBzbyB3ZSBtdXN0IGNvbXBlbnNhdGUuIExhdGVyIHdlIGFkZGVkIGNvZGUgdG8gU2Nyb2xsVHJpZ2dlciB0byByb2xsIGJhY2sgaW4gdGhpcyBzaXR1YXRpb24gYW55d2F5LCBzbyB0aGlzIGlzbid0IG5lY2Vzc2FyeS4gU2F2aW5nIGl0IGluIGNhc2UgYSBzaXR1YXRpb24gYXJpc2VzIHdoZXJlIGl0IGNvbWVzIGluIGhhbmR5LlxuXG4gICAgICAgICAgICBwaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRpZiAtPSBwLmRpc3RhbmNlIC8gc3QucmF0aW8gLSBwLmRpc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmlnLnNldFBvc2l0aW9ucyhzdGFydCArIGRpZiwgdHJpZy5lbmQgKyBkaWYpO1xuICAgICAgICAgICAgdHJpZy5tYXJrZXJTdGFydCAmJiBtYXJrZXJzLnB1c2goZ3NhcC5xdWlja1NldHRlcihbdHJpZy5tYXJrZXJTdGFydCwgdHJpZy5tYXJrZXJFbmRdLCBcInlcIiwgXCJweFwiKSk7XG5cbiAgICAgICAgICAgIGlmICh0cmlnLnBpbiAmJiB0cmlnLmVuZCAIDApIHtcbiAgICAgICAgICAgICAgZGlmID0gdHJpZy5lbmQgLSB0cmlnLnN0YXJ0O1xuICAgICAgICAgICAgICBwaW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB0cmlnLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogdHJpZy5lbmQsXG4gICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpZixcbiAgICAgICAgICAgICAgICB0cmlnOiB0cmlnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzdC5zZXRQb3NpdGlvbnMoc3Quc3RhcnQsIHN0LmVuZCArIGRpZik7XG4gICAgICAgICAgICAgIHN0LnZhcnMub25SZWZyZXNoKHN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgb25SZWZyZXNoID0gZnVuY3Rpb24gb25SZWZyZXNoKCkge1xuICAgICAgcmVtb3ZlU2Nyb2xsKCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVtb3ZlU2Nyb2xsKTtcblxuICAgICAgaWYgKGVmZmVjdHMpIHtcbiAgICAgICAgLy8gYWRqdXN0IGFsbCB0aGUgZWZmZWN0IHN0YXJ0L2VuZCBwb3NpdGlvbnMgaW5jbHVkaW5nIGFueSBwaW5zIVxuICAgICAgICBlZmZlY3RzLmZvckVhY2goZnVuY3Rpb24gKHN0KSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gc3Quc3RhcnQsXG4gICAgICAgICAgICAgIGVuZCA9IHN0LmF1dG8gPyBNYXRoLm1pbihTY3JvbGxUcmlnZ2VyLm1heFNjcm9sbChzdC5zY3JvbGxlciksIHN0LmVuZCkgOiBzdGFydCArIChzdC5lbmQgLSBzdGFydCkgLyBzdC5yYXRpbyxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gKGVuZCAtIHN0LmVuZCkgLyAyOyAvLyB3ZSBzcGxpdCB0aGUgZGlmZmVyZW5jZSBzbyB0aGF0IGl0IHJlYWNoZXMgaXRzIG5hdHVyYWwgcG9zaXRpb24gaW4gdGhlIE1JRERMRSBvZiB0aGUgdmlld3BvcnRcblxuICAgICAgICAgIHN0YXJ0IC09IG9mZnNldDtcbiAgICAgICAgICBlbmQgLT0gb2Zmc2V0O1xuICAgICAgICAgIHN0Lm9mZnNldCA9IG9mZnNldCB8fCAwLjAwMDE7IC8vIHdlIGFzc2lnbiBhdCBsZWFzdCBhIHRpbnkgdmFsdWUgYmVjYXVzZSB3ZSBjaGVjayBpbiB0aGUgb25VcGRhdGUgZm9yIC5vZmZzZXQgYmVpbmcgc2V0IGluIG9yZGVyIHRvIGFwcGx5IHZhbHVlcy5cblxuICAgICAgICAgIHN0LnBpbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICBzdC5zZXRQb3NpdGlvbnMoTWF0aC5taW4oc3RhcnQsIGVuZCksIE1hdGgubWF4KHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICBzdC52YXJzLm9uUmVmcmVzaChzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGp1c3RQYXJhbGxheFBvc2l0aW9uKFNjcm9sbFRyaWdnZXIuc29ydCgpKTtcbiAgICAgIH1cblxuICAgICAgdHJhY2tlci5yZXNldCgpO1xuICAgIH0sXG4gICAgICAgIHJlc3RvcmVFZmZlY3RzID0gZnVuY3Rpb24gcmVzdG9yZUVmZmVjdHMoKSB7XG4gICAgICByZXR1cm4gZWZmZWN0cyAmJiBlZmZlY3RzLmZvckVhY2goZnVuY3Rpb24gKHN0KSB7XG4gICAgICAgIHJldHVybiBzdC52YXJzLm9uUmVmcmVzaChzdCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgICAgICByZXZlcnRFZmZlY3RzID0gZnVuY3Rpb24gcmV2ZXJ0RWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdHMgJiYgZWZmZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdCkge1xuICAgICAgICByZXR1cm4gc3QudmFycy5vblJlZnJlc2hJbml0KHN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3RvcmVFZmZlY3RzO1xuICAgIH0sXG4gICAgICAgIGVmZmVjdFZhbHVlR2V0dGVyID0gZnVuY3Rpb24gZWZmZWN0VmFsdWVHZXR0ZXIobmFtZSwgdmFsdWUsIGluZGV4LCBlbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHYgPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlKGluZGV4LCBlbCkgOiB2YWx1ZTtcbiAgICAgICAgdiB8fCB2ID09PSAwIHx8ICh2ID0gZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUpIHx8IChuYW1lID09PSBcInNwZWVkXCIgPyAxIDogMCkpO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgbmFtZSwgdik7XG4gICAgICAgIHJldHVybiB2ID09PSBcImF1dG9cIiA/IHYgOiBwYXJzZUZsb2F0KHYpO1xuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBjcmVhdGVFZmZlY3QgPSBmdW5jdGlvbiBjcmVhdGVFZmZlY3QoZWwsIHNwZWVkLCBsYWcsIGluZGV4KSB7XG4gICAgICB2YXIgZ2V0U3BlZWQgPSBlZmZlY3RWYWx1ZUdldHRlcihcInNwZWVkXCIsIHNwZWVkLCBpbmRleCwgZWwpLFxuICAgICAgICAgIGdldExhZyA9IGVmZmVjdFZhbHVlR2V0dGVyKFwibGFnXCIsIGxhZywgaW5kZXgsIGVsKSxcbiAgICAgICAgICBzdGFydFkgPSBnc2FwLmdldFByb3BlcnR5KGVsLCBcInlcIiksXG4gICAgICAgICAgY2FjaGUgPSBlbC5fZ3NhcCxcbiAgICAgICAgICByYXRpbyxcbiAgICAgICAgICBzdCxcbiAgICAgICAgICBhdXRvU3BlZWQsXG4gICAgICAgICAgc2NydWIsXG4gICAgICAgICAgcHJvZ3Jlc3NPZmZzZXQsXG4gICAgICAgICAgeU9mZnNldCxcbiAgICAgICAgICBpbml0RHluYW1pY1ZhbHVlcyA9IGZ1bmN0aW9uIGluaXREeW5hbWljVmFsdWVzKCkge1xuICAgICAgICBzcGVlZCA9IGdldFNwZWVkKCk7XG4gICAgICAgIGxhZyA9IGdldExhZygpO1xuICAgICAgICByYXRpbyA9IHBhcnNlRmxvYXQoc3BlZWQpIHx8IDE7XG4gICAgICAgIGF1dG9TcGVlZCA9IHNwZWVkID09PSBcImF1dG9cIjtcbiAgICAgICAgcHJvZ3Jlc3NPZmZzZXQgPSBhdXRvU3BlZWQgPyAwIDogMC41O1xuICAgICAgICBzY3J1YiAmJiBzY3J1Yi5raWxsKCk7XG4gICAgICAgIHNjcnViID0gbGFnICYmIGdzYXAudG8oZWwsIHtcbiAgICAgICAgICBlYXNlOiBfZXhwbyxcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgIHk6IFwiKz0wXCIsXG4gICAgICAgICAgZHVyYXRpb246IGxhZ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3QpIHtcbiAgICAgICAgICBzdC5yYXRpbyA9IHJhdGlvO1xuICAgICAgICAgIHN0LmF1dG9TcGVlZCA9IGF1dG9TcGVlZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICAgICByZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQoKSB7XG4gICAgICAgIGNhY2hlLnkgPSBzdGFydFkgKyBcInB4XCI7XG4gICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSgxKTtcbiAgICAgICAgaW5pdER5bmFtaWNWYWx1ZXMoKTtcbiAgICAgIH0sXG4gICAgICAgICAgcGlucyA9IFtdLFxuICAgICAgICAgIG1hcmtlcnMgPSBbXSxcbiAgICAgICAgICBjaGFuZ2UgPSAwLFxuICAgICAgICAgIHVwZGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIHVwZGF0ZUNoYW5nZShzZWxmKSB7XG4gICAgICAgIGlmIChhdXRvU3BlZWQpIHtcbiAgICAgICAgICByZXZlcnQoKTtcblxuICAgICAgICAgIHZhciBhdXRvID0gX2F1dG9EaXN0YW5jZShlbCwgX2NsYW1wKDAsIDEsIC1zZWxmLnN0YXJ0IC8gKHNlbGYuZW5kIC0gc2VsZi5zdGFydCkpKTtcblxuICAgICAgICAgIGNoYW5nZSA9IGF1dG8uY2hhbmdlO1xuICAgICAgICAgIHlPZmZzZXQgPSBhdXRvLm9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2UgPSAoc2VsZi5lbmQgLSBzZWxmLnN0YXJ0KSAqICgxIC0gcmF0aW8pO1xuICAgICAgICAgIHlPZmZzZXQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcGlucy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYW5nZSAtPSBwLmRpc3RhbmNlICogKDEgLSByYXRpbyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnZhcnMub25VcGRhdGUoc2VsZik7XG4gICAgICAgIHNjcnViICYmIHNjcnViLnByb2dyZXNzKDEpO1xuICAgICAgfTtcblxuICAgICAgaW5pdER5bmFtaWNWYWx1ZXMoKTtcblxuICAgICAgaWYgKHJhdGlvICE9PSAxIHx8IGF1dG9TcGVlZCB8fCBzY3J1Yikge1xuICAgICAgICBzdCA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgICB0cmlnZ2VyOiBhdXRvU3BlZWQgPyBlbC5wYXJlbnROb2RlIDogZWwsXG4gICAgICAgICAgc2Nyb2xsZXI6IHdyYXBwZXIsXG4gICAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgICAgcmVmcmVzaFByaW9yaXR5OiAtOTk5LFxuICAgICAgICAgIC8vIG11c3QgdXBkYXRlIEFGVEVSIGFueSBvdGhlciBTY3JvbGxUcmlnZ2VyIHBpbnNcbiAgICAgICAgICBvblJlZnJlc2hJbml0OiByZXZlcnQsXG4gICAgICAgICAgb25SZWZyZXNoOiB1cGRhdGVDaGFuZ2UsXG4gICAgICAgICAgb25LaWxsOiBmdW5jdGlvbiBvbktpbGwoc2VsZikge1xuICAgICAgICAgICAgdmFyIGkgPSBlZmZlY3RzLmluZGV4T2Yoc2VsZik7XG4gICAgICAgICAgICBpID49IDAgJiYgZWZmZWN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXZlcnQoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHN0YXJ0WSArIGNoYW5nZSAqIChzZWxmLnByb2dyZXNzIC0gcHJvZ3Jlc3NPZmZzZXQpLFxuICAgICAgICAgICAgICAgIGkgPSBwaW5zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBleHRyYVkgPSAwLFxuICAgICAgICAgICAgICAgIHBpbixcbiAgICAgICAgICAgICAgICBzY3JvbGxZLFxuICAgICAgICAgICAgICAgIGVuZDtcblxuICAgICAgICAgICAgaWYgKHNlbGYub2Zmc2V0KSB7XG4gICAgICAgICAgICAgIC8vIHdhaXQgdW50aWwgdGhlIGVmZmVjdHMgYXJlIGFkanVzdGVkLlxuICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIC8vIHBpbm5pbmcgbXVzdCBiZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgYmVjYXVzZSB3aGVuIHBpbm5lZCwgc2xvcGUgY2hhbmdlcyB0byAxLlxuICAgICAgICAgICAgICAgIHNjcm9sbFkgPSAtY3VycmVudFk7IC8vIC1zY3JvbGwueTtcblxuICAgICAgICAgICAgICAgIGVuZCA9IHNlbGYuZW5kO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgcGluID0gcGluc1tpXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHBpbi50cmlnLmlzQWN0aXZlIHx8IHNjcm9sbFkgPj0gcGluLnN0YXJ0ICYmIHNjcm9sbFkgPD0gcGluLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50bHkgcGlubmVkIHNvIG5vIG5lZWQgdG8gc2V0IGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3J1Yikge1xuICAgICAgICAgICAgICAgICAgICAgIHBpbi50cmlnLnByb2dyZXNzICs9IHBpbi50cmlnLmRpcmVjdGlvbiA8IDAgPyAwLjAwMSA6IC0wLjAwMTsgLy8ganVzdCB0byBtYWtlIGFic29sdXRlbHkgc3VyZSB0aGF0IGl0IHJlbmRlcnMgKGlmIHRoZSBwcm9ncmVzcyBkaWRuJ3QgY2hhbmdlLCBpdCdsbCBza2lwKVxuXG4gICAgICAgICAgICAgICAgICAgICAgcGluLnRyaWcudXBkYXRlKDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIHNjcnViLnJlc2V0VG8oXCJ5XCIsIHBhcnNlRmxvYXQoY2FjaGUueSksIC1kZWx0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnR1cFBoYXNlICYmIHNjcnViLnByb2dyZXNzKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBzY3JvbGxZID4gcGluLmVuZCAmJiAoZXh0cmFZICs9IHBpbi5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICBlbmQgLT0gcGluLmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHkgPSBzdGFydFkgKyBleHRyYVkgKyBjaGFuZ2UgKiAoKGdzYXAudXRpbHMuY2xhbXAoc2VsZi5zdGFydCwgc2VsZi5lbmQsIHNjcm9sbFkpIC0gc2VsZi5zdGFydCAtIGV4dHJhWSkgLyAoZW5kIC0gc2VsZi5zdGFydCkgLSBwcm9ncmVzc09mZnNldCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB5ID0gX3JvdW5kKHkgKyB5T2Zmc2V0KTtcbiAgICAgICAgICAgICAgbWFya2Vycy5sZW5ndGggJiYgIWF1dG9TcGVlZCAmJiBtYXJrZXJzLmZvckVhY2goZnVuY3Rpb24gKHNldHRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0ZXIoeSAtIGV4dHJhWSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChzY3J1Yikge1xuICAgICAgICAgICAgICAgIHNjcnViLnJlc2V0VG8oXCJ5XCIsIHksIC1kZWx0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3RhcnR1cFBoYXNlICYmIHNjcnViLnByb2dyZXNzKDEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhY2hlLnkgPSB5ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSgxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZUNoYW5nZShzdCk7XG4gICAgICAgIGdzYXAuY29yZS5nZXRDYWNoZShzdC50cmlnZ2VyKS5zdFJldmVydCA9IHJldmVydEVmZmVjdHM7IC8vIGlmIHVzZXIgY2FsbHMgU2Nyb2xsU21vb3RoZXIuY3JlYXRlKCkgd2l0aCBlZmZlY3RzIGFuZCBUSEVOIGNyZWF0ZXMgYSBTY3JvbGxUcmlnZ2VyIG9uIHRoZSBzYW1lIHRyaWdnZXIgZWxlbWVudCwgdGhlIGVmZmVjdCB3b3VsZCB0aHJvdyBvZmYgdGhlIHN0YXJ0L2VuZCBwb3NpdGlvbnMgdGh1cyB3ZSBuZWVkZWQgYSB3YXkgdG8gcmV2ZXJ0IHRoaW5ncyB3aGVuIGNyZWF0aW5nIGEgbmV3IFNjcm9sbFRyaWdnZXIgaW4gdGhhdCBzY2VuYXJpbywgc28gd2UgdXNlIHRoaXMgc3RSZXZlcnQgcHJvcGVydHkgb2YgdGhlIEdTQ2FjaGUgaW5zaWRlIFNjcm9sbFRyaWdnZXIuXG5cbiAgICAgICAgc3Quc3RhcnRZID0gc3RhcnRZO1xuICAgICAgICBzdC5waW5zID0gcGlucztcbiAgICAgICAgc3QubWFya2VycyA9IG1hcmtlcnM7XG4gICAgICAgIHN0LnJhdGlvID0gcmF0aW87XG4gICAgICAgIHN0LmF1dG9TcGVlZCA9IGF1dG9TcGVlZDtcbiAgICAgICAgZWwuc3R5bGUud2lsbENoYW5nZSA9IFwidHJhbnNmb3JtXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdDtcbiAgICB9O1xuXG4gICAgU2Nyb2xsVHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwicmVmcmVzaFwiLCBvblJlZnJlc2gpO1xuICAgIGdzYXAuZGVsYXllZENhbGwoMC41LCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3RhcnR1cFBoYXNlID0gMDtcbiAgICB9KTtcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcblxuICAgIHRoaXMuc2Nyb2xsVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBzbW9vdGgsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgcCA9IGdzYXAudXRpbHMuY2xhbXAoMCwgU2Nyb2xsVHJpZ2dlci5tYXhTY3JvbGwoX3dpbiksIGlzTmFOKHRhcmdldCkgPyBfdGhpcy5vZmZzZXQodGFyZ2V0LCBwb3NpdGlvbikgOiArdGFyZ2V0KTtcbiAgICAgICFzbW9vdGggPyBzY3JvbGxUb3AocCkgOiBwYXVzZWQgPyBnc2FwLnRvKF90aGlzLCB7XG4gICAgICAgIGR1cmF0aW9uOiBzbW9vdGhEdXJhdGlvbixcbiAgICAgICAgc2Nyb2xsVG9wOiBwLFxuICAgICAgICBvdmVyd3JpdGU6IFwiYXV0b1wiLFxuICAgICAgICBlYXNlOiBfZXhwb1xuICAgICAgfSkgOiBzY3JvbGxGdW5jKHApO1xuICAgIH07XG5cbiAgICB0aGlzLm9mZnNldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICB0YXJnZXQgPSBfdG9BcnJheSh0YXJnZXQpWzBdO1xuICAgICAgdmFyIGNzc1RleHQgPSB0YXJnZXQuc3R5bGUuY3NzVGV4dCxcbiAgICAgICAgICAvLyBiZWNhdXNlIGlmIHRoZXJlJ3MgYW4gZWZmZWN0IGFwcGxpZWQsIHdlIHJldmVydCgpLiBXZSBuZWVkIHRvIHJlc3RvcmUuXG4gICAgICBzdCA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGFyZ2V0LFxuICAgICAgICBzdGFydDogcG9zaXRpb24gfHwgXCJ0b3AgdG9wXCJcbiAgICAgIH0pLFxuICAgICAgICAgIHk7XG4gICAgICBlZmZlY3RzICYmIGFkanVzdFBhcmFsbGF4UG9zaXRpb24oW3N0XSwgdHJ1ZSk7XG4gICAgICB5ID0gc3Quc3RhcnQ7XG4gICAgICBzdC5raWxsKGZhbHNlKTtcbiAgICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgIGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpLnVuY2FjaGUgPSAxO1xuICAgICAgcmV0dXJuIHk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlZnJlc2hIZWlnaHQoKSB7XG4gICAgICBoZWlnaHQgPSBjb250ZW50LmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnRlbnQuc3R5bGUub3ZlcmZsb3cgPSBcInZpc2libGVcIjtcbiAgICAgIF9ib2R5LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgIHJldHVybiBoZWlnaHQgLSBfd2luLmlubmVySGVpZ2h0O1xuICAgIH1cblxuICAgIHRoaXMuY29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3Q29udGVudCA9IF90b0FycmF5KGVsZW1lbnQgfHwgXCIjc21vb3RoLWNvbnRlbnRcIilbMF0gfHwgX2JvZHkuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgaWYgKG5ld0NvbnRlbnQgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgICBjb250ZW50ID0gbmV3Q29udGVudDtcbiAgICAgICAgICBjb250ZW50Q1NTID0gY29udGVudC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiO1xuICAgICAgICAgIGdzYXAuc2V0KGNvbnRlbnQsIHtcbiAgICAgICAgICAgIG92ZXJmbG93OiBcInZpc2libGVcIixcbiAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9O1xuXG4gICAgdGhpcy53cmFwcGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHdyYXBwZXIgPSBfdG9BcnJheShlbGVtZW50IHx8IFwiI3Ntb290aC13cmFwcGVyXCIpWzBdIHx8IF93cmFwKGNvbnRlbnQpO1xuICAgICAgICB3cmFwcGVyQ1NTID0gd3JhcHBlci5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiO1xuICAgICAgICByZWZyZXNoSGVpZ2h0KCk7XG4gICAgICAgIGdzYXAuc2V0KHdyYXBwZXIsIHNtb290aER1cmF0aW9uID8ge1xuICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgb3ZlcmZsb3c6IFwidmlzaWJsZVwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgdG9wOiBcImF1dG9cIixcbiAgICAgICAgICBib3R0b206IFwiYXV0b1wiLFxuICAgICAgICAgIGxlZnQ6IFwiYXV0b1wiLFxuICAgICAgICAgIHJpZ2h0OiBcImF1dG9cIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH07XG5cbiAgICB0aGlzLmVmZmVjdHMgPSBmdW5jdGlvbiAodGFyZ2V0cywgY29uZmlnKSB7XG4gICAgICB2YXIgX2VmZmVjdHM7XG5cbiAgICAgIGVmZmVjdHMgfHwgKGVmZmVjdHMgPSBbXSk7XG5cbiAgICAgIGlmICghdGFyZ2V0cykge1xuICAgICAgICByZXR1cm4gZWZmZWN0cy5zbGljZSgwKTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0cyA9IF90b0FycmF5KHRhcmdldHMpO1xuICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGkgPSBlZmZlY3RzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgaWYgKGVmZmVjdHNbaV0udHJpZ2dlciA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBlZmZlY3RzW2ldLmtpbGwoKTtcbiAgICAgICAgICAgIGVmZmVjdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICB2YXIgX2NvbmZpZyA9IGNvbmZpZyxcbiAgICAgICAgICBzcGVlZCA9IF9jb25maWcuc3BlZWQsXG4gICAgICAgICAgbGFnID0gX2NvbmZpZy5sYWcsXG4gICAgICAgICAgZWZmZWN0c1RvQWRkID0gW10sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBzdDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3QgPSBjcmVhdGVFZmZlY3QodGFyZ2V0c1tpXSwgc3BlZWQsIGxhZywgaSk7XG4gICAgICAgIHN0ICYmIGVmZmVjdHNUb0FkZC5wdXNoKHN0KTtcbiAgICAgIH1cblxuICAgICAgKF9lZmZlY3RzID0gZWZmZWN0cykucHVzaC5hcHBseShfZWZmZWN0cywgZWZmZWN0c1RvQWRkKTtcblxuICAgICAgcmV0dXJuIGVmZmVjdHNUb0FkZDtcbiAgICB9O1xuXG4gICAgdGhpcy5zZWN0aW9ucyA9IGZ1bmN0aW9uICh0YXJnZXRzLCBjb25maWcpIHtcbiAgICAgIHZhciBfc2VjdGlvbnM7XG5cbiAgICAgIHNlY3Rpb25zIHx8IChzZWN0aW9ucyA9IFtdKTtcblxuICAgICAgaWYgKCF0YXJnZXRzKSB7XG4gICAgICAgIHJldHVybiBzZWN0aW9ucy5zbGljZSgwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1NlY3Rpb25zID0gX3RvQXJyYXkodGFyZ2V0cykubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICAgIHRyaWdnZXI6IGVsLFxuICAgICAgICAgIHN0YXJ0OiBcInRvcCAxMjAlXCIsXG4gICAgICAgICAgZW5kOiBcImJvdHRvbSAtMjAlXCIsXG4gICAgICAgICAgb25Ub2dnbGU6IGZ1bmN0aW9uIG9uVG9nZ2xlKHNlbGYpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSBzZWxmLmlzQWN0aXZlID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgICAgIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBzZWxmLmlzQWN0aXZlID8gXCJhbGxcIiA6IFwibm9uZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgY29uZmlnICYmIGNvbmZpZy5hZGQgPyAoX3NlY3Rpb25zID0gc2VjdGlvbnMpLnB1c2guYXBwbHkoX3NlY3Rpb25zLCBuZXdTZWN0aW9ucykgOiBzZWN0aW9ucyA9IG5ld1NlY3Rpb25zLnNsaWNlKDApO1xuICAgICAgcmV0dXJuIG5ld1NlY3Rpb25zO1xuICAgIH07XG5cbiAgICB0aGlzLmNvbnRlbnQodmFycy5jb250ZW50KTtcbiAgICB0aGlzLndyYXBwZXIodmFycy53cmFwcGVyKTtcblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgIHJldHVybiByZW5kZXIoeSB8fCB5ID09PSAwID8geSA6IGN1cnJlbnRZKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cmFja2VyLmdldFZlbG9jaXR5KC1jdXJyZW50WSk7XG4gICAgfTtcblxuICAgIFNjcm9sbFRyaWdnZXIuc2Nyb2xsZXJQcm94eSh3cmFwcGVyLCB7XG4gICAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcCxcbiAgICAgIHNjcm9sbEhlaWdodDogZnVuY3Rpb24gc2Nyb2xsSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gcmVmcmVzaEhlaWdodCgpICYmIF9ib2R5LnNjcm9sbEhlaWdodDtcbiAgICAgIH0sXG4gICAgICBmaXhlZE1hcmtlcnM6IHZhcnMuZml4ZWRNYXJrZXJzICE9PSBmYWxzZSAmJiAhIXNtb290aER1cmF0aW9uLFxuICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHdpZHRoOiBfd2luLmlubmVyV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBfd2luLmlubmVySGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgU2Nyb2xsVHJpZ2dlci5kZWZhdWx0cyh7XG4gICAgICBzY3JvbGxlcjogd3JhcHBlclxuICAgIH0pO1xuICAgIHZhciBleGlzdGluZ1Njcm9sbFRyaWdnZXJzID0gU2Nyb2xsVHJpZ2dlci5nZXRBbGwoKS5maWx0ZXIoZnVuY3Rpb24gKHN0KSB7XG4gICAgICByZXR1cm4gc3Quc2Nyb2xsZXIgPT09IF93aW4gfHwgc3Quc2Nyb2xsZXIgPT09IHdyYXBwZXI7XG4gICAgfSk7XG4gICAgZXhpc3RpbmdTY3JvbGxUcmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChzdCkge1xuICAgICAgcmV0dXJuIHN0LnJldmVydCh0cnVlKTtcbiAgICB9KTsgLy8gaW4gY2FzZSBpdCdzIGluIGFuIGVudmlyb25tZW50IGxpa2UgUmVhY3Qgd2hlcmUgY2hpbGQgY29tcG9uZW50cyB0aGF0IGhhdmUgU2Nyb2xsVHJpZ2dlcnMgaW5zdGFudGlhdGUgQkVGT1JFIHRoZSBwYXJlbnQgdGhhdCBkb2VzIFNjcm9sbFNtb290aGVyLmNyZWF0ZSguLi4pO1xuXG4gICAgbWFpblNUID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgYW5pbWF0aW9uOiBnc2FwLnRvKHNjcm9sbCwge1xuICAgICAgICB5OiBmdW5jdGlvbiB5KCkge1xuICAgICAgICAgIHJldHVybiAtcmVmcmVzaEhlaWdodCgpO1xuICAgICAgICB9LFxuICAgICAgICBlYXNlOiBcIm5vbmVcIixcbiAgICAgICAgZGF0YTogXCJTY3JvbGxTbW9vdGhlclwiLFxuICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICAvLyBmb3IgYWRkZWQgcHJlY2lzaW9uXG4gICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHtcbiAgICAgICAgICB2YXIgZm9yY2UgPSBpc1Byb3h5U2Nyb2xsaW5nO1xuXG4gICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICBzY3JvbGwueSA9IGN1cnJlbnRZO1xuICAgICAgICAgICAga2lsbFNjcnViKG1haW5TVCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVuZGVyKHNjcm9sbC55LCBmb3JjZSk7XG4gICAgICAgICAgdXBkYXRlVmVsb2NpdHkoKTtcbiAgICAgICAgICBfb25VcGRhdGUgJiYgIXBhdXNlZCAmJiBfb25VcGRhdGUoX3RoaXMpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIG9uUmVmcmVzaEluaXQ6IGZ1bmN0aW9uIG9uUmVmcmVzaEluaXQoKSB7XG4gICAgICAgIHJlY29yZGVkUmVmcmVzaFNjcm9sbCA9IGN1cnJlbnRZO1xuICAgICAgICBzY3JvbGwueSA9IHdyYXBwZXIuc2Nyb2xsVG9wID0gMDsgLy8gc2V0IHdyYXBwZXIuc2Nyb2xsVG9wIHRvIDAgYmVjYXVzZSBpbiBzb21lIHZlcnkgcmFyZSBzaXR1YXRpb25zLCB0aGUgYnJvd3NlciB3aWxsIGF1dG8tc2V0IHRoYXQsIGxpa2UgaWYgdGhlcmUncyBhIGhhc2ggaW4gdGhlIGxpbmsgb3IgY2hhbmdpbmcgZm9jdXMgdG8gYW4gb2ZmLXNjcmVlbiBpbnB1dFxuICAgICAgfSxcbiAgICAgIGlkOiBcIlNjcm9sbFNtb290aGVyXCIsXG4gICAgICBzY3JvbGxlcjogX3dpbixcbiAgICAgIGludmFsaWRhdGVPblJlZnJlc2g6IHRydWUsXG4gICAgICBzdGFydDogMCxcbiAgICAgIHJlZnJlc2hQcmlvcml0eTogLTk5OTksXG4gICAgICAvLyBiZWNhdXNlIGFsbCBvdGhlciBwaW5zLCBldGMuIHNob3VsZCBiZSBjYWxjdWxhdGVkIGZpcnN0IGJlZm9yZSB0aGlzIGZpZ3VyZXMgb3V0IHRoZSBoZWlnaHQgb2YgdGhlIGJvZHkuIEJVVCB0aGlzIHNob3VsZCBhbHNvIHVwZGF0ZSBGSVJTVCBzbyB0aGF0IHRoZSBzY3JvbGwgcG9zaXRpb24gb24gdGhlIHByb3h5IGlzIHVwLXRvLWRhdGUgd2hlbiBhbGwgdGhlIFNjcm9sbFRyaWdnZXJzIGNhbGN1bGF0ZSB0aGVpciBwcm9ncmVzcyEgLTk5OTkgaXMgYSBzcGVjaWFsIG51bWJlciB0aGF0IFNjcm9sbFRyaWdnZXIgbG9va3MgZm9yIHRvIGhhbmRsZSBpbiB0aGlzIHdheS5cbiAgICAgIGVuZDogcmVmcmVzaEhlaWdodCxcbiAgICAgIG9uU2NydWJDb21wbGV0ZTogZnVuY3Rpb24gb25TY3J1YkNvbXBsZXRlKCkge1xuICAgICAgICB0cmFja2VyLnJlc2V0KCk7XG4gICAgICAgIG9uU3RvcCAmJiBvblN0b3AoX3RoaXMpO1xuICAgICAgfSxcbiAgICAgIHNjcnViOiBzbW9vdGhEdXJhdGlvbiB8fCB0cnVlLFxuICAgICAgb25SZWZyZXNoOiBmdW5jdGlvbiBvblJlZnJlc2goc2VsZikge1xuICAgICAgICBraWxsU2NydWIoc2VsZik7XG4gICAgICAgIHNjcm9sbC55ID0gLXNjcm9sbEZ1bmMoKTtcbiAgICAgICAgcmVuZGVyKHNjcm9sbC55KTtcbiAgICAgICAgc3RhcnR1cFBoYXNlIHx8IHNlbGYuYW5pbWF0aW9uLnByb2dyZXNzKGdzYXAudXRpbHMuY2xhbXAoMCwgMSwgcmVjb3JkZWRSZWZyZXNoU2Nyb2xsIC8gLXNlbGYuZW5kKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnNtb290aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgc21vb3RoRHVyYXRpb24gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gbWFpblNULnNjcnViRHVyYXRpb24odmFsdWUpIDogbWFpblNULmdldFR3ZWVuKCkgPyBtYWluU1QuZ2V0VHdlZW4oKS5kdXJhdGlvbigpIDogMDtcbiAgICB9O1xuXG4gICAgbWFpblNULmdldFR3ZWVuKCkgJiYgKG1haW5TVC5nZXRUd2VlbigpLnZhcnMuZWFzZSA9IHZhcnMuZWFzZSB8fCBfZXhwbyk7XG4gICAgdGhpcy5zY3JvbGxUcmlnZ2VyID0gbWFpblNUO1xuICAgIHZhcnMuZWZmZWN0cyAmJiB0aGlzLmVmZmVjdHModmFycy5lZmZlY3RzID09PSB0cnVlID8gXCJbZGF0YS1zcGVlZF0sIFtkYXRhLWxhZ11cIiA6IHZhcnMuZWZmZWN0cywge30pO1xuICAgIHZhcnMuc2VjdGlvbnMgJiYgdGhpcy5zZWN0aW9ucyh2YXJzLnNlY3Rpb25zID09PSB0cnVlID8gXCJbZGF0YS1zZWN0aW9uXVwiIDogdmFycy5zZWN0aW9ucyk7XG4gICAgZXhpc3RpbmdTY3JvbGxUcmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChzdCkge1xuICAgICAgc3QudmFycy5zY3JvbGxlciA9IHdyYXBwZXI7XG4gICAgICBzdC5pbml0KHN0LnZhcnMsIHN0LmFuaW1hdGlvbik7XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhdXNlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgYWxsb3dOZXN0ZWRTY3JvbGwpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghIXBhdXNlZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHBhdXNlXG4gICAgICAgICAgICBtYWluU1QuZ2V0VHdlZW4oKSAmJiBtYWluU1QuZ2V0VHdlZW4oKS5wYXVzZSgpO1xuICAgICAgICAgICAgc2Nyb2xsRnVuYygtY3VycmVudFkpO1xuICAgICAgICAgICAgdHJhY2tlci5yZXNldCgpO1xuICAgICAgICAgICAgcGF1c2VkTm9ybWFsaXplciA9IFNjcm9sbFRyaWdnZXIubm9ybWFsaXplU2Nyb2xsKCk7XG4gICAgICAgICAgICBwYXVzZWROb3JtYWxpemVyICYmIHBhdXNlZE5vcm1hbGl6ZXIuZGlzYWJsZSgpOyAvLyBvdGhlcndpc2UgdGhlIG5vcm1hbGl6ZXIgd291bGQgdHJ5IHRvIHNjcm9sbCB0aGUgcGFnZSBvbiB0aGluZ3MgbGlrZSB3aGVlbCBldmVudHMuXG5cbiAgICAgICAgICAgIHBhdXNlZCA9IFNjcm9sbFRyaWdnZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBcIndoZWVsLHRvdWNoLHNjcm9sbFwiLFxuICAgICAgICAgICAgICBkZWJvdW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgIGFsbG93Q2xpY2tzOiB0cnVlLFxuICAgICAgICAgICAgICBvbkNoYW5nZVk6IGZ1bmN0aW9uIG9uQ2hhbmdlWSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsVG9wKC1jdXJyZW50WSk7XG4gICAgICAgICAgICAgIH0gLy8gcmVmdXNlIHRvIHNjcm9sbFxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhdXNlZC5uZXN0ZWQgPSBfaW5wdXRPYnNlcnZlcihfZG9jRWwsIFwid2hlZWwsdG91Y2gsc2Nyb2xsXCIsIHRydWUsIGFsbG93TmVzdGVkU2Nyb2xsICE9PSBmYWxzZSk7IC8vIGFsbG93IG5lc3RlZCBzY3JvbGxpbmcsIGxpa2UgbW9kYWxzXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlc3VtZVxuICAgICAgICAgICAgcGF1c2VkLm5lc3RlZC5raWxsKCk7XG4gICAgICAgICAgICBwYXVzZWQua2lsbCgpO1xuICAgICAgICAgICAgcGF1c2VkID0gMDtcbiAgICAgICAgICAgIHBhdXNlZE5vcm1hbGl6ZXIgJiYgcGF1c2VkTm9ybWFsaXplci5lbmFibGUoKTtcbiAgICAgICAgICAgIG1haW5TVC5wcm9ncmVzcyA9ICgtY3VycmVudFkgLSBtYWluU1Quc3RhcnQpIC8gKG1haW5TVC5lbmQgLSBtYWluU1Quc3RhcnQpO1xuICAgICAgICAgICAga2lsbFNjcnViKG1haW5TVCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIXBhdXNlZDtcbiAgICB9O1xuXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucGF1c2VkKGZhbHNlKTtcblxuICAgICAga2lsbFNjcnViKG1haW5TVCk7XG4gICAgICBtYWluU1Qua2lsbCgpO1xuICAgICAgdmFyIHRyaWdnZXJzID0gKGVmZmVjdHMgfHwgW10pLmNvbmNhdChzZWN0aW9ucyB8fCBbXSksXG4gICAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZ28gYmFja3dhcmRzIGJlY2F1c2UgdGhlIG9uS2lsbCgpIHdpbGwgZWZmZWN0cy5zcGxpY2UoaW5kZXgsIDEpIGFuZCB3ZSBkb24ndCB3YW50IHRvIHNraXBcbiAgICAgICAgdHJpZ2dlcnNbaV0ua2lsbCgpO1xuICAgICAgfVxuXG4gICAgICBTY3JvbGxUcmlnZ2VyLnNjcm9sbGVyUHJveHkod3JhcHBlcik7XG4gICAgICBTY3JvbGxUcmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWZyZXNoXCIsIG9uUmVmcmVzaCk7XG5cbiAgICAgIF9ib2R5LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiaGVpZ2h0XCIpO1xuXG4gICAgICB3cmFwcGVyLnN0eWxlLmNzc1RleHQgPSB3cmFwcGVyQ1NTO1xuICAgICAgY29udGVudC5zdHlsZS5jc3NUZXh0ID0gY29udGVudENTUztcbiAgICAgIHZhciBkZWZhdWx0cyA9IFNjcm9sbFRyaWdnZXIuZGVmYXVsdHMoe30pO1xuICAgICAgZGVmYXVsdHMgJiYgZGVmYXVsdHMuc2Nyb2xsZXIgPT09IHdyYXBwZXIgJiYgU2Nyb2xsVHJpZ2dlci5kZWZhdWx0cyh7XG4gICAgICAgIHNjcm9sbGVyOiBfd2luXG4gICAgICB9KTtcbiAgICAgIF90aGlzLm5vcm1hbGl6ZXIgJiYgU2Nyb2xsVHJpZ2dlci5ub3JtYWxpemVTY3JvbGwoZmFsc2UpO1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElEKTtcbiAgICAgIF9tYWluSW5zdGFuY2UgPSBudWxsO1xuXG4gICAgICBfd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIF9vbkZvY3VzSW4pO1xuICAgIH07XG5cbiAgICB0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiAoc29mdCwgZm9yY2UpIHtcbiAgICAgIHJldHVybiBtYWluU1QucmVmcmVzaChzb2Z0LCBmb3JjZSk7XG4gICAgfTtcblxuICAgIGlmIChub3JtYWxpemVTY3JvbGwpIHtcbiAgICAgIHRoaXMubm9ybWFsaXplciA9IFNjcm9sbFRyaWdnZXIubm9ybWFsaXplU2Nyb2xsKG5vcm1hbGl6ZVNjcm9sbCA9PT0gdHJ1ZSA/IHtcbiAgICAgICAgZGVib3VuY2U6IHRydWUsXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgIH0gOiBub3JtYWxpemVTY3JvbGwpO1xuICAgIH1cblxuICAgIFNjcm9sbFRyaWdnZXIuY29uZmlnKHZhcnMpOyAvLyBpbiBjYXNlIHVzZXIgcGFzc2VzIGluIGlnbm9yZU1vYmlsZVJlc2l6ZSBmb3IgZXhhbXBsZVxuXG4gICAgXCJvdmVyc2Nyb2xsQmVoYXZpb3JcIiBpbiBfd2luLmdldENvbXB1dGVkU3R5bGUoX2JvZHkpICYmIGdzYXAuc2V0KFtfYm9keSwgX2RvY0VsXSwge1xuICAgICAgb3ZlcnNjcm9sbEJlaGF2aW9yOiBcIm5vbmVcIlxuICAgIH0pO1xuICAgIFwic2Nyb2xsQmVoYXZpb3JcIiBpbiBfd2luLmdldENvbXB1dGVkU3R5bGUoX2JvZHkpICYmIGdzYXAuc2V0KFtfYm9keSwgX2RvY0VsXSwge1xuICAgICAgc2Nyb2xsQmVoYXZpb3I6IFwiYXV0b1wiXG4gICAgfSk7IC8vIGlmIHRoZSB1c2VyIGhpdHMgdGhlIHRhYiBrZXkgKG9yIHdoYXRldmVyKSB0byBzaGlmdCBmb2N1cyB0byBhbiBlbGVtZW50IHRoYXQncyBvZmYtc2NyZWVuLCBjZW50ZXIgdGhhdCBlbGVtZW50LlxuXG4gICAgX3dpbi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBfb25Gb2N1c0luKTtcblxuICAgIGludGVydmFsSUQgPSBzZXRJbnRlcnZhbCh1cGRhdGVWZWxvY2l0eSwgMjUwKTtcbiAgICBfZG9jLnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiIHx8IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gU2Nyb2xsVHJpZ2dlci5yZWZyZXNoKCk7XG4gICAgfSk7XG4gIH1cblxuICBTY3JvbGxTbW9vdGhlci5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgICAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICAgICAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgX3dpbiA9IHdpbmRvdztcbiAgICAgICAgX2RvYyA9IGRvY3VtZW50O1xuICAgICAgICBfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgX2JvZHkgPSBfZG9jLmJvZHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnc2FwKSB7XG4gICAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgICBfY2xhbXAgPSBnc2FwLnV0aWxzLmNsYW1wO1xuICAgICAgICBfZXhwbyA9IGdzYXAucGFyc2VFYXNlKFwiZXhwb1wiKTtcbiAgICAgICAgU2Nyb2xsVHJpZ2dlciA9IGdzYXAuY29yZS5nbG9iYWxzKCkuU2Nyb2xsVHJpZ2dlcjtcbiAgICAgICAgZ3NhcC5jb3JlLmdsb2JhbHMoXCJTY3JvbGxTbW9vdGhlclwiLCBTY3JvbGxTbW9vdGhlcik7IC8vIG11c3QgcmVnaXN0ZXIgdGhlIGdsb2JhbCBtYW51YWxseSBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyLCBmdW5jdGlvbnMgKGNsYXNzZXMpIGRvbid0IGhhdmUgYSBcIm5hbWVcIiBwcm9wZXJ0eS5cbiAgICAgICAgLy9cdGdzYXAudGlja2VyLmxhZ1Ntb290aGluZyg1MCwgMTAwKTsgLy8gZ2VuZXJhbGx5IHBlb3BsZSBkb24ndCB3YW50IHRoaW5ncyB0byBqdW1wIChob25vcmluZyBzbW9vdGhuZXNzIG92ZXIgdGltZSBpcyBiZXR0ZXIgd2l0aCBzbW9vdGggc2Nyb2xsaW5nKVxuXG4gICAgICAgIGlmIChfYm9keSAmJiBTY3JvbGxUcmlnZ2VyKSB7XG4gICAgICAgICAgX3Jvb3QgPSBbX3dpbiwgX2RvYywgX2RvY0VsLCBfYm9keV07XG4gICAgICAgICAgX2dldFZlbG9jaXR5UHJvcCA9IFNjcm9sbFRyaWdnZXIuY29yZS5fZ2V0VmVsb2NpdHlQcm9wO1xuICAgICAgICAgIF9pbnB1dE9ic2VydmVyID0gU2Nyb2xsVHJpZ2dlci5jb3JlLl9pbnB1dE9ic2VydmVyO1xuICAgICAgICAgIFNjcm9sbFNtb290aGVyLnJlZnJlc2ggPSBTY3JvbGxUcmlnZ2VyLnJlZnJlc2g7XG4gICAgICAgICAgX2NvcmVJbml0dGVkID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfY29yZUluaXR0ZWQ7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNjcm9sbFNtb290aGVyLCBbe1xuICAgIGtleTogXCJwcm9ncmVzc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVHJpZ2dlci5hbmltYXRpb24uX3RpbWUgLyAxMDA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjcm9sbFNtb290aGVyO1xufSgpO1xuU2Nyb2xsU21vb3RoZXIudmVyc2lvbiA9IFwiMy4xMC40XCI7XG5cblNjcm9sbFNtb290aGVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gIHJldHVybiBfbWFpbkluc3RhbmNlICYmIHZhcnMgJiYgX21haW5JbnN0YW5jZS5jb250ZW50KCkgPT09IF90b0FycmF5KHZhcnMuY29udGVudClbMF0gPyBfbWFpbkluc3RhbmNlIDogbmV3IFNjcm9sbFNtb290aGVyKHZhcnMpO1xufTtcblxuU2Nyb2xsU21vb3RoZXIuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX21haW5JbnN0YW5jZTtcbn07XG5cbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxTbW9vdGhlcik7XG5leHBvcnQgeyBTY3JvbGxTbW9vdGhlciBhcyBkZWZhdWx0IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/ScrollSmoother.js\n");

/***/ }),

/***/ "./node_modules/gsap/ScrollToPlugin.js":
/*!*********************************************!*\
  !*** ./node_modules/gsap/ScrollToPlugin.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollToPlugin: () => (/* binding */ ScrollToPlugin),\n/* harmony export */   \"default\": () => (/* binding */ ScrollToPlugin)\n/* harmony export */ });\n/*!\n * ScrollToPlugin 3.10.4\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _window,\n    _docEl,\n    _body,\n    _toArray,\n    _config,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _max = function _max(element, axis) {\n  var dim = axis === \"x\" ? \"Width\" : \"Height\",\n      scroll = \"scroll\"  dim,\n      client = \"client\"  dim;\n  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\"  dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\"  dim];\n},\n    _buildGetter = function _buildGetter(e, axis) {\n  //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n  var p = \"scroll\"  (axis === \"x\" ? \"Left\" : \"Top\");\n\n  if (e === _window) {\n    if (e.pageXOffset != null) {\n      p = \"page\"  axis.toUpperCase()  \"Offset\";\n    } else {\n      e = _docEl[p] != null ? _docEl : _body;\n    }\n  }\n\n  return function () {\n    return e[p];\n  };\n},\n    _clean = function _clean(value, index, target, targets) {\n  _isFunction(value) && (value = value(index, target, targets));\n\n  if (typeof value !== \"object\") {\n    return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\n      x: value,\n      y: value\n    } : {\n      y: value\n    }; //if we don't receive an object as the parameter, assume the user intends \"y\".\n  } else if (value.nodeType) {\n    return {\n      y: value,\n      x: value\n    };\n  } else {\n    var result = {},\n        p;\n\n    for (p in value) {\n      result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n    }\n\n    return result;\n  }\n},\n    _getOffset = function _getOffset(element, container) {\n  element = _toArray(element)[0];\n\n  if (!element || !element.getBoundingClientRect) {\n    return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var rect = element.getBoundingClientRect(),\n      isRoot = !container || container === _window || container === _body,\n      cRect = isRoot ? {\n    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n  } : container.getBoundingClientRect(),\n      offsets = {\n    x: rect.left - cRect.left,\n    y: rect.top - cRect.top\n  };\n\n  if (!isRoot && container) {\n    //only add the current scroll position if it's not the window/body.\n    offsets.x = _buildGetter(container, \"x\")();\n    offsets.y = _buildGetter(container, \"y\")();\n  }\n\n  return offsets;\n},\n    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {\n  return !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1)  currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);\n},\n    _initCore = function _initCore() {\n  gsap = _getGSAP();\n\n  if (_windowExists() && gsap && document.body) {\n    _window = window;\n    _body = document.body;\n    _docEl = document.documentElement;\n    _toArray = gsap.utils.toArray;\n    gsap.config({\n      autoKillThreshold: 7\n    });\n    _config = gsap.config();\n    _coreInitted = 1;\n  }\n};\n\nvar ScrollToPlugin = {\n  version: \"3.10.4\",\n  name: \"scrollTo\",\n  rawVars: 1,\n  register: function register(core) {\n    gsap = core;\n\n    _initCore();\n  },\n  init: function init(target, value, tween, index, targets) {\n    _coreInitted || _initCore();\n    var data = this,\n        snapType = gsap.getProperty(target, \"scrollSnapType\");\n    data.isWin = target === _window;\n    data.target = target;\n    data.tween = tween;\n    value = _clean(value, index, target, targets);\n    data.vars = value;\n    data.autoKill = !!value.autoKill;\n    data.getX = _buildGetter(target, \"x\");\n    data.getY = _buildGetter(target, \"y\");\n    data.x = data.xPrev = data.getX();\n    data.y = data.yPrev = data.getY();\n\n    if (snapType && snapType !== \"none\") {\n      // disable scroll snapping to avoid strange behavior\n      data.snap = 1;\n      data.snapInline = target.style.scrollSnapType;\n      target.style.scrollSnapType = \"none\";\n    }\n\n    if (value.x != null) {\n      data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n\n      data._props.push(\"scrollTo_x\");\n    } else {\n      data.skipX = 1;\n    }\n\n    if (value.y != null) {\n      data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n\n      data._props.push(\"scrollTo_y\");\n    } else {\n      data.skipY = 1;\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt,\n        target = data.target,\n        tween = data.tween,\n        autoKill = data.autoKill,\n        xPrev = data.xPrev,\n        yPrev = data.yPrev,\n        isWin = data.isWin,\n        snap = data.snap,\n        snapInline = data.snapInline,\n        x,\n        y,\n        yDif,\n        xDif,\n        threshold;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    x = isWin || !data.skipX ? data.getX() : xPrev;\n    y = isWin || !data.skipY ? data.getY() : yPrev;\n    yDif = y - yPrev;\n    xDif = x - xPrev;\n    threshold = _config.autoKillThreshold;\n\n    if (data.x < 0) {\n      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n      data.x = 0;\n    }\n\n    if (data.y < 0) {\n      data.y = 0;\n    }\n\n    if (autoKill) {\n      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n        data.skipX = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n        data.skipY = 1; //if the user scrolls separately, we should stop tweening!\n      }\n\n      if (data.skipX && data.skipY) {\n        tween.kill();\n        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n      }\n    }\n\n    if (isWin) {\n      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n    } else {\n      data.skipY || (target.scrollTop = data.y);\n      data.skipX || (target.scrollLeft = data.x);\n    }\n\n    if (snap && (ratio === 1 || ratio === 0)) {\n      y = target.scrollTop;\n      x = target.scrollLeft;\n      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\n      target.scrollTop = y  1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.\n\n      target.scrollLeft = x  1;\n      target.scrollTop = y;\n      target.scrollLeft = x;\n    }\n\n    data.xPrev = data.x;\n    data.yPrev = data.y;\n  },\n  kill: function kill(property) {\n    var both = property === \"scrollTo\";\n\n    if (both || property === \"scrollTo_x\") {\n      this.skipX = 1;\n    }\n\n    if (both || property === \"scrollTo_y\") {\n      this.skipY = 1;\n    }\n  }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUb1BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsT0FBTztBQUNQLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2dzYXAvU2Nyb2xsVG9QbHVnaW4uanM/OTQyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFNjcm9sbFRvUGx1Z2luIDMuMTAuNFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfd2luZG93LFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfdG9BcnJheSxcbiAgICBfY29uZmlnLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfbWF4ID0gZnVuY3Rpb24gX21heChlbGVtZW50LCBheGlzKSB7XG4gIHZhciBkaW0gPSBheGlzID09PSBcInhcIiA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIsXG4gICAgICBzY3JvbGwgPSBcInNjcm9sbFwiICsgZGltLFxuICAgICAgY2xpZW50ID0gXCJjbGllbnRcIiArIGRpbTtcbiAgcmV0dXJuIGVsZW1lbnQgPT09IF93aW5kb3cgfHwgZWxlbWVudCA9PT0gX2RvY0VsIHx8IGVsZW1lbnQgPT09IF9ib2R5ID8gTWF0aC5tYXgoX2RvY0VsW3Njcm9sbF0sIF9ib2R5W3Njcm9sbF0pIC0gKF93aW5kb3dbXCJpbm5lclwiICsgZGltXSB8fCBfZG9jRWxbY2xpZW50XSB8fCBfYm9keVtjbGllbnRdKSA6IGVsZW1lbnRbc2Nyb2xsXSAtIGVsZW1lbnRbXCJvZmZzZXRcIiArIGRpbV07XG59LFxuICAgIF9idWlsZEdldHRlciA9IGZ1bmN0aW9uIF9idWlsZEdldHRlcihlLCBheGlzKSB7XG4gIC8vcGFzcyBpbiBhbiBlbGVtZW50IGFuZCBhbiBheGlzIChcInhcIiBvciBcInlcIikgYW5kIGl0J2xsIHJldHVybiBhIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGF0IGVsZW1lbnQgKGxpa2Ugc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQsIGFsdGhvdWdoIGlmIHRoZSBlbGVtZW50IGlzIHRoZSB3aW5kb3csIGl0J2xsIHVzZSB0aGUgcGFnZVhPZmZzZXQvcGFnZVlPZmZzZXQgb3IgdGhlIGRvY3VtZW50RWxlbWVudCdzIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IG9yIGRvY3VtZW50LmJvZHkncy4gQmFzaWNhbGx5IHRoaXMgc3RyZWFtbGluZXMgdGhpbmdzIGFuZCBtYWtlcyBhIHZlcnkgZmFzdCBnZXR0ZXIgYWNyb3NzIGJyb3dzZXJzLlxuICB2YXIgcCA9IFwic2Nyb2xsXCIgKyAoYXhpcyA9PT0gXCJ4XCIgPyBcIkxlZnRcIiA6IFwiVG9wXCIpO1xuXG4gIGlmIChlID09PSBfd2luZG93KSB7XG4gICAgaWYgKGUucGFnZVhPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgcCA9IFwicGFnZVwiICsgYXhpcy50b1VwcGVyQ2FzZSgpICsgXCJPZmZzZXRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IF9kb2NFbFtwXSAhPSBudWxsID8gX2RvY0VsIDogX2JvZHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZVtwXTtcbiAgfTtcbn0sXG4gICAgX2NsZWFuID0gZnVuY3Rpb24gX2NsZWFuKHZhbHVlLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSB7XG4gIF9pc0Z1bmN0aW9uKHZhbHVlKSAmJiAodmFsdWUgPSB2YWx1ZShpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlICE9PSBcIm1heFwiICYmIHZhbHVlLmNoYXJBdCgxKSAhPT0gXCI9XCIgPyB7XG4gICAgICB4OiB2YWx1ZSxcbiAgICAgIHk6IHZhbHVlXG4gICAgfSA6IHtcbiAgICAgIHk6IHZhbHVlXG4gICAgfTsgLy9pZiB3ZSBkb24ndCByZWNlaXZlIGFuIG9iamVjdCBhcyB0aGUgcGFyYW1ldGVyLCBhc3N1bWUgdGhlIHVzZXIgaW50ZW5kcyBcInlcIi5cbiAgfSBlbHNlIGlmICh2YWx1ZS5ub2RlVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICB5OiB2YWx1ZSxcbiAgICAgIHg6IHZhbHVlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgIHA7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWUpIHtcbiAgICAgIHJlc3VsdFtwXSA9IHAgIT09IFwib25BdXRvS2lsbFwiICYmIF9pc0Z1bmN0aW9uKHZhbHVlW3BdKSA/IHZhbHVlW3BdKGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFsdWVbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSxcbiAgICBfZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gX2dldE9mZnNldChlbGVtZW50LCBjb250YWluZXIpIHtcbiAgZWxlbWVudCA9IF90b0FycmF5KGVsZW1lbnQpWzBdO1xuXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFwic2Nyb2xsVG8gdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuIFVzaW5nIDBcIikgfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgaXNSb290ID0gIWNvbnRhaW5lciB8fCBjb250YWluZXIgPT09IF93aW5kb3cgfHwgY29udGFpbmVyID09PSBfYm9keSxcbiAgICAgIGNSZWN0ID0gaXNSb290ID8ge1xuICAgIHRvcDogX2RvY0VsLmNsaWVudFRvcCAtIChfd2luZG93LnBhZ2VZT2Zmc2V0IHx8IF9kb2NFbC5zY3JvbGxUb3AgfHwgX2JvZHkuc2Nyb2xsVG9wIHx8IDApLFxuICAgIGxlZnQ6IF9kb2NFbC5jbGllbnRMZWZ0IC0gKF93aW5kb3cucGFnZVhPZmZzZXQgfHwgX2RvY0VsLnNjcm9sbExlZnQgfHwgX2JvZHkuc2Nyb2xsTGVmdCB8fCAwKVxuICB9IDogY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICB4OiByZWN0LmxlZnQgLSBjUmVjdC5sZWZ0LFxuICAgIHk6IHJlY3QudG9wIC0gY1JlY3QudG9wXG4gIH07XG5cbiAgaWYgKCFpc1Jvb3QgJiYgY29udGFpbmVyKSB7XG4gICAgLy9vbmx5IGFkZCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gaWYgaXQncyBub3QgdGhlIHdpbmRvdy9ib2R5LlxuICAgIG9mZnNldHMueCArPSBfYnVpbGRHZXR0ZXIoY29udGFpbmVyLCBcInhcIikoKTtcbiAgICBvZmZzZXRzLnkgKz0gX2J1aWxkR2V0dGVyKGNvbnRhaW5lciwgXCJ5XCIpKCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0sXG4gICAgX3BhcnNlVmFsID0gZnVuY3Rpb24gX3BhcnNlVmFsKHZhbHVlLCB0YXJnZXQsIGF4aXMsIGN1cnJlbnRWYWwsIG9mZnNldCkge1xuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgPyBwYXJzZUZsb2F0KHZhbHVlKSAtIG9mZnNldCA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/IHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKSAqICh2YWx1ZS5jaGFyQXQoMCkgPT09IFwiLVwiID8gLTEgOiAxKSArIGN1cnJlbnRWYWwgLSBvZmZzZXQgOiB2YWx1ZSA9PT0gXCJtYXhcIiA/IF9tYXgodGFyZ2V0LCBheGlzKSAtIG9mZnNldCA6IE1hdGgubWluKF9tYXgodGFyZ2V0LCBheGlzKSwgX2dldE9mZnNldCh2YWx1ZSwgdGFyZ2V0KVtheGlzXSAtIG9mZnNldCk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgZ3NhcCA9IF9nZXRHU0FQKCk7XG5cbiAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiBnc2FwICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICBfd2luZG93ID0gd2luZG93O1xuICAgIF9ib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICBfZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX3RvQXJyYXkgPSBnc2FwLnV0aWxzLnRvQXJyYXk7XG4gICAgZ3NhcC5jb25maWcoe1xuICAgICAgYXV0b0tpbGxUaHJlc2hvbGQ6IDdcbiAgICB9KTtcbiAgICBfY29uZmlnID0gZ3NhcC5jb25maWcoKTtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIFNjcm9sbFRvUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTAuNFwiLFxuICBuYW1lOiBcInNjcm9sbFRvXCIsXG4gIHJhd1ZhcnM6IDEsXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgZ3NhcCA9IGNvcmU7XG5cbiAgICBfaW5pdENvcmUoKTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLFxuICAgICAgICBzbmFwVHlwZSA9IGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInNjcm9sbFNuYXBUeXBlXCIpO1xuICAgIGRhdGEuaXNXaW4gPSB0YXJnZXQgPT09IF93aW5kb3c7XG4gICAgZGF0YS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZGF0YS50d2VlbiA9IHR3ZWVuO1xuICAgIHZhbHVlID0gX2NsZWFuKHZhbHVlLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICBkYXRhLnZhcnMgPSB2YWx1ZTtcbiAgICBkYXRhLmF1dG9LaWxsID0gISF2YWx1ZS5hdXRvS2lsbDtcbiAgICBkYXRhLmdldFggPSBfYnVpbGRHZXR0ZXIodGFyZ2V0LCBcInhcIik7XG4gICAgZGF0YS5nZXRZID0gX2J1aWxkR2V0dGVyKHRhcmdldCwgXCJ5XCIpO1xuICAgIGRhdGEueCA9IGRhdGEueFByZXYgPSBkYXRhLmdldFgoKTtcbiAgICBkYXRhLnkgPSBkYXRhLnlQcmV2ID0gZGF0YS5nZXRZKCk7XG5cbiAgICBpZiAoc25hcFR5cGUgJiYgc25hcFR5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBkaXNhYmxlIHNjcm9sbCBzbmFwcGluZyB0byBhdm9pZCBzdHJhbmdlIGJlaGF2aW9yXG4gICAgICBkYXRhLnNuYXAgPSAxO1xuICAgICAgZGF0YS5zbmFwSW5saW5lID0gdGFyZ2V0LnN0eWxlLnNjcm9sbFNuYXBUeXBlO1xuICAgICAgdGFyZ2V0LnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJub25lXCI7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnggIT0gbnVsbCkge1xuICAgICAgZGF0YS5hZGQoZGF0YSwgXCJ4XCIsIGRhdGEueCwgX3BhcnNlVmFsKHZhbHVlLngsIHRhcmdldCwgXCJ4XCIsIGRhdGEueCwgdmFsdWUub2Zmc2V0WCB8fCAwKSwgaW5kZXgsIHRhcmdldHMpO1xuXG4gICAgICBkYXRhLl9wcm9wcy5wdXNoKFwic2Nyb2xsVG9feFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5za2lwWCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnkgIT0gbnVsbCkge1xuICAgICAgZGF0YS5hZGQoZGF0YSwgXCJ5XCIsIGRhdGEueSwgX3BhcnNlVmFsKHZhbHVlLnksIHRhcmdldCwgXCJ5XCIsIGRhdGEueSwgdmFsdWUub2Zmc2V0WSB8fCAwKSwgaW5kZXgsIHRhcmdldHMpO1xuXG4gICAgICBkYXRhLl9wcm9wcy5wdXNoKFwic2Nyb2xsVG9feVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5za2lwWSA9IDE7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgICB0YXJnZXQgPSBkYXRhLnRhcmdldCxcbiAgICAgICAgdHdlZW4gPSBkYXRhLnR3ZWVuLFxuICAgICAgICBhdXRvS2lsbCA9IGRhdGEuYXV0b0tpbGwsXG4gICAgICAgIHhQcmV2ID0gZGF0YS54UHJldixcbiAgICAgICAgeVByZXYgPSBkYXRhLnlQcmV2LFxuICAgICAgICBpc1dpbiA9IGRhdGEuaXNXaW4sXG4gICAgICAgIHNuYXAgPSBkYXRhLnNuYXAsXG4gICAgICAgIHNuYXBJbmxpbmUgPSBkYXRhLnNuYXBJbmxpbmUsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHlEaWYsXG4gICAgICAgIHhEaWYsXG4gICAgICAgIHRocmVzaG9sZDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHggPSBpc1dpbiB8fCAhZGF0YS5za2lwWCA/IGRhdGEuZ2V0WCgpIDogeFByZXY7XG4gICAgeSA9IGlzV2luIHx8ICFkYXRhLnNraXBZID8gZGF0YS5nZXRZKCkgOiB5UHJldjtcbiAgICB5RGlmID0geSAtIHlQcmV2O1xuICAgIHhEaWYgPSB4IC0geFByZXY7XG4gICAgdGhyZXNob2xkID0gX2NvbmZpZy5hdXRvS2lsbFRocmVzaG9sZDtcblxuICAgIGlmIChkYXRhLnggPCAwKSB7XG4gICAgICAvL2Nhbid0IHNjcm9sbCB0byBhIHBvc2l0aW9uIGxlc3MgdGhhbiAwISBNaWdodCBoYXBwZW4gaWYgc29tZW9uZSB1c2VzIGEgQmFjay5lYXNlT3V0IG9yIEVsYXN0aWMuZWFzZU91dCB3aGVuIHNjcm9sbGluZyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UgKGZvciBleGFtcGxlKVxuICAgICAgZGF0YS54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS55IDwgMCkge1xuICAgICAgZGF0YS55ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYXV0b0tpbGwpIHtcbiAgICAgIC8vbm90ZTogaU9TIGhhcyBhIGJ1ZyB0aGF0IHRocm93cyBvZmYgdGhlIHNjcm9sbCBieSBzZXZlcmFsIHBpeGVscywgc28gd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIHdpdGhpbiA3IHBpeGVscyBvZiB0aGUgcHJldmlvdXMgb25lIHRoYXQgd2Ugc2V0IGluc3RlYWQgb2YganVzdCBsb29raW5nIGZvciBhbiBleGFjdCBtYXRjaC5cbiAgICAgIGlmICghZGF0YS5za2lwWCAmJiAoeERpZiAIHRocmVzaG9sZCB8fCB4RGlmIDwgLXRocmVzaG9sZCkgJiYgeCA8IF9tYXgodGFyZ2V0LCBcInhcIikpIHtcbiAgICAgICAgZGF0YS5za2lwWCA9IDE7IC8vaWYgdGhlIHVzZXIgc2Nyb2xscyBzZXBhcmF0ZWx5LCB3ZSBzaG91bGQgc3RvcCB0d2VlbmluZyFcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhLnNraXBZICYmICh5RGlmID4gdGhyZXNob2xkIHx8IHlEaWYgPCAtdGhyZXNob2xkKSAmJiB5IDwgX21heCh0YXJnZXQsIFwieVwiKSkge1xuICAgICAgICBkYXRhLnNraXBZID0gMTsgLy9pZiB0aGUgdXNlciBzY3JvbGxzIHNlcGFyYXRlbHksIHdlIHNob3VsZCBzdG9wIHR3ZWVuaW5nIVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5za2lwWCAmJiBkYXRhLnNraXBZKSB7XG4gICAgICAgIHR3ZWVuLmtpbGwoKTtcbiAgICAgICAgZGF0YS52YXJzLm9uQXV0b0tpbGwgJiYgZGF0YS52YXJzLm9uQXV0b0tpbGwuYXBwbHkodHdlZW4sIGRhdGEudmFycy5vbkF1dG9LaWxsUGFyYW1zIHx8IFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNXaW4pIHtcbiAgICAgIF93aW5kb3cuc2Nyb2xsVG8oIWRhdGEuc2tpcFggPyBkYXRhLnggOiB4LCAhZGF0YS5za2lwWSA/IGRhdGEueSA6IHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnNraXBZIHx8ICh0YXJnZXQuc2Nyb2xsVG9wID0gZGF0YS55KTtcbiAgICAgIGRhdGEuc2tpcFggfHwgKHRhcmdldC5zY3JvbGxMZWZ0ID0gZGF0YS54KTtcbiAgICB9XG5cbiAgICBpZiAoc25hcCAmJiAocmF0aW8gPT09IDEgfHwgcmF0aW8gPT09IDApKSB7XG4gICAgICB5ID0gdGFyZ2V0LnNjcm9sbFRvcDtcbiAgICAgIHggPSB0YXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgIHNuYXBJbmxpbmUgPyB0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBzbmFwSW5saW5lIDogdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwic2Nyb2xsLXNuYXAtdHlwZVwiKTtcbiAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSB5ICsgMTsgLy8gYnVnIGluIFNhZmFyaSBjYXVzZXMgdGhlIGVsZW1lbnQgdG8gdG90YWxseSByZXNldCBpdHMgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gc2Nyb2xsLXNuYXAtdHlwZSBjaGFuZ2VzLCBzbyB3ZSBuZWVkIHRvIHNldCBpdCB0byBhIHNsaWdodGx5IGRpZmZlcmVudCB2YWx1ZSBhbmQgdGhlbiBiYWNrIGFnYWluIHRvIHdvcmsgYXJvdW5kIHRoaXMgYnVnLlxuXG4gICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHggKyAxO1xuICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IHk7XG4gICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHg7XG4gICAgfVxuXG4gICAgZGF0YS54UHJldiA9IGRhdGEueDtcbiAgICBkYXRhLnlQcmV2ID0gZGF0YS55O1xuICB9LFxuICBraWxsOiBmdW5jdGlvbiBraWxsKHByb3BlcnR5KSB7XG4gICAgdmFyIGJvdGggPSBwcm9wZXJ0eSA9PT0gXCJzY3JvbGxUb1wiO1xuXG4gICAgaWYgKGJvdGggfHwgcHJvcGVydHkgPT09IFwic2Nyb2xsVG9feFwiKSB7XG4gICAgICB0aGlzLnNraXBYID0gMTtcbiAgICB9XG5cbiAgICBpZiAoYm90aCB8fCBwcm9wZXJ0eSA9PT0gXCJzY3JvbGxUb195XCIpIHtcbiAgICAgIHRoaXMuc2tpcFkgPSAxO1xuICAgIH1cbiAgfVxufTtcblNjcm9sbFRvUGx1Z2luLm1heCA9IF9tYXg7XG5TY3JvbGxUb1BsdWdpbi5nZXRPZmZzZXQgPSBfZ2V0T2Zmc2V0O1xuU2Nyb2xsVG9QbHVnaW4uYnVpbGRHZXR0ZXIgPSBfYnVpbGRHZXR0ZXI7XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVG9QbHVnaW4pO1xuZXhwb3J0IHsgU2Nyb2xsVG9QbHVnaW4gYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/ScrollToPlugin.js\n");

/***/ }),

/***/ "./node_modules/gsap/ScrollTrigger.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/ScrollTrigger.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollTrigger: () => (/* binding */ ScrollTrigger),\n/* harmony export */   \"default\": () => (/* binding */ ScrollTrigger)\n/* harmony export */ });\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observer.js */ \"./node_modules/gsap/Observer.js\");\n/*!\n * ScrollTrigger 3.10.4\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar gsap,\n    _coreInitted,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _root,\n    _resizeDelay,\n    _toArray,\n    _clamp,\n    _time2,\n    _syncInterval,\n    _refreshing,\n    _pointerIsDown,\n    _transformProp,\n    _i,\n    _prevWidth,\n    _prevHeight,\n    _autoRefresh,\n    _sort,\n    _suppressOverwrites,\n    _ignoreResize,\n    _normalizer,\n    _ignoreMobileResize,\n    _baseScreenHeight,\n    _baseScreenWidth,\n    _fixIOSBug,\n    _limitCallbacks,\n    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n_startup = 1,\n    _getTime = Date.now,\n    _time1 = _getTime(),\n    _lastScrollTime = 0,\n    _enabled = 0,\n    _pointerDownHandler = function _pointerDownHandler() {\n  return _pointerIsDown = 1;\n},\n    _pointerUpHandler = function _pointerUpHandler() {\n  return _pointerIsDown = 0;\n},\n    _passThrough = function _passThrough(v) {\n  return v;\n},\n    _round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _isViewport = function _isViewport(e) {\n  return !!~_root.indexOf(e);\n},\n    _getBoundsFunc = function _getBoundsFunc(element) {\n  return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, \"getBoundingClientRect\") || (_isViewport(element) ? function () {\n    _winOffsets.width = _win.innerWidth;\n    _winOffsets.height = _win.innerHeight;\n    return _winOffsets;\n  } : function () {\n    return _getBounds(element);\n  });\n},\n    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {\n  var d = _ref.d,\n      d2 = _ref.d2,\n      a = _ref.a;\n  return (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"getBoundingClientRect\")) ? function () {\n    return a()[d];\n  } : function () {\n    return (isViewport ? _win[\"inner\"  d2] : scroller[\"client\"  d2]) || 0;\n  };\n},\n    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\n  return !isViewport || ~_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.indexOf(element) ? _getBoundsFunc(element) : function () {\n    return _winOffsets;\n  };\n},\n    _maxScroll = function _maxScroll(element, _ref2) {\n  var s = _ref2.s,\n      d2 = _ref2.d2,\n      d = _ref2.d,\n      a = _ref2.a;\n  return (s = \"scroll\"  d2) && (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - (_win[\"inner\"  d2] || _docEl[\"client\"  d2] || _body[\"client\"  d2]) : element[s] - element[\"offset\"  d2];\n},\n    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\n  for (var i = 0; i < _autoRefresh.length; i = 3) {\n    (!events || ~events.indexOf(_autoRefresh[i  1])) && func(_autoRefresh[i], _autoRefresh[i  1], _autoRefresh[i  2]);\n  }\n},\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === \"number\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _callIfFunc = function _callIfFunc(value) {\n  return _isFunction(value) && value();\n},\n    _combineFunc = function _combineFunc(f1, f2) {\n  return function () {\n    var result1 = _callIfFunc(f1),\n        result2 = _callIfFunc(f2);\n\n    return function () {\n      _callIfFunc(result1);\n\n      _callIfFunc(result2);\n    };\n  };\n},\n    _endAnimation = function _endAnimation(animation, reversed, pause) {\n  return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();\n},\n    _callback = function _callback(self, func) {\n  if (self.enabled) {\n    var result = func(self);\n    result && result.totalTime && (self.callbackAnimation = result);\n  }\n},\n    _abs = Math.abs,\n    _scrollLeft = \"scrollLeft\",\n    _scrollTop = \"scrollTop\",\n    _left = \"left\",\n    _top = \"top\",\n    _right = \"right\",\n    _bottom = \"bottom\",\n    _width = \"width\",\n    _height = \"height\",\n    _Right = \"Right\",\n    _Left = \"Left\",\n    _Top = \"Top\",\n    _Bottom = \"Bottom\",\n    _padding = \"padding\",\n    _margin = \"margin\",\n    _Width = \"Width\",\n    _Height = \"Height\",\n    _px = \"px\",\n    _getComputedStyle = function _getComputedStyle(element) {\n  return _win.getComputedStyle(element);\n},\n    _makePositionable = function _makePositionable(element) {\n  // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative\n  var position = _getComputedStyle(element).position;\n\n  element.style.position = position === \"absolute\" || position === \"fixed\" ? position : \"relative\";\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    _getBounds = function _getBounds(element, withoutTransforms) {\n  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\n    x: 0,\n    y: 0,\n    xPercent: 0,\n    yPercent: 0,\n    rotation: 0,\n    rotationX: 0,\n    rotationY: 0,\n    scale: 1,\n    skewX: 0,\n    skewY: 0\n  }).progress(1),\n      bounds = element.getBoundingClientRect();\n  tween && tween.progress(0).kill();\n  return bounds;\n},\n    _getSize = function _getSize(element, _ref3) {\n  var d2 = _ref3.d2;\n  return element[\"offset\"  d2] || element[\"client\"  d2] || 0;\n},\n    _getLabelRatioArray = function _getLabelRatioArray(timeline) {\n  var a = [],\n      labels = timeline.labels,\n      duration = timeline.duration(),\n      p;\n\n  for (p in labels) {\n    a.push(labels[p] / duration);\n  }\n\n  return a;\n},\n    _getClosestLabel = function _getClosestLabel(animation) {\n  return function (value) {\n    return gsap.utils.snap(_getLabelRatioArray(animation), value);\n  };\n},\n    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {\n  var snap = gsap.utils.snap(snapIncrementOrArray),\n      a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {\n    return a - b;\n  });\n  return a ? function (value, direction, threshold) {\n    if (threshold === void 0) {\n      threshold = 1e-3;\n    }\n\n    var i;\n\n    if (!direction) {\n      return snap(value);\n    }\n\n    if (direction > 0) {\n      value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.\n\n      for (i = 0; i < a.length; i) {\n        if (a[i] >= value) {\n          return a[i];\n        }\n      }\n\n      return a[i - 1];\n    } else {\n      i = a.length;\n      value = threshold;\n\n      while (i--) {\n        if (a[i] <= value) {\n          return a[i];\n        }\n      }\n    }\n\n    return a[0];\n  } : function (value, direction, threshold) {\n    if (threshold === void 0) {\n      threshold = 1e-3;\n    }\n\n    var snapped = snap(value);\n    return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value  snapIncrementOrArray);\n  };\n},\n    _getLabelAtDirection = function _getLabelAtDirection(timeline) {\n  return function (value, st) {\n    return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);\n  };\n},\n    _multiListener = function _multiListener(func, element, types, callback) {\n  return types.split(\",\").forEach(function (type) {\n    return func(element, type, callback);\n  });\n},\n    _addListener = function _addListener(element, type, func, nonPassive, capture) {\n  return element.addEventListener(type, func, {\n    passive: !nonPassive,\n    capture: !!capture\n  });\n},\n    _removeListener = function _removeListener(element, type, func, capture) {\n  return element.removeEventListener(type, func, !!capture);\n},\n    _wheelListener = function _wheelListener(func, el, scrollFunc) {\n  return scrollFunc && scrollFunc.wheelHandler && func(el, \"wheel\", scrollFunc);\n},\n    _markerDefaults = {\n  startColor: \"green\",\n  endColor: \"red\",\n  indent: 0,\n  fontSize: \"16px\",\n  fontWeight: \"normal\"\n},\n    _defaults = {\n  toggleActions: \"play\",\n  anticipatePin: 0\n},\n    _keywords = {\n  top: 0,\n  left: 0,\n  center: 0.5,\n  bottom: 1,\n  right: 1\n},\n    _offsetToPx = function _offsetToPx(value, size) {\n  if (_isString(value)) {\n    var eqIndex = value.indexOf(\"=\"),\n        relative = ~eqIndex ? (value.charAt(eqIndex - 1)  1) * parseFloat(value.substr(eqIndex  1)) : 0;\n\n    if (~eqIndex) {\n      value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\n      value = value.substr(0, eqIndex - 1);\n    }\n\n    value = relative  (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n  }\n\n  return value;\n},\n    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {\n  var startColor = _ref4.startColor,\n      endColor = _ref4.endColor,\n      fontSize = _ref4.fontSize,\n      indent = _ref4.indent,\n      fontWeight = _ref4.fontWeight;\n\n  var e = _doc.createElement(\"div\"),\n      useFixedPosition = _isViewport(container) || (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(container, \"pinType\") === \"fixed\",\n      isScroller = type.indexOf(\"scroller\") !== -1,\n      parent = useFixedPosition ? _body : container,\n      isStart = type.indexOf(\"start\") !== -1,\n      color = isStart ? startColor : endColor,\n      css = \"border-color:\"  color  \";font-size:\"  fontSize  \";color:\"  color  \";font-weight:\"  fontWeight  \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n\n  css = \"position:\"  ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\n  (isScroller || containerAnimation || !useFixedPosition) && (css = (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _right : _bottom)  \":\"  (offset  parseFloat(indent))  \"px;\");\n  matchWidthEl && (css = \"box-sizing:border-box;text-align:left;width:\"  matchWidthEl.offsetWidth  \"px;\");\n  e._isStart = isStart;\n  e.setAttribute(\"class\", \"gsap-marker-\"  type  (name ? \" marker-\"  name : \"\"));\n  e.style.cssText = css;\n  e.innerText = name || name === 0 ? type  \"-\"  name : type;\n  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n  e._offset = e[\"offset\"  direction.op.d2];\n\n  _positionMarker(e, 0, direction, isStart);\n\n  return e;\n},\n    _positionMarker = function _positionMarker(marker, start, direction, flipped) {\n  var vars = {\n    display: \"block\"\n  },\n      side = direction[flipped ? \"os2\" : \"p2\"],\n      oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n  marker._isFlipped = flipped;\n  vars[direction.a  \"Percent\"] = flipped ? -100 : 0;\n  vars[direction.a] = flipped ? \"1px\" : 0;\n  vars[\"border\"  side  _Width] = 1;\n  vars[\"border\"  oppositeSide  _Width] = 0;\n  vars[direction.p] = start  \"px\";\n  gsap.set(marker, vars);\n},\n    _triggers = [],\n    _ids = {},\n    _rafID,\n    _sync = function _sync() {\n  return _getTime() - _lastScrollTime > 34 && _updateAll();\n},\n    _onScroll = function _onScroll() {\n  // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010\n  if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {\n    // if the user is dragging the scrollbar, allow it.\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;\n    _rafID || (_rafID = requestAnimationFrame(_updateAll));\n    _lastScrollTime || _dispatch(\"scrollStart\");\n    _lastScrollTime = _getTime();\n  }\n},\n    _setBaseDimensions = function _setBaseDimensions() {\n  _baseScreenWidth = _win.innerWidth;\n  _baseScreenHeight = _win.innerHeight;\n},\n    _onResize = function _onResize() {\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;\n  !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(true);\n},\n    // ignore resizes triggered by refresh()\n_listeners = {},\n    _emptyArray = [],\n    _media = [],\n    _creatingMedia,\n    // when ScrollTrigger.matchMedia() is called, we record the current media key here (like \"(min-width: 800px)\") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a \"media\" property on the instance.\n_lastMediaTick,\n    _onMediaChange = function _onMediaChange(e) {\n  var tick = gsap.ticker.frame,\n      matches = [],\n      i = 0,\n      index;\n\n  if (_lastMediaTick !== tick || _startup) {\n    _revertAll();\n\n    for (; i < _media.length; i = 4) {\n      index = _win.matchMedia(_media[i]).matches;\n\n      if (index !== _media[i  3]) {\n        // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn't call the function multiple times. Check to see if it's already matched.\n        _media[i  3] = index;\n        index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i  2]) && _media[i  2](); // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n      }\n    }\n\n    _revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.\n\n\n    for (i = 0; i < matches.length; i) {\n      index = matches[i];\n      _creatingMedia = _media[index];\n      _media[index  2] = _media[index  1](e);\n    }\n\n    _creatingMedia = 0;\n    _coreInitted && _refreshAll(0, 1);\n    _lastMediaTick = tick;\n\n    _dispatch(\"matchMedia\");\n  }\n},\n    _softRefresh = function _softRefresh() {\n  return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true);\n},\n    _dispatch = function _dispatch(type) {\n  return _listeners[type] && _listeners[type].map(function (f) {\n    return f();\n  }) || _emptyArray;\n},\n    _savedStyles = [],\n    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n_revertRecorded = function _revertRecorded(media) {\n  for (var i = 0; i < _savedStyles.length; i = 5) {\n    if (!media || _savedStyles[i  4] === media) {\n      _savedStyles[i].style.cssText = _savedStyles[i  1];\n      _savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i  2] || \"\");\n      _savedStyles[i  3].uncache = 1;\n    }\n  }\n},\n    _revertAll = function _revertAll(kill, media) {\n  var trigger;\n\n  for (_i = 0; _i < _triggers.length; _i) {\n    trigger = _triggers[_i];\n\n    if (!media || trigger.media === media) {\n      if (kill) {\n        trigger.kill(1);\n      } else {\n        trigger.revert();\n      }\n    }\n  }\n\n  media && _revertRecorded(media);\n  media || _dispatch(\"revert\");\n},\n    _clearScrollMemory = function _clearScrollMemory() {\n  return _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (obj) {\n    return typeof obj === \"function\" && (obj.rec = 0);\n  });\n},\n    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.\n_refreshingAll,\n    _refreshID = 0,\n    _refreshAll = function _refreshAll(force, skipRevert) {\n  if (_lastScrollTime && !force) {\n    _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\n    return;\n  }\n\n  _refreshingAll = true;\n\n  var refreshInits = _dispatch(\"refreshInit\");\n\n  _sort && ScrollTrigger.sort();\n  skipRevert || _revertAll();\n\n  _triggers.slice(0).forEach(function (t) {\n    return t.refresh();\n  }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.\n\n\n  _triggers.forEach(function (t) {\n    return t.vars.end === \"max\" && t.setPositions(t.start, _maxScroll(t.scroller, t._dir));\n  }); // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: \"max\".\n\n\n  refreshInits.forEach(function (result) {\n    return result && result.render && result.render(-1);\n  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n\n  _clearScrollMemory();\n\n  _resizeDelay.pause();\n\n  _refreshID;\n  _refreshingAll = false;\n\n  _dispatch(\"refresh\");\n},\n    _lastScroll = 0,\n    _direction = 1,\n    _primary,\n    _updateAll = function _updateAll() {\n  if (!_refreshingAll) {\n    ScrollTrigger.isUpdating = true;\n    _primary && _primary.update(0); // ScrollSmoother users refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.\n\n    var l = _triggers.length,\n        time = _getTime(),\n        recordVelocity = time - _time1 >= 50,\n        scroll = l && _triggers[0].scroll();\n\n    _direction = _lastScroll > scroll ? -1 : 1;\n    _lastScroll = scroll;\n\n    if (recordVelocity) {\n      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n        _lastScrollTime = 0;\n\n        _dispatch(\"scrollEnd\");\n      }\n\n      _time2 = _time1;\n      _time1 = time;\n    }\n\n    if (_direction < 0) {\n      _i = l;\n\n      while (_i-- > 0) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n\n      _direction = 1;\n    } else {\n      for (_i = 0; _i < l; _i) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n    }\n\n    ScrollTrigger.isUpdating = false;\n  }\n\n  _rafID = 0;\n},\n    _propNamesToCopy = [_left, _top, _bottom, _right, _margin  _Bottom, _margin  _Right, _margin  _Top, _margin  _Left, \"display\", \"flexShrink\", \"float\", \"zIndex\", \"gridColumnStart\", \"gridColumnEnd\", \"gridRowStart\", \"gridRowEnd\", \"gridArea\", \"justifySelf\", \"alignSelf\", \"placeSelf\", \"order\"],\n    _stateProps = _propNamesToCopy.concat([_width, _height, \"boxSizing\", \"max\"  _Width, \"max\"  _Height, \"position\", _margin, _padding, _padding  _Top, _padding  _Right, _padding  _Bottom, _padding  _Left]),\n    _swapPinOut = function _swapPinOut(pin, spacer, state) {\n  _setState(state);\n\n  var cache = pin._gsap;\n\n  if (cache.spacerIsNative) {\n    _setState(cache.spacerState);\n  } else if (pin.parentNode === spacer) {\n    var parent = spacer.parentNode;\n\n    if (parent) {\n      parent.insertBefore(pin, spacer);\n      parent.removeChild(spacer);\n    }\n  }\n},\n    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\n  if (pin.parentNode !== spacer) {\n    var i = _propNamesToCopy.length,\n        spacerStyle = spacer.style,\n        pinStyle = pin.style,\n        p;\n\n    while (i--) {\n      p = _propNamesToCopy[i];\n      spacerStyle[p] = cs[p];\n    }\n\n    spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n    cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\n    pinStyle[_bottom] = pinStyle[_right] = spacerStyle.flexBasis = \"auto\";\n    spacerStyle.overflow = \"visible\";\n    spacerStyle.boxSizing = \"border-box\";\n    spacerStyle[_width] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)  _px;\n    spacerStyle[_height] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)  _px;\n    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n\n    _setState(spacerState);\n\n    pinStyle[_width] = pinStyle[\"max\"  _Width] = cs[_width];\n    pinStyle[_height] = pinStyle[\"max\"  _Height] = cs[_height];\n    pinStyle[_padding] = cs[_padding];\n    pin.parentNode.insertBefore(spacer, pin);\n    spacer.appendChild(pin);\n  }\n},\n    _capsExp = /([A-Z])/g,\n    _setState = function _setState(state) {\n  if (state) {\n    var style = state.t.style,\n        l = state.length,\n        i = 0,\n        p,\n        value;\n    (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\n\n    for (; i < l; i = 2) {\n      value = state[i  1];\n      p = state[i];\n\n      if (value) {\n        style[p] = value;\n      } else if (style[p]) {\n        style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n      }\n    }\n  }\n},\n    _getState = function _getState(element) {\n  // returns an Array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\n  var l = _stateProps.length,\n      style = element.style,\n      state = [],\n      i = 0;\n\n  for (; i < l; i) {\n    state.push(_stateProps[i], style[_stateProps[i]]);\n  }\n\n  state.t = element;\n  return state;\n},\n    _copyState = function _copyState(state, override, omitOffsets) {\n  var result = [],\n      l = state.length,\n      i = omitOffsets ? 8 : 0,\n      // skip top, left, right, bottom if omitOffsets is true\n  p;\n\n  for (; i < l; i = 2) {\n    p = state[i];\n    result.push(p, p in override ? override[p] : state[i  1]);\n  }\n\n  result.t = state.t;\n  return result;\n},\n    _winOffsets = {\n  left: 0,\n  top: 0\n},\n    // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition(\"#id\", \"top bottom\")\n// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {\n// \tscroller = _getTarget(scroller || _win);\n// \tlet direction = horizontal ? _horizontal : _vertical,\n// \t\tisViewport = _isViewport(scroller);\n// \t_getSizeFunc(scroller, isViewport, direction);\n// \treturn _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\"  direction.p2  _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);\n// },\n_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {\n  _isFunction(value) && (value = value(self));\n\n  if (_isString(value) && value.substr(0, 3) === \"max\") {\n    value = scrollerMax  (value.charAt(4) === \"=\" ? _offsetToPx(\"0\"  value.substr(3), scrollerSize) : 0);\n  }\n\n  var time = containerAnimation ? containerAnimation.time() : 0,\n      p1,\n      p2,\n      element;\n  containerAnimation && containerAnimation.seek(0);\n\n  if (!_isNumber(value)) {\n    _isFunction(trigger) && (trigger = trigger(self));\n    var offsets = value.split(\" \"),\n        bounds,\n        localOffset,\n        globalOffset,\n        display;\n    element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger) || _body;\n    bounds = _getBounds(element) || {};\n\n    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\n      // if display is \"none\", it won't report getBoundingClientRect() properly\n      display = element.style.display;\n      element.style.display = \"block\";\n      bounds = _getBounds(element);\n      display ? element.style.display = display : element.style.removeProperty(\"display\");\n    }\n\n    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n    globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth  localOffset  scroll - globalOffset;\n    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n  } else if (markerScroller) {\n    _positionMarker(markerScroller, scrollerSize, direction, true);\n  }\n\n  if (marker) {\n    var position = value  scrollerSize,\n        isStart = marker._isStart;\n    p1 = \"scroll\"  direction.d2;\n\n    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position  1);\n\n    if (useFixedPosition) {\n      scrollerBounds = _getBounds(markerScroller);\n      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset  _px);\n    }\n  }\n\n  if (containerAnimation && element) {\n    p1 = _getBounds(element);\n    containerAnimation.seek(scrollerMax);\n    p2 = _getBounds(element);\n    containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\n    value = value / containerAnimation._caScrollDist * scrollerMax;\n  }\n\n  containerAnimation && containerAnimation.seek(time);\n  return containerAnimation ? value : Math.round(value);\n},\n    _prefixExp = /(webkit|moz|length|cssText|inset)/i,\n    _reparent = function _reparent(element, parent, top, left) {\n  if (element.parentNode !== parent) {\n    var style = element.style,\n        p,\n        cs;\n\n    if (parent === _body) {\n      element._stOrig = style.cssText; // record original inline styles so we can revert them later\n\n      cs = _getComputedStyle(element);\n\n      for (p in cs) {\n        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n        if (!p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n          style[p] = cs[p];\n        }\n      }\n\n      style.top = top;\n      style.left = left;\n    } else {\n      style.cssText = element._stOrig;\n    }\n\n    gsap.core.getCache(element).uncache = 1;\n    parent.appendChild(element);\n  }\n},\n    // _mergeAnimations = animations => {\n// \tlet tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));\n// \tanimations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });\n// \ttl.smoothChildTiming = false;\n// \treturn tl;\n// },\n// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\n  var getScroll = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction),\n      prop = \"_scroll\"  direction.p2,\n      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\n  lastScroll1,\n      lastScroll2,\n      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\n    var tween = getTween.tween,\n        onComplete = vars.onComplete,\n        modifiers = {};\n    initialValue = initialValue || getScroll();\n    change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.\n\n    change1 = change1 || scrollTo - initialValue;\n    tween && tween.kill();\n    lastScroll1 = Math.round(initialValue);\n    vars[prop] = scrollTo;\n    vars.modifiers = modifiers;\n\n    modifiers[prop] = function (value) {\n      value = _round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.\n\n      if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2 && Math.abs(value - lastScroll2) > 2) {\n        // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.\n        tween.kill();\n        getTween.tween = 0;\n      } else {\n        value = initialValue  change1 * tween.ratio  change2 * tween.ratio * tween.ratio;\n      }\n\n      lastScroll2 = lastScroll1;\n      return lastScroll1 = _round(value);\n    };\n\n    vars.onComplete = function () {\n      getTween.tween = 0;\n      onComplete && onComplete.call(tween);\n    };\n\n    tween = getTween.tween = gsap.to(scroller, vars);\n    return tween;\n  };\n\n  scroller[prop] = getScroll;\n\n  getScroll.wheelHandler = function () {\n    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);\n  };\n\n  _addListener(scroller, \"wheel\", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like \"3 lines per scroll\") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.\n\n\n  return getTween;\n};\n\nvar ScrollTrigger = /*#__PURE__*/function () {\n  function ScrollTrigger(vars, animation) {\n    _coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n    this.init(vars, animation);\n  }\n\n  var _proto = ScrollTrigger.prototype;\n\n  _proto.init = function init(vars, animation) {\n    this.progress = this.start = 0;\n    this.vars && this.kill(true, true); // in case it's being initted again\n\n    if (!_enabled) {\n      this.update = this.refresh = this.kill = _passThrough;\n      return;\n    }\n\n    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n      trigger: vars\n    } : vars, _defaults);\n\n    var _vars = vars,\n        onUpdate = _vars.onUpdate,\n        toggleClass = _vars.toggleClass,\n        id = _vars.id,\n        onToggle = _vars.onToggle,\n        onRefresh = _vars.onRefresh,\n        scrub = _vars.scrub,\n        trigger = _vars.trigger,\n        pin = _vars.pin,\n        pinSpacing = _vars.pinSpacing,\n        invalidateOnRefresh = _vars.invalidateOnRefresh,\n        anticipatePin = _vars.anticipatePin,\n        onScrubComplete = _vars.onScrubComplete,\n        onSnapComplete = _vars.onSnapComplete,\n        once = _vars.once,\n        snap = _vars.snap,\n        pinReparent = _vars.pinReparent,\n        pinSpacer = _vars.pinSpacer,\n        containerAnimation = _vars.containerAnimation,\n        fastScrollEnd = _vars.fastScrollEnd,\n        preventOverlaps = _vars.preventOverlaps,\n        direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical,\n        isToggle = !scrub && scrub !== 0,\n        scroller = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.scroller || _win),\n        scrollerCache = gsap.core.getCache(scroller),\n        isViewport = _isViewport(scroller),\n        useFixedPosition = (\"pinType\" in vars ? vars.pinType : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"pinType\") || isViewport && \"fixed\") === \"fixed\",\n        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\n        toggleActions = isToggle && vars.toggleActions.split(\" \"),\n        markers = \"markers\" in vars ? vars.markers : _defaults.markers,\n        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\"  direction.p2  _Width]) || 0,\n        self = this,\n        onRefreshInit = vars.onRefreshInit && function () {\n      return vars.onRefreshInit(self);\n    },\n        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),\n        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),\n        lastSnap = 0,\n        lastRefresh = 0,\n        scrollFunc = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction),\n        tweenTo,\n        pinCache,\n        snapFunc,\n        scroll1,\n        scroll2,\n        start,\n        end,\n        markerStart,\n        markerEnd,\n        markerStartTrigger,\n        markerEndTrigger,\n        markerVars,\n        change,\n        pinOriginalState,\n        pinActiveState,\n        pinState,\n        spacer,\n        offset,\n        pinGetter,\n        pinSetter,\n        pinStart,\n        pinChange,\n        spacingStart,\n        spacerState,\n        markerStartSetter,\n        markerEndSetter,\n        cs,\n        snap1,\n        snap2,\n        scrubTween,\n        scrubSmooth,\n        snapDurClamp,\n        snapDelayedCall,\n        prevProgress,\n        prevScroll,\n        prevAnimProgress,\n        caMarkerSetter,\n        customRevertReturn;\n\n    self.media = _creatingMedia;\n    self._dir = direction;\n    anticipatePin *= 45;\n    self.scroller = scroller;\n    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\n    scroll1 = scrollFunc();\n    self.vars = vars;\n    animation = animation || vars.animation;\n\n    if (\"refreshPriority\" in vars) {\n      _sort = 1;\n      vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother\n    }\n\n    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n      top: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\n      left: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)\n    };\n    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n\n    self.scrubDuration = function (value) {\n      scrubSmooth = _isNumber(value) && value;\n\n      if (!scrubSmooth) {\n        scrubTween && scrubTween.progress(1).kill();\n        scrubTween = 0;\n      } else {\n        scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {\n          ease: \"expo\",\n          totalProgress: \"=0.001\",\n          duration: scrubSmooth,\n          paused: true,\n          onComplete: function onComplete() {\n            return onScrubComplete && onScrubComplete(self);\n          }\n        });\n      }\n    };\n\n    if (animation) {\n      animation.vars.lazy = false;\n      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);\n      self.animation = animation.pause();\n      animation.scrollTrigger = self;\n      self.scrubDuration(scrub);\n      snap1 = 0;\n      id || (id = animation.vars.id);\n    }\n\n    _triggers.push(self);\n\n    if (snap) {\n      if (!_isObject(snap) || snap.push) {\n        snap = {\n          snapTo: snap\n        };\n      }\n\n      \"scrollBehavior\" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {\n        scrollBehavior: \"auto\"\n      }); // smooth scrolling doesn't work with snap.\n\n      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {\n        return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);\n      } : gsap.utils.snap(snap.snapTo);\n      snapDurClamp = snap.duration || {\n        min: 0.1,\n        max: 2\n      };\n      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {\n        var scroll = scrollFunc(),\n            refreshedRecently = _getTime() - lastRefresh < 500,\n            tween = tweenTo.tween;\n\n        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {\n          var progress = (scroll - start) / change,\n              totalProgress = animation && !isToggle ? animation.totalProgress() : progress,\n              velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,\n              change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),\n              naturalEnd = progress  (snap.inertia === false ? 0 : change1),\n              endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),\n              endScroll = Math.round(start  endValue * change),\n              _snap = snap,\n              onStart = _snap.onStart,\n              _onInterrupt = _snap.onInterrupt,\n              _onComplete = _snap.onComplete;\n\n          if (scroll <= end && scroll >= start && endScroll !== scroll) {\n            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {\n              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\n              return;\n            }\n\n            if (snap.inertia === false) {\n              change1 = endValue - progress;\n            }\n\n            tweenTo(endScroll, {\n              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n              ease: snap.ease || \"power3\",\n              data: _abs(endScroll - scroll),\n              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n              onInterrupt: function onInterrupt() {\n                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);\n              },\n              onComplete: function onComplete() {\n                self.update();\n                lastSnap = scrollFunc();\n                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                onSnapComplete && onSnapComplete(self);\n                _onComplete && _onComplete(self);\n              }\n            }, scroll, change1 * change, endScroll - scroll - change1 * change);\n            onStart && onStart(self, tweenTo.tween);\n          }\n        } else if (self.isActive && lastSnap !== scroll) {\n          snapDelayedCall.restart(true);\n        }\n      }).pause();\n    }\n\n    id && (_ids[id] = self);\n    trigger = self.trigger = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger || pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the \"y\" or \"x\" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.\n\n    customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;\n    customRevertReturn && (customRevertReturn = customRevertReturn(self));\n    pin = pin === true ? trigger : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pin);\n    _isString(toggleClass) && (toggleClass = {\n      targets: trigger,\n      className: toggleClass\n    });\n\n    if (pin) {\n      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.\n\n      self.pin = pin;\n      vars.force3D !== false && gsap.set(pin, {\n        force3D: true\n      });\n      pinCache = gsap.core.getCache(pin);\n\n      if (!pinCache.spacer) {\n        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\n        if (pinSpacer) {\n          pinSpacer = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pinSpacer);\n          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular\n\n          pinCache.spacerIsNative = !!pinSpacer;\n          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));\n        }\n\n        pinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\n        spacer.classList.add(\"pin-spacer\");\n        id && spacer.classList.add(\"pin-spacer-\"  id);\n        pinCache.pinState = pinOriginalState = _getState(pin);\n      } else {\n        pinOriginalState = pinCache.pinState;\n      }\n\n      self.spacer = spacer = pinCache.spacer;\n      cs = _getComputedStyle(pin);\n      spacingStart = cs[pinSpacing  direction.os2];\n      pinGetter = gsap.getProperty(pin);\n      pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n\n      _swapPinIn(pin, spacer, cs);\n\n      pinState = _getState(pin);\n    }\n\n    if (markers) {\n      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n      markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n      markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n      offset = markerStartTrigger[\"offset\"  direction.op.d2];\n\n      var content = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"content\") || scroller);\n\n      markerStart = this.markerStart = _createMarker(\"start\", id, content, direction, markerVars, offset, 0, containerAnimation);\n      markerEnd = this.markerEnd = _createMarker(\"end\", id, content, direction, markerVars, offset, 0, containerAnimation);\n      containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));\n\n      if (!useFixedPosition && !(_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.length && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"fixedMarkers\") === true)) {\n        _makePositionable(isViewport ? _body : scroller);\n\n        gsap.set([markerStartTrigger, markerEndTrigger], {\n          force3D: true\n        });\n        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n      }\n    }\n\n    if (containerAnimation) {\n      var oldOnUpdate = containerAnimation.vars.onUpdate,\n          oldParams = containerAnimation.vars.onUpdateParams;\n      containerAnimation.eventCallback(\"onUpdate\", function () {\n        self.update(0, 0, 1);\n        oldOnUpdate && oldOnUpdate.apply(oldParams || []);\n      });\n    }\n\n    self.previous = function () {\n      return _triggers[_triggers.indexOf(self) - 1];\n    };\n\n    self.next = function () {\n      return _triggers[_triggers.indexOf(self)  1];\n    };\n\n    self.revert = function (revert) {\n      var r = revert !== false || !self.enabled,\n          prevRefreshing = _refreshing;\n\n      if (r !== self.isReverted) {\n        if (r) {\n          self.scroll.rec || !_refreshing || !_refreshingAll || (self.scroll.rec = scrollFunc());\n          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n\n          prevProgress = self.progress;\n          prevAnimProgress = animation && animation.progress();\n        }\n\n        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n          return m.style.display = r ? \"none\" : \"block\";\n        });\n        r && (_refreshing = 1);\n        self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.\n\n        _refreshing = prevRefreshing;\n        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));\n        self.isReverted = r;\n      }\n    };\n\n    self.refresh = function (soft, force) {\n      if ((_refreshing || !self.enabled) && !force) {\n        return;\n      }\n\n      if (pin && soft && _lastScrollTime) {\n        _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n\n        return;\n      }\n\n      !_refreshingAll && onRefreshInit && onRefreshInit(self);\n      _refreshing = 1;\n      lastRefresh = _getTime();\n\n      if (tweenTo.tween) {\n        tweenTo.tween.kill();\n        tweenTo.tween = 0;\n      }\n\n      scrubTween && scrubTween.pause();\n      invalidateOnRefresh && animation && animation.time(-0.01, true).invalidate();\n      self.isReverted || self.revert();\n\n      var size = getScrollerSize(),\n          scrollerBounds = getScrollerOffsets(),\n          max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),\n          offset = 0,\n          otherPinOffset = 0,\n          parsedEnd = vars.end,\n          parsedEndTrigger = vars.endTrigger || trigger,\n          parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? \"0 0\" : \"0 100%\"),\n          pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.pinnedContainer),\n          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,\n          i = triggerIndex,\n          cs,\n          bounds,\n          scroll,\n          isVertical,\n          override,\n          curTrigger,\n          curPin,\n          oppositeScroll,\n          initted,\n          revertedPins;\n\n      while (i--) {\n        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\n        curTrigger = _triggers[i];\n        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.\n\n        curPin = curTrigger.pin;\n\n        if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {\n          revertedPins || (revertedPins = []);\n          revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly\n\n          curTrigger.revert();\n        }\n\n        if (curTrigger !== _triggers[i]) {\n          // in case it got removed.\n          triggerIndex--;\n          i--;\n        }\n      }\n\n      _isFunction(parsedStart) && (parsedStart = parsedStart(self));\n      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);\n      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n\n      if (_isString(parsedEnd) && !parsedEnd.indexOf(\"=\")) {\n        if (~parsedEnd.indexOf(\" \")) {\n          parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\")  parsedEnd;\n        } else {\n          offset = _offsetToPx(parsedEnd.substr(2), size);\n          parsedEnd = _isString(parsedStart) ? parsedStart : start  offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\n\n          parsedEndTrigger = trigger;\n        }\n      }\n\n      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc()  offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;\n      change = end - start || (start -= 0.01) && 0.001;\n      offset = 0;\n      i = triggerIndex;\n\n      while (i--) {\n        curTrigger = _triggers[i];\n        curPin = curTrigger.pin;\n\n        if (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation && curTrigger.end > 0) {\n          cs = curTrigger.end - curTrigger.start;\n\n          if ((curPin === trigger || curPin === pinnedContainer) && !_isNumber(parsedStart)) {\n            // numeric start values shouldn't be offset at all - treat them as absolute\n            offset = cs * (1 - curTrigger.progress);\n          }\n\n          curPin === pin && (otherPinOffset = cs);\n        }\n      }\n\n      start = offset;\n      end = offset;\n      self._pinPush = otherPinOffset;\n\n      if (markerStart && offset) {\n        // offset the markers if necessary\n        cs = {};\n        cs[direction.a] = \"=\"  offset;\n        pinnedContainer && (cs[direction.p] = \"-=\"  scrollFunc());\n        gsap.set([markerStart, markerEnd], cs);\n      }\n\n      if (pin) {\n        cs = _getComputedStyle(pin);\n        isVertical = direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical;\n        scroll = scrollFunc(); // recalculate because the triggers can affect the scroll\n\n        pinStart = parseFloat(pinGetter(direction.a))  otherPinOffset;\n        !max && end > 1 && ((isViewport ? _body : scroller).style[\"overflow-\"  direction.a] = \"scroll\"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n\n        _swapPinIn(pin, spacer, cs);\n\n        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n\n        bounds = _getBounds(pin, true);\n        oppositeScroll = useFixedPosition && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, isVertical ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)();\n\n        if (pinSpacing) {\n          spacerState = [pinSpacing  direction.os2, change  otherPinOffset  _px];\n          spacerState.t = spacer;\n          i = pinSpacing === _padding ? _getSize(pin, direction)  change  otherPinOffset : 0;\n          i && spacerState.push(direction.d, i  _px); // for box-sizing: border-box (must include padding).\n\n          _setState(spacerState);\n\n          useFixedPosition && scrollFunc(prevScroll);\n        }\n\n        if (useFixedPosition) {\n          override = {\n            top: bounds.top  (isVertical ? scroll - start : oppositeScroll)  _px,\n            left: bounds.left  (isVertical ? oppositeScroll : scroll - start)  _px,\n            boxSizing: \"border-box\",\n            position: \"fixed\"\n          };\n          override[_width] = override[\"max\"  _Width] = Math.ceil(bounds.width)  _px;\n          override[_height] = override[\"max\"  _Height] = Math.ceil(bounds.height)  _px;\n          override[_margin] = override[_margin  _Top] = override[_margin  _Right] = override[_margin  _Bottom] = override[_margin  _Left] = \"0\";\n          override[_padding] = cs[_padding];\n          override[_padding  _Top] = cs[_padding  _Top];\n          override[_padding  _Right] = cs[_padding  _Right];\n          override[_padding  _Bottom] = cs[_padding  _Bottom];\n          override[_padding  _Left] = cs[_padding  _Left];\n          pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n        }\n\n        if (animation) {\n          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\n          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\n\n          _suppressOverwrites(1);\n\n          animation.render(animation.duration(), true, true);\n          pinChange = pinGetter(direction.a) - pinStart  change  otherPinOffset;\n          change !== pinChange && useFixedPosition && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n\n          animation.render(0, true, true);\n          initted || animation.invalidate();\n\n          _suppressOverwrites(0);\n        } else {\n          pinChange = change;\n        }\n      } else if (trigger && scrollFunc() && !containerAnimation) {\n        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\n        bounds = trigger.parentNode;\n\n        while (bounds && bounds !== _body) {\n          if (bounds._pinOffset) {\n            start -= bounds._pinOffset;\n            end -= bounds._pinOffset;\n          }\n\n          bounds = bounds.parentNode;\n        }\n      }\n\n      revertedPins && revertedPins.forEach(function (t) {\n        return t.revert(false);\n      });\n      self.start = start;\n      self.end = end;\n      scroll1 = scroll2 = scrollFunc(); // reset velocity\n\n      if (!containerAnimation) {\n        scroll1 < prevScroll && scrollFunc(prevScroll);\n        self.scroll.rec = 0;\n      }\n\n      self.revert(false);\n\n      if (snapDelayedCall) {\n        lastSnap = -1;\n        self.isActive && scrollFunc(start  change * prevProgress); // just so snapping gets re-enabled, clear out any recorded last value\n\n        snapDelayedCall.restart(true);\n      }\n\n      _refreshing = 0;\n      animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\n\n      if (prevProgress !== self.progress || containerAnimation) {\n        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n        animation && !isToggle && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\n\n        self.progress = prevProgress;\n        self.update(0, 0, 1);\n      }\n\n      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange)); //\t\t\tscrubTween && scrubTween.invalidate();\n\n      onRefresh && onRefresh(self);\n    };\n\n    self.getVelocity = function () {\n      return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n    };\n\n    self.endAnimation = function () {\n      _endAnimation(self.callbackAnimation);\n\n      if (animation) {\n        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);\n      }\n    };\n\n    self.labelToScroll = function (label) {\n      return animation && animation.labels && (start || self.refresh() || start)  animation.labels[label] / animation.duration() * change || 0;\n    };\n\n    self.getTrailing = function (name) {\n      var i = _triggers.indexOf(self),\n          a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i  1);\n\n      return (_isString(name) ? a.filter(function (t) {\n        return t.vars.preventOverlaps === name;\n      }) : a).filter(function (t) {\n        return self.direction > 0 ? t.end <= start : t.start >= end;\n      });\n    };\n\n    self.update = function (reset, recordVelocity, forceFake) {\n      if (containerAnimation && !forceFake && !reset) {\n        return;\n      }\n\n      var scroll = self.scroll(),\n          p = reset ? 0 : (scroll - start) / change,\n          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\n          prevProgress = self.progress,\n          isActive,\n          wasActive,\n          toggleState,\n          action,\n          stateChanged,\n          toggled,\n          isAtMax,\n          isTakingAction;\n\n      if (recordVelocity) {\n        scroll2 = scroll1;\n        scroll1 = containerAnimation ? scrollFunc() : scroll;\n\n        if (snap) {\n          snap2 = snap1;\n          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n        }\n      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n\n\n      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll  (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);\n\n      if (clipped !== prevProgress && self.enabled) {\n        isActive = self.isActive = !!clipped && clipped < 1;\n        wasActive = !!prevProgress && prevProgress < 1;\n        toggled = isActive !== wasActive;\n        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\n\n        self.direction = clipped > prevProgress ? 1 : -1;\n        self.progress = clipped;\n\n        if (stateChanged && !_refreshing) {\n          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\n\n          if (isToggle) {\n            action = !toggled && toggleActions[toggleState  1] !== \"none\" && toggleActions[toggleState  1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\n\n            isTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\n          }\n        }\n\n        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {\n          return t.endAnimation();\n        }));\n\n        if (!isToggle) {\n          if (scrubTween && !_refreshing && !_startup) {\n            (containerAnimation || _primary && _primary !== self) && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.\n\n            if (scrubTween.resetTo) {\n              scrubTween.resetTo(\"totalProgress\", clipped, animation._tTime / animation._tDur);\n            } else {\n              // legacy support (courtesy), before 3.10.0\n              scrubTween.vars.totalProgress = clipped;\n              scrubTween.invalidate().restart();\n            }\n          } else if (animation) {\n            animation.totalProgress(clipped, !!_refreshing);\n          }\n        }\n\n        if (pin) {\n          reset && pinSpacing && (spacer.style[pinSpacing  direction.os2] = spacingStart);\n\n          if (!useFixedPosition) {\n            pinSetter(_round(pinStart  pinChange * clipped));\n          } else if (stateChanged) {\n            isAtMax = !reset && clipped > prevProgress && end  1 > scroll && scroll  1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n\n            if (pinReparent) {\n              if (!reset && (isActive || isAtMax)) {\n                var bounds = _getBounds(pin, true),\n                    _offset = scroll - start;\n\n                _reparent(pin, _body, bounds.top  (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _offset : 0)  _px, bounds.left  (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? 0 : _offset)  _px);\n              } else {\n                _reparent(pin, spacer);\n              }\n            }\n\n            _setState(isActive || isAtMax ? pinActiveState : pinState);\n\n            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart  (clipped === 1 && !isAtMax ? pinChange : 0));\n          }\n        }\n\n        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {\n          return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\n        }); // classes could affect positioning, so do it even if reset or refreshing is true.\n\n        onUpdate && !isToggle && !reset && onUpdate(self);\n\n        if (stateChanged && !_refreshing) {\n          if (isToggle) {\n            if (isTakingAction) {\n              if (action === \"complete\") {\n                animation.pause().totalProgress(1);\n              } else if (action === \"reset\") {\n                animation.restart(true).pause();\n              } else if (action === \"restart\") {\n                animation.restart(true);\n              } else {\n                animation[action]();\n              }\n            }\n\n            onUpdate && onUpdate(self);\n          }\n\n          if (toggled || !_limitCallbacks) {\n            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\n            onToggle && toggled && _callback(self, onToggle);\n            callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.\n\n            if (!toggled) {\n              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n              toggleState = clipped === 1 ? 1 : 3;\n              callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n            }\n          }\n\n          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\n            _endAnimation(self.callbackAnimation);\n\n            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, !clipped, 1);\n          }\n        } else if (isToggle && onUpdate && !_refreshing) {\n          onUpdate(self);\n        }\n      } // update absolutely-positioned markers (only if the scroller isn't the viewport)\n\n\n      if (markerEndSetter) {\n        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\n        markerStartSetter(n  (markerStartTrigger._isFlipped ? 1 : 0));\n        markerEndSetter(n);\n      }\n\n      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\n    };\n\n    self.enable = function (reset, refresh) {\n      if (!self.enabled) {\n        self.enabled = true;\n\n        _addListener(scroller, \"resize\", _onResize);\n\n        _addListener(isViewport ? _doc : scroller, \"scroll\", _onScroll);\n\n        onRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\n        if (reset !== false) {\n          self.progress = prevProgress = 0;\n          scroll1 = scroll2 = lastSnap = scrollFunc();\n        }\n\n        refresh !== false && self.refresh();\n      }\n    };\n\n    self.getTween = function (snap) {\n      return snap && tweenTo ? tweenTo.tween : scrubTween;\n    };\n\n    self.setPositions = function (newStart, newEnd) {\n      // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()\n      if (pin) {\n        pinStart = newStart - start;\n        pinChange = newEnd - newStart - change;\n      }\n\n      self.start = start = newStart;\n      self.end = end = newEnd;\n      change = newEnd - newStart;\n      self.update();\n    };\n\n    self.disable = function (reset, allowAnimation) {\n      if (self.enabled) {\n        reset !== false && self.revert();\n        self.enabled = self.isActive = false;\n        allowAnimation || scrubTween && scrubTween.pause();\n        prevScroll = 0;\n        pinCache && (pinCache.uncache = 1);\n        onRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\n\n        if (snapDelayedCall) {\n          snapDelayedCall.pause();\n          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n        }\n\n        if (!isViewport) {\n          var i = _triggers.length;\n\n          while (i--) {\n            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n              return; //don't remove the listeners if there are still other triggers referencing it.\n            }\n          }\n\n          _removeListener(scroller, \"resize\", _onResize);\n\n          _removeListener(scroller, \"scroll\", _onScroll);\n        }\n      }\n    };\n\n    self.kill = function (revert, allowAnimation) {\n      self.disable(revert, allowAnimation);\n      scrubTween && !allowAnimation && scrubTween.kill();\n      id && delete _ids[id];\n\n      var i = _triggers.indexOf(self);\n\n      i >= 0 && _triggers.splice(i, 1);\n      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n      // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.\n\n      i = 0;\n\n      _triggers.forEach(function (t) {\n        return t.scroller === self.scroller && (i = 1);\n      });\n\n      i || (self.scroll.rec = 0);\n\n      if (animation) {\n        animation.scrollTrigger = null;\n        revert && animation.render(-1);\n        allowAnimation || animation.kill();\n      }\n\n      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\n        return m.parentNode && m.parentNode.removeChild(m);\n      });\n      _primary === self && (_primary = 0);\n\n      if (pin) {\n        pinCache && (pinCache.uncache = 1);\n        i = 0;\n\n        _triggers.forEach(function (t) {\n          return t.pin === pin && i;\n        });\n\n        i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\n      }\n\n      vars.onKill && vars.onKill(self);\n    };\n\n    self.enable(false, false);\n    customRevertReturn && customRevertReturn(self);\n    !animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, function () {\n      return start || end || self.refresh();\n    }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If \"change\" is defined, we know it must be re-enabling, thus we can refresh() right away.\n  };\n\n  ScrollTrigger.register = function register(core) {\n    if (!_coreInitted) {\n      gsap = core || _getGSAP();\n      _windowExists() && window.document && ScrollTrigger.enable();\n      _coreInitted = _enabled;\n    }\n\n    return _coreInitted;\n  };\n\n  ScrollTrigger.defaults = function defaults(config) {\n    if (config) {\n      for (var p in config) {\n        _defaults[p] = config[p];\n      }\n    }\n\n    return _defaults;\n  };\n\n  ScrollTrigger.disable = function disable(reset, kill) {\n    _enabled = 0;\n\n    _triggers.forEach(function (trigger) {\n      return trigger[kill ? \"kill\" : \"disable\"](reset);\n    });\n\n    _removeListener(_win, \"wheel\", _onScroll);\n\n    _removeListener(_doc, \"scroll\", _onScroll);\n\n    clearInterval(_syncInterval);\n\n    _removeListener(_doc, \"touchcancel\", _passThrough);\n\n    _removeListener(_body, \"touchstart\", _passThrough);\n\n    _multiListener(_removeListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n\n    _multiListener(_removeListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n\n    _resizeDelay.kill();\n\n    _iterateAutoRefresh(_removeListener);\n\n    for (var i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i = 3) {\n      _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i  1]);\n\n      _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i  2]);\n    }\n  };\n\n  ScrollTrigger.enable = function enable() {\n    _win = window;\n    _doc = document;\n    _docEl = _doc.documentElement;\n    _body = _doc.body;\n\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _clamp = gsap.utils.clamp;\n      _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n      gsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n\n      if (_body) {\n        _enabled = 1;\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n\n        ScrollTrigger.isTouch = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch;\n        _fixIOSBug = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503\n\n        _addListener(_win, \"wheel\", _onScroll); // mostly for 3rd party smooth scrolling libraries.\n\n\n        _root = [_win, _doc, _docEl, _body];\n        ScrollTrigger.matchMedia({\n          // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.\n          \"(orientation: portrait)\": function orientationPortrait() {\n            _setBaseDimensions();\n\n            return _setBaseDimensions;\n          }\n        });\n\n        _addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\n\n\n        var bodyStyle = _body.style,\n            border = bodyStyle.borderTopStyle,\n            bounds,\n            i;\n        bodyStyle.borderTopStyle = \"solid\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\n\n        bounds = _getBounds(_body);\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.m = Math.round(bounds.top  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.m = Math.round(bounds.left  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.sc()) || 0;\n        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty(\"border-top-style\"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.\n\n        _syncInterval = setInterval(_sync, 250);\n        gsap.delayedCall(0.5, function () {\n          return _startup = 0;\n        });\n\n        _addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\n\n\n        _addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n\n\n        _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n\n        _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n\n        _transformProp = gsap.utils.checkPrefix(\"transform\");\n\n        _stateProps.push(_transformProp);\n\n        _coreInitted = _getTime();\n        _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n        _autoRefresh = [_doc, \"visibilitychange\", function () {\n          var w = _win.innerWidth,\n              h = _win.innerHeight;\n\n          if (_doc.hidden) {\n            _prevWidth = w;\n            _prevHeight = h;\n          } else if (_prevWidth !== w || _prevHeight !== h) {\n            _onResize();\n          }\n        }, _doc, \"DOMContentLoaded\", _refreshAll, _win, \"load\", _refreshAll, _win, \"resize\", _onResize];\n\n        _iterateAutoRefresh(_addListener);\n\n        _triggers.forEach(function (trigger) {\n          return trigger.enable(0, 1);\n        });\n\n        for (i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i = 3) {\n          _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i  1]);\n\n          _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i  2]);\n        }\n      }\n    }\n  };\n\n  ScrollTrigger.config = function config(vars) {\n    \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n    var ms = vars.syncInterval;\n    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n    \"ignoreMobileResize\" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);\n\n    if (\"autoRefreshEvents\" in vars) {\n      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\n      _ignoreResize = (vars.autoRefreshEvents  \"\").indexOf(\"resize\") === -1;\n    }\n  };\n\n  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\n    var t = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(target),\n        i = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.indexOf(t),\n        isViewport = _isViewport(t);\n\n    if (~i) {\n      _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.splice(i, isViewport ? 6 : 2);\n    }\n\n    if (vars) {\n      isViewport ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(t, vars);\n    }\n  };\n\n  ScrollTrigger.matchMedia = function matchMedia(vars) {\n    // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8\n    var mq, p, i, func, result;\n\n    for (p in vars) {\n      i = _media.indexOf(p);\n      func = vars[p];\n      _creatingMedia = p;\n\n      if (p === \"all\") {\n        func();\n      } else {\n        mq = _win.matchMedia(p);\n\n        if (mq) {\n          mq.matches && (result = func());\n\n          if (~i) {\n            _media[i  1] = _combineFunc(_media[i  1], func);\n            _media[i  2] = _combineFunc(_media[i  2], result);\n          } else {\n            i = _media.length;\n\n            _media.push(p, func, result);\n\n            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n          }\n\n          _media[i  3] = mq.matches;\n        }\n      }\n\n      _creatingMedia = 0;\n    }\n\n    return _media;\n  };\n\n  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {\n    query || (_media.length = 0);\n    query = _media.indexOf(query);\n    query >= 0 && _media.splice(query, 4);\n  };\n\n  ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {\n    var bounds = (_isString(element) ? (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element) : element).getBoundingClientRect(),\n        offset = bounds[horizontal ? _width : _height] * ratio || 0;\n    return horizontal ? bounds.right - offset > 0 && bounds.left  offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top  offset < _win.innerHeight;\n  };\n\n  ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {\n    _isString(element) && (element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element));\n    var bounds = element.getBoundingClientRect(),\n        size = bounds[horizontal ? _width : _height],\n        offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;\n    return horizontal ? (bounds.left  offset) / _win.innerWidth : (bounds.top  offset) / _win.innerHeight;\n  };\n\n  return ScrollTrigger;\n}();\nScrollTrigger.version = \"3.10.4\";\n\nScrollTrigger.saveStyles = function (targets) {\n  return targets ? _toArray(targets).forEach(function (target) {\n    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]\n    if (target && target.style) {\n      var i = _savedStyles.indexOf(target);\n\n      i >= 0 && _savedStyles.splice(i, 5);\n\n      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _creatingMedia);\n    }\n  }) : _savedStyles;\n};\n\nScrollTrigger.revert = function (soft, media) {\n  return _revertAll(!soft, media);\n};\n\nScrollTrigger.create = function (vars, animation) {\n  return new ScrollTrigger(vars, animation);\n};\n\nScrollTrigger.refresh = function (safe) {\n  return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\n};\n\nScrollTrigger.update = _updateAll;\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\n\nScrollTrigger.maxScroll = function (element, horizontal) {\n  return _maxScroll(element, horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\n\nScrollTrigger.getScrollFunc = function (element, horizontal) {\n  return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element), horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n};\n\nScrollTrigger.getById = function (id) {\n  return _ids[id];\n};\n\nScrollTrigger.getAll = function () {\n  return _triggers.filter(function (t) {\n    return t.vars.id !== \"ScrollSmoother\";\n  });\n}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.\n\n\nScrollTrigger.isScrolling = function () {\n  return !!_lastScrollTime;\n};\n\nScrollTrigger.snapDirectional = _snapDirectional;\n\nScrollTrigger.addEventListener = function (type, callback) {\n  var a = _listeners[type] || (_listeners[type] = []);\n  ~a.indexOf(callback) || a.push(callback);\n};\n\nScrollTrigger.removeEventListener = function (type, callback) {\n  var a = _listeners[type],\n      i = a && a.indexOf(callback);\n  i >= 0 && a.splice(i, 1);\n};\n\nScrollTrigger.batch = function (targets, vars) {\n  var result = [],\n      varsCopy = {},\n      interval = vars.interval || 0.016,\n      batchMax = vars.batchMax || 1e9,\n      proxyCallback = function proxyCallback(type, callback) {\n    var elements = [],\n        triggers = [],\n        delay = gsap.delayedCall(interval, function () {\n      callback(elements, triggers);\n      elements = [];\n      triggers = [];\n    }).pause();\n    return function (self) {\n      elements.length || delay.restart(true);\n      elements.push(self.trigger);\n      triggers.push(self);\n      batchMax <= elements.length && delay.progress(1);\n    };\n  },\n      p;\n\n  for (p in vars) {\n    varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\n  }\n\n  if (_isFunction(batchMax)) {\n    batchMax = batchMax();\n\n    _addListener(ScrollTrigger, \"refresh\", function () {\n      return batchMax = vars.batchMax();\n    });\n  }\n\n  _toArray(targets).forEach(function (target) {\n    var config = {};\n\n    for (p in varsCopy) {\n      config[p] = varsCopy[p];\n    }\n\n    config.trigger = target;\n    result.push(ScrollTrigger.create(config));\n  });\n\n  return result;\n}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).\n\n\nvar _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {\n  current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);\n  return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;\n},\n    _allowNativePanning = function _allowNativePanning(target, direction) {\n  if (direction === true) {\n    target.style.removeProperty(\"touch-action\");\n  } else {\n    target.style.touchAction = direction === true ? \"auto\" : direction ? \"pan-\"  direction  (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch ? \" pinch-zoom\" : \"\") : \"none\"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.\n  }\n\n  target === _docEl && _allowNativePanning(_body, direction);\n},\n    _overflow = {\n  auto: 1,\n  scroll: 1\n},\n    _nestedScroll = function _nestedScroll(_ref5) {\n  var event = _ref5.event,\n      target = _ref5.target,\n      axis = _ref5.axis;\n\n  var node = (event.changedTouches ? event.changedTouches[0] : event).target,\n      cache = node._gsap || gsap.core.getCache(node),\n      time = _getTime(),\n      cs;\n\n  if (!cache._isScrollT || time - cache._isScrollT > 2000) {\n    // cache for 2 seconds to improve performance.\n    while (node && node.scrollHeight <= node.clientHeight) {\n      node = node.parentNode;\n    }\n\n    cache._isScroll = node && !_isViewport(node) && node !== target && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);\n    cache._isScrollT = time;\n  }\n\n  (cache._isScroll || axis === \"x\") && (event._gsapAllow = true);\n},\n    // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor\n_inputObserver = function _inputObserver(target, type, inputs, nested) {\n  return _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.create({\n    target: target,\n    capture: true,\n    debounce: false,\n    lockAxis: true,\n    type: type,\n    onWheel: nested = nested && _nestedScroll,\n    onPress: nested,\n    onDrag: nested,\n    onScroll: nested,\n    onEnable: function onEnable() {\n      return inputs && _addListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, false, true);\n    },\n    onDisable: function onDisable() {\n      return _removeListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, true);\n    }\n  });\n},\n    _inputExp = /(input|label|select|textarea)/i,\n    _inputIsFocused,\n    _captureInputs = function _captureInputs(e) {\n  var isInput = _inputExp.test(e.target.tagName);\n\n  if (isInput || _inputIsFocused) {\n    e._gsapAllow = true;\n    _inputIsFocused = isInput;\n  }\n},\n    _getScrollNormalizer = function _getScrollNormalizer(vars) {\n  _isObject(vars) || (vars = {});\n  vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;\n  vars.type || (vars.type = \"wheel,touch\");\n  vars.debounce = !!vars.debounce;\n  vars.id = vars.id || \"normalizer\";\n\n  var _vars2 = vars,\n      normalizeScrollX = _vars2.normalizeScrollX,\n      momentum = _vars2.momentum,\n      allowNestedScroll = _vars2.allowNestedScroll,\n      self,\n      maxY,\n      target = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.target) || _docEl,\n      smoother = gsap.core.globals().ScrollSmoother,\n      content = _fixIOSBug && (vars.content && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.content) || smoother && smoother.get() && smoother.get().content()),\n      scrollFuncY = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\n      scrollFuncX = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal),\n      scale = 1,\n      initialScale = (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,\n      wheelRefresh = 0,\n      resolveMomentumDuration = _isFunction(momentum) ? function () {\n    return momentum(self);\n  } : function () {\n    return momentum || 2.8;\n  },\n      skipTouchMove,\n      lastRefreshID,\n      inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),\n      resumeTouchMove = function resumeTouchMove() {\n    return skipTouchMove = false;\n  },\n      scrollClampX = _passThrough,\n      scrollClampY = _passThrough,\n      updateClamps = function updateClamps() {\n    maxY = _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\n    scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);\n    normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)));\n    lastRefreshID = _refreshID;\n  },\n      ignoreDrag = function ignoreDrag() {\n    if (skipTouchMove) {\n      requestAnimationFrame(resumeTouchMove); // we MUST wait for a requestAnimationFrame, otherwise iOS will misreport the value.\n\n      var offset = _round(self.deltaY / 2),\n          scroll = scrollClampY(scrollFuncY.v - offset);\n\n      if (content && scroll !== scrollFuncY.v  scrollFuncY.offset) {\n        scrollFuncY.offset = scroll - scrollFuncY.v;\n        content.style.transform = \"translateY(\"  -scrollFuncY.offset  \"px)\";\n        content._gsap && (content._gsap.y = -scrollFuncY.offset  \"px\");\n        scrollFuncY.cacheID = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;\n\n        _updateAll();\n      }\n\n      return true;\n    }\n\n    if (content) {\n      content.style.transform = \"translateY(0px)\";\n      scrollFuncY.offset = scrollFuncY.cacheID = 0;\n      content._gsap && (content._gsap.y = \"0px\");\n    }\n\n    skipTouchMove = true;\n  },\n      tween,\n      startScrollX,\n      startScrollY,\n      onStopDelayedCall,\n      onResize = function onResize() {\n    // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.\n    updateClamps();\n\n    if (tween.isActive() && tween.vars.scrollY > maxY) {\n      scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo(\"scrollY\", maxY);\n    }\n  };\n\n  vars.ignoreCheck = function (e) {\n    return _fixIOSBug && e.type === \"touchmove\" && ignoreDrag(e) || scale > 1.05 && e.type !== \"touchstart\" || self.isGesturing || e.touches && e.touches.length > 1;\n  };\n\n  vars.onPress = function () {\n    var prevScale = scale;\n    scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);\n    tween.pause();\n    prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : \"x\");\n    skipTouchMove = false;\n    startScrollX = scrollFuncX();\n    startScrollY = scrollFuncY();\n    updateClamps();\n    lastRefreshID = _refreshID;\n  };\n\n  vars.onRelease = vars.onGestureStart = function (self, wasDragging) {\n    if (content) {\n      content.style.transform = \"translateY(0px)\";\n      scrollFuncY.offset = scrollFuncY.cacheID = 0;\n      content._gsap && (content._gsap.y = \"0px\");\n    }\n\n    if (!wasDragging) {\n      onStopDelayedCall.restart(true);\n    } else {\n      _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache; // make sure we're pulling the non-cached value\n      // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),\tdur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4  (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)\n\n      var dur = resolveMomentumDuration(),\n          currentScroll,\n          endScroll;\n\n      if (normalizeScrollX) {\n        currentScroll = scrollFuncX();\n        endScroll = currentScroll  dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.\n\n        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal));\n        tween.vars.scrollX = scrollClampX(endScroll);\n      }\n\n      currentScroll = scrollFuncY();\n      endScroll = currentScroll  dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)\n\n      dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical));\n      tween.vars.scrollY = scrollClampY(endScroll);\n      tween.invalidate().duration(dur).play(0.01);\n\n      if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {\n        // iOS bug: it'll show the address bar but NOT fire the window \"resize\" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.\n        gsap.to({}, {\n          onUpdate: onResize,\n          duration: dur\n        });\n      }\n    }\n  };\n\n  vars.onWheel = function () {\n    tween._ts && tween.pause();\n\n    if (_getTime() - wheelRefresh > 1000) {\n      // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.\n      lastRefreshID = 0;\n      wheelRefresh = _getTime();\n    }\n  };\n\n  vars.onChange = function (self, dx, dy, xArray, yArray) {\n    _refreshID !== lastRefreshID && updateClamps();\n    dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX  (self.startX - self.x) : scrollFuncX()  dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.\n\n    dy && scrollFuncY(scrollClampY(yArray[2] === dy ? startScrollY  (self.startY - self.y) : scrollFuncY()  dy - yArray[1]));\n\n    _updateAll();\n  };\n\n  vars.onEnable = function () {\n    _allowNativePanning(target, normalizeScrollX ? false : \"x\");\n\n    _addListener(_win, \"resize\", onResize);\n\n    inputObserver.enable();\n  };\n\n  vars.onDisable = function () {\n    _allowNativePanning(target, true);\n\n    _removeListener(_win, \"resize\", onResize);\n\n    inputObserver.kill();\n  };\n\n  self = new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n  self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.\n\n  _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.\n\n  onStopDelayedCall = self._dc;\n  tween = gsap.to(self, {\n    ease: \"power4\",\n    paused: true,\n    scrollX: normalizeScrollX ? \"=0.1\" : \"=0\",\n    scrollY: \"=0.1\",\n    onComplete: onStopDelayedCall.vars.onComplete\n  });\n  return self;\n};\n\nScrollTrigger.sort = function (func) {\n  return _triggers.sort(func || function (a, b) {\n    return (a.vars.refreshPriority || 0) * -1e6  a.start - (b.start  (b.vars.refreshPriority || 0) * -1e6);\n  });\n};\n\nScrollTrigger.observe = function (vars) {\n  return new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\n};\n\nScrollTrigger.normalizeScroll = function (vars) {\n  if (typeof vars === \"undefined\") {\n    return _normalizer;\n  }\n\n  if (vars === true && _normalizer) {\n    return _normalizer.enable();\n  }\n\n  if (vars === false) {\n    return _normalizer && _normalizer.kill();\n  }\n\n  var normalizer = vars instanceof _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer ? vars : _getScrollNormalizer(vars);\n  _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();\n  _isViewport(normalizer.target) && (_normalizer = normalizer);\n  return normalizer;\n};\n\nScrollTrigger.core = {\n  // smaller file size way to leverage in ScrollSmoother and Observer\n  _getVelocityProp: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getVelocityProp,\n  _inputObserver: _inputObserver,\n  _scrollers: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers,\n  _proxies: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies,\n  bridge: {\n    // when normalizeScroll sets the scroll position (ss = setScroll)\n    ss: function ss() {\n      _lastScrollTime || _dispatch(\"scrollStart\");\n      _lastScrollTime = _getTime();\n    },\n    // a way to get the _refreshing value in Observer\n    ref: function ref() {\n      return _refreshing;\n    }\n  }\n};\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvSjs7QUFFcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsU0FBUywyREFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyREFBYTtBQUMzQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseUJBQXlCLGtEQUFRO0FBQ2pDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyREFBYTtBQUNsRCxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FB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LGFBQWEsa0RBQVE7QUFDckIseUJBQXlCOztBQUV6QixrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsYUFBYSxrREFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxrREFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFnQjtBQUNwQztBQUNBLGNBQWMsb0RBQVU7QUFDeEIsWUFBWSxrREFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2dzYXAvU2Nyb2xsVHJpZ2dlci5qcz8xZGFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogU2Nyb2xsVHJpZ2dlciAzLjEwLjRcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjIsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBPYnNlcnZlciwgX2dldFRhcmdldCwgX3ZlcnRpY2FsLCBfaG9yaXpvbnRhbCwgX3Njcm9sbGVycywgX3Byb3hpZXMsIF9nZXRTY3JvbGxGdW5jLCBfZ2V0UHJveHlQcm9wLCBfZ2V0VmVsb2NpdHlQcm9wIH0gZnJvbSBcIi4vT2JzZXJ2ZXIuanNcIjtcblxudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWwsXG4gICAgX2JvZHksXG4gICAgX3Jvb3QsXG4gICAgX3Jlc2l6ZURlbGF5LFxuICAgIF90b0FycmF5LFxuICAgIF9jbGFtcCxcbiAgICBfdGltZTIsXG4gICAgX3N5bmNJbnRlcnZhbCxcbiAgICBfcmVmcmVzaGluZyxcbiAgICBfcG9pbnRlcklzRG93bixcbiAgICBfdHJhbnNmb3JtUHJvcCxcbiAgICBfaSxcbiAgICBfcHJldldpZHRoLFxuICAgIF9wcmV2SGVpZ2h0LFxuICAgIF9hdXRvUmVmcmVzaCxcbiAgICBfc29ydCxcbiAgICBfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgIF9pZ25vcmVSZXNpemUsXG4gICAgX25vcm1hbGl6ZXIsXG4gICAgX2lnbm9yZU1vYmlsZVJlc2l6ZSxcbiAgICBfYmFzZVNjcmVlbkhlaWdodCxcbiAgICBfYmFzZVNjcmVlbldpZHRoLFxuICAgIF9maXhJT1NCdWcsXG4gICAgX2xpbWl0Q2FsbGJhY2tzLFxuICAgIC8vIGlmIHRydWUsIHdlJ2xsIG9ubHkgdHJpZ2dlciBjYWxsYmFja3MgaWYgdGhlIGFjdGl2ZSBzdGF0ZSB0b2dnbGVzLCBzbyBpZiB5b3Ugc2Nyb2xsIGltbWVkaWF0ZWx5IHBhc3QgYm90aCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgYSBTY3JvbGxUcmlnZ2VyICh0aHVzIGluYWN0aXZlIHRvIGluYWN0aXZlKSwgbmVpdGhlciBpdHMgb25FbnRlciBub3Igb25MZWF2ZSB3aWxsIGJlIGNhbGxlZC4gVGhpcyBpcyB1c2VmdWwgZHVyaW5nIHN0YXJ0dXAuXG5fc3RhcnR1cCA9IDEsXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICBfdGltZTEgPSBfZ2V0VGltZSgpLFxuICAgIF9sYXN0U2Nyb2xsVGltZSA9IDAsXG4gICAgX2VuYWJsZWQgPSAwLFxuICAgIF9wb2ludGVyRG93bkhhbmRsZXIgPSBmdW5jdGlvbiBfcG9pbnRlckRvd25IYW5kbGVyKCkge1xuICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAxO1xufSxcbiAgICBfcG9pbnRlclVwSGFuZGxlciA9IGZ1bmN0aW9uIF9wb2ludGVyVXBIYW5kbGVyKCkge1xuICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAwO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2godikge1xuICByZXR1cm4gdjtcbn0sXG4gICAgX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwO1xufSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9pc1ZpZXdwb3J0ID0gZnVuY3Rpb24gX2lzVmlld3BvcnQoZSkge1xuICByZXR1cm4gISFX3Jvb3QuaW5kZXhPZihlKTtcbn0sXG4gICAgX2dldEJvdW5kc0Z1bmMgPSBmdW5jdGlvbiBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSB7XG4gIHJldHVybiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/IGZ1bmN0aW9uICgpIHtcbiAgICBfd2luT2Zmc2V0cy53aWR0aCA9IF93aW4uaW5uZXJXaWR0aDtcbiAgICBfd2luT2Zmc2V0cy5oZWlnaHQgPSBfd2luLmlubmVySGVpZ2h0O1xuICAgIHJldHVybiBfd2luT2Zmc2V0cztcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldEJvdW5kcyhlbGVtZW50KTtcbiAgfSk7XG59LFxuICAgIF9nZXRTaXplRnVuYyA9IGZ1bmN0aW9uIF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgX3JlZikge1xuICB2YXIgZCA9IF9yZWYuZCxcbiAgICAgIGQyID0gX3JlZi5kMixcbiAgICAgIGEgPSBfcmVmLmE7XG4gIHJldHVybiAoYSA9IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpKSA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYSgpW2RdO1xuICB9IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoaXNWaWV3cG9ydCA/IF93aW5bXCJpbm5lclwiICsgZDJdIDogc2Nyb2xsZXJbXCJjbGllbnRcIiArIGQyXSkgfHwgMDtcbiAgfTtcbn0sXG4gICAgX2dldE9mZnNldHNGdW5jID0gZnVuY3Rpb24gX2dldE9mZnNldHNGdW5jKGVsZW1lbnQsIGlzVmlld3BvcnQpIHtcbiAgcmV0dXJuICFpc1ZpZXdwb3J0IHx8IH5fcHJveGllcy5pbmRleE9mKGVsZW1lbnQpID8gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF93aW5PZmZzZXRzO1xuICB9O1xufSxcbiAgICBfbWF4U2Nyb2xsID0gZnVuY3Rpb24gX21heFNjcm9sbChlbGVtZW50LCBfcmVmMikge1xuICB2YXIgcyA9IF9yZWYyLnMsXG4gICAgICBkMiA9IF9yZWYyLmQyLFxuICAgICAgZCA9IF9yZWYyLmQsXG4gICAgICBhID0gX3JlZjIuYTtcbiAgcmV0dXJuIChzID0gXCJzY3JvbGxcIiArIGQyKSAmJiAoYSA9IF9nZXRQcm94eVByb3AoZWxlbWVudCwgcykpID8gYSgpIC0gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkoKVtkXSA6IF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gKF9kb2NFbFtzXSB8fCBfYm9keVtzXSkgLSAoX3dpbltcImlubmVyXCIgKyBkMl0gfHwgX2RvY0VsW1wiY2xpZW50XCIgKyBkMl0gfHwgX2JvZHlbXCJjbGllbnRcIiArIGQyXSkgOiBlbGVtZW50W3NdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdO1xufSxcbiAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoID0gZnVuY3Rpb24gX2l0ZXJhdGVBdXRvUmVmcmVzaChmdW5jLCBldmVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYXV0b1JlZnJlc2gubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAoIWV2ZW50cyB8fCBZXZlbnRzLmluZGV4T2YoX2F1dG9SZWZyZXNoW2kgKyAxXSkpICYmIGZ1bmMoX2F1dG9SZWZyZXNoW2ldLCBfYXV0b1JlZnJlc2hbaSArIDFdLCBfYXV0b1JlZnJlc2hbaSArIDJdKTtcbiAgfVxufSxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2NhbGxJZkZ1bmMgPSBmdW5jdGlvbiBfY2FsbElmRnVuYyh2YWx1ZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpICYmIHZhbHVlKCk7XG59LFxuICAgIF9jb21iaW5lRnVuYyA9IGZ1bmN0aW9uIF9jb21iaW5lRnVuYyhmMSwgZjIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0MSA9IF9jYWxsSWZGdW5jKGYxKSxcbiAgICAgICAgcmVzdWx0MiA9IF9jYWxsSWZGdW5jKGYyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfY2FsbElmRnVuYyhyZXN1bHQxKTtcblxuICAgICAgX2NhbGxJZkZ1bmMocmVzdWx0Mik7XG4gICAgfTtcbiAgfTtcbn0sXG4gICAgX2VuZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCByZXZlcnNlZCwgcGF1c2UpIHtcbiAgcmV0dXJuIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucHJvZ3Jlc3MocmV2ZXJzZWQgPyAwIDogMSkgJiYgcGF1c2UgJiYgYW5pbWF0aW9uLnBhdXNlKCk7XG59LFxuICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIF9jYWxsYmFjayhzZWxmLCBmdW5jKSB7XG4gIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuYyhzZWxmKTtcbiAgICByZXN1bHQgJiYgcmVzdWx0LnRvdGFsVGltZSAmJiAoc2VsZi5jYWxsYmFja0FuaW1hdGlvbiA9IHJlc3VsdCk7XG4gIH1cbn0sXG4gICAgX2FicyA9IE1hdGguYWJzLFxuICAgIF9zY3JvbGxMZWZ0ID0gXCJzY3JvbGxMZWZ0XCIsXG4gICAgX3Njcm9sbFRvcCA9IFwic2Nyb2xsVG9wXCIsXG4gICAgX2xlZnQgPSBcImxlZnRcIixcbiAgICBfdG9wID0gXCJ0b3BcIixcbiAgICBfcmlnaHQgPSBcInJpZ2h0XCIsXG4gICAgX2JvdHRvbSA9IFwiYm90dG9tXCIsXG4gICAgX3dpZHRoID0gXCJ3aWR0aFwiLFxuICAgIF9oZWlnaHQgPSBcImhlaWdodFwiLFxuICAgIF9SaWdodCA9IFwiUmlnaHRcIixcbiAgICBfTGVmdCA9IFwiTGVmdFwiLFxuICAgIF9Ub3AgPSBcIlRvcFwiLFxuICAgIF9Cb3R0b20gPSBcIkJvdHRvbVwiLFxuICAgIF9wYWRkaW5nID0gXCJwYWRkaW5nXCIsXG4gICAgX21hcmdpbiA9IFwibWFyZ2luXCIsXG4gICAgX1dpZHRoID0gXCJXaWR0aFwiLFxuICAgIF9IZWlnaHQgPSBcIkhlaWdodFwiLFxuICAgIF9weCA9IFwicHhcIixcbiAgICBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0sXG4gICAgX21ha2VQb3NpdGlvbmFibGUgPSBmdW5jdGlvbiBfbWFrZVBvc2l0aW9uYWJsZShlbGVtZW50KSB7XG4gIC8vIGlmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIHBvc2l0aW9uOiBhYnNvbHV0ZSBvciBmaXhlZCwgbGVhdmUgdGhhdCwgb3RoZXJ3aXNlIG1ha2UgaXQgcG9zaXRpb246IHJlbGF0aXZlXG4gIHZhciBwb3NpdGlvbiA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uO1xuXG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBwb3NpdGlvbiA6IFwicmVsYXRpdmVcIjtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfZ2V0Qm91bmRzID0gZnVuY3Rpb24gX2dldEJvdW5kcyhlbGVtZW50LCB3aXRob3V0VHJhbnNmb3Jtcykge1xuICB2YXIgdHdlZW4gPSB3aXRob3V0VHJhbnNmb3JtcyAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gIT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIgJiYgZ3NhcC50byhlbGVtZW50LCB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHhQZXJjZW50OiAwLFxuICAgIHlQZXJjZW50OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHJvdGF0aW9uWDogMCxcbiAgICByb3RhdGlvblk6IDAsXG4gICAgc2NhbGU6IDEsXG4gICAgc2tld1g6IDAsXG4gICAgc2tld1k6IDBcbiAgfSkucHJvZ3Jlc3MoMSksXG4gICAgICBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB0d2VlbiAmJiB0d2Vlbi5wcm9ncmVzcygwKS5raWxsKCk7XG4gIHJldHVybiBib3VuZHM7XG59LFxuICAgIF9nZXRTaXplID0gZnVuY3Rpb24gX2dldFNpemUoZWxlbWVudCwgX3JlZjMpIHtcbiAgdmFyIGQyID0gX3JlZjMuZDI7XG4gIHJldHVybiBlbGVtZW50W1wib2Zmc2V0XCIgKyBkMl0gfHwgZWxlbWVudFtcImNsaWVudFwiICsgZDJdIHx8IDA7XG59LFxuICAgIF9nZXRMYWJlbFJhdGlvQXJyYXkgPSBmdW5jdGlvbiBfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSB7XG4gIHZhciBhID0gW10sXG4gICAgICBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBkdXJhdGlvbiA9IHRpbWVsaW5lLmR1cmF0aW9uKCksXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICBhLnB1c2gobGFiZWxzW3BdIC8gZHVyYXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59LFxuICAgIF9nZXRDbG9zZXN0TGFiZWwgPSBmdW5jdGlvbiBfZ2V0Q2xvc2VzdExhYmVsKGFuaW1hdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdzYXAudXRpbHMuc25hcChfZ2V0TGFiZWxSYXRpb0FycmF5KGFuaW1hdGlvbiksIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgX3NuYXBEaXJlY3Rpb25hbCA9IGZ1bmN0aW9uIF9zbmFwRGlyZWN0aW9uYWwoc25hcEluY3JlbWVudE9yQXJyYXkpIHtcbiAgdmFyIHNuYXAgPSBnc2FwLnV0aWxzLnNuYXAoc25hcEluY3JlbWVudE9yQXJyYXkpLFxuICAgICAgYSA9IEFycmF5LmlzQXJyYXkoc25hcEluY3JlbWVudE9yQXJyYXkpICYmIHNuYXBJbmNyZW1lbnRPckFycmF5LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICByZXR1cm4gYSA/IGZ1bmN0aW9uICh2YWx1ZSwgZGlyZWN0aW9uLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDFlLTM7XG4gICAgfVxuXG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIHNuYXAodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICB2YWx1ZSAtPSB0aHJlc2hvbGQ7IC8vIHRvIGF2b2lkIHJvdW5kaW5nIGVycm9ycy4gSWYgd2UncmUgdG9vIHN0cmljdCwgaXQgbWlnaHQgc25hcCBmb3J3YXJkLCB0aGVuIGltbWVkaWF0ZWx5IGFnYWluLCBhbmQgYWdhaW4uXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldID49IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGFbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFbaSAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gYS5sZW5ndGg7XG4gICAgICB2YWx1ZSArPSB0aHJlc2hvbGQ7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGFbaV0gPD0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhWzBdO1xuICB9IDogZnVuY3Rpb24gKHZhbHVlLCBkaXJlY3Rpb24sIHRocmVzaG9sZCkge1xuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMWUtMztcbiAgICB9XG5cbiAgICB2YXIgc25hcHBlZCA9IHNuYXAodmFsdWUpO1xuICAgIHJldHVybiAhZGlyZWN0aW9uIHx8IE1hdGguYWJzKHNuYXBwZWQgLSB2YWx1ZSkgPCB0aHJlc2hvbGQgfHwgc25hcHBlZCAtIHZhbHVlIDwgMCA9PT0gZGlyZWN0aW9uIDwgMCA/IHNuYXBwZWQgOiBzbmFwKGRpcmVjdGlvbiA8IDAgPyB2YWx1ZSAtIHNuYXBJbmNyZW1lbnRPckFycmF5IDogdmFsdWUgKyBzbmFwSW5jcmVtZW50T3JBcnJheSk7XG4gIH07XG59LFxuICAgIF9nZXRMYWJlbEF0RGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsQXREaXJlY3Rpb24odGltZWxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgc3QpIHtcbiAgICByZXR1cm4gX3NuYXBEaXJlY3Rpb25hbChfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSkodmFsdWUsIHN0LmRpcmVjdGlvbik7XG4gIH07XG59LFxuICAgIF9tdWx0aUxpc3RlbmVyID0gZnVuY3Rpb24gX211bHRpTGlzdGVuZXIoZnVuYywgZWxlbWVudCwgdHlwZXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0eXBlcy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBmdW5jKGVsZW1lbnQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgfSk7XG59LFxuICAgIF9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBub25QYXNzaXZlLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywge1xuICAgIHBhc3NpdmU6ICFub25QYXNzaXZlLFxuICAgIGNhcHR1cmU6ICEhY2FwdHVyZVxuICB9KTtcbn0sXG4gICAgX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCAhIWNhcHR1cmUpO1xufSxcbiAgICBfd2hlZWxMaXN0ZW5lciA9IGZ1bmN0aW9uIF93aGVlbExpc3RlbmVyKGZ1bmMsIGVsLCBzY3JvbGxGdW5jKSB7XG4gIHJldHVybiBzY3JvbGxGdW5jICYmIHNjcm9sbEZ1bmMud2hlZWxIYW5kbGVyICYmIGZ1bmMoZWwsIFwid2hlZWxcIiwgc2Nyb2xsRnVuYyk7XG59LFxuICAgIF9tYXJrZXJEZWZhdWx0cyA9IHtcbiAgc3RhcnRDb2xvcjogXCJncmVlblwiLFxuICBlbmRDb2xvcjogXCJyZWRcIixcbiAgaW5kZW50OiAwLFxuICBmb250U2l6ZTogXCIxNnB4XCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCJcbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICB0b2dnbGVBY3Rpb25zOiBcInBsYXlcIixcbiAgYW50aWNpcGF0ZVBpbjogMFxufSxcbiAgICBfa2V5d29yZHMgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgY2VudGVyOiAwLjUsXG4gIGJvdHRvbTogMSxcbiAgcmlnaHQ6IDFcbn0sXG4gICAgX29mZnNldFRvUHggPSBmdW5jdGlvbiBfb2Zmc2V0VG9QeCh2YWx1ZSwgc2l6ZSkge1xuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBlcUluZGV4ID0gdmFsdWUuaW5kZXhPZihcIj1cIiksXG4gICAgICAgIHJlbGF0aXZlID0gfmVxSW5kZXggPyArKHZhbHVlLmNoYXJBdChlcUluZGV4IC0gMSkgKyAxKSAqIHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKGVxSW5kZXggKyAxKSkgOiAwO1xuXG4gICAgaWYgKH5lcUluZGV4KSB7XG4gICAgICB2YWx1ZS5pbmRleE9mKFwiJVwiKSAIGVxSW5kZXggJiYgKHJlbGF0aXZlICo9IHNpemUgLyAxMDApO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgZXFJbmRleCAtIDEpO1xuICAgIH1cblxuICAgIHZhbHVlID0gcmVsYXRpdmUgKyAodmFsdWUgaW4gX2tleXdvcmRzID8gX2tleXdvcmRzW3ZhbHVlXSAqIHNpemUgOiBdmFsdWUuaW5kZXhPZihcIiVcIikgPyBwYXJzZUZsb2F0KHZhbHVlKSAqIHNpemUgLyAxMDAgOiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn0sXG4gICAgX2NyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIF9jcmVhdGVNYXJrZXIodHlwZSwgbmFtZSwgY29udGFpbmVyLCBkaXJlY3Rpb24sIF9yZWY0LCBvZmZzZXQsIG1hdGNoV2lkdGhFbCwgY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gIHZhciBzdGFydENvbG9yID0gX3JlZjQuc3RhcnRDb2xvcixcbiAgICAgIGVuZENvbG9yID0gX3JlZjQuZW5kQ29sb3IsXG4gICAgICBmb250U2l6ZSA9IF9yZWY0LmZvbnRTaXplLFxuICAgICAgaW5kZW50ID0gX3JlZjQuaW5kZW50LFxuICAgICAgZm9udFdlaWdodCA9IF9yZWY0LmZvbnRXZWlnaHQ7XG5cbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICB1c2VGaXhlZFBvc2l0aW9uID0gX2lzVmlld3BvcnQoY29udGFpbmVyKSB8fCBfZ2V0UHJveHlQcm9wKGNvbnRhaW5lciwgXCJwaW5UeXBlXCIpID09PSBcImZpeGVkXCIsXG4gICAgICBpc1Njcm9sbGVyID0gdHlwZS5pbmRleE9mKFwic2Nyb2xsZXJcIikgIT09IC0xLFxuICAgICAgcGFyZW50ID0gdXNlRml4ZWRQb3NpdGlvbiA/IF9ib2R5IDogY29udGFpbmVyLFxuICAgICAgaXNTdGFydCA9IHR5cGUuaW5kZXhPZihcInN0YXJ0XCIpICE9PSAtMSxcbiAgICAgIGNvbG9yID0gaXNTdGFydCA/IHN0YXJ0Q29sb3IgOiBlbmRDb2xvcixcbiAgICAgIGNzcyA9IFwiYm9yZGVyLWNvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXNpemU6XCIgKyBmb250U2l6ZSArIFwiO2NvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXdlaWdodDpcIiArIGZvbnRXZWlnaHQgKyBcIjtwb2ludGVyLWV2ZW50czpub25lO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpzYW5zLXNlcmlmLEFyaWFsO3otaW5kZXg6MTAwMDtwYWRkaW5nOjRweCA4cHg7Ym9yZGVyLXdpZHRoOjA7Ym9yZGVyLXN0eWxlOnNvbGlkO1wiO1xuXG4gIGNzcyArPSBcInBvc2l0aW9uOlwiICsgKChpc1Njcm9sbGVyIHx8IGNvbnRhaW5lckFuaW1hdGlvbikgJiYgdXNlRml4ZWRQb3NpdGlvbiA/IFwiZml4ZWQ7XCIgOiBcImFic29sdXRlO1wiKTtcbiAgKGlzU2Nyb2xsZXIgfHwgY29udGFpbmVyQW5pbWF0aW9uIHx8ICF1c2VGaXhlZFBvc2l0aW9uKSAmJiAoY3NzICs9IChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IF9yaWdodCA6IF9ib3R0b20pICsgXCI6XCIgKyAob2Zmc2V0ICsgcGFyc2VGbG9hdChpbmRlbnQpKSArIFwicHg7XCIpO1xuICBtYXRjaFdpZHRoRWwgJiYgKGNzcyArPSBcImJveC1zaXppbmc6Ym9yZGVyLWJveDt0ZXh0LWFsaWduOmxlZnQ7d2lkdGg6XCIgKyBtYXRjaFdpZHRoRWwub2Zmc2V0V2lkdGggKyBcInB4O1wiKTtcbiAgZS5faXNTdGFydCA9IGlzU3RhcnQ7XG4gIGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJnc2FwLW1hcmtlci1cIiArIHR5cGUgKyAobmFtZSA/IFwiIG1hcmtlci1cIiArIG5hbWUgOiBcIlwiKSk7XG4gIGUuc3R5bGUuY3NzVGV4dCA9IGNzcztcbiAgZS5pbm5lclRleHQgPSBuYW1lIHx8IG5hbWUgPT09IDAgPyB0eXBlICsgXCItXCIgKyBuYW1lIDogdHlwZTtcbiAgcGFyZW50LmNoaWxkcmVuWzBdID8gcGFyZW50Lmluc2VydEJlZm9yZShlLCBwYXJlbnQuY2hpbGRyZW5bMF0pIDogcGFyZW50LmFwcGVuZENoaWxkKGUpO1xuICBlLl9vZmZzZXQgPSBlW1wib2Zmc2V0XCIgKyBkaXJlY3Rpb24ub3AuZDJdO1xuXG4gIF9wb3NpdGlvbk1hcmtlcihlLCAwLCBkaXJlY3Rpb24sIGlzU3RhcnQpO1xuXG4gIHJldHVybiBlO1xufSxcbiAgICBfcG9zaXRpb25NYXJrZXIgPSBmdW5jdGlvbiBfcG9zaXRpb25NYXJrZXIobWFya2VyLCBzdGFydCwgZGlyZWN0aW9uLCBmbGlwcGVkKSB7XG4gIHZhciB2YXJzID0ge1xuICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICB9LFxuICAgICAgc2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJvczJcIiA6IFwicDJcIl0sXG4gICAgICBvcHBvc2l0ZVNpZGUgPSBkaXJlY3Rpb25bZmxpcHBlZCA/IFwicDJcIiA6IFwib3MyXCJdO1xuICBtYXJrZXIuX2lzRmxpcHBlZCA9IGZsaXBwZWQ7XG4gIHZhcnNbZGlyZWN0aW9uLmEgKyBcIlBlcmNlbnRcIl0gPSBmbGlwcGVkID8gLTEwMCA6IDA7XG4gIHZhcnNbZGlyZWN0aW9uLmFdID0gZmxpcHBlZCA/IFwiMXB4XCIgOiAwO1xuICB2YXJzW1wiYm9yZGVyXCIgKyBzaWRlICsgX1dpZHRoXSA9IDE7XG4gIHZhcnNbXCJib3JkZXJcIiArIG9wcG9zaXRlU2lkZSArIF9XaWR0aF0gPSAwO1xuICB2YXJzW2RpcmVjdGlvbi5wXSA9IHN0YXJ0ICsgXCJweFwiO1xuICBnc2FwLnNldChtYXJrZXIsIHZhcnMpO1xufSxcbiAgICBfdHJpZ2dlcnMgPSBbXSxcbiAgICBfaWRzID0ge30sXG4gICAgX3JhZklELFxuICAgIF9zeW5jID0gZnVuY3Rpb24gX3N5bmMoKSB7XG4gIHJldHVybiBfZ2V0VGltZSgpIC0gX2xhc3RTY3JvbGxUaW1lID4gMzQgJiYgX3VwZGF0ZUFsbCgpO1xufSxcbiAgICBfb25TY3JvbGwgPSBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gIC8vIHByZXZpb3VzbHksIHdlIHRyaWVkIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIGJ5IGJhdGNoaW5nL2RlZmVycmluZyB0byB0aGUgbmV4dCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSwgYnV0IGRpc2NvdmVyZWQgdGhhdCBTYWZhcmkgaGFzIGEgZmV3IGJ1Z3MgdGhhdCBtYWtlIHRoaXMgdW53b3JrYWJsZSAoZXNwZWNpYWxseSBvbiBpT1MpLiBTZWUgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vMTZjNDM1YjEyZWYwOWMzODEyNTIwNDgxOGU3YjQ1ZmM/ZWRpdG9ycz0wMDEwIGFuZCBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9Kak94WXBRLzNkZDY1Y2NlYzVhNjBmMWQ4NjJjMzU1ZDg0ZDE0NTYyP2VkaXRvcnM9MDAxMCBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vRXhiclBOYS8wODdjZWYxOTdkYzM1NDQ1YTA5NTFlODkzNWM0MTUwMz9lZGl0b3JzPTAwMTBcbiAgaWYgKCFfbm9ybWFsaXplciB8fCAhX25vcm1hbGl6ZXIuaXNQcmVzc2VkIHx8IF9ub3JtYWxpemVyLnN0YXJ0WCAIF9ib2R5LmNsaWVudFdpZHRoKSB7XG4gICAgLy8gaWYgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIHNjcm9sbGJhciwgYWxsb3cgaXQuXG4gICAgX3Njcm9sbGVycy5jYWNoZSsrO1xuICAgIF9yYWZJRCB8fCAoX3JhZklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF91cGRhdGVBbGwpKTtcbiAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XG4gICAgX2xhc3RTY3JvbGxUaW1lID0gX2dldFRpbWUoKTtcbiAgfVxufSxcbiAgICBfc2V0QmFzZURpbWVuc2lvbnMgPSBmdW5jdGlvbiBfc2V0QmFzZURpbWVuc2lvbnMoKSB7XG4gIF9iYXNlU2NyZWVuV2lkdGggPSBfd2luLmlubmVyV2lkdGg7XG4gIF9iYXNlU2NyZWVuSGVpZ2h0ID0gX3dpbi5pbm5lckhlaWdodDtcbn0sXG4gICAgX29uUmVzaXplID0gZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gICFfcmVmcmVzaGluZyAmJiAhX2lnbm9yZVJlc2l6ZSAmJiAhX2RvYy5mdWxsc2NyZWVuRWxlbWVudCAmJiAhX2RvYy53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCAmJiAoIV9pZ25vcmVNb2JpbGVSZXNpemUgfHwgX2Jhc2VTY3JlZW5XaWR0aCAhPT0gX3dpbi5pbm5lcldpZHRoIHx8IE1hdGguYWJzKF93aW4uaW5uZXJIZWlnaHQgLSBfYmFzZVNjcmVlbkhlaWdodCkgPiBfd2luLmlubmVySGVpZ2h0ICogMC4yNSkgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSk7XG59LFxuICAgIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcbl9saXN0ZW5lcnMgPSB7fSxcbiAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgIF9tZWRpYSA9IFtdLFxuICAgIF9jcmVhdGluZ01lZGlhLFxuICAgIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhKCkgaXMgY2FsbGVkLCB3ZSByZWNvcmQgdGhlIGN1cnJlbnQgbWVkaWEga2V5IGhlcmUgKGxpa2UgXCIobWluLXdpZHRoOiA4MDBweClcIikgc28gdGhhdCB3ZSBjYW4gYXNzaWduIGl0IHRvIGV2ZXJ5dGhpbmcgdGhhdCdzIGNyZWF0ZWQgZHVyaW5nIHRoYXQgY2FsbC4gVGhlbiB3ZSBjYW4gcmV2ZXJ0IGp1c3QgdGhvc2Ugd2hlbiBuZWNlc3NhcnkuIEluIHRoZSBTY3JvbGxUcmlnZ2VyJ3MgaW5pdCgpIGNhbGwsIHRoZSBfY3JlYXRpbmdNZWRpYSBpcyByZWNvcmRlZCBhcyBhIFwibWVkaWFcIiBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2UuXG5fbGFzdE1lZGlhVGljayxcbiAgICBfb25NZWRpYUNoYW5nZSA9IGZ1bmN0aW9uIF9vbk1lZGlhQ2hhbmdlKGUpIHtcbiAgdmFyIHRpY2sgPSBnc2FwLnRpY2tlci5mcmFtZSxcbiAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgaW5kZXg7XG5cbiAgaWYgKF9sYXN0TWVkaWFUaWNrICE9PSB0aWNrIHx8IF9zdGFydHVwKSB7XG4gICAgX3JldmVydEFsbCgpO1xuXG4gICAgZm9yICg7IGkgPCBfbWVkaWEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGluZGV4ID0gX3dpbi5tYXRjaE1lZGlhKF9tZWRpYVtpXSkubWF0Y2hlcztcblxuICAgICAgaWYgKGluZGV4ICE9PSBfbWVkaWFbaSArIDNdKSB7XG4gICAgICAgIC8vIG5vdGU6IHNvbWUgYnJvd3NlcnMgZmlyZSB0aGUgbWF0Y2hNZWRpYSBldmVudCBtdWx0aXBsZSB0aW1lcywgbGlrZSB3aGVuIGdvaW5nIGZ1bGwgc2NyZWVuLCBzbyB3ZSBzaG91bGRuJ3QgY2FsbCB0aGUgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMuIENoZWNrIHRvIHNlZSBpZiBpdCdzIGFscmVhZHkgbWF0Y2hlZC5cbiAgICAgICAgX21lZGlhW2kgKyAzXSA9IGluZGV4O1xuICAgICAgICBpbmRleCA/IG1hdGNoZXMucHVzaChpKSA6IF9yZXZlcnRBbGwoMSwgX21lZGlhW2ldKSB8fCBfaXNGdW5jdGlvbihfbWVkaWFbaSArIDJdKSAmJiBfbWVkaWFbaSArIDJdKCk7IC8vIEZpcmVmb3ggZG9lc24ndCB1cGRhdGUgdGhlIFwibWF0Y2hlc1wiIHByb3BlcnR5IG9mIHRoZSBNZWRpYVF1ZXJ5TGlzdCBvYmplY3QgY29ycmVjdGx5IC0gaXQgb25seSBkb2VzIHNvIGFzIGl0IGNhbGxzIGl0cyBjaGFuZ2UgaGFuZGxlciAtIHNvIHdlIG11c3QgcmUtY3JlYXRlIGEgbWVkaWEgcXVlcnkgaGVyZSB0byBlbnN1cmUgaXQncyBhY2N1cmF0ZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmV2ZXJ0UmVjb3JkZWQoKTsgLy8gaW4gY2FzZSBraWxsaW5nL3JldmVydGluZyBhbnkgb2YgdGhlIGFuaW1hdGlvbnMgYWN0dWFsbHkgYWRkZWQgaW5saW5lIHN0eWxlcyBiYWNrLlxuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBtYXRjaGVzW2ldO1xuICAgICAgX2NyZWF0aW5nTWVkaWEgPSBfbWVkaWFbaW5kZXhdO1xuICAgICAgX21lZGlhW2luZGV4ICsgMl0gPSBfbWVkaWFbaW5kZXggKyAxXShlKTtcbiAgICB9XG5cbiAgICBfY3JlYXRpbmdNZWRpYSA9IDA7XG4gICAgX2NvcmVJbml0dGVkICYmIF9yZWZyZXNoQWxsKDAsIDEpO1xuICAgIF9sYXN0TWVkaWFUaWNrID0gdGljaztcblxuICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFcIik7XG4gIH1cbn0sXG4gICAgX3NvZnRSZWZyZXNoID0gZnVuY3Rpb24gX3NvZnRSZWZyZXNoKCkge1xuICByZXR1cm4gX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCkgfHwgX3JlZnJlc2hBbGwodHJ1ZSk7XG59LFxuICAgIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIF9kaXNwYXRjaCh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzW3R5cGVdICYmIF9saXN0ZW5lcnNbdHlwZV0ubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYoKTtcbiAgfSkgfHwgX2VtcHR5QXJyYXk7XG59LFxuICAgIF9zYXZlZFN0eWxlcyA9IFtdLFxuICAgIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5zYXZlU3R5bGVzKCkgaXMgY2FsbGVkLCB0aGUgaW5saW5lIHN0eWxlcyBhcmUgcmVjb3JkZWQgaW4gdGhpcyBBcnJheSBpbiBhIHNlcXVlbnRpYWwgZm9ybWF0IGxpa2UgW2VsZW1lbnQsIGNzc1RleHQsIGdzQ2FjaGUsIG1lZGlhXS4gVGhpcyBrZWVwcyBpdCB2ZXJ5IG1lbW9yeS1lZmZpY2llbnQgYW5kIGZhc3QgdG8gaXRlcmF0ZSB0aHJvdWdoLlxuX3JldmVydFJlY29yZGVkID0gZnVuY3Rpb24gX3JldmVydFJlY29yZGVkKG1lZGlhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3NhdmVkU3R5bGVzLmxlbmd0aDsgaSArPSA1KSB7XG4gICAgaWYgKCFtZWRpYSB8fCBfc2F2ZWRTdHlsZXNbaSArIDRdID09PSBtZWRpYSkge1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSArIDFdO1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLmdldEJCb3ggJiYgX3NhdmVkU3R5bGVzW2ldLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBfc2F2ZWRTdHlsZXNbaSArIDJdIHx8IFwiXCIpO1xuICAgICAgX3NhdmVkU3R5bGVzW2kgKyAzXS51bmNhY2hlID0gMTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3JldmVydEFsbCA9IGZ1bmN0aW9uIF9yZXZlcnRBbGwoa2lsbCwgbWVkaWEpIHtcbiAgdmFyIHRyaWdnZXI7XG5cbiAgZm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcnNbX2ldO1xuXG4gICAgaWYgKCFtZWRpYSB8fCB0cmlnZ2VyLm1lZGlhID09PSBtZWRpYSkge1xuICAgICAgaWYgKGtpbGwpIHtcbiAgICAgICAgdHJpZ2dlci5raWxsKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJpZ2dlci5yZXZlcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBtZWRpYSAmJiBfcmV2ZXJ0UmVjb3JkZWQobWVkaWEpO1xuICBtZWRpYSB8fCBfZGlzcGF0Y2goXCJyZXZlcnRcIik7XG59LFxuICAgIF9jbGVhclNjcm9sbE1lbW9yeSA9IGZ1bmN0aW9uIF9jbGVhclNjcm9sbE1lbW9yeSgpIHtcbiAgcmV0dXJuIF9zY3JvbGxlcnMuY2FjaGUrKyAmJiBfc2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgKG9iai5yZWMgPSAwKTtcbiAgfSk7XG59LFxuICAgIC8vIHplcm8tb3V0IGFsbCB0aGUgcmVjb3JkZWQgc2Nyb2xsIHBvc2l0aW9ucy4gRG9uJ3QgdXNlIF90cmlnZ2VycyBiZWNhdXNlIGlmLCBmb3IgZXhhbXBsZSwgLm1hdGNoTWVkaWEoKSBpcyB1c2VkIHRvIGNyZWF0ZSBzb21lIFNjcm9sbFRyaWdnZXJzIGFuZCB0aGVuIHRoZSB1c2VyIHJlc2l6ZXMgYW5kIGl0IHJlbW92ZXMgQUxMIFNjcm9sbFRyaWdnZXJzLCBhbmQgdGhlbiBnbyBiYWNrIHRvIGEgc2l6ZSB3aGVyZSB0aGVyZSBhcmUgU2Nyb2xsVHJpZ2dlcnMsIGl0IHdvdWxkIGhhdmUga2VwdCB0aGUgcG9zaXRpb24ocykgc2F2ZWQgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZS5cbl9yZWZyZXNoaW5nQWxsLFxuICAgIF9yZWZyZXNoSUQgPSAwLFxuICAgIF9yZWZyZXNoQWxsID0gZnVuY3Rpb24gX3JlZnJlc2hBbGwoZm9yY2UsIHNraXBSZXZlcnQpIHtcbiAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhZm9yY2UpIHtcbiAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJzY3JvbGxFbmRcIiwgX3NvZnRSZWZyZXNoKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIF9yZWZyZXNoaW5nQWxsID0gdHJ1ZTtcblxuICB2YXIgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XG5cbiAgX3NvcnQgJiYgU2Nyb2xsVHJpZ2dlci5zb3J0KCk7XG4gIHNraXBSZXZlcnQgfHwgX3JldmVydEFsbCgpO1xuXG4gIF90cmlnZ2Vycy5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQucmVmcmVzaCgpO1xuICB9KTsgLy8gZG9uJ3QgbG9vcCB3aXRoIF9pIGJlY2F1c2UgZHVyaW5nIGEgcmVmcmVzaCgpIHNvbWVvbmUgY291bGQgY2FsbCBTY3JvbGxUcmlnZ2VyLnVwZGF0ZSgpIHdoaWNoIHdvdWxkIGl0ZXJhdGUgdGhyb3VnaCBfaSByZXN1bHRpbmcgaW4gYSBza2lwLlxuXG5cbiAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC52YXJzLmVuZCA9PT0gXCJtYXhcIiAmJiB0LnNldFBvc2l0aW9ucyh0LnN0YXJ0LCBfbWF4U2Nyb2xsKHQuc2Nyb2xsZXIsIHQuX2RpcikpO1xuICB9KTsgLy8gdGhlIHNjcm9sbGVyJ3MgbWF4IHNjcm9sbCBwb3NpdGlvbiBtYXkgY2hhbmdlIGFmdGVyIGFsbCB0aGUgU2Nyb2xsVHJpZ2dlcnMgcmVmcmVzaGVkIChsaWtlIHBpbm5pbmcgY291bGQgcHVzaCBpdCBkb3duKSwgc28gd2UgbmVlZCB0byBsb29wIGJhY2sgYW5kIGNvcnJlY3QgYW55IHdpdGggZW5kOiBcIm1heFwiLlxuXG5cbiAgcmVmcmVzaEluaXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQgJiYgcmVzdWx0LnJlbmRlciAmJiByZXN1bHQucmVuZGVyKC0xKTtcbiAgfSk7IC8vIGlmIHRoZSBvblJlZnJlc2hJbml0KCkgcmV0dXJucyBhbiBhbmltYXRpb24gKHR5cGljYWxseSBhIGdzYXAuc2V0KCkpLCByZXZlcnQgaXQuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBwdXQgdGhpbmdzIGluIGEgY2VydGFpbiBzcG90IGJlZm9yZSByZWZyZXNoaW5nIGZvciBtZWFzdXJlbWVudCBwdXJwb3NlcywgYW5kIHRoZW4gcHV0IHRoaW5ncyBiYWNrLlxuXG4gIF9jbGVhclNjcm9sbE1lbW9yeSgpO1xuXG4gIF9yZXNpemVEZWxheS5wYXVzZSgpO1xuXG4gIF9yZWZyZXNoSUQrKztcbiAgX3JlZnJlc2hpbmdBbGwgPSBmYWxzZTtcblxuICBfZGlzcGF0Y2goXCJyZWZyZXNoXCIpO1xufSxcbiAgICBfbGFzdFNjcm9sbCA9IDAsXG4gICAgX2RpcmVjdGlvbiA9IDEsXG4gICAgX3ByaW1hcnksXG4gICAgX3VwZGF0ZUFsbCA9IGZ1bmN0aW9uIF91cGRhdGVBbGwoKSB7XG4gIGlmICghX3JlZnJlc2hpbmdBbGwpIHtcbiAgICBTY3JvbGxUcmlnZ2VyLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgIF9wcmltYXJ5ICYmIF9wcmltYXJ5LnVwZGF0ZSgwKTsgLy8gU2Nyb2xsU21vb3RoZXIgdXNlcnMgcmVmcmVzaFByaW9yaXR5IC05OTk5IHRvIGJlY29tZSB0aGUgcHJpbWFyeSB0aGF0IGdldHMgdXBkYXRlZCBiZWZvcmUgYWxsIG90aGVycyBiZWNhdXNlIGl0IGFmZmVjdHMgdGhlIHNjcm9sbCBwb3NpdGlvbi5cblxuICAgIHZhciBsID0gX3RyaWdnZXJzLmxlbmd0aCxcbiAgICAgICAgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgIHJlY29yZFZlbG9jaXR5ID0gdGltZSAtIF90aW1lMSAPSA1MCxcbiAgICAgICAgc2Nyb2xsID0gbCAmJiBfdHJpZ2dlcnNbMF0uc2Nyb2xsKCk7XG5cbiAgICBfZGlyZWN0aW9uID0gX2xhc3RTY3JvbGwgPiBzY3JvbGwgPyAtMSA6IDE7XG4gICAgX2xhc3RTY3JvbGwgPSBzY3JvbGw7XG5cbiAgICBpZiAocmVjb3JkVmVsb2NpdHkpIHtcbiAgICAgIGlmIChfbGFzdFNjcm9sbFRpbWUgJiYgIV9wb2ludGVySXNEb3duICYmIHRpbWUgLSBfbGFzdFNjcm9sbFRpbWUgPiAyMDApIHtcbiAgICAgICAgX2xhc3RTY3JvbGxUaW1lID0gMDtcblxuICAgICAgICBfZGlzcGF0Y2goXCJzY3JvbGxFbmRcIik7XG4gICAgICB9XG5cbiAgICAgIF90aW1lMiA9IF90aW1lMTtcbiAgICAgIF90aW1lMSA9IHRpbWU7XG4gICAgfVxuXG4gICAgaWYgKF9kaXJlY3Rpb24gPCAwKSB7XG4gICAgICBfaSA9IGw7XG5cbiAgICAgIHdoaWxlIChfaS0tID4gMCkge1xuICAgICAgICBfdHJpZ2dlcnNbX2ldICYmIF90cmlnZ2Vyc1tfaV0udXBkYXRlKDAsIHJlY29yZFZlbG9jaXR5KTtcbiAgICAgIH1cblxuICAgICAgX2RpcmVjdGlvbiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoX2kgPSAwOyBfaSA8IGw7IF9pKyspIHtcbiAgICAgICAgX3RyaWdnZXJzW19pXSAmJiBfdHJpZ2dlcnNbX2ldLnVwZGF0ZSgwLCByZWNvcmRWZWxvY2l0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgU2Nyb2xsVHJpZ2dlci5pc1VwZGF0aW5nID0gZmFsc2U7XG4gIH1cblxuICBfcmFmSUQgPSAwO1xufSxcbiAgICBfcHJvcE5hbWVzVG9Db3B5ID0gW19sZWZ0LCBfdG9wLCBfYm90dG9tLCBfcmlnaHQsIF9tYXJnaW4gKyBfQm90dG9tLCBfbWFyZ2luICsgX1JpZ2h0LCBfbWFyZ2luICsgX1RvcCwgX21hcmdpbiArIF9MZWZ0LCBcImRpc3BsYXlcIiwgXCJmbGV4U2hyaW5rXCIsIFwiZmxvYXRcIiwgXCJ6SW5kZXhcIiwgXCJncmlkQ29sdW1uU3RhcnRcIiwgXCJncmlkQ29sdW1uRW5kXCIsIFwiZ3JpZFJvd1N0YXJ0XCIsIFwiZ3JpZFJvd0VuZFwiLCBcImdyaWRBcmVhXCIsIFwianVzdGlmeVNlbGZcIiwgXCJhbGlnblNlbGZcIiwgXCJwbGFjZVNlbGZcIiwgXCJvcmRlclwiXSxcbiAgICBfc3RhdGVQcm9wcyA9IF9wcm9wTmFtZXNUb0NvcHkuY29uY2F0KFtfd2lkdGgsIF9oZWlnaHQsIFwiYm94U2l6aW5nXCIsIFwibWF4XCIgKyBfV2lkdGgsIFwibWF4XCIgKyBfSGVpZ2h0LCBcInBvc2l0aW9uXCIsIF9tYXJnaW4sIF9wYWRkaW5nLCBfcGFkZGluZyArIF9Ub3AsIF9wYWRkaW5nICsgX1JpZ2h0LCBfcGFkZGluZyArIF9Cb3R0b20sIF9wYWRkaW5nICsgX0xlZnRdKSxcbiAgICBfc3dhcFBpbk91dCA9IGZ1bmN0aW9uIF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBzdGF0ZSkge1xuICBfc2V0U3RhdGUoc3RhdGUpO1xuXG4gIHZhciBjYWNoZSA9IHBpbi5fZ3NhcDtcblxuICBpZiAoY2FjaGUuc3BhY2VySXNOYXRpdmUpIHtcbiAgICBfc2V0U3RhdGUoY2FjaGUuc3BhY2VyU3RhdGUpO1xuICB9IGVsc2UgaWYgKHBpbi5wYXJlbnROb2RlID09PSBzcGFjZXIpIHtcbiAgICB2YXIgcGFyZW50ID0gc3BhY2VyLnBhcmVudE5vZGU7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHBpbiwgc3BhY2VyKTtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChzcGFjZXIpO1xuICAgIH1cbiAgfVxufSxcbiAgICBfc3dhcFBpbkluID0gZnVuY3Rpb24gX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MsIHNwYWNlclN0YXRlKSB7XG4gIGlmIChwaW4ucGFyZW50Tm9kZSAhPT0gc3BhY2VyKSB7XG4gICAgdmFyIGkgPSBfcHJvcE5hbWVzVG9Db3B5Lmxlbmd0aCxcbiAgICAgICAgc3BhY2VyU3R5bGUgPSBzcGFjZXIuc3R5bGUsXG4gICAgICAgIHBpblN0eWxlID0gcGluLnN0eWxlLFxuICAgICAgICBwO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcCA9IF9wcm9wTmFtZXNUb0NvcHlbaV07XG4gICAgICBzcGFjZXJTdHlsZVtwXSA9IGNzW3BdO1xuICAgIH1cblxuICAgIHNwYWNlclN0eWxlLnBvc2l0aW9uID0gY3MucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiA/IFwiYWJzb2x1dGVcIiA6IFwicmVsYXRpdmVcIjtcbiAgICBjcy5kaXNwbGF5ID09PSBcImlubGluZVwiICYmIChzcGFjZXJTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIik7XG4gICAgcGluU3R5bGVbX2JvdHRvbV0gPSBwaW5TdHlsZVtfcmlnaHRdID0gc3BhY2VyU3R5bGUuZmxleEJhc2lzID0gXCJhdXRvXCI7XG4gICAgc3BhY2VyU3R5bGUub3ZlcmZsb3cgPSBcInZpc2libGVcIjtcbiAgICBzcGFjZXJTdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICBzcGFjZXJTdHlsZVtfd2lkdGhdID0gX2dldFNpemUocGluLCBfaG9yaXpvbnRhbCkgKyBfcHg7XG4gICAgc3BhY2VyU3R5bGVbX2hlaWdodF0gPSBfZ2V0U2l6ZShwaW4sIF92ZXJ0aWNhbCkgKyBfcHg7XG4gICAgc3BhY2VyU3R5bGVbX3BhZGRpbmddID0gcGluU3R5bGVbX21hcmdpbl0gPSBwaW5TdHlsZVtfdG9wXSA9IHBpblN0eWxlW19sZWZ0XSA9IFwiMFwiO1xuXG4gICAgX3NldFN0YXRlKHNwYWNlclN0YXRlKTtcblxuICAgIHBpblN0eWxlW193aWR0aF0gPSBwaW5TdHlsZVtcIm1heFwiICsgX1dpZHRoXSA9IGNzW193aWR0aF07XG4gICAgcGluU3R5bGVbX2hlaWdodF0gPSBwaW5TdHlsZVtcIm1heFwiICsgX0hlaWdodF0gPSBjc1tfaGVpZ2h0XTtcbiAgICBwaW5TdHlsZVtfcGFkZGluZ10gPSBjc1tfcGFkZGluZ107XG4gICAgcGluLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNwYWNlciwgcGluKTtcbiAgICBzcGFjZXIuYXBwZW5kQ2hpbGQocGluKTtcbiAgfVxufSxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX3NldFN0YXRlID0gZnVuY3Rpb24gX3NldFN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnQuc3R5bGUsXG4gICAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBwLFxuICAgICAgICB2YWx1ZTtcbiAgICAoc3RhdGUudC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUoc3RhdGUudCkpLnVuY2FjaGUgPSAxOyAvLyBvdGhlcndpc2UgdHJhbnNmb3JtcyBtYXkgYmUgb2ZmXG5cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgdmFsdWUgPSBzdGF0ZVtpICsgMV07XG4gICAgICBwID0gc3RhdGVbaV07XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzdHlsZVtwXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZVtwXSkge1xuICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0U3RhdGUgPSBmdW5jdGlvbiBfZ2V0U3RhdGUoZWxlbWVudCkge1xuICAvLyByZXR1cm5zIGFuIEFycmF5IHdpdGggYWx0ZXJuYXRpbmcgdmFsdWVzIGxpa2UgW3Byb3BlcnR5LCB2YWx1ZSwgcHJvcGVydHksIHZhbHVlXSBhbmQgYSBcInRcIiBwcm9wZXJ0eSBwb2ludGluZyB0byB0aGUgdGFyZ2V0IChlbGVtZW50KS4gTWFrZXMgaXQgZmFzdCBhbmQgY2hlYXAuXG4gIHZhciBsID0gX3N0YXRlUHJvcHMubGVuZ3RoLFxuICAgICAgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuICAgICAgc3RhdGUgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3RhdGUucHVzaChfc3RhdGVQcm9wc1tpXSwgc3R5bGVbX3N0YXRlUHJvcHNbaV1dKTtcbiAgfVxuXG4gIHN0YXRlLnQgPSBlbGVtZW50O1xuICByZXR1cm4gc3RhdGU7XG59LFxuICAgIF9jb3B5U3RhdGUgPSBmdW5jdGlvbiBfY29weVN0YXRlKHN0YXRlLCBvdmVycmlkZSwgb21pdE9mZnNldHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgbCA9IHN0YXRlLmxlbmd0aCxcbiAgICAgIGkgPSBvbWl0T2Zmc2V0cyA/IDggOiAwLFxuICAgICAgLy8gc2tpcCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gaWYgb21pdE9mZnNldHMgaXMgdHJ1ZVxuICBwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgcCA9IHN0YXRlW2ldO1xuICAgIHJlc3VsdC5wdXNoKHAsIHAgaW4gb3ZlcnJpZGUgPyBvdmVycmlkZVtwXSA6IHN0YXRlW2kgKyAxXSk7XG4gIH1cblxuICByZXN1bHQudCA9IHN0YXRlLnQ7XG4gIHJldHVybiByZXN1bHQ7XG59LFxuICAgIF93aW5PZmZzZXRzID0ge1xuICBsZWZ0OiAwLFxuICB0b3A6IDBcbn0sXG4gICAgLy8gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlICg/KSBBbGxvdyB1c2VycyB0byBjYWxjdWxhdGUgd2hlcmUgYSB0cmlnZ2VyIGhpdHMgKHNjcm9sbCBwb3NpdGlvbikgbGlrZSBnZXRTY3JvbGxQb3NpdGlvbihcIiNpZFwiLCBcInRvcCBib3R0b21cIilcbi8vIF9nZXRTY3JvbGxQb3NpdGlvbiA9ICh0cmlnZ2VyLCBwb3NpdGlvbiwge3Njcm9sbGVyLCBjb250YWluZXJBbmltYXRpb24sIGhvcml6b250YWx9KSA9PiB7XG4vLyBcdHNjcm9sbGVyID0gX2dldFRhcmdldChzY3JvbGxlciB8fCBfd2luKTtcbi8vIFx0bGV0IGRpcmVjdGlvbiA9IGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcbi8vIFx0XHRpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQoc2Nyb2xsZXIpO1xuLy8gXHRfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIGRpcmVjdGlvbik7XG4vLyBcdHJldHVybiBfcGFyc2VQb3NpdGlvbihwb3NpdGlvbiwgX2dldFRhcmdldCh0cmlnZ2VyKSwgX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pKCksIGRpcmVjdGlvbiwgX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbikoKSwgMCwgMCwgMCwgX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSgpLCBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLCAwLCBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSA6IF9tYXhTY3JvbGwoc2Nyb2xsZXIpLCBjb250YWluZXJBbmltYXRpb24pO1xuLy8gfSxcbl9wYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24gX3BhcnNlUG9zaXRpb24odmFsdWUsIHRyaWdnZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGwsIG1hcmtlciwgbWFya2VyU2Nyb2xsZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgc2Nyb2xsZXJNYXgsIGNvbnRhaW5lckFuaW1hdGlvbikge1xuICBfaXNGdW5jdGlvbih2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUoc2VsZikpO1xuXG4gIGlmIChfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLnN1YnN0cigwLCAzKSA9PT0gXCJtYXhcIikge1xuICAgIHZhbHVlID0gc2Nyb2xsZXJNYXggKyAodmFsdWUuY2hhckF0KDQpID09PSBcIj1cIiA/IF9vZmZzZXRUb1B4KFwiMFwiICsgdmFsdWUuc3Vic3RyKDMpLCBzY3JvbGxlclNpemUpIDogMCk7XG4gIH1cblxuICB2YXIgdGltZSA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi50aW1lKCkgOiAwLFxuICAgICAgcDEsXG4gICAgICBwMixcbiAgICAgIGVsZW1lbnQ7XG4gIGNvbnRhaW5lckFuaW1hdGlvbiAmJiBjb250YWluZXJBbmltYXRpb24uc2VlaygwKTtcblxuICBpZiAoIV9pc051bWJlcih2YWx1ZSkpIHtcbiAgICBfaXNGdW5jdGlvbih0cmlnZ2VyKSAmJiAodHJpZ2dlciA9IHRyaWdnZXIoc2VsZikpO1xuICAgIHZhciBvZmZzZXRzID0gdmFsdWUuc3BsaXQoXCIgXCIpLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIGxvY2FsT2Zmc2V0LFxuICAgICAgICBnbG9iYWxPZmZzZXQsXG4gICAgICAgIGRpc3BsYXk7XG4gICAgZWxlbWVudCA9IF9nZXRUYXJnZXQodHJpZ2dlcikgfHwgX2JvZHk7XG4gICAgYm91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KSB8fCB7fTtcblxuICAgIGlmICgoIWJvdW5kcyB8fCAhYm91bmRzLmxlZnQgJiYgIWJvdW5kcy50b3ApICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBpZiBkaXNwbGF5IGlzIFwibm9uZVwiLCBpdCB3b24ndCByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgcHJvcGVybHlcbiAgICAgIGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgICAgZGlzcGxheSA/IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgOiBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9XG5cbiAgICBsb2NhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMF0sIGJvdW5kc1tkaXJlY3Rpb24uZF0pO1xuICAgIGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XG4gICAgdmFsdWUgPSBib3VuZHNbZGlyZWN0aW9uLnBdIC0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLnBdIC0gYm9yZGVyV2lkdGggKyBsb2NhbE9mZnNldCArIHNjcm9sbCAtIGdsb2JhbE9mZnNldDtcbiAgICBtYXJrZXJTY3JvbGxlciAmJiBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIGdsb2JhbE9mZnNldCwgZGlyZWN0aW9uLCBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQgPCAyMCB8fCBtYXJrZXJTY3JvbGxlci5faXNTdGFydCAmJiBnbG9iYWxPZmZzZXQgPiAyMCk7XG4gICAgc2Nyb2xsZXJTaXplIC09IHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldDsgLy8gYWRqdXN0IGZvciB0aGUgbWFya2VyXG4gIH0gZWxzZSBpZiAobWFya2VyU2Nyb2xsZXIpIHtcbiAgICBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChtYXJrZXIpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB2YWx1ZSArIHNjcm9sbGVyU2l6ZSxcbiAgICAgICAgaXNTdGFydCA9IG1hcmtlci5faXNTdGFydDtcbiAgICBwMSA9IFwic2Nyb2xsXCIgKyBkaXJlY3Rpb24uZDI7XG5cbiAgICBfcG9zaXRpb25NYXJrZXIobWFya2VyLCBwb3NpdGlvbiwgZGlyZWN0aW9uLCBpc1N0YXJ0ICYmIHBvc2l0aW9uID4gMjAgfHwgIWlzU3RhcnQgJiYgKHVzZUZpeGVkUG9zaXRpb24gPyBNYXRoLm1heChfYm9keVtwMV0sIF9kb2NFbFtwMV0pIDogbWFya2VyLnBhcmVudE5vZGVbcDFdKSA8PSBwb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKHVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgIHNjcm9sbGVyQm91bmRzID0gX2dldEJvdW5kcyhtYXJrZXJTY3JvbGxlcik7XG4gICAgICB1c2VGaXhlZFBvc2l0aW9uICYmIChtYXJrZXIuc3R5bGVbZGlyZWN0aW9uLm9wLnBdID0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLm9wLnBdIC0gZGlyZWN0aW9uLm9wLm0gLSBtYXJrZXIuX29mZnNldCArIF9weCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbiAmJiBlbGVtZW50KSB7XG4gICAgcDEgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgIGNvbnRhaW5lckFuaW1hdGlvbi5zZWVrKHNjcm9sbGVyTWF4KTtcbiAgICBwMiA9IF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgPSBwMVtkaXJlY3Rpb24ucF0gLSBwMltkaXJlY3Rpb24ucF07XG4gICAgdmFsdWUgPSB2YWx1ZSAvIGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0ICogc2Nyb2xsZXJNYXg7XG4gIH1cblxuICBjb250YWluZXJBbmltYXRpb24gJiYgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsodGltZSk7XG4gIHJldHVybiBjb250YWluZXJBbmltYXRpb24gPyB2YWx1ZSA6IE1hdGgucm91bmQodmFsdWUpO1xufSxcbiAgICBfcHJlZml4RXhwID0gLyh3ZWJraXR8bW96fGxlbmd0aHxjc3NUZXh0fGluc2V0KS9pLFxuICAgIF9yZXBhcmVudCA9IGZ1bmN0aW9uIF9yZXBhcmVudChlbGVtZW50LCBwYXJlbnQsIHRvcCwgbGVmdCkge1xuICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuICAgICAgICBwLFxuICAgICAgICBjcztcblxuICAgIGlmIChwYXJlbnQgPT09IF9ib2R5KSB7XG4gICAgICBlbGVtZW50Ll9zdE9yaWcgPSBzdHlsZS5jc3NUZXh0OyAvLyByZWNvcmQgb3JpZ2luYWwgaW5saW5lIHN0eWxlcyBzbyB3ZSBjYW4gcmV2ZXJ0IHRoZW0gbGF0ZXJcblxuICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgICAgZm9yIChwIGluIGNzKSB7XG4gICAgICAgIC8vIG11c3QgY29weSBhbGwgcmVsZXZhbnQgc3R5bGVzIHRvIGVuc3VyZSB0aGF0IG5vdGhpbmcgY2hhbmdlcyB2aXN1YWxseSB3aGVuIHdlIHJlcGFyZW50IHRvIHRoZSA8Ym9keT4uIFNraXAgdGhlIHZlbmRvciBwcmVmaXhlZCBvbmVzLlxuICAgICAgICBpZiAoIStwICYmICFfcHJlZml4RXhwLnRlc3QocCkgJiYgY3NbcF0gJiYgdHlwZW9mIHN0eWxlW3BdID09PSBcInN0cmluZ1wiICYmIHAgIT09IFwiMFwiKSB7XG4gICAgICAgICAgc3R5bGVbcF0gPSBjc1twXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHlsZS50b3AgPSB0b3A7XG4gICAgICBzdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuY3NzVGV4dCA9IGVsZW1lbnQuX3N0T3JpZztcbiAgICB9XG5cbiAgICBnc2FwLmNvcmUuZ2V0Q2FjaGUoZWxlbWVudCkudW5jYWNoZSA9IDE7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG59LFxuICAgIC8vIF9tZXJnZUFuaW1hdGlvbnMgPSBhbmltYXRpb25zID0IHtcbi8vIFx0bGV0IHRsID0gZ3NhcC50aW1lbGluZSh7c21vb3RoQ2hpbGRUaW1pbmc6IHRydWV9KS5zdGFydFRpbWUoTWF0aC5taW4oLi4uYW5pbWF0aW9ucy5tYXAoYSA9PiBhLmdsb2JhbFRpbWUoMCkpKSk7XG4vLyBcdGFuaW1hdGlvbnMuZm9yRWFjaChhID0IHtsZXQgdGltZSA9IGEudG90YWxUaW1lKCk7IHRsLmFkZChhKTsgYS50b3RhbFRpbWUodGltZSk7IH0pO1xuLy8gXHR0bC5zbW9vdGhDaGlsZFRpbWluZyA9IGZhbHNlO1xuLy8gXHRyZXR1cm4gdGw7XG4vLyB9LFxuLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gdHdlZW4gdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIHByb3ZpZGVkLCBhbmQgd2hlbiBkb2luZyBzbyBpdCdsbCBhZGQgYSAudHdlZW4gcHJvcGVydHkgdG8gdGhlIEZVTkNUSU9OIGl0c2VsZiwgYW5kIHJlbW92ZSBpdCB3aGVuIHRoZSB0d2VlbiBjb21wbGV0ZXMgb3IgZ2V0cyBraWxsZWQuIFRoaXMgZ2l2ZXMgdXMgYSB3YXkgdG8gaGF2ZSBtdWx0aXBsZSBTY3JvbGxUcmlnZ2VycyB1c2UgYSBjZW50cmFsIGZ1bmN0aW9uIGZvciBhbnkgZ2l2ZW4gc2Nyb2xsZXIgYW5kIHNlZSBpZiB0aGVyZSdzIGEgc2Nyb2xsIHR3ZWVuIHJ1bm5pbmcgKHdoaWNoIHdvdWxkIGFmZmVjdCBpZi9ob3cgdGhpbmdzIGdldCB1cGRhdGVkKVxuX2dldFR3ZWVuQ3JlYXRvciA9IGZ1bmN0aW9uIF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIGRpcmVjdGlvbikge1xuICB2YXIgZ2V0U2Nyb2xsID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXG4gICAgICBwcm9wID0gXCJfc2Nyb2xsXCIgKyBkaXJlY3Rpb24ucDIsXG4gICAgICAvLyBhZGQgYSB0d2VlbmFibGUgcHJvcGVydHkgdG8gdGhlIHNjcm9sbGVyIHRoYXQncyBhIGdldHRlci9zZXR0ZXIgZnVuY3Rpb24sIGxpa2UgX3Njcm9sbFRvcCBvciBfc2Nyb2xsTGVmdC4gVGhpcyB3YXksIGlmIHNvbWVvbmUgZG9lcyBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxlcikgaXQnbGwga2lsbCB0aGUgc2Nyb2xsIHR3ZWVuLlxuICBsYXN0U2Nyb2xsMSxcbiAgICAgIGxhc3RTY3JvbGwyLFxuICAgICAgZ2V0VHdlZW4gPSBmdW5jdGlvbiBnZXRUd2VlbihzY3JvbGxUbywgdmFycywgaW5pdGlhbFZhbHVlLCBjaGFuZ2UxLCBjaGFuZ2UyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4sXG4gICAgICAgIG9uQ29tcGxldGUgPSB2YXJzLm9uQ29tcGxldGUsXG4gICAgICAgIG1vZGlmaWVycyA9IHt9O1xuICAgIGluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZSB8fCBnZXRTY3JvbGwoKTtcbiAgICBjaGFuZ2UyID0gY2hhbmdlMSAmJiBjaGFuZ2UyIHx8IDA7IC8vIGlmIGNoYW5nZTEgaXMgMCwgd2Ugc2V0IHRoYXQgdG8gdGhlIGRpZmZlcmVuY2UgYW5kIGlnbm9yZSBjaGFuZ2UyLiBPdGhlcndpc2UsIHRoZXJlIHdvdWxkIGJlIGEgY29tcG91bmQgZWZmZWN0LlxuXG4gICAgY2hhbmdlMSA9IGNoYW5nZTEgfHwgc2Nyb2xsVG8gLSBpbml0aWFsVmFsdWU7XG4gICAgdHdlZW4gJiYgdHdlZW4ua2lsbCgpO1xuICAgIGxhc3RTY3JvbGwxID0gTWF0aC5yb3VuZChpbml0aWFsVmFsdWUpO1xuICAgIHZhcnNbcHJvcF0gPSBzY3JvbGxUbztcbiAgICB2YXJzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIG1vZGlmaWVyc1twcm9wXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBfcm91bmQoZ2V0U2Nyb2xsKCkpOyAvLyByb3VuZCBiZWNhdXNlIGluIHNvbWUgW3ZlcnkgdW5jb21tb25dIFdpbmRvd3MgZW52aXJvbm1lbnRzLCBpdCBjYW4gZ2V0IHJlcG9ydGVkIHdpdGggZGVjaW1hbHMgZXZlbiB0aG91Z2ggaXQgd2FzIHNldCB3aXRob3V0LlxuXG4gICAgICBpZiAodmFsdWUgIT09IGxhc3RTY3JvbGwxICYmIHZhbHVlICE9PSBsYXN0U2Nyb2xsMiAmJiBNYXRoLmFicyh2YWx1ZSAtIGxhc3RTY3JvbGwxKSAIDIgJiYgTWF0aC5hYnModmFsdWUgLSBsYXN0U2Nyb2xsMikgPiAyKSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIHNjcm9sbHMsIGtpbGwgdGhlIHR3ZWVuLiBpT1MgU2FmYXJpIGludGVybWl0dGVudGx5IG1pc3JlcG9ydHMgdGhlIHNjcm9sbCBwb3NpdGlvbiwgaXQgbWF5IGJlIHRoZSBtb3N0IHJlY2VudGx5LXNldCBvbmUgb3IgdGhlIG9uZSBiZWZvcmUgdGhhdCEgV2hlbiBTYWZhcmkgaXMgem9vbWVkIChDTUQtKyksIGl0IG9mdGVuIG1pc3JlcG9ydHMgYXMgMSBwaXhlbCBvZmYgdG9vISBTbyBpZiB3ZSBzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byAxMjUsIGZvciBleGFtcGxlLCBpdCdsbCBhY3R1YWxseSByZXBvcnQgaXQgYXMgMTI0LlxuICAgICAgICB0d2Vlbi5raWxsKCk7XG4gICAgICAgIGdldFR3ZWVuLnR3ZWVuID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gaW5pdGlhbFZhbHVlICsgY2hhbmdlMSAqIHR3ZWVuLnJhdGlvICsgY2hhbmdlMiAqIHR3ZWVuLnJhdGlvICogdHdlZW4ucmF0aW87XG4gICAgICB9XG5cbiAgICAgIGxhc3RTY3JvbGwyID0gbGFzdFNjcm9sbDE7XG4gICAgICByZXR1cm4gbGFzdFNjcm9sbDEgPSBfcm91bmQodmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXJzLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUuY2FsbCh0d2Vlbik7XG4gICAgfTtcblxuICAgIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4gPSBnc2FwLnRvKHNjcm9sbGVyLCB2YXJzKTtcbiAgICByZXR1cm4gdHdlZW47XG4gIH07XG5cbiAgc2Nyb2xsZXJbcHJvcF0gPSBnZXRTY3JvbGw7XG5cbiAgZ2V0U2Nyb2xsLndoZWVsSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0VHdlZW4udHdlZW4gJiYgZ2V0VHdlZW4udHdlZW4ua2lsbCgpICYmIChnZXRUd2Vlbi50d2VlbiA9IDApO1xuICB9O1xuXG4gIF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJ3aGVlbFwiLCBnZXRTY3JvbGwud2hlZWxIYW5kbGVyKTsgLy8gV2luZG93cyBtYWNoaW5lcyBoYW5kbGUgbW91c2V3aGVlbCBzY3JvbGxpbmcgaW4gY2h1bmtzIChsaWtlIFwiMyBsaW5lcyBwZXIgc2Nyb2xsXCIpIG1lYW5pbmcgdGhlIHR5cGljYWwgc3RyYXRlZ3kgZm9yIGNhbmNlbGxpbmcgdGhlIHNjcm9sbCBpc24ndCBhcyBzZW5zaXRpdmUuIEl0J3MgbXVjaCBtb3JlIGxpa2VseSB0byBtYXRjaCBvbmUgb2YgdGhlIHByZXZpb3VzIDIgc2Nyb2xsIGV2ZW50IHBvc2l0aW9ucy4gU28gd2Uga2lsbCBhbnkgc25hcHBpbmcgYXMgc29vbiBhcyB0aGVyZSdzIGEgd2hlZWwgZXZlbnQuXG5cblxuICByZXR1cm4gZ2V0VHdlZW47XG59O1xuXG5leHBvcnQgdmFyIFNjcm9sbFRyaWdnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbikge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxUcmlnZ2VyLnJlZ2lzdGVyKGdzYXApIHx8IGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpXCIpO1xuICAgIHRoaXMuaW5pdCh2YXJzLCBhbmltYXRpb24pO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNjcm9sbFRyaWdnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh2YXJzLCBhbmltYXRpb24pIHtcbiAgICB0aGlzLnByb2dyZXNzID0gdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy52YXJzICYmIHRoaXMua2lsbCh0cnVlLCB0cnVlKTsgLy8gaW4gY2FzZSBpdCdzIGJlaW5nIGluaXR0ZWQgYWdhaW5cblxuICAgIGlmICghX2VuYWJsZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlID0gdGhpcy5yZWZyZXNoID0gdGhpcy5raWxsID0gX3Bhc3NUaHJvdWdoO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhcnMgPSBfc2V0RGVmYXVsdHMoX2lzU3RyaW5nKHZhcnMpIHx8IF9pc051bWJlcih2YXJzKSB8fCB2YXJzLm5vZGVUeXBlID8ge1xuICAgICAgdHJpZ2dlcjogdmFyc1xuICAgIH0gOiB2YXJzLCBfZGVmYXVsdHMpO1xuXG4gICAgdmFyIF92YXJzID0gdmFycyxcbiAgICAgICAgb25VcGRhdGUgPSBfdmFycy5vblVwZGF0ZSxcbiAgICAgICAgdG9nZ2xlQ2xhc3MgPSBfdmFycy50b2dnbGVDbGFzcyxcbiAgICAgICAgaWQgPSBfdmFycy5pZCxcbiAgICAgICAgb25Ub2dnbGUgPSBfdmFycy5vblRvZ2dsZSxcbiAgICAgICAgb25SZWZyZXNoID0gX3ZhcnMub25SZWZyZXNoLFxuICAgICAgICBzY3J1YiA9IF92YXJzLnNjcnViLFxuICAgICAgICB0cmlnZ2VyID0gX3ZhcnMudHJpZ2dlcixcbiAgICAgICAgcGluID0gX3ZhcnMucGluLFxuICAgICAgICBwaW5TcGFjaW5nID0gX3ZhcnMucGluU3BhY2luZyxcbiAgICAgICAgaW52YWxpZGF0ZU9uUmVmcmVzaCA9IF92YXJzLmludmFsaWRhdGVPblJlZnJlc2gsXG4gICAgICAgIGFudGljaXBhdGVQaW4gPSBfdmFycy5hbnRpY2lwYXRlUGluLFxuICAgICAgICBvblNjcnViQ29tcGxldGUgPSBfdmFycy5vblNjcnViQ29tcGxldGUsXG4gICAgICAgIG9uU25hcENvbXBsZXRlID0gX3ZhcnMub25TbmFwQ29tcGxldGUsXG4gICAgICAgIG9uY2UgPSBfdmFycy5vbmNlLFxuICAgICAgICBzbmFwID0gX3ZhcnMuc25hcCxcbiAgICAgICAgcGluUmVwYXJlbnQgPSBfdmFycy5waW5SZXBhcmVudCxcbiAgICAgICAgcGluU3BhY2VyID0gX3ZhcnMucGluU3BhY2VyLFxuICAgICAgICBjb250YWluZXJBbmltYXRpb24gPSBfdmFycy5jb250YWluZXJBbmltYXRpb24sXG4gICAgICAgIGZhc3RTY3JvbGxFbmQgPSBfdmFycy5mYXN0U2Nyb2xsRW5kLFxuICAgICAgICBwcmV2ZW50T3ZlcmxhcHMgPSBfdmFycy5wcmV2ZW50T3ZlcmxhcHMsXG4gICAgICAgIGRpcmVjdGlvbiA9IHZhcnMuaG9yaXpvbnRhbCB8fCB2YXJzLmNvbnRhaW5lckFuaW1hdGlvbiAmJiB2YXJzLmhvcml6b250YWwgIT09IGZhbHNlID8gX2hvcml6b250YWwgOiBfdmVydGljYWwsXG4gICAgICAgIGlzVG9nZ2xlID0gIXNjcnViICYmIHNjcnViICE9PSAwLFxuICAgICAgICBzY3JvbGxlciA9IF9nZXRUYXJnZXQodmFycy5zY3JvbGxlciB8fCBfd2luKSxcbiAgICAgICAgc2Nyb2xsZXJDYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShzY3JvbGxlciksXG4gICAgICAgIGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydChzY3JvbGxlciksXG4gICAgICAgIHVzZUZpeGVkUG9zaXRpb24gPSAoXCJwaW5UeXBlXCIgaW4gdmFycyA/IHZhcnMucGluVHlwZSA6IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwicGluVHlwZVwiKSB8fCBpc1ZpZXdwb3J0ICYmIFwiZml4ZWRcIikgPT09IFwiZml4ZWRcIixcbiAgICAgICAgY2FsbGJhY2tzID0gW3ZhcnMub25FbnRlciwgdmFycy5vbkxlYXZlLCB2YXJzLm9uRW50ZXJCYWNrLCB2YXJzLm9uTGVhdmVCYWNrXSxcbiAgICAgICAgdG9nZ2xlQWN0aW9ucyA9IGlzVG9nZ2xlICYmIHZhcnMudG9nZ2xlQWN0aW9ucy5zcGxpdChcIiBcIiksXG4gICAgICAgIG1hcmtlcnMgPSBcIm1hcmtlcnNcIiBpbiB2YXJzID8gdmFycy5tYXJrZXJzIDogX2RlZmF1bHRzLm1hcmtlcnMsXG4gICAgICAgIGJvcmRlcldpZHRoID0gaXNWaWV3cG9ydCA/IDAgOiBwYXJzZUZsb2F0KF9nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGVyKVtcImJvcmRlclwiICsgZGlyZWN0aW9uLnAyICsgX1dpZHRoXSkgfHwgMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIG9uUmVmcmVzaEluaXQgPSB2YXJzLm9uUmVmcmVzaEluaXQgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZhcnMub25SZWZyZXNoSW5pdChzZWxmKTtcbiAgICB9LFxuICAgICAgICBnZXRTY3JvbGxlclNpemUgPSBfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIGRpcmVjdGlvbiksXG4gICAgICAgIGdldFNjcm9sbGVyT2Zmc2V0cyA9IF9nZXRPZmZzZXRzRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCksXG4gICAgICAgIGxhc3RTbmFwID0gMCxcbiAgICAgICAgbGFzdFJlZnJlc2ggPSAwLFxuICAgICAgICBzY3JvbGxGdW5jID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXG4gICAgICAgIHR3ZWVuVG8sXG4gICAgICAgIHBpbkNhY2hlLFxuICAgICAgICBzbmFwRnVuYyxcbiAgICAgICAgc2Nyb2xsMSxcbiAgICAgICAgc2Nyb2xsMixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgbWFya2VyU3RhcnQsXG4gICAgICAgIG1hcmtlckVuZCxcbiAgICAgICAgbWFya2VyU3RhcnRUcmlnZ2VyLFxuICAgICAgICBtYXJrZXJFbmRUcmlnZ2VyLFxuICAgICAgICBtYXJrZXJWYXJzLFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUsXG4gICAgICAgIHBpbkFjdGl2ZVN0YXRlLFxuICAgICAgICBwaW5TdGF0ZSxcbiAgICAgICAgc3BhY2VyLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHBpbkdldHRlcixcbiAgICAgICAgcGluU2V0dGVyLFxuICAgICAgICBwaW5TdGFydCxcbiAgICAgICAgcGluQ2hhbmdlLFxuICAgICAgICBzcGFjaW5nU3RhcnQsXG4gICAgICAgIHNwYWNlclN0YXRlLFxuICAgICAgICBtYXJrZXJTdGFydFNldHRlcixcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyLFxuICAgICAgICBjcyxcbiAgICAgICAgc25hcDEsXG4gICAgICAgIHNuYXAyLFxuICAgICAgICBzY3J1YlR3ZWVuLFxuICAgICAgICBzY3J1YlNtb290aCxcbiAgICAgICAgc25hcER1ckNsYW1wLFxuICAgICAgICBzbmFwRGVsYXllZENhbGwsXG4gICAgICAgIHByZXZQcm9ncmVzcyxcbiAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgcHJldkFuaW1Qcm9ncmVzcyxcbiAgICAgICAgY2FNYXJrZXJTZXR0ZXIsXG4gICAgICAgIGN1c3RvbVJldmVydFJldHVybjtcblxuICAgIHNlbGYubWVkaWEgPSBfY3JlYXRpbmdNZWRpYTtcbiAgICBzZWxmLl9kaXIgPSBkaXJlY3Rpb247XG4gICAgYW50aWNpcGF0ZVBpbiAqPSA0NTtcbiAgICBzZWxmLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG4gICAgc2VsZi5zY3JvbGwgPSBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24udGltZS5iaW5kKGNvbnRhaW5lckFuaW1hdGlvbikgOiBzY3JvbGxGdW5jO1xuICAgIHNjcm9sbDEgPSBzY3JvbGxGdW5jKCk7XG4gICAgc2VsZi52YXJzID0gdmFycztcbiAgICBhbmltYXRpb24gPSBhbmltYXRpb24gfHwgdmFycy5hbmltYXRpb247XG5cbiAgICBpZiAoXCJyZWZyZXNoUHJpb3JpdHlcIiBpbiB2YXJzKSB7XG4gICAgICBfc29ydCA9IDE7XG4gICAgICB2YXJzLnJlZnJlc2hQcmlvcml0eSA9PT0gLTk5OTkgJiYgKF9wcmltYXJ5ID0gc2VsZik7IC8vIHVzZWQgYnkgU2Nyb2xsU21vb3RoZXJcbiAgICB9XG5cbiAgICBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCB8fCB7XG4gICAgICB0b3A6IF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIF92ZXJ0aWNhbCksXG4gICAgICBsZWZ0OiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfaG9yaXpvbnRhbClcbiAgICB9O1xuICAgIHNlbGYudHdlZW5UbyA9IHR3ZWVuVG8gPSBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsW2RpcmVjdGlvbi5wXTtcblxuICAgIHNlbGYuc2NydWJEdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgc2NydWJTbW9vdGggPSBfaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlO1xuXG4gICAgICBpZiAoIXNjcnViU21vb3RoKSB7XG4gICAgICAgIHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wcm9ncmVzcygxKS5raWxsKCk7XG4gICAgICAgIHNjcnViVHdlZW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4uZHVyYXRpb24odmFsdWUpIDogc2NydWJUd2VlbiA9IGdzYXAudG8oYW5pbWF0aW9uLCB7XG4gICAgICAgICAgZWFzZTogXCJleHBvXCIsXG4gICAgICAgICAgdG90YWxQcm9ncmVzczogXCIrPTAuMDAxXCIsXG4gICAgICAgICAgZHVyYXRpb246IHNjcnViU21vb3RoLFxuICAgICAgICAgIHBhdXNlZDogdHJ1ZSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uU2NydWJDb21wbGV0ZSAmJiBvblNjcnViQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgYW5pbWF0aW9uLnZhcnMubGF6eSA9IGZhbHNlO1xuICAgICAgYW5pbWF0aW9uLl9pbml0dGVkIHx8IGFuaW1hdGlvbi52YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UgJiYgdmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlICYmIGFuaW1hdGlvbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBzZWxmLmFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBzZWxmO1xuICAgICAgc2VsZi5zY3J1YkR1cmF0aW9uKHNjcnViKTtcbiAgICAgIHNuYXAxID0gMDtcbiAgICAgIGlkIHx8IChpZCA9IGFuaW1hdGlvbi52YXJzLmlkKTtcbiAgICB9XG5cbiAgICBfdHJpZ2dlcnMucHVzaChzZWxmKTtcblxuICAgIGlmIChzbmFwKSB7XG4gICAgICBpZiAoIV9pc09iamVjdChzbmFwKSB8fCBzbmFwLnB1c2gpIHtcbiAgICAgICAgc25hcCA9IHtcbiAgICAgICAgICBzbmFwVG86IHNuYXBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgXCJzY3JvbGxCZWhhdmlvclwiIGluIF9ib2R5LnN0eWxlICYmIGdzYXAuc2V0KGlzVmlld3BvcnQgPyBbX2JvZHksIF9kb2NFbF0gOiBzY3JvbGxlciwge1xuICAgICAgICBzY3JvbGxCZWhhdmlvcjogXCJhdXRvXCJcbiAgICAgIH0pOyAvLyBzbW9vdGggc2Nyb2xsaW5nIGRvZXNuJ3Qgd29yayB3aXRoIHNuYXAuXG5cbiAgICAgIHNuYXBGdW5jID0gX2lzRnVuY3Rpb24oc25hcC5zbmFwVG8pID8gc25hcC5zbmFwVG8gOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNcIiA/IF9nZXRDbG9zZXN0TGFiZWwoYW5pbWF0aW9uKSA6IHNuYXAuc25hcFRvID09PSBcImxhYmVsc0RpcmVjdGlvbmFsXCIgPyBfZ2V0TGFiZWxBdERpcmVjdGlvbihhbmltYXRpb24pIDogc25hcC5kaXJlY3Rpb25hbCAhPT0gZmFsc2UgPyBmdW5jdGlvbiAodmFsdWUsIHN0KSB7XG4gICAgICAgIHJldHVybiBfc25hcERpcmVjdGlvbmFsKHNuYXAuc25hcFRvKSh2YWx1ZSwgX2dldFRpbWUoKSAtIGxhc3RSZWZyZXNoIDwgNTAwID8gMCA6IHN0LmRpcmVjdGlvbik7XG4gICAgICB9IDogZ3NhcC51dGlscy5zbmFwKHNuYXAuc25hcFRvKTtcbiAgICAgIHNuYXBEdXJDbGFtcCA9IHNuYXAuZHVyYXRpb24gfHwge1xuICAgICAgICBtaW46IDAuMSxcbiAgICAgICAgbWF4OiAyXG4gICAgICB9O1xuICAgICAgc25hcER1ckNsYW1wID0gX2lzT2JqZWN0KHNuYXBEdXJDbGFtcCkgPyBfY2xhbXAoc25hcER1ckNsYW1wLm1pbiwgc25hcER1ckNsYW1wLm1heCkgOiBfY2xhbXAoc25hcER1ckNsYW1wLCBzbmFwRHVyQ2xhbXApO1xuICAgICAgc25hcERlbGF5ZWRDYWxsID0gZ3NhcC5kZWxheWVkQ2FsbChzbmFwLmRlbGF5IHx8IHNjcnViU21vb3RoIC8gMiB8fCAwLjEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjcm9sbCA9IHNjcm9sbEZ1bmMoKSxcbiAgICAgICAgICAgIHJlZnJlc2hlZFJlY2VudGx5ID0gX2dldFRpbWUoKSAtIGxhc3RSZWZyZXNoIDwgNTAwLFxuICAgICAgICAgICAgdHdlZW4gPSB0d2VlblRvLnR3ZWVuO1xuXG4gICAgICAgIGlmICgocmVmcmVzaGVkUmVjZW50bHkgfHwgTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA8IDEwKSAmJiAhdHdlZW4gJiYgIV9wb2ludGVySXNEb3duICYmIGxhc3RTbmFwICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAoc2Nyb2xsIC0gc3RhcnQpIC8gY2hhbmdlLFxuICAgICAgICAgICAgICB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBwcm9ncmVzcyxcbiAgICAgICAgICAgICAgdmVsb2NpdHkgPSByZWZyZXNoZWRSZWNlbnRseSA/IDAgOiAodG90YWxQcm9ncmVzcyAtIHNuYXAyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIDEwMDAgfHwgMCxcbiAgICAgICAgICAgICAgY2hhbmdlMSA9IGdzYXAudXRpbHMuY2xhbXAoLXByb2dyZXNzLCAxIC0gcHJvZ3Jlc3MsIF9hYnModmVsb2NpdHkgLyAyKSAqIHZlbG9jaXR5IC8gMC4xODUpLFxuICAgICAgICAgICAgICBuYXR1cmFsRW5kID0gcHJvZ3Jlc3MgKyAoc25hcC5pbmVydGlhID09PSBmYWxzZSA/IDAgOiBjaGFuZ2UxKSxcbiAgICAgICAgICAgICAgZW5kVmFsdWUgPSBfY2xhbXAoMCwgMSwgc25hcEZ1bmMobmF0dXJhbEVuZCwgc2VsZikpLFxuICAgICAgICAgICAgICBlbmRTY3JvbGwgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgZW5kVmFsdWUgKiBjaGFuZ2UpLFxuICAgICAgICAgICAgICBfc25hcCA9IHNuYXAsXG4gICAgICAgICAgICAgIG9uU3RhcnQgPSBfc25hcC5vblN0YXJ0LFxuICAgICAgICAgICAgICBfb25JbnRlcnJ1cHQgPSBfc25hcC5vbkludGVycnVwdCxcbiAgICAgICAgICAgICAgX29uQ29tcGxldGUgPSBfc25hcC5vbkNvbXBsZXRlO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbCA8PSBlbmQgJiYgc2Nyb2xsID49IHN0YXJ0ICYmIGVuZFNjcm9sbCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgICBpZiAodHdlZW4gJiYgIXR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmRhdGEgPD0gX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW4gb3ZlcmxhcHBpbmcgc25hcCEgU28gd2UgbXVzdCBmaWd1cmUgb3V0IHdoaWNoIG9uZSBpcyBjbG9zZXIgYW5kIGxldCB0aGF0IHR3ZWVuIGxpdmUuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY2hhbmdlMSA9IGVuZFZhbHVlIC0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHR3ZWVuVG8oZW5kU2Nyb2xsLCB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBzbmFwRHVyQ2xhbXAoX2FicyhNYXRoLm1heChfYWJzKG5hdHVyYWxFbmQgLSB0b3RhbFByb2dyZXNzKSwgX2FicyhlbmRWYWx1ZSAtIHRvdGFsUHJvZ3Jlc3MpKSAqIDAuMTg1IC8gdmVsb2NpdHkgLyAwLjA1IHx8IDApKSxcbiAgICAgICAgICAgICAgZWFzZTogc25hcC5lYXNlIHx8IFwicG93ZXIzXCIsXG4gICAgICAgICAgICAgIGRhdGE6IF9hYnMoZW5kU2Nyb2xsIC0gc2Nyb2xsKSxcbiAgICAgICAgICAgICAgLy8gcmVjb3JkIHRoZSBkaXN0YW5jZSBzbyB0aGF0IGlmIGFub3RoZXIgc25hcCB0d2VlbiBvY2N1cnMgKGNvbmZsaWN0KSB3ZSBjYW4gcHJpb3JpdGl6ZSB0aGUgY2xvc2VzdCBzbmFwLlxuICAgICAgICAgICAgICBvbkludGVycnVwdDogZnVuY3Rpb24gb25JbnRlcnJ1cHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpICYmIF9vbkludGVycnVwdCAmJiBfb25JbnRlcnJ1cHQoc2VsZik7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBsYXN0U25hcCA9IHNjcm9sbEZ1bmMoKTtcbiAgICAgICAgICAgICAgICBzbmFwMSA9IHNuYXAyID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBzZWxmLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIG9uU25hcENvbXBsZXRlICYmIG9uU25hcENvbXBsZXRlKHNlbGYpO1xuICAgICAgICAgICAgICAgIF9vbkNvbXBsZXRlICYmIF9vbkNvbXBsZXRlKHNlbGYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzY3JvbGwsIGNoYW5nZTEgKiBjaGFuZ2UsIGVuZFNjcm9sbCAtIHNjcm9sbCAtIGNoYW5nZTEgKiBjaGFuZ2UpO1xuICAgICAgICAgICAgb25TdGFydCAmJiBvblN0YXJ0KHNlbGYsIHR3ZWVuVG8udHdlZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmlzQWN0aXZlICYmIGxhc3RTbmFwICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSkucGF1c2UoKTtcbiAgICB9XG5cbiAgICBpZCAmJiAoX2lkc1tpZF0gPSBzZWxmKTtcbiAgICB0cmlnZ2VyID0gc2VsZi50cmlnZ2VyID0gX2dldFRhcmdldCh0cmlnZ2VyIHx8IHBpbik7IC8vIGlmIGEgdHJpZ2dlciBoYXMgc29tZSBraW5kIG9mIHNjcm9sbC1yZWxhdGVkIGVmZmVjdCBhcHBsaWVkIHRoYXQgY291bGQgY29udGFtaW5hdGUgdGhlIFwieVwiIG9yIFwieFwiIHBvc2l0aW9uIChsaWtlIGEgU2Nyb2xsU21vb3RoZXIgZWZmZWN0KSwgd2UgbmVlZGVkIGEgd2F5IHRvIHRlbXBvcmFyaWx5IHJldmVydCBpdCwgc28gd2UgdXNlIHRoZSBzdFJldmVydCBwcm9wZXJ0eSBvZiB0aGUgZ3NDYWNoZS4gSXQgY2FuIHJldHVybiBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgd2UnbGwgY2FsbCBhdCB0aGUgZW5kIHNvIGl0IGNhbiByZXR1cm4gdG8gaXRzIG5vcm1hbCBzdGF0ZS5cblxuICAgIGN1c3RvbVJldmVydFJldHVybiA9IHRyaWdnZXIgJiYgdHJpZ2dlci5fZ3NhcCAmJiB0cmlnZ2VyLl9nc2FwLnN0UmV2ZXJ0O1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiAoY3VzdG9tUmV2ZXJ0UmV0dXJuID0gY3VzdG9tUmV2ZXJ0UmV0dXJuKHNlbGYpKTtcbiAgICBwaW4gPSBwaW4gPT09IHRydWUgPyB0cmlnZ2VyIDogX2dldFRhcmdldChwaW4pO1xuICAgIF9pc1N0cmluZyh0b2dnbGVDbGFzcykgJiYgKHRvZ2dsZUNsYXNzID0ge1xuICAgICAgdGFyZ2V0czogdHJpZ2dlcixcbiAgICAgIGNsYXNzTmFtZTogdG9nZ2xlQ2xhc3NcbiAgICB9KTtcblxuICAgIGlmIChwaW4pIHtcbiAgICAgIHBpblNwYWNpbmcgPT09IGZhbHNlIHx8IHBpblNwYWNpbmcgPT09IF9tYXJnaW4gfHwgKHBpblNwYWNpbmcgPSAhcGluU3BhY2luZyAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4ucGFyZW50Tm9kZSkuZGlzcGxheSA9PT0gXCJmbGV4XCIgPyBmYWxzZSA6IF9wYWRkaW5nKTsgLy8gaWYgdGhlIHBhcmVudCBpcyBkaXNwbGF5OiBmbGV4LCBkb24ndCBhcHBseSBwaW5TcGFjaW5nIGJ5IGRlZmF1bHQuXG5cbiAgICAgIHNlbGYucGluID0gcGluO1xuICAgICAgdmFycy5mb3JjZTNEICE9PSBmYWxzZSAmJiBnc2FwLnNldChwaW4sIHtcbiAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBwaW5DYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShwaW4pO1xuXG4gICAgICBpZiAoIXBpbkNhY2hlLnNwYWNlcikge1xuICAgICAgICAvLyByZWNvcmQgdGhlIHNwYWNlciBhbmQgcGluT3JpZ2luYWxTdGF0ZSBvbiB0aGUgY2FjaGUgaW4gY2FzZSBzb21lb25lIHRyaWVzIHBpbm5pbmcgdGhlIHNhbWUgZWxlbWVudCB3aXRoIE1VTFRJUExFIFNjcm9sbFRyaWdnZXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBoYXZlIG11bHRpcGxlIHNwYWNlcnMgb3IgcmVjb3JkIHRoZSBcIm9yaWdpbmFsXCIgcGluIHN0YXRlIGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWZmZWN0ZWQgYnkgYW5vdGhlciBTY3JvbGxUcmlnZ2VyLlxuICAgICAgICBpZiAocGluU3BhY2VyKSB7XG4gICAgICAgICAgcGluU3BhY2VyID0gX2dldFRhcmdldChwaW5TcGFjZXIpO1xuICAgICAgICAgIHBpblNwYWNlciAmJiAhcGluU3BhY2VyLm5vZGVUeXBlICYmIChwaW5TcGFjZXIgPSBwaW5TcGFjZXIuY3VycmVudCB8fCBwaW5TcGFjZXIubmF0aXZlRWxlbWVudCk7IC8vIGZvciBSZWFjdCAmIEFuZ3VsYXJcblxuICAgICAgICAgIHBpbkNhY2hlLnNwYWNlcklzTmF0aXZlID0gISFwaW5TcGFjZXI7XG4gICAgICAgICAgcGluU3BhY2VyICYmIChwaW5DYWNoZS5zcGFjZXJTdGF0ZSA9IF9nZXRTdGF0ZShwaW5TcGFjZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBpbkNhY2hlLnNwYWNlciA9IHNwYWNlciA9IHBpblNwYWNlciB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNwYWNlci5jbGFzc0xpc3QuYWRkKFwicGluLXNwYWNlclwiKTtcbiAgICAgICAgaWQgJiYgc3BhY2VyLmNsYXNzTGlzdC5hZGQoXCJwaW4tc3BhY2VyLVwiICsgaWQpO1xuICAgICAgICBwaW5DYWNoZS5waW5TdGF0ZSA9IHBpbk9yaWdpbmFsU3RhdGUgPSBfZ2V0U3RhdGUocGluKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUgPSBwaW5DYWNoZS5waW5TdGF0ZTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zcGFjZXIgPSBzcGFjZXIgPSBwaW5DYWNoZS5zcGFjZXI7XG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHBpbik7XG4gICAgICBzcGFjaW5nU3RhcnQgPSBjc1twaW5TcGFjaW5nICsgZGlyZWN0aW9uLm9zMl07XG4gICAgICBwaW5HZXR0ZXIgPSBnc2FwLmdldFByb3BlcnR5KHBpbik7XG4gICAgICBwaW5TZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKHBpbiwgZGlyZWN0aW9uLmEsIF9weCk7IC8vIHBpbi5maXJzdENoaWxkICYmICFfbWF4U2Nyb2xsKHBpbiwgZGlyZWN0aW9uKSAmJiAocGluLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIik7IC8vIHByb3RlY3RzIGZyb20gY29sbGFwc2luZyBtYXJnaW5zLCBidXQgY2FuIGhhdmUgdW5pbnRlbmRlZCBjb25zZXF1ZW5jZXMgYXMgZGVtb25zdHJhdGVkIGhlcmU6IGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzFlNDJjN2E3M2JmYTQwOWQyY2YxZTE4NGU3YTQyNDhkIHNvIGl0IHdhcyByZW1vdmVkIGluIGZhdm9yIG9mIGp1c3QgdGVsbGluZyBwZW9wbGUgdG8gc2V0IHVwIHRoZWlyIENTUyB0byBhdm9pZCB0aGUgY29sbGFwc2luZyBtYXJnaW5zIChvdmVyZmxvdzogaGlkZGVuIHwgYXV0byBpcyBqdXN0IG9uZSBvcHRpb24uIEFub3RoZXIgaXMgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHRyYW5zcGFyZW50KS5cblxuICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xuXG4gICAgICBwaW5TdGF0ZSA9IF9nZXRTdGF0ZShwaW4pO1xuICAgIH1cblxuICAgIGlmIChtYXJrZXJzKSB7XG4gICAgICBtYXJrZXJWYXJzID0gX2lzT2JqZWN0KG1hcmtlcnMpID8gX3NldERlZmF1bHRzKG1hcmtlcnMsIF9tYXJrZXJEZWZhdWx0cykgOiBfbWFya2VyRGVmYXVsdHM7XG4gICAgICBtYXJrZXJTdGFydFRyaWdnZXIgPSBfY3JlYXRlTWFya2VyKFwic2Nyb2xsZXItc3RhcnRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDApO1xuICAgICAgbWFya2VyRW5kVHJpZ2dlciA9IF9jcmVhdGVNYXJrZXIoXCJzY3JvbGxlci1lbmRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDAsIG1hcmtlclN0YXJ0VHJpZ2dlcik7XG4gICAgICBvZmZzZXQgPSBtYXJrZXJTdGFydFRyaWdnZXJbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XG5cbiAgICAgIHZhciBjb250ZW50ID0gX2dldFRhcmdldChfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImNvbnRlbnRcIikgfHwgc2Nyb2xsZXIpO1xuXG4gICAgICBtYXJrZXJTdGFydCA9IHRoaXMubWFya2VyU3RhcnQgPSBfY3JlYXRlTWFya2VyKFwic3RhcnRcIiwgaWQsIGNvbnRlbnQsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0LCAwLCBjb250YWluZXJBbmltYXRpb24pO1xuICAgICAgbWFya2VyRW5kID0gdGhpcy5tYXJrZXJFbmQgPSBfY3JlYXRlTWFya2VyKFwiZW5kXCIsIGlkLCBjb250ZW50LCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIG9mZnNldCwgMCwgY29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiAmJiAoY2FNYXJrZXJTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgZGlyZWN0aW9uLmEsIF9weCkpO1xuXG4gICAgICBpZiAoIXVzZUZpeGVkUG9zaXRpb24gJiYgIShfcHJveGllcy5sZW5ndGggJiYgX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJmaXhlZE1hcmtlcnNcIikgPT09IHRydWUpKSB7XG4gICAgICAgIF9tYWtlUG9zaXRpb25hYmxlKGlzVmlld3BvcnQgPyBfYm9keSA6IHNjcm9sbGVyKTtcblxuICAgICAgICBnc2FwLnNldChbbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXSwge1xuICAgICAgICAgIGZvcmNlM0Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtlclN0YXJ0U2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbi5hLCBfcHgpO1xuICAgICAgICBtYXJrZXJFbmRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlckVuZFRyaWdnZXIsIGRpcmVjdGlvbi5hLCBfcHgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgIHZhciBvbGRPblVwZGF0ZSA9IGNvbnRhaW5lckFuaW1hdGlvbi52YXJzLm9uVXBkYXRlLFxuICAgICAgICAgIG9sZFBhcmFtcyA9IGNvbnRhaW5lckFuaW1hdGlvbi52YXJzLm9uVXBkYXRlUGFyYW1zO1xuICAgICAgY29udGFpbmVyQW5pbWF0aW9uLmV2ZW50Q2FsbGJhY2soXCJvblVwZGF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYudXBkYXRlKDAsIDAsIDEpO1xuICAgICAgICBvbGRPblVwZGF0ZSAmJiBvbGRPblVwZGF0ZS5hcHBseShvbGRQYXJhbXMgfHwgW10pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZi5wcmV2aW91cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdHJpZ2dlcnNbX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikgLSAxXTtcbiAgICB9O1xuXG4gICAgc2VsZi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90cmlnZ2Vyc1tfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSArIDFdO1xuICAgIH07XG5cbiAgICBzZWxmLnJldmVydCA9IGZ1bmN0aW9uIChyZXZlcnQpIHtcbiAgICAgIHZhciByID0gcmV2ZXJ0ICE9PSBmYWxzZSB8fCAhc2VsZi5lbmFibGVkLFxuICAgICAgICAgIHByZXZSZWZyZXNoaW5nID0gX3JlZnJlc2hpbmc7XG5cbiAgICAgIGlmIChyICE9PSBzZWxmLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICBzZWxmLnNjcm9sbC5yZWMgfHwgIV9yZWZyZXNoaW5nIHx8ICFfcmVmcmVzaGluZ0FsbCB8fCAoc2VsZi5zY3JvbGwucmVjID0gc2Nyb2xsRnVuYygpKTtcbiAgICAgICAgICBwcmV2U2Nyb2xsID0gTWF0aC5tYXgoc2Nyb2xsRnVuYygpLCBzZWxmLnNjcm9sbC5yZWMgfHwgMCk7IC8vIHJlY29yZCB0aGUgc2Nyb2xsIHNvIHdlIGNhbiByZXZlcnQgbGF0ZXIgKHJlcG9zaXRpb25pbmcvcGlubmluZyB0aGluZ3MgY2FuIGFmZmVjdCBzY3JvbGwgcG9zaXRpb24pLiBJbiB0aGUgc3RhdGljIHJlZnJlc2goKSBtZXRob2QsIHdlIGZpcnN0IHJlY29yZCBhbGwgdGhlIHNjcm9sbCBwb3NpdGlvbnMgYXMgYSByZWZlcmVuY2UuXG5cbiAgICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBzZWxmLnByb2dyZXNzO1xuICAgICAgICAgIHByZXZBbmltUHJvZ3Jlc3MgPSBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnByb2dyZXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uc3R5bGUuZGlzcGxheSA9IHIgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIHIgJiYgKF9yZWZyZXNoaW5nID0gMSk7XG4gICAgICAgIHNlbGYudXBkYXRlKHIpOyAvLyBtYWtlIHN1cmUgdGhlIHBpbiBpcyBiYWNrIGluIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiBzbyB0aGF0IGFsbCB0aGUgbWVhc3VyZW1lbnRzIGFyZSBjb3JyZWN0LlxuXG4gICAgICAgIF9yZWZyZXNoaW5nID0gcHJldlJlZnJlc2hpbmc7XG4gICAgICAgIHBpbiAmJiAociA/IF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBwaW5PcmlnaW5hbFN0YXRlKSA6ICghcGluUmVwYXJlbnQgfHwgIXNlbGYuaXNBY3RpdmUpICYmIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIF9nZXRDb21wdXRlZFN0eWxlKHBpbiksIHNwYWNlclN0YXRlKSk7XG4gICAgICAgIHNlbGYuaXNSZXZlcnRlZCA9IHI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uIChzb2Z0LCBmb3JjZSkge1xuICAgICAgaWYgKChfcmVmcmVzaGluZyB8fCAhc2VsZi5lbmFibGVkKSAmJiAhZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluICYmIHNvZnQgJiYgX2xhc3RTY3JvbGxUaW1lKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgIV9yZWZyZXNoaW5nQWxsICYmIG9uUmVmcmVzaEluaXQgJiYgb25SZWZyZXNoSW5pdChzZWxmKTtcbiAgICAgIF9yZWZyZXNoaW5nID0gMTtcbiAgICAgIGxhc3RSZWZyZXNoID0gX2dldFRpbWUoKTtcblxuICAgICAgaWYgKHR3ZWVuVG8udHdlZW4pIHtcbiAgICAgICAgdHdlZW5Uby50d2Vlbi5raWxsKCk7XG4gICAgICAgIHR3ZWVuVG8udHdlZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucGF1c2UoKTtcbiAgICAgIGludmFsaWRhdGVPblJlZnJlc2ggJiYgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi50aW1lKC0wLjAxLCB0cnVlKS5pbnZhbGlkYXRlKCk7XG4gICAgICBzZWxmLmlzUmV2ZXJ0ZWQgfHwgc2VsZi5yZXZlcnQoKTtcblxuICAgICAgdmFyIHNpemUgPSBnZXRTY3JvbGxlclNpemUoKSxcbiAgICAgICAgICBzY3JvbGxlckJvdW5kcyA9IGdldFNjcm9sbGVyT2Zmc2V0cygpLFxuICAgICAgICAgIG1heCA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpIDogX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKSxcbiAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgIG90aGVyUGluT2Zmc2V0ID0gMCxcbiAgICAgICAgICBwYXJzZWRFbmQgPSB2YXJzLmVuZCxcbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdmFycy5lbmRUcmlnZ2VyIHx8IHRyaWdnZXIsXG4gICAgICAgICAgcGFyc2VkU3RhcnQgPSB2YXJzLnN0YXJ0IHx8ICh2YXJzLnN0YXJ0ID09PSAwIHx8ICF0cmlnZ2VyID8gMCA6IHBpbiA/IFwiMCAwXCIgOiBcIjAgMTAwJVwiKSxcbiAgICAgICAgICBwaW5uZWRDb250YWluZXIgPSBzZWxmLnBpbm5lZENvbnRhaW5lciA9IHZhcnMucGlubmVkQ29udGFpbmVyICYmIF9nZXRUYXJnZXQodmFycy5waW5uZWRDb250YWluZXIpLFxuICAgICAgICAgIHRyaWdnZXJJbmRleCA9IHRyaWdnZXIgJiYgTWF0aC5tYXgoMCwgX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikpIHx8IDAsXG4gICAgICAgICAgaSA9IHRyaWdnZXJJbmRleCxcbiAgICAgICAgICBjcyxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgICAgb3ZlcnJpZGUsXG4gICAgICAgICAgY3VyVHJpZ2dlcixcbiAgICAgICAgICBjdXJQaW4sXG4gICAgICAgICAgb3Bwb3NpdGVTY3JvbGwsXG4gICAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgICByZXZlcnRlZFBpbnM7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgLy8gdXNlciBtaWdodCB0cnkgdG8gcGluIHRoZSBzYW1lIGVsZW1lbnQgbW9yZSB0aGFuIG9uY2UsIHNvIHdlIG11c3QgZmluZCBhbnkgcHJpb3IgdHJpZ2dlcnMgd2l0aCB0aGUgc2FtZSBwaW4sIHJldmVydCB0aGVtLCBhbmQgZGV0ZXJtaW5lIGhvdyBsb25nIHRoZXkncmUgcGlubmluZyBzbyB0aGF0IHdlIGNhbiBvZmZzZXQgdGhpbmdzIGFwcHJvcHJpYXRlbHkuIE1ha2Ugc3VyZSB3ZSByZXZlcnQgZnJvbSBsYXN0IHRvIGZpcnN0IHNvIHRoYXQgdGhpbmdzIFwicmV3aW5kXCIgcHJvcGVybHkuXG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG4gICAgICAgIGN1clRyaWdnZXIuZW5kIHx8IGN1clRyaWdnZXIucmVmcmVzaCgwLCAxKSB8fCAoX3JlZnJlc2hpbmcgPSAxKTsgLy8gaWYgaXQncyBhIHRpbWVsaW5lLWJhc2VkIHRyaWdnZXIgdGhhdCBoYXNuJ3QgYmVlbiBmdWxseSBpbml0aWFsaXplZCB5ZXQgYmVjYXVzZSBpdCdzIHdhaXRpbmcgZm9yIDEgdGljaywganVzdCBmb3JjZSB0aGUgcmVmcmVzaCgpIGhlcmUsIG90aGVyd2lzZSBpZiBpdCBjb250YWlucyBhIHBpbiB0aGF0J3Mgc3VwcG9zZWQgdG8gYWZmZWN0IG90aGVyIFNjcm9sbFRyaWdnZXJzIGZ1cnRoZXIgZG93biB0aGUgcGFnZSwgdGhleSB3b24ndCBiZSBhZGp1c3RlZCBwcm9wZXJseS5cblxuICAgICAgICBjdXJQaW4gPSBjdXJUcmlnZ2VyLnBpbjtcblxuICAgICAgICBpZiAoY3VyUGluICYmIChjdXJQaW4gPT09IHRyaWdnZXIgfHwgY3VyUGluID09PSBwaW4pICYmICFjdXJUcmlnZ2VyLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgICByZXZlcnRlZFBpbnMgfHwgKHJldmVydGVkUGlucyA9IFtdKTtcbiAgICAgICAgICByZXZlcnRlZFBpbnMudW5zaGlmdChjdXJUcmlnZ2VyKTsgLy8gd2UnbGwgcmV2ZXJ0IGZyb20gZmlyc3QgdG8gbGFzdCB0byBtYWtlIHN1cmUgdGhpbmdzIHJlYWNoIHRoZWlyIGVuZCBzdGF0ZSBwcm9wZXJseVxuXG4gICAgICAgICAgY3VyVHJpZ2dlci5yZXZlcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJUcmlnZ2VyICE9PSBfdHJpZ2dlcnNbaV0pIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIGl0IGdvdCByZW1vdmVkLlxuICAgICAgICAgIHRyaWdnZXJJbmRleC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfaXNGdW5jdGlvbihwYXJzZWRTdGFydCkgJiYgKHBhcnNlZFN0YXJ0ID0gcGFyc2VkU3RhcnQoc2VsZikpO1xuICAgICAgc3RhcnQgPSBfcGFyc2VQb3NpdGlvbihwYXJzZWRTdGFydCwgdHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGxGdW5jKCksIG1hcmtlclN0YXJ0LCBtYXJrZXJTdGFydFRyaWdnZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgbWF4LCBjb250YWluZXJBbmltYXRpb24pIHx8IChwaW4gPyAtMC4wMDEgOiAwKTtcbiAgICAgIF9pc0Z1bmN0aW9uKHBhcnNlZEVuZCkgJiYgKHBhcnNlZEVuZCA9IHBhcnNlZEVuZChzZWxmKSk7XG5cbiAgICAgIGlmIChfaXNTdHJpbmcocGFyc2VkRW5kKSAmJiAhcGFyc2VkRW5kLmluZGV4T2YoXCIrPVwiKSkge1xuICAgICAgICBpZiAofnBhcnNlZEVuZC5pbmRleE9mKFwiIFwiKSkge1xuICAgICAgICAgIHBhcnNlZEVuZCA9IChfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQuc3BsaXQoXCIgXCIpWzBdIDogXCJcIikgKyBwYXJzZWRFbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gX29mZnNldFRvUHgocGFyc2VkRW5kLnN1YnN0cigyKSwgc2l6ZSk7XG4gICAgICAgICAgcGFyc2VkRW5kID0gX2lzU3RyaW5nKHBhcnNlZFN0YXJ0KSA/IHBhcnNlZFN0YXJ0IDogc3RhcnQgKyBvZmZzZXQ7IC8vIF9wYXJzZVBvc2l0aW9uIHdvbid0IGZhY3RvciBpbiB0aGUgb2Zmc2V0IGlmIHRoZSBzdGFydCBpcyBhIG51bWJlciwgc28gZG8gaXQgaGVyZS5cblxuICAgICAgICAgIHBhcnNlZEVuZFRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBfcGFyc2VQb3NpdGlvbihwYXJzZWRFbmQgfHwgKHBhcnNlZEVuZFRyaWdnZXIgPyBcIjEwMCUgMFwiIDogbWF4KSwgcGFyc2VkRW5kVHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGxGdW5jKCkgKyBvZmZzZXQsIG1hcmtlckVuZCwgbWFya2VyRW5kVHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgsIGNvbnRhaW5lckFuaW1hdGlvbikpIHx8IC0wLjAwMTtcbiAgICAgIGNoYW5nZSA9IGVuZCAtIHN0YXJ0IHx8IChzdGFydCAtPSAwLjAxKSAmJiAwLjAwMTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBpID0gdHJpZ2dlckluZGV4O1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG4gICAgICAgIGN1clBpbiA9IGN1clRyaWdnZXIucGluO1xuXG4gICAgICAgIGlmIChjdXJQaW4gJiYgY3VyVHJpZ2dlci5zdGFydCAtIGN1clRyaWdnZXIuX3BpblB1c2ggPCBzdGFydCAmJiAhY29udGFpbmVyQW5pbWF0aW9uICYmIGN1clRyaWdnZXIuZW5kID4gMCkge1xuICAgICAgICAgIGNzID0gY3VyVHJpZ2dlci5lbmQgLSBjdXJUcmlnZ2VyLnN0YXJ0O1xuXG4gICAgICAgICAgaWYgKChjdXJQaW4gPT09IHRyaWdnZXIgfHwgY3VyUGluID09PSBwaW5uZWRDb250YWluZXIpICYmICFfaXNOdW1iZXIocGFyc2VkU3RhcnQpKSB7XG4gICAgICAgICAgICAvLyBudW1lcmljIHN0YXJ0IHZhbHVlcyBzaG91bGRuJ3QgYmUgb2Zmc2V0IGF0IGFsbCAtIHRyZWF0IHRoZW0gYXMgYWJzb2x1dGVcbiAgICAgICAgICAgIG9mZnNldCArPSBjcyAqICgxIC0gY3VyVHJpZ2dlci5wcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyUGluID09PSBwaW4gJiYgKG90aGVyUGluT2Zmc2V0ICs9IGNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGFydCArPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgICAgc2VsZi5fcGluUHVzaCA9IG90aGVyUGluT2Zmc2V0O1xuXG4gICAgICBpZiAobWFya2VyU3RhcnQgJiYgb2Zmc2V0KSB7XG4gICAgICAgIC8vIG9mZnNldCB0aGUgbWFya2VycyBpZiBuZWNlc3NhcnlcbiAgICAgICAgY3MgPSB7fTtcbiAgICAgICAgY3NbZGlyZWN0aW9uLmFdID0gXCIrPVwiICsgb2Zmc2V0O1xuICAgICAgICBwaW5uZWRDb250YWluZXIgJiYgKGNzW2RpcmVjdGlvbi5wXSA9IFwiLT1cIiArIHNjcm9sbEZ1bmMoKSk7XG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgY3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluKSB7XG4gICAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcbiAgICAgICAgaXNWZXJ0aWNhbCA9IGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsO1xuICAgICAgICBzY3JvbGwgPSBzY3JvbGxGdW5jKCk7IC8vIHJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHRyaWdnZXJzIGNhbiBhZmZlY3QgdGhlIHNjcm9sbFxuXG4gICAgICAgIHBpblN0YXJ0ID0gcGFyc2VGbG9hdChwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpKSArIG90aGVyUGluT2Zmc2V0O1xuICAgICAgICAhbWF4ICYmIGVuZCAIDEgJiYgKChpc1ZpZXdwb3J0ID8gX2JvZHkgOiBzY3JvbGxlcikuc3R5bGVbXCJvdmVyZmxvdy1cIiArIGRpcmVjdGlvbi5hXSA9IFwic2Nyb2xsXCIpOyAvLyBtYWtlcyBzdXJlIHRoZSBzY3JvbGxlciBoYXMgYSBzY3JvbGxiYXIsIG90aGVyd2lzZSBpZiBzb21ldGhpbmcgaGFzIHdpZHRoOiAxMDAlLCBmb3IgZXhhbXBsZSwgaXQgd291bGQgYmUgdG9vIGJpZyAoZXhjbHVkZSB0aGUgc2Nyb2xsYmFyKS4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjUxODItc2Nyb2xsdHJpZ2dlci13aWR0aC1vZi1wYWdlLWluY3JlYXNlLXdoZXJlLW1hcmtlcnMtYXJlLXNldC10by1mYWxzZS9cblxuICAgICAgICBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBjcyk7XG5cbiAgICAgICAgcGluU3RhdGUgPSBfZ2V0U3RhdGUocGluKTsgLy8gdHJhbnNmb3JtcyB3aWxsIGludGVyZmVyZSB3aXRoIHRoZSB0b3AvbGVmdC9yaWdodC9ib3R0b20gcGxhY2VtZW50LCBzbyByZW1vdmUgdGhlbSB0ZW1wb3JhcmlseS4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgZmFjdG9ycyBpbiB0cmFuc2Zvcm1zLlxuXG4gICAgICAgIGJvdW5kcyA9IF9nZXRCb3VuZHMocGluLCB0cnVlKTtcbiAgICAgICAgb3Bwb3NpdGVTY3JvbGwgPSB1c2VGaXhlZFBvc2l0aW9uICYmIF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBpc1ZlcnRpY2FsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpKCk7XG5cbiAgICAgICAgaWYgKHBpblNwYWNpbmcpIHtcbiAgICAgICAgICBzcGFjZXJTdGF0ZSA9IFtwaW5TcGFjaW5nICsgZGlyZWN0aW9uLm9zMiwgY2hhbmdlICsgb3RoZXJQaW5PZmZzZXQgKyBfcHhdO1xuICAgICAgICAgIHNwYWNlclN0YXRlLnQgPSBzcGFjZXI7XG4gICAgICAgICAgaSA9IHBpblNwYWNpbmcgPT09IF9wYWRkaW5nID8gX2dldFNpemUocGluLCBkaXJlY3Rpb24pICsgY2hhbmdlICsgb3RoZXJQaW5PZmZzZXQgOiAwO1xuICAgICAgICAgIGkgJiYgc3BhY2VyU3RhdGUucHVzaChkaXJlY3Rpb24uZCwgaSArIF9weCk7IC8vIGZvciBib3gtc2l6aW5nOiBib3JkZXItYm94IChtdXN0IGluY2x1ZGUgcGFkZGluZykuXG5cbiAgICAgICAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuXG4gICAgICAgICAgdXNlRml4ZWRQb3NpdGlvbiAmJiBzY3JvbGxGdW5jKHByZXZTY3JvbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgICAgICBvdmVycmlkZSA9IHtcbiAgICAgICAgICAgIHRvcDogYm91bmRzLnRvcCArIChpc1ZlcnRpY2FsID8gc2Nyb2xsIC0gc3RhcnQgOiBvcHBvc2l0ZVNjcm9sbCkgKyBfcHgsXG4gICAgICAgICAgICBsZWZ0OiBib3VuZHMubGVmdCArIChpc1ZlcnRpY2FsID8gb3Bwb3NpdGVTY3JvbGwgOiBzY3JvbGwgLSBzdGFydCkgKyBfcHgsXG4gICAgICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgb3ZlcnJpZGVbX3dpZHRoXSA9IG92ZXJyaWRlW1wibWF4XCIgKyBfV2lkdGhdID0gTWF0aC5jZWlsKGJvdW5kcy53aWR0aCkgKyBfcHg7XG4gICAgICAgICAgb3ZlcnJpZGVbX2hlaWdodF0gPSBvdmVycmlkZVtcIm1heFwiICsgX0hlaWdodF0gPSBNYXRoLmNlaWwoYm91bmRzLmhlaWdodCkgKyBfcHg7XG4gICAgICAgICAgb3ZlcnJpZGVbX21hcmdpbl0gPSBvdmVycmlkZVtfbWFyZ2luICsgX1RvcF0gPSBvdmVycmlkZVtfbWFyZ2luICsgX1JpZ2h0XSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfQm90dG9tXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfTGVmdF0gPSBcIjBcIjtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZ10gPSBjc1tfcGFkZGluZ107XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfVG9wXSA9IGNzW19wYWRkaW5nICsgX1RvcF07XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfUmlnaHRdID0gY3NbX3BhZGRpbmcgKyBfUmlnaHRdO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX0JvdHRvbV0gPSBjc1tfcGFkZGluZyArIF9Cb3R0b21dO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX0xlZnRdID0gY3NbX3BhZGRpbmcgKyBfTGVmdF07XG4gICAgICAgICAgcGluQWN0aXZlU3RhdGUgPSBfY29weVN0YXRlKHBpbk9yaWdpbmFsU3RhdGUsIG92ZXJyaWRlLCBwaW5SZXBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBtaWdodCBiZSBhZmZlY3RpbmcgdGhlIHRyYW5zZm9ybSwgc28gd2UgbXVzdCBqdW1wIHRvIHRoZSBlbmQsIGNoZWNrIHRoZSB2YWx1ZSwgYW5kIGNvbXBlbnNhdGUgYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgd2hlbiBpdCBiZWNvbWVzIHVucGlubmVkLCB0aGUgcGluU2V0dGVyKCkgd2lsbCBnZXQgc2V0IHRvIGEgdmFsdWUgdGhhdCBkb2Vzbid0IGluY2x1ZGUgd2hhdGV2ZXIgdGhlIGFuaW1hdGlvbiBkaWQuXG4gICAgICAgICAgaW5pdHRlZCA9IGFuaW1hdGlvbi5faW5pdHRlZDsgLy8gaWYgbm90LCB3ZSBtdXN0IGludmFsaWRhdGUoKSBhZnRlciB0aGlzIHN0ZXAsIG90aGVyd2lzZSBpdCBjb3VsZCBsb2NrIGluIHN0YXJ0aW5nIHZhbHVlcyBwcmVtYXR1cmVseS5cblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMSk7XG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKGFuaW1hdGlvbi5kdXJhdGlvbigpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBwaW5DaGFuZ2UgPSBwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpIC0gcGluU3RhcnQgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldDtcbiAgICAgICAgICBjaGFuZ2UgIT09IHBpbkNoYW5nZSAmJiB1c2VGaXhlZFBvc2l0aW9uICYmIHBpbkFjdGl2ZVN0YXRlLnNwbGljZShwaW5BY3RpdmVTdGF0ZS5sZW5ndGggLSAyLCAyKTsgLy8gdHJhbnNmb3JtIGlzIHRoZSBsYXN0IHByb3BlcnR5L3ZhbHVlIHNldCBpbiB0aGUgc3RhdGUgQXJyYXkuIFNpbmNlIHRoZSBhbmltYXRpb24gaXMgY29udHJvbGxpbmcgdGhhdCwgd2Ugc2hvdWxkIG9taXQgaXQuXG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGluaXR0ZWQgfHwgYW5pbWF0aW9uLmludmFsaWRhdGUoKTtcblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGluQ2hhbmdlID0gY2hhbmdlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgJiYgc2Nyb2xsRnVuYygpICYmICFjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgICAgLy8gaXQgbWF5IGJlIElOU0lERSBhIHBpbm5lZCBlbGVtZW50LCBzbyB3YWxrIHVwIHRoZSB0cmVlIGFuZCBsb29rIGZvciBhbnkgZWxlbWVudHMgd2l0aCBfcGluT2Zmc2V0IHRvIGNvbXBlbnNhdGUgYmVjYXVzZSBhbnl0aGluZyB3aXRoIHBpblNwYWNpbmcgdGhhdCdzIGFscmVhZHkgc2Nyb2xsZWQgd291bGQgdGhyb3cgb2ZmIHRoZSBtZWFzdXJlbWVudHMgaW4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgYm91bmRzID0gdHJpZ2dlci5wYXJlbnROb2RlO1xuXG4gICAgICAgIHdoaWxlIChib3VuZHMgJiYgYm91bmRzICE9PSBfYm9keSkge1xuICAgICAgICAgIGlmIChib3VuZHMuX3Bpbk9mZnNldCkge1xuICAgICAgICAgICAgc3RhcnQgLT0gYm91bmRzLl9waW5PZmZzZXQ7XG4gICAgICAgICAgICBlbmQgLT0gYm91bmRzLl9waW5PZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm91bmRzID0gYm91bmRzLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV2ZXJ0ZWRQaW5zICYmIHJldmVydGVkUGlucy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnJldmVydChmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHNlbGYuc3RhcnQgPSBzdGFydDtcbiAgICAgIHNlbGYuZW5kID0gZW5kO1xuICAgICAgc2Nyb2xsMSA9IHNjcm9sbDIgPSBzY3JvbGxGdW5jKCk7IC8vIHJlc2V0IHZlbG9jaXR5XG5cbiAgICAgIGlmICghY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIHNjcm9sbDEgPCBwcmV2U2Nyb2xsICYmIHNjcm9sbEZ1bmMocHJldlNjcm9sbCk7XG4gICAgICAgIHNlbGYuc2Nyb2xsLnJlYyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmV2ZXJ0KGZhbHNlKTtcblxuICAgICAgaWYgKHNuYXBEZWxheWVkQ2FsbCkge1xuICAgICAgICBsYXN0U25hcCA9IC0xO1xuICAgICAgICBzZWxmLmlzQWN0aXZlICYmIHNjcm9sbEZ1bmMoc3RhcnQgKyBjaGFuZ2UgKiBwcmV2UHJvZ3Jlc3MpOyAvLyBqdXN0IHNvIHNuYXBwaW5nIGdldHMgcmUtZW5hYmxlZCwgY2xlYXIgb3V0IGFueSByZWNvcmRlZCBsYXN0IHZhbHVlXG5cbiAgICAgICAgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIF9yZWZyZXNoaW5nID0gMDtcbiAgICAgIGFuaW1hdGlvbiAmJiBpc1RvZ2dsZSAmJiAoYW5pbWF0aW9uLl9pbml0dGVkIHx8IHByZXZBbmltUHJvZ3Jlc3MpICYmIGFuaW1hdGlvbi5wcm9ncmVzcygpICE9PSBwcmV2QW5pbVByb2dyZXNzICYmIGFuaW1hdGlvbi5wcm9ncmVzcyhwcmV2QW5pbVByb2dyZXNzLCB0cnVlKS5yZW5kZXIoYW5pbWF0aW9uLnRpbWUoKSwgdHJ1ZSwgdHJ1ZSk7IC8vIG11c3QgZm9yY2UgYSByZS1yZW5kZXIgYmVjYXVzZSBpZiBzYXZlU3R5bGVzKCkgd2FzIHVzZWQgb24gdGhlIHRhcmdldChzKSwgdGhlIHN0eWxlcyBjb3VsZCBoYXZlIGJlZW4gd2lwZWQgb3V0IGR1cmluZyB0aGUgcmVmcmVzaCgpLlxuXG4gICAgICBpZiAocHJldlByb2dyZXNzICE9PSBzZWxmLnByb2dyZXNzIHx8IGNvbnRhaW5lckFuaW1hdGlvbikge1xuICAgICAgICAvLyBlbnN1cmVzIHRoYXQgdGhlIGRpcmVjdGlvbiBpcyBzZXQgcHJvcGVybHkgKHdoZW4gcmVmcmVzaGluZywgcHJvZ3Jlc3MgaXMgc2V0IGJhY2sgdG8gMCBpbml0aWFsbHksIHRoZW4gYmFjayBhZ2FpbiB0byB3aGVyZXZlciBpdCBuZWVkcyB0byBiZSkgYW5kIHRoYXQgY2FsbGJhY2tzIGFyZSB0cmlnZ2VyZWQuXG4gICAgICAgIGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgJiYgYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MocHJldlByb2dyZXNzLCB0cnVlKTsgLy8gdG8gYXZvaWQgaXNzdWVzIHdoZXJlIGFuaW1hdGlvbiBjYWxsYmFja3MgbGlrZSBvblN0YXJ0IGFyZW4ndCB0cmlnZ2VyZWQuXG5cbiAgICAgICAgc2VsZi5wcm9ncmVzcyA9IHByZXZQcm9ncmVzcztcbiAgICAgICAgc2VsZi51cGRhdGUoMCwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHBpbiAmJiBwaW5TcGFjaW5nICYmIChzcGFjZXIuX3Bpbk9mZnNldCA9IE1hdGgucm91bmQoc2VsZi5wcm9ncmVzcyAqIHBpbkNoYW5nZSkpOyAvL1x0XHRcdHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCk7XG5cbiAgICAgIG9uUmVmcmVzaCAmJiBvblJlZnJlc2goc2VsZik7XG4gICAgfTtcblxuICAgIHNlbGYuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHNjcm9sbEZ1bmMoKSAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogMTAwMCB8fCAwO1xuICAgIH07XG5cbiAgICBzZWxmLmVuZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9lbmRBbmltYXRpb24oc2VsZi5jYWxsYmFja0FuaW1hdGlvbik7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4ucHJvZ3Jlc3MoMSkgOiAhYW5pbWF0aW9uLnBhdXNlZCgpID8gX2VuZEFuaW1hdGlvbihhbmltYXRpb24sIGFuaW1hdGlvbi5yZXZlcnNlZCgpKSA6IGlzVG9nZ2xlIHx8IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBzZWxmLmRpcmVjdGlvbiA8IDAsIDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmxhYmVsVG9TY3JvbGwgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgIHJldHVybiBhbmltYXRpb24gJiYgYW5pbWF0aW9uLmxhYmVscyAmJiAoc3RhcnQgfHwgc2VsZi5yZWZyZXNoKCkgfHwgc3RhcnQpICsgYW5pbWF0aW9uLmxhYmVsc1tsYWJlbF0gLyBhbmltYXRpb24uZHVyYXRpb24oKSAqIGNoYW5nZSB8fCAwO1xuICAgIH07XG5cbiAgICBzZWxmLmdldFRyYWlsaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZiksXG4gICAgICAgICAgYSA9IHNlbGYuZGlyZWN0aW9uID4gMCA/IF90cmlnZ2Vycy5zbGljZSgwLCBpKS5yZXZlcnNlKCkgOiBfdHJpZ2dlcnMuc2xpY2UoaSArIDEpO1xuXG4gICAgICByZXR1cm4gKF9pc1N0cmluZyhuYW1lKSA/IGEuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnZhcnMucHJldmVudE92ZXJsYXBzID09PSBuYW1lO1xuICAgICAgfSkgOiBhKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZGlyZWN0aW9uID4gMCA/IHQuZW5kIDw9IHN0YXJ0IDogdC5zdGFydCAPSBlbmQ7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgc2VsZi51cGRhdGUgPSBmdW5jdGlvbiAocmVzZXQsIHJlY29yZFZlbG9jaXR5LCBmb3JjZUZha2UpIHtcbiAgICAgIGlmIChjb250YWluZXJBbmltYXRpb24gJiYgIWZvcmNlRmFrZSAmJiAhcmVzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2Nyb2xsID0gc2VsZi5zY3JvbGwoKSxcbiAgICAgICAgICBwID0gcmVzZXQgPyAwIDogKHNjcm9sbCAtIHN0YXJ0KSAvIGNoYW5nZSxcbiAgICAgICAgICBjbGlwcGVkID0gcCA8IDAgPyAwIDogcCAIDEgPyAxIDogcCB8fCAwLFxuICAgICAgICAgIHByZXZQcm9ncmVzcyA9IHNlbGYucHJvZ3Jlc3MsXG4gICAgICAgICAgaXNBY3RpdmUsXG4gICAgICAgICAgd2FzQWN0aXZlLFxuICAgICAgICAgIHRvZ2dsZVN0YXRlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBzdGF0ZUNoYW5nZWQsXG4gICAgICAgICAgdG9nZ2xlZCxcbiAgICAgICAgICBpc0F0TWF4LFxuICAgICAgICAgIGlzVGFraW5nQWN0aW9uO1xuXG4gICAgICBpZiAocmVjb3JkVmVsb2NpdHkpIHtcbiAgICAgICAgc2Nyb2xsMiA9IHNjcm9sbDE7XG4gICAgICAgIHNjcm9sbDEgPSBjb250YWluZXJBbmltYXRpb24gPyBzY3JvbGxGdW5jKCkgOiBzY3JvbGw7XG5cbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICBzbmFwMiA9IHNuYXAxO1xuICAgICAgICAgIHNuYXAxID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBjbGlwcGVkO1xuICAgICAgICB9XG4gICAgICB9IC8vIGFudGljaXBhdGUgdGhlIHBpbm5pbmcgYSBmZXcgdGlja3MgYWhlYWQgb2YgdGltZSBiYXNlZCBvbiB2ZWxvY2l0eSB0byBhdm9pZCBhIHZpc3VhbCBnbGl0Y2ggZHVlIHRvIHRoZSBmYWN0IHRoYXQgbW9zdCBicm93c2VycyBkbyBzY3JvbGxpbmcgb24gYSBzZXBhcmF0ZSB0aHJlYWQgKG5vdCBzeW5jZWQgd2l0aCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLlxuXG5cbiAgICAgIGFudGljaXBhdGVQaW4gJiYgIWNsaXBwZWQgJiYgcGluICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgX2xhc3RTY3JvbGxUaW1lICYmIHN0YXJ0IDwgc2Nyb2xsICsgKHNjcm9sbCAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogYW50aWNpcGF0ZVBpbiAmJiAoY2xpcHBlZCA9IDAuMDAwMSk7XG5cbiAgICAgIGlmIChjbGlwcGVkICE9PSBwcmV2UHJvZ3Jlc3MgJiYgc2VsZi5lbmFibGVkKSB7XG4gICAgICAgIGlzQWN0aXZlID0gc2VsZi5pc0FjdGl2ZSA9ICEhY2xpcHBlZCAmJiBjbGlwcGVkIDwgMTtcbiAgICAgICAgd2FzQWN0aXZlID0gISFwcmV2UHJvZ3Jlc3MgJiYgcHJldlByb2dyZXNzIDwgMTtcbiAgICAgICAgdG9nZ2xlZCA9IGlzQWN0aXZlICE9PSB3YXNBY3RpdmU7XG4gICAgICAgIHN0YXRlQ2hhbmdlZCA9IHRvZ2dsZWQgfHwgISFjbGlwcGVkICE9PSAhIXByZXZQcm9ncmVzczsgLy8gY291bGQgZ28gZnJvbSBzdGFydCBhbGwgdGhlIHdheSB0byBlbmQsIHRodXMgaXQgZGlkbid0IHRvZ2dsZSBidXQgaXQgZGlkIGNoYW5nZSBzdGF0ZSBpbiBhIHNlbnNlIChtYXkgbmVlZCB0byBmaXJlIGEgY2FsbGJhY2spXG5cbiAgICAgICAgc2VsZi5kaXJlY3Rpb24gPSBjbGlwcGVkID4gcHJldlByb2dyZXNzID8gMSA6IC0xO1xuICAgICAgICBzZWxmLnByb2dyZXNzID0gY2xpcHBlZDtcblxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIHRvZ2dsZVN0YXRlID0gY2xpcHBlZCAmJiAhcHJldlByb2dyZXNzID8gMCA6IGNsaXBwZWQgPT09IDEgPyAxIDogcHJldlByb2dyZXNzID09PSAxID8gMiA6IDM7IC8vIDAgPSBlbnRlciwgMSA9IGxlYXZlLCAyID0gZW50ZXJCYWNrLCAzID0gbGVhdmVCYWNrICh3ZSBwcmlvcml0aXplIHRoZSBGSVJTVCBlbmNvdW50ZXIsIHRodXMgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCBwYXN0IHRoZSBvbkVudGVyIGFuZCBvbkxlYXZlIGluIG9uZSB0aWNrLCBpdCdkIHByaW9yaXRpemUgb25FbnRlci5cblxuICAgICAgICAgIGlmIChpc1RvZ2dsZSkge1xuICAgICAgICAgICAgYWN0aW9uID0gIXRvZ2dsZWQgJiYgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZSArIDFdICE9PSBcIm5vbmVcIiAmJiB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlICsgMV0gfHwgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZV07IC8vIGlmIGl0IGRpZG4ndCB0b2dnbGUsIHRoYXQgbWVhbnMgaXQgc2hvdCByaWdodCBwYXN0IGFuZCBzaW5jZSB3ZSBwcmlvcml0aXplIHRoZSBcImVudGVyXCIgYWN0aW9uLCB3ZSBzaG91bGQgc3dpdGNoIHRvIHRoZSBcImxlYXZlXCIgaW4gdGhpcyBjYXNlIChidXQgb25seSBpZiBvbmUgaXMgZGVmaW5lZClcblxuICAgICAgICAgICAgaXNUYWtpbmdBY3Rpb24gPSBhbmltYXRpb24gJiYgKGFjdGlvbiA9PT0gXCJjb21wbGV0ZVwiIHx8IGFjdGlvbiA9PT0gXCJyZXNldFwiIHx8IGFjdGlvbiBpbiBhbmltYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZlbnRPdmVybGFwcyAmJiAodG9nZ2xlZCB8fCBpc1Rha2luZ0FjdGlvbikgJiYgKGlzVGFraW5nQWN0aW9uIHx8IHNjcnViIHx8ICFhbmltYXRpb24pICYmIChfaXNGdW5jdGlvbihwcmV2ZW50T3ZlcmxhcHMpID8gcHJldmVudE92ZXJsYXBzKHNlbGYpIDogc2VsZi5nZXRUcmFpbGluZyhwcmV2ZW50T3ZlcmxhcHMpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5lbmRBbmltYXRpb24oKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmICghaXNUb2dnbGUpIHtcbiAgICAgICAgICBpZiAoc2NydWJUd2VlbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwKSB7XG4gICAgICAgICAgICAoY29udGFpbmVyQW5pbWF0aW9uIHx8IF9wcmltYXJ5ICYmIF9wcmltYXJ5ICE9PSBzZWxmKSAmJiBzY3J1YlR3ZWVuLnJlbmRlcihzY3J1YlR3ZWVuLl9kcC5fdGltZSAtIHNjcnViVHdlZW4uX3N0YXJ0KTsgLy8gaWYgdGhlcmUncyBhIHNjcnViIG9uIGJvdGggdGhlIGNvbnRhaW5lciBhbmltYXRpb24gYW5kIHRoaXMgb25lIChvciBhIFNjcm9sbFNtb290aGVyKSwgdGhlIHVwZGF0ZSBvcmRlciB3b3VsZCBjYXVzZSB0aGlzIG9uZSBub3QgdG8gaGF2ZSByZW5kZXJlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IG1ha2UgYW55IHByb2dyZXNzIGJlZm9yZSB3ZSAucmVzdGFydCgpIGl0IGhlYWRpbmcgdG93YXJkIHRoZSBuZXcgcHJvZ3Jlc3Mgc28gaXQnZCBhcHBlYXIgc3R1Y2sgdGh1cyB3ZSBmb3JjZSBhIHJlbmRlciBoZXJlLlxuXG4gICAgICAgICAgICBpZiAoc2NydWJUd2Vlbi5yZXNldFRvKSB7XG4gICAgICAgICAgICAgIHNjcnViVHdlZW4ucmVzZXRUbyhcInRvdGFsUHJvZ3Jlc3NcIiwgY2xpcHBlZCwgYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsZWdhY3kgc3VwcG9ydCAoY291cnRlc3kpLCBiZWZvcmUgMy4xMC4wXG4gICAgICAgICAgICAgIHNjcnViVHdlZW4udmFycy50b3RhbFByb2dyZXNzID0gY2xpcHBlZDtcbiAgICAgICAgICAgICAgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCkucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb24udG90YWxQcm9ncmVzcyhjbGlwcGVkLCAhIV9yZWZyZXNoaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGluKSB7XG4gICAgICAgICAgcmVzZXQgJiYgcGluU3BhY2luZyAmJiAoc3BhY2VyLnN0eWxlW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXSA9IHNwYWNpbmdTdGFydCk7XG5cbiAgICAgICAgICBpZiAoIXVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBpblNldHRlcihfcm91bmQocGluU3RhcnQgKyBwaW5DaGFuZ2UgKiBjbGlwcGVkKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlzQXRNYXggPSAhcmVzZXQgJiYgY2xpcHBlZCAIHByZXZQcm9ncmVzcyAmJiBlbmQgKyAxID4gc2Nyb2xsICYmIHNjcm9sbCArIDEgPj0gX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKTsgLy8gaWYgaXQncyBhdCB0aGUgVkVSWSBlbmQgb2YgdGhlIHBhZ2UsIGRvbid0IHN3aXRjaCBhd2F5IGZyb20gcG9zaXRpb246IGZpeGVkIGJlY2F1c2UgaXQncyBwb2ludGxlc3MgYW5kIGl0IGNvdWxkIGNhdXNlIGEgYnJpZWYgZmxhc2ggd2hlbiB0aGUgdXNlciBzY3JvbGxzIGJhY2sgdXAgKHdoZW4gaXQgZ2V0cyBwaW5uZWQgYWdhaW4pXG5cbiAgICAgICAgICAgIGlmIChwaW5SZXBhcmVudCkge1xuICAgICAgICAgICAgICBpZiAoIXJlc2V0ICYmIChpc0FjdGl2ZSB8fCBpc0F0TWF4KSkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBzY3JvbGwgLSBzdGFydDtcblxuICAgICAgICAgICAgICAgIF9yZXBhcmVudChwaW4sIF9ib2R5LCBib3VuZHMudG9wICsgKGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsID8gX29mZnNldCA6IDApICsgX3B4LCBib3VuZHMubGVmdCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IDAgOiBfb2Zmc2V0KSArIF9weCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3JlcGFyZW50KHBpbiwgc3BhY2VyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc2V0U3RhdGUoaXNBY3RpdmUgfHwgaXNBdE1heCA/IHBpbkFjdGl2ZVN0YXRlIDogcGluU3RhdGUpO1xuXG4gICAgICAgICAgICBwaW5DaGFuZ2UgIT09IGNoYW5nZSAmJiBjbGlwcGVkIDwgMSAmJiBpc0FjdGl2ZSB8fCBwaW5TZXR0ZXIocGluU3RhcnQgKyAoY2xpcHBlZCA9PT0gMSAmJiAhaXNBdE1heCA/IHBpbkNoYW5nZSA6IDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzbmFwICYmICF0d2VlblRvLnR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzICYmICh0b2dnbGVkIHx8IG9uY2UgJiYgY2xpcHBlZCAmJiAoY2xpcHBlZCA8IDEgfHwgIV9saW1pdENhbGxiYWNrcykpICYmIF90b0FycmF5KHRvZ2dsZUNsYXNzLnRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdFtpc0FjdGl2ZSB8fCBvbmNlID8gXCJhZGRcIiA6IFwicmVtb3ZlXCJdKHRvZ2dsZUNsYXNzLmNsYXNzTmFtZSk7XG4gICAgICAgIH0pOyAvLyBjbGFzc2VzIGNvdWxkIGFmZmVjdCBwb3NpdGlvbmluZywgc28gZG8gaXQgZXZlbiBpZiByZXNldCBvciByZWZyZXNoaW5nIGlzIHRydWUuXG5cbiAgICAgICAgb25VcGRhdGUgJiYgIWlzVG9nZ2xlICYmICFyZXNldCAmJiBvblVwZGF0ZShzZWxmKTtcblxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIGlmIChpc1RvZ2dsZSkge1xuICAgICAgICAgICAgaWYgKGlzVGFraW5nQWN0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpLnRvdGFsUHJvZ3Jlc3MoMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucmVzdGFydCh0cnVlKS5wYXVzZSgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucmVzdGFydCh0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25bYWN0aW9uXSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uVXBkYXRlICYmIG9uVXBkYXRlKHNlbGYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b2dnbGVkIHx8ICFfbGltaXRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIG9uIHN0YXJ0dXAsIHRoZSBwYWdlIGNvdWxkIGJlIHNjcm9sbGVkIGFuZCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgY2FsbGJhY2tzIHRoYXQgZGlkbid0IHRvZ2dsZS4gRm9yIGV4YW1wbGUgb25FbnRlciBzaG91bGRuJ3QgZmlyZSBpZiB0aGUgU2Nyb2xsVHJpZ2dlciBpc24ndCBhY3R1YWxseSBlbnRlcmVkLlxuICAgICAgICAgICAgb25Ub2dnbGUgJiYgdG9nZ2xlZCAmJiBfY2FsbGJhY2soc2VsZiwgb25Ub2dnbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSAmJiBfY2FsbGJhY2soc2VsZiwgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSk7XG4gICAgICAgICAgICBvbmNlICYmIChjbGlwcGVkID09PSAxID8gc2VsZi5raWxsKGZhbHNlLCAxKSA6IGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gPSAwKTsgLy8gYSBjYWxsYmFjayBzaG91bGRuJ3QgYmUgY2FsbGVkIGFnYWluIGlmIG9uY2UgaXMgdHJ1ZS5cblxuICAgICAgICAgICAgaWYgKCF0b2dnbGVkKSB7XG4gICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdG8gZ28gY29tcGxldGVseSBwYXN0LCBsaWtlIGZyb20gYmVmb3JlIHRoZSBzdGFydCB0byBhZnRlciB0aGUgZW5kIChvciB2aWNlLXZlcnNhKSBpbiB3aGljaCBjYXNlIEJPVEggY2FsbGJhY2tzIHNob3VsZCBiZSBmaXJlZCBpbiB0aGF0IG9yZGVyXG4gICAgICAgICAgICAgIHRvZ2dsZVN0YXRlID0gY2xpcHBlZCA9PT0gMSA/IDEgOiAzO1xuICAgICAgICAgICAgICBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIF9jYWxsYmFjayhzZWxmLCBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmFzdFNjcm9sbEVuZCAmJiAhaXNBY3RpdmUgJiYgTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSAIChfaXNOdW1iZXIoZmFzdFNjcm9sbEVuZCkgPyBmYXN0U2Nyb2xsRW5kIDogMjUwMCkpIHtcbiAgICAgICAgICAgIF9lbmRBbmltYXRpb24oc2VsZi5jYWxsYmFja0FuaW1hdGlvbik7XG5cbiAgICAgICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogX2VuZEFuaW1hdGlvbihhbmltYXRpb24sICFjbGlwcGVkLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUb2dnbGUgJiYgb25VcGRhdGUgJiYgIV9yZWZyZXNoaW5nKSB7XG4gICAgICAgICAgb25VcGRhdGUoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdXBkYXRlIGFic29sdXRlbHktcG9zaXRpb25lZCBtYXJrZXJzIChvbmx5IGlmIHRoZSBzY3JvbGxlciBpc24ndCB0aGUgdmlld3BvcnQpXG5cblxuICAgICAgaWYgKG1hcmtlckVuZFNldHRlcikge1xuICAgICAgICB2YXIgbiA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IHNjcm9sbCAvIGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpICogKGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0IHx8IDApIDogc2Nyb2xsO1xuICAgICAgICBtYXJrZXJTdGFydFNldHRlcihuICsgKG1hcmtlclN0YXJ0VHJpZ2dlci5faXNGbGlwcGVkID8gMSA6IDApKTtcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyKG4pO1xuICAgICAgfVxuXG4gICAgICBjYU1hcmtlclNldHRlciAmJiBjYU1hcmtlclNldHRlcigtc2Nyb2xsIC8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgKiAoY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgfHwgMCkpO1xuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVmcmVzaCkge1xuICAgICAgaWYgKCFzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKGlzVmlld3BvcnQgPyBfZG9jIDogc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgb25SZWZyZXNoSW5pdCAmJiBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoSW5pdFwiLCBvblJlZnJlc2hJbml0KTtcblxuICAgICAgICBpZiAocmVzZXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc2VsZi5wcm9ncmVzcyA9IHByZXZQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgc2Nyb2xsMSA9IHNjcm9sbDIgPSBsYXN0U25hcCA9IHNjcm9sbEZ1bmMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZnJlc2ggIT09IGZhbHNlICYmIHNlbGYucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmdldFR3ZWVuID0gZnVuY3Rpb24gKHNuYXApIHtcbiAgICAgIHJldHVybiBzbmFwICYmIHR3ZWVuVG8gPyB0d2VlblRvLnR3ZWVuIDogc2NydWJUd2VlbjtcbiAgICB9O1xuXG4gICAgc2VsZi5zZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAobmV3U3RhcnQsIG5ld0VuZCkge1xuICAgICAgLy8gZG9lc24ndCBwZXJzaXN0IGFmdGVyIHJlZnJlc2goKSEgSW50ZW5kZWQgdG8gYmUgYSB3YXkgdG8gb3ZlcnJpZGUgdmFsdWVzIHRoYXQgd2VyZSBzZXQgZHVyaW5nIHJlZnJlc2goKSwgbGlrZSB5b3UgY291bGQgc2V0IGl0IGluIG9uUmVmcmVzaCgpXG4gICAgICBpZiAocGluKSB7XG4gICAgICAgIHBpblN0YXJ0ICs9IG5ld1N0YXJ0IC0gc3RhcnQ7XG4gICAgICAgIHBpbkNoYW5nZSArPSBuZXdFbmQgLSBuZXdTdGFydCAtIGNoYW5nZTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zdGFydCA9IHN0YXJ0ID0gbmV3U3RhcnQ7XG4gICAgICBzZWxmLmVuZCA9IGVuZCA9IG5ld0VuZDtcbiAgICAgIGNoYW5nZSA9IG5ld0VuZCAtIG5ld1N0YXJ0O1xuICAgICAgc2VsZi51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgc2VsZi5kaXNhYmxlID0gZnVuY3Rpb24gKHJlc2V0LCBhbGxvd0FuaW1hdGlvbikge1xuICAgICAgaWYgKHNlbGYuZW5hYmxlZCkge1xuICAgICAgICByZXNldCAhPT0gZmFsc2UgJiYgc2VsZi5yZXZlcnQoKTtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gc2VsZi5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0FuaW1hdGlvbiB8fCBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucGF1c2UoKTtcbiAgICAgICAgcHJldlNjcm9sbCA9IDA7XG4gICAgICAgIHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cbiAgICAgICAgaWYgKHNuYXBEZWxheWVkQ2FsbCkge1xuICAgICAgICAgIHNuYXBEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgICAgIHR3ZWVuVG8udHdlZW4gJiYgdHdlZW5Uby50d2Vlbi5raWxsKCkgJiYgKHR3ZWVuVG8udHdlZW4gPSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWaWV3cG9ydCkge1xuICAgICAgICAgIHZhciBpID0gX3RyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChfdHJpZ2dlcnNbaV0uc2Nyb2xsZXIgPT09IHNjcm9sbGVyICYmIF90cmlnZ2Vyc1tpXSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICByZXR1cm47IC8vZG9uJ3QgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgaWYgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHRyaWdnZXJzIHJlZmVyZW5jaW5nIGl0LlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihzY3JvbGxlciwgXCJyZXNpemVcIiwgX29uUmVzaXplKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihzY3JvbGxlciwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmtpbGwgPSBmdW5jdGlvbiAocmV2ZXJ0LCBhbGxvd0FuaW1hdGlvbikge1xuICAgICAgc2VsZi5kaXNhYmxlKHJldmVydCwgYWxsb3dBbmltYXRpb24pO1xuICAgICAgc2NydWJUd2VlbiAmJiAhYWxsb3dBbmltYXRpb24gJiYgc2NydWJUd2Vlbi5raWxsKCk7XG4gICAgICBpZCAmJiBkZWxldGUgX2lkc1tpZF07XG5cbiAgICAgIHZhciBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZik7XG5cbiAgICAgIGkgPj0gMCAmJiBfdHJpZ2dlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgaSA9PT0gX2kgJiYgX2RpcmVjdGlvbiAIDAgJiYgX2ktLTsgLy8gaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHJlZnJlc2goKSBvciB1cGRhdGUoKSwgc3BsaWNpbmcgd291bGQgY2F1c2Ugc2tpcHMgaW4gdGhlIGluZGV4LCBzbyBhZGp1c3QuLi5cbiAgICAgIC8vIGlmIG5vIG90aGVyIFNjcm9sbFRyaWdnZXIgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIHNjcm9sbGVyIGFyZSBmb3VuZCwgd2lwZSBvdXQgYW55IHJlY29yZGVkIHNjcm9sbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLCBpbiBhIHNpbmdsZSBwYWdlIGFwcGxpY2F0aW9uLCBmb3IgZXhhbXBsZSwgaXQgY291bGQgbWFpbnRhaW4gc2Nyb2xsIHBvc2l0aW9uIHdoZW4gaXQgcmVhbGx5IHNob3VsZG4ndC5cblxuICAgICAgaSA9IDA7XG5cbiAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnNjcm9sbGVyID09PSBzZWxmLnNjcm9sbGVyICYmIChpID0gMSk7XG4gICAgICB9KTtcblxuICAgICAgaSB8fCAoc2VsZi5zY3JvbGwucmVjID0gMCk7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBudWxsO1xuICAgICAgICByZXZlcnQgJiYgYW5pbWF0aW9uLnJlbmRlcigtMSk7XG4gICAgICAgIGFsbG93QW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5raWxsKCk7XG4gICAgICB9XG5cbiAgICAgIG1hcmtlclN0YXJ0ICYmIFttYXJrZXJTdGFydCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIG0ucGFyZW50Tm9kZSAmJiBtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobSk7XG4gICAgICB9KTtcbiAgICAgIF9wcmltYXJ5ID09PSBzZWxmICYmIChfcHJpbWFyeSA9IDApO1xuXG4gICAgICBpZiAocGluKSB7XG4gICAgICAgIHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQucGluID09PSBwaW4gJiYgaSsrO1xuICAgICAgICB9KTtcblxuICAgICAgICBpIHx8IChwaW5DYWNoZS5zcGFjZXIgPSAwKTsgLy8gaWYgdGhlcmUgYXJlbid0IGFueSBtb3JlIFNjcm9sbFRyaWdnZXJzIHdpdGggdGhlIHNhbWUgcGluLCByZW1vdmUgdGhlIHNwYWNlciwgb3RoZXJ3aXNlIGl0IGNvdWxkIGJlIGNvbnRhbWluYXRlZCB3aXRoIG9sZC9zdGFsZSB2YWx1ZXMgaWYgdGhlIHVzZXIgcmUtY3JlYXRlcyBhIFNjcm9sbFRyaWdnZXIgZm9yIHRoZSBzYW1lIGVsZW1lbnQuXG4gICAgICB9XG5cbiAgICAgIHZhcnMub25LaWxsICYmIHZhcnMub25LaWxsKHNlbGYpO1xuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiBjdXN0b21SZXZlcnRSZXR1cm4oc2VsZik7XG4gICAgIWFuaW1hdGlvbiB8fCAhYW5pbWF0aW9uLmFkZCB8fCBjaGFuZ2UgPyBzZWxmLnJlZnJlc2goKSA6IGdzYXAuZGVsYXllZENhbGwoMC4wMSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YXJ0IHx8IGVuZCB8fCBzZWxmLnJlZnJlc2goKTtcbiAgICB9KSAmJiAoY2hhbmdlID0gMC4wMSkgJiYgKHN0YXJ0ID0gZW5kID0gMCk7IC8vIGlmIHRoZSBhbmltYXRpb24gaXMgYSB0aW1lbGluZSwgaXQgbWF5IG5vdCBoYXZlIGJlZW4gcG9wdWxhdGVkIHlldCwgc28gaXQgd291bGRuJ3QgcmVuZGVyIGF0IHRoZSBwcm9wZXIgcGxhY2Ugb24gdGhlIGZpcnN0IHJlZnJlc2goKSwgdGh1cyB3ZSBzaG91bGQgc2NoZWR1bGUgb25lIGZvciB0aGUgbmV4dCB0aWNrLiBJZiBcImNoYW5nZVwiIGlzIGRlZmluZWQsIHdlIGtub3cgaXQgbXVzdCBiZSByZS1lbmFibGluZywgdGh1cyB3ZSBjYW4gcmVmcmVzaCgpIHJpZ2h0IGF3YXkuXG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgICAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcbiAgICAgIF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgU2Nyb2xsVHJpZ2dlci5lbmFibGUoKTtcbiAgICAgIF9jb3JlSW5pdHRlZCA9IF9lbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiBfY29yZUluaXR0ZWQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKGNvbmZpZykge1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gY29uZmlnKSB7XG4gICAgICAgIF9kZWZhdWx0c1twXSA9IGNvbmZpZ1twXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2RlZmF1bHRzO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUocmVzZXQsIGtpbGwpIHtcbiAgICBfZW5hYmxlZCA9IDA7XG5cbiAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgcmV0dXJuIHRyaWdnZXJba2lsbCA/IFwia2lsbFwiIDogXCJkaXNhYmxlXCJdKHJlc2V0KTtcbiAgICB9KTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcIndoZWVsXCIsIF9vblNjcm9sbCk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2RvYywgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblxuICAgIGNsZWFySW50ZXJ2YWwoX3N5bmNJbnRlcnZhbCk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfcGFzc1Rocm91Z2gpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9ib2R5LCBcInRvdWNoc3RhcnRcIiwgX3Bhc3NUaHJvdWdoKTtcblxuICAgIF9tdWx0aUxpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVyZG93bix0b3VjaHN0YXJ0LG1vdXNlZG93blwiLCBfcG9pbnRlckRvd25IYW5kbGVyKTtcblxuICAgIF9tdWx0aUxpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBfcG9pbnRlclVwSGFuZGxlcik7XG5cbiAgICBfcmVzaXplRGVsYXkua2lsbCgpO1xuXG4gICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfcmVtb3ZlTGlzdGVuZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfc2Nyb2xsZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBfd2hlZWxMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9zY3JvbGxlcnNbaV0sIF9zY3JvbGxlcnNbaSArIDFdKTtcblxuICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAyXSk7XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuXG4gICAgaWYgKGdzYXApIHtcbiAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcbiAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMgPSBnc2FwLmNvcmUuc3VwcHJlc3NPdmVyd3JpdGVzIHx8IF9wYXNzVGhyb3VnaDtcbiAgICAgIGdzYXAuY29yZS5nbG9iYWxzKFwiU2Nyb2xsVHJpZ2dlclwiLCBTY3JvbGxUcmlnZ2VyKTsgLy8gbXVzdCByZWdpc3RlciB0aGUgZ2xvYmFsIG1hbnVhbGx5IGJlY2F1c2UgaW4gSW50ZXJuZXQgRXhwbG9yZXIsIGZ1bmN0aW9ucyAoY2xhc3NlcykgZG9uJ3QgaGF2ZSBhIFwibmFtZVwiIHByb3BlcnR5LlxuXG4gICAgICBpZiAoX2JvZHkpIHtcbiAgICAgICAgX2VuYWJsZWQgPSAxO1xuICAgICAgICBPYnNlcnZlci5yZWdpc3Rlcihnc2FwKTsgLy8gaXNUb3VjaCBpcyAwIGlmIG5vIHRvdWNoLCAxIGlmIE9OTFkgdG91Y2gsIGFuZCAyIGlmIGl0IGNhbiBhY2NvbW1vZGF0ZSB0b3VjaCBidXQgYWxzbyBvdGhlciB0eXBlcyBsaWtlIG1vdXNlL3BvaW50ZXIuXG5cbiAgICAgICAgU2Nyb2xsVHJpZ2dlci5pc1RvdWNoID0gT2JzZXJ2ZXIuaXNUb3VjaDtcbiAgICAgICAgX2ZpeElPU0J1ZyA9IE9ic2VydmVyLmlzVG91Y2ggJiYgLyhpUGFkfGlQaG9uZXxpUG9kfE1hYykvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBzaW5jZSAyMDE3LCBpT1MgaGFzIGhhZCBhIGJ1ZyB0aGF0IGNhdXNlcyBldmVudC5jbGllbnRYL1kgdG8gYmUgaW5hY2N1cmF0ZSB3aGVuIGEgc2Nyb2xsIG9jY3VycywgdGh1cyB3ZSBtdXN0IGFsdGVybmF0ZSBpZ25vcmluZyBldmVyeSBvdGhlciB0b3VjaG1vdmUgZXZlbnQgdG8gd29yayBhcm91bmQgaXQuIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTgxOTU0IGFuZCBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9FeGJyUE5hLzA4N2NlZjE5N2RjMzU0NDVhMDk1MWU4OTM1YzQxNTAzXG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwid2hlZWxcIiwgX29uU2Nyb2xsKTsgLy8gbW9zdGx5IGZvciAzcmQgcGFydHkgc21vb3RoIHNjcm9sbGluZyBsaWJyYXJpZXMuXG5cblxuICAgICAgICBfcm9vdCA9IFtfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5XTtcbiAgICAgICAgU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhKHtcbiAgICAgICAgICAvLyB3aGVuIG9yaWVudGF0aW9uIGNoYW5nZXMsIHdlIHNob3VsZCB0YWtlIG5ldyBiYXNlIG1lYXN1cmVtZW50cyBmb3IgdGhlIGlnbm9yZU1vYmlsZVJlc2l6ZSBmZWF0dXJlLlxuICAgICAgICAgIFwiKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcIjogZnVuY3Rpb24gb3JpZW50YXRpb25Qb3J0cmFpdCgpIHtcbiAgICAgICAgICAgIF9zZXRCYXNlRGltZW5zaW9ucygpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3NldEJhc2VEaW1lbnNpb25zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9kb2MsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7IC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgQ2hyb21lKSwgdGhlIHdpbmRvdyBzdG9wcyBkaXNwYXRjaGluZyBzY3JvbGwgZXZlbnRzIG9uIHRoZSB3aW5kb3cgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCwgYnV0IGl0J3MgY29uc2lzdGVudCBvbiB0aGUgZG9jdW1lbnQhXG5cblxuICAgICAgICB2YXIgYm9keVN0eWxlID0gX2JvZHkuc3R5bGUsXG4gICAgICAgICAgICBib3JkZXIgPSBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUsXG4gICAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgICBpO1xuICAgICAgICBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUgPSBcInNvbGlkXCI7IC8vIHdvcmtzIGFyb3VuZCBhbiBpc3N1ZSB3aGVyZSBhIG1hcmdpbiBvZiBhIGNoaWxkIGVsZW1lbnQgY291bGQgdGhyb3cgb2ZmIHRoZSBib3VuZHMgb2YgdGhlIF9ib2R5LCBtYWtpbmcgaXQgc2VlbSBsaWtlIHRoZXJlJ3MgYSBtYXJnaW4gd2hlbiB0aGVyZSBhY3R1YWxseSBpc24ndC4gVGhlIGJvcmRlciBlbnN1cmVzIHRoYXQgdGhlIGJvdW5kcyBhcmUgYWNjdXJhdGUuXG5cbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyhfYm9keSk7XG4gICAgICAgIF92ZXJ0aWNhbC5tID0gTWF0aC5yb3VuZChib3VuZHMudG9wICsgX3ZlcnRpY2FsLnNjKCkpIHx8IDA7IC8vIGFjY29tbW9kYXRlIHRoZSBvZmZzZXQgb2YgdGhlIDxib2R5PiBjYXVzZWQgYnkgbWFyZ2lucyBhbmQvb3IgcGFkZGluZ1xuXG4gICAgICAgIF9ob3Jpem9udGFsLm0gPSBNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0ICsgX2hvcml6b250YWwuc2MoKSkgfHwgMDtcbiAgICAgICAgYm9yZGVyID8gYm9keVN0eWxlLmJvcmRlclRvcFN0eWxlID0gYm9yZGVyIDogYm9keVN0eWxlLnJlbW92ZVByb3BlcnR5KFwiYm9yZGVyLXRvcC1zdHlsZVwiKTsgLy8gVE9ETzogKD8pIG1heWJlIG1vdmUgdG8gbGV2ZXJhZ2luZyB0aGUgdmVsb2NpdHkgbWVjaGFuaXNtIGluIE9ic2VydmVyIGFuZCBza2lwIGludGVydmFscy5cblxuICAgICAgICBfc3luY0ludGVydmFsID0gc2V0SW50ZXJ2YWwoX3N5bmMsIDI1MCk7XG4gICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC41LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF9zdGFydHVwID0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX3Bhc3NUaHJvdWdoKTsgLy8gc29tZSBvbGRlciBBbmRyb2lkIGRldmljZXMgaW50ZXJtaXR0ZW50bHkgc3RvcCBkaXNwYXRjaGluZyBcInRvdWNobW92ZVwiIGV2ZW50cyBpZiB3ZSBkb24ndCBsaXN0ZW4gZm9yIFwidG91Y2hjYW5jZWxcIiBvbiB0aGUgZG9jdW1lbnQuXG5cblxuICAgICAgICBfYWRkTGlzdGVuZXIoX2JvZHksIFwidG91Y2hzdGFydFwiLCBfcGFzc1Rocm91Z2gpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVnOiBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIxNDUwLWRyYWdnYWJsZS1pbi1pZnJhbWUtb24tbW9iaWxlLWlzLWJ1Z2d5L1xuXG5cbiAgICAgICAgX211bHRpTGlzdGVuZXIoX2FkZExpc3RlbmVyLCBfZG9jLCBcInBvaW50ZXJkb3duLHRvdWNoc3RhcnQsbW91c2Vkb3duXCIsIF9wb2ludGVyRG93bkhhbmRsZXIpO1xuXG4gICAgICAgIF9tdWx0aUxpc3RlbmVyKF9hZGRMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBfcG9pbnRlclVwSGFuZGxlcik7XG5cbiAgICAgICAgX3RyYW5zZm9ybVByb3AgPSBnc2FwLnV0aWxzLmNoZWNrUHJlZml4KFwidHJhbnNmb3JtXCIpO1xuXG4gICAgICAgIF9zdGF0ZVByb3BzLnB1c2goX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgICAgIF9jb3JlSW5pdHRlZCA9IF9nZXRUaW1lKCk7XG4gICAgICAgIF9yZXNpemVEZWxheSA9IGdzYXAuZGVsYXllZENhbGwoMC4yLCBfcmVmcmVzaEFsbCkucGF1c2UoKTtcbiAgICAgICAgX2F1dG9SZWZyZXNoID0gW19kb2MsIFwidmlzaWJpbGl0eWNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHcgPSBfd2luLmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgIGggPSBfd2luLmlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKF9kb2MuaGlkZGVuKSB7XG4gICAgICAgICAgICBfcHJldldpZHRoID0gdztcbiAgICAgICAgICAgIF9wcmV2SGVpZ2h0ID0gaDtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9wcmV2V2lkdGggIT09IHcgfHwgX3ByZXZIZWlnaHQgIT09IGgpIHtcbiAgICAgICAgICAgIF9vblJlc2l6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2RvYywgXCJET01Db250ZW50TG9hZGVkXCIsIF9yZWZyZXNoQWxsLCBfd2luLCBcImxvYWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwicmVzaXplXCIsIF9vblJlc2l6ZV07XG5cbiAgICAgICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfYWRkTGlzdGVuZXIpO1xuXG4gICAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXIuZW5hYmxlKDAsIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3Njcm9sbGVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMV0pO1xuXG4gICAgICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5jb25maWcgPSBmdW5jdGlvbiBjb25maWcodmFycykge1xuICAgIFwibGltaXRDYWxsYmFja3NcIiBpbiB2YXJzICYmIChfbGltaXRDYWxsYmFja3MgPSAhIXZhcnMubGltaXRDYWxsYmFja3MpO1xuICAgIHZhciBtcyA9IHZhcnMuc3luY0ludGVydmFsO1xuICAgIG1zICYmIGNsZWFySW50ZXJ2YWwoX3N5bmNJbnRlcnZhbCkgfHwgKF9zeW5jSW50ZXJ2YWwgPSBtcykgJiYgc2V0SW50ZXJ2YWwoX3N5bmMsIG1zKTtcbiAgICBcImlnbm9yZU1vYmlsZVJlc2l6ZVwiIGluIHZhcnMgJiYgKF9pZ25vcmVNb2JpbGVSZXNpemUgPSBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggPT09IDEgJiYgdmFycy5pZ25vcmVNb2JpbGVSZXNpemUpO1xuXG4gICAgaWYgKFwiYXV0b1JlZnJlc2hFdmVudHNcIiBpbiB2YXJzKSB7XG4gICAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoKF9yZW1vdmVMaXN0ZW5lcikgfHwgX2l0ZXJhdGVBdXRvUmVmcmVzaChfYWRkTGlzdGVuZXIsIHZhcnMuYXV0b1JlZnJlc2hFdmVudHMgfHwgXCJub25lXCIpO1xuICAgICAgX2lnbm9yZVJlc2l6ZSA9ICh2YXJzLmF1dG9SZWZyZXNoRXZlbnRzICsgXCJcIikuaW5kZXhPZihcInJlc2l6ZVwiKSA9PT0gLTE7XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuc2Nyb2xsZXJQcm94eSA9IGZ1bmN0aW9uIHNjcm9sbGVyUHJveHkodGFyZ2V0LCB2YXJzKSB7XG4gICAgdmFyIHQgPSBfZ2V0VGFyZ2V0KHRhcmdldCksXG4gICAgICAgIGkgPSBfc2Nyb2xsZXJzLmluZGV4T2YodCksXG4gICAgICAgIGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydCh0KTtcblxuICAgIGlmIChaSkge1xuICAgICAgX3Njcm9sbGVycy5zcGxpY2UoaSwgaXNWaWV3cG9ydCA/IDYgOiAyKTtcbiAgICB9XG5cbiAgICBpZiAodmFycykge1xuICAgICAgaXNWaWV3cG9ydCA/IF9wcm94aWVzLnVuc2hpZnQoX3dpbiwgdmFycywgX2JvZHksIHZhcnMsIF9kb2NFbCwgdmFycykgOiBfcHJveGllcy51bnNoaWZ0KHQsIHZhcnMpO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLm1hdGNoTWVkaWEgPSBmdW5jdGlvbiBtYXRjaE1lZGlhKHZhcnMpIHtcbiAgICAvLyBfbWVkaWEgaXMgcG9wdWxhdGVkIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6IG1lZGlhUXVlcnlTdHJpbmcsIG9uTWF0Y2gsIG9uVW5tYXRjaCwgaXNNYXRjaGVkLiBTbyBpZiB0aGVyZSBhcmUgdHdvIG1lZGlhIHF1ZXJpZXMsIHRoZSBBcnJheSB3b3VsZCBoYXZlIGEgbGVuZ3RoIG9mIDhcbiAgICB2YXIgbXEsIHAsIGksIGZ1bmMsIHJlc3VsdDtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBpID0gX21lZGlhLmluZGV4T2YocCk7XG4gICAgICBmdW5jID0gdmFyc1twXTtcbiAgICAgIF9jcmVhdGluZ01lZGlhID0gcDtcblxuICAgICAgaWYgKHAgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgZnVuYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXEgPSBfd2luLm1hdGNoTWVkaWEocCk7XG5cbiAgICAgICAgaWYgKG1xKSB7XG4gICAgICAgICAgbXEubWF0Y2hlcyAmJiAocmVzdWx0ID0gZnVuYygpKTtcblxuICAgICAgICAgIGlmIChaSkge1xuICAgICAgICAgICAgX21lZGlhW2kgKyAxXSA9IF9jb21iaW5lRnVuYyhfbWVkaWFbaSArIDFdLCBmdW5jKTtcbiAgICAgICAgICAgIF9tZWRpYVtpICsgMl0gPSBfY29tYmluZUZ1bmMoX21lZGlhW2kgKyAyXSwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSA9IF9tZWRpYS5sZW5ndGg7XG5cbiAgICAgICAgICAgIF9tZWRpYS5wdXNoKHAsIGZ1bmMsIHJlc3VsdCk7XG5cbiAgICAgICAgICAgIG1xLmFkZExpc3RlbmVyID8gbXEuYWRkTGlzdGVuZXIoX29uTWVkaWFDaGFuZ2UpIDogbXEuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBfb25NZWRpYUNoYW5nZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX21lZGlhW2kgKyAzXSA9IG1xLm1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2NyZWF0aW5nTWVkaWEgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBfbWVkaWE7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5jbGVhck1hdGNoTWVkaWEgPSBmdW5jdGlvbiBjbGVhck1hdGNoTWVkaWEocXVlcnkpIHtcbiAgICBxdWVyeSB8fCAoX21lZGlhLmxlbmd0aCA9IDApO1xuICAgIHF1ZXJ5ID0gX21lZGlhLmluZGV4T2YocXVlcnkpO1xuICAgIHF1ZXJ5ID49IDAgJiYgX21lZGlhLnNwbGljZShxdWVyeSwgNCk7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5pc0luVmlld3BvcnQgPSBmdW5jdGlvbiBpc0luVmlld3BvcnQoZWxlbWVudCwgcmF0aW8sIGhvcml6b250YWwpIHtcbiAgICB2YXIgYm91bmRzID0gKF9pc1N0cmluZyhlbGVtZW50KSA/IF9nZXRUYXJnZXQoZWxlbWVudCkgOiBlbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgb2Zmc2V0ID0gYm91bmRzW2hvcml6b250YWwgPyBfd2lkdGggOiBfaGVpZ2h0XSAqIHJhdGlvIHx8IDA7XG4gICAgcmV0dXJuIGhvcml6b250YWwgPyBib3VuZHMucmlnaHQgLSBvZmZzZXQgPiAwICYmIGJvdW5kcy5sZWZ0ICsgb2Zmc2V0IDwgX3dpbi5pbm5lcldpZHRoIDogYm91bmRzLmJvdHRvbSAtIG9mZnNldCAIDAgJiYgYm91bmRzLnRvcCArIG9mZnNldCA8IF93aW4uaW5uZXJIZWlnaHQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5wb3NpdGlvbkluVmlld3BvcnQgPSBmdW5jdGlvbiBwb3NpdGlvbkluVmlld3BvcnQoZWxlbWVudCwgcmVmZXJlbmNlUG9pbnQsIGhvcml6b250YWwpIHtcbiAgICBfaXNTdHJpbmcoZWxlbWVudCkgJiYgKGVsZW1lbnQgPSBfZ2V0VGFyZ2V0KGVsZW1lbnQpKTtcbiAgICB2YXIgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgc2l6ZSA9IGJvdW5kc1tob3Jpem9udGFsID8gX3dpZHRoIDogX2hlaWdodF0sXG4gICAgICAgIG9mZnNldCA9IHJlZmVyZW5jZVBvaW50ID09IG51bGwgPyBzaXplIC8gMiA6IHJlZmVyZW5jZVBvaW50IGluIF9rZXl3b3JkcyA/IF9rZXl3b3Jkc1tyZWZlcmVuY2VQb2ludF0gKiBzaXplIDogfnJlZmVyZW5jZVBvaW50LmluZGV4T2YoXCIlXCIpID8gcGFyc2VGbG9hdChyZWZlcmVuY2VQb2ludCkgKiBzaXplIC8gMTAwIDogcGFyc2VGbG9hdChyZWZlcmVuY2VQb2ludCkgfHwgMDtcbiAgICByZXR1cm4gaG9yaXpvbnRhbCA/IChib3VuZHMubGVmdCArIG9mZnNldCkgLyBfd2luLmlubmVyV2lkdGggOiAoYm91bmRzLnRvcCArIG9mZnNldCkgLyBfd2luLmlubmVySGVpZ2h0O1xuICB9O1xuXG4gIHJldHVybiBTY3JvbGxUcmlnZ2VyO1xufSgpO1xuU2Nyb2xsVHJpZ2dlci52ZXJzaW9uID0gXCIzLjEwLjRcIjtcblxuU2Nyb2xsVHJpZ2dlci5zYXZlU3R5bGVzID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgcmV0dXJuIHRhcmdldHMgPyBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAvLyBzYXZlZCBzdHlsZXMgYXJlIHJlY29yZGVkIGluIGEgY29uc2VjdXRpdmUgYWx0ZXJuYXRpbmcgQXJyYXksIGxpa2UgW2VsZW1lbnQsIGNzc1RleHQsIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIGNhY2hlLCBtYXRjaE1lZGlhLCAuLi5dXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuc3R5bGUpIHtcbiAgICAgIHZhciBpID0gX3NhdmVkU3R5bGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaSAPSAwICYmIF9zYXZlZFN0eWxlcy5zcGxpY2UoaSwgNSk7XG5cbiAgICAgIF9zYXZlZFN0eWxlcy5wdXNoKHRhcmdldCwgdGFyZ2V0LnN0eWxlLmNzc1RleHQsIHRhcmdldC5nZXRCQm94ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiksIGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpLCBfY3JlYXRpbmdNZWRpYSk7XG4gICAgfVxuICB9KSA6IF9zYXZlZFN0eWxlcztcbn07XG5cblNjcm9sbFRyaWdnZXIucmV2ZXJ0ID0gZnVuY3Rpb24gKHNvZnQsIG1lZGlhKSB7XG4gIHJldHVybiBfcmV2ZXJ0QWxsKCFzb2Z0LCBtZWRpYSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzLCBhbmltYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbik7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2FmZSkge1xuICByZXR1cm4gc2FmZSA/IF9vblJlc2l6ZSgpIDogKF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxUcmlnZ2VyLnJlZ2lzdGVyKCkpICYmIF9yZWZyZXNoQWxsKHRydWUpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci51cGRhdGUgPSBfdXBkYXRlQWxsO1xuU2Nyb2xsVHJpZ2dlci5jbGVhclNjcm9sbE1lbW9yeSA9IF9jbGVhclNjcm9sbE1lbW9yeTtcblxuU2Nyb2xsVHJpZ2dlci5tYXhTY3JvbGwgPSBmdW5jdGlvbiAoZWxlbWVudCwgaG9yaXpvbnRhbCkge1xuICByZXR1cm4gX21heFNjcm9sbChlbGVtZW50LCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRTY3JvbGxGdW5jID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhvcml6b250YWwpIHtcbiAgcmV0dXJuIF9nZXRTY3JvbGxGdW5jKF9nZXRUYXJnZXQoZWxlbWVudCksIGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIF9pZHNbaWRdO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfdHJpZ2dlcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQudmFycy5pZCAhPT0gXCJTY3JvbGxTbW9vdGhlclwiO1xuICB9KTtcbn07IC8vIGl0J3MgY29tbW9uIGZvciBwZW9wbGUgdG8gU2Nyb2xsVHJpZ2dlci5nZXRBbGwodCA9PiB0LmtpbGwoKSkgb24gcGFnZSByb3V0ZXMsIGZvciBleGFtcGxlLCBhbmQgd2UgZG9uJ3Qgd2FudCBpdCB0byBydWluIHNtb290aCBzY3JvbGxpbmcgYnkga2lsbGluZyB0aGUgbWFpbiBTY3JvbGxTbW9vdGhlciBvbmUuXG5cblxuU2Nyb2xsVHJpZ2dlci5pc1Njcm9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhX2xhc3RTY3JvbGxUaW1lO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5zbmFwRGlyZWN0aW9uYWwgPSBfc25hcERpcmVjdGlvbmFsO1xuXG5TY3JvbGxUcmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdIHx8IChfbGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICBYS5pbmRleE9mKGNhbGxiYWNrKSB8fCBhLnB1c2goY2FsbGJhY2spO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSxcbiAgICAgIGkgPSBhICYmIGEuaW5kZXhPZihjYWxsYmFjayk7XG4gIGkgPj0gMCAmJiBhLnNwbGljZShpLCAxKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuYmF0Y2ggPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycykge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICB2YXJzQ29weSA9IHt9LFxuICAgICAgaW50ZXJ2YWwgPSB2YXJzLmludGVydmFsIHx8IDAuMDE2LFxuICAgICAgYmF0Y2hNYXggPSB2YXJzLmJhdGNoTWF4IHx8IDFlOSxcbiAgICAgIHByb3h5Q2FsbGJhY2sgPSBmdW5jdGlvbiBwcm94eUNhbGxiYWNrKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW10sXG4gICAgICAgIHRyaWdnZXJzID0gW10sXG4gICAgICAgIGRlbGF5ID0gZ3NhcC5kZWxheWVkQ2FsbChpbnRlcnZhbCwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soZWxlbWVudHMsIHRyaWdnZXJzKTtcbiAgICAgIGVsZW1lbnRzID0gW107XG4gICAgICB0cmlnZ2VycyA9IFtdO1xuICAgIH0pLnBhdXNlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICBlbGVtZW50cy5sZW5ndGggfHwgZGVsYXkucmVzdGFydCh0cnVlKTtcbiAgICAgIGVsZW1lbnRzLnB1c2goc2VsZi50cmlnZ2VyKTtcbiAgICAgIHRyaWdnZXJzLnB1c2goc2VsZik7XG4gICAgICBiYXRjaE1heCA8PSBlbGVtZW50cy5sZW5ndGggJiYgZGVsYXkucHJvZ3Jlc3MoMSk7XG4gICAgfTtcbiAgfSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIHZhcnMpIHtcbiAgICB2YXJzQ29weVtwXSA9IHAuc3Vic3RyKDAsIDIpID09PSBcIm9uXCIgJiYgX2lzRnVuY3Rpb24odmFyc1twXSkgJiYgcCAhPT0gXCJvblJlZnJlc2hJbml0XCIgPyBwcm94eUNhbGxiYWNrKHAsIHZhcnNbcF0pIDogdmFyc1twXTtcbiAgfVxuXG4gIGlmIChfaXNGdW5jdGlvbihiYXRjaE1heCkpIHtcbiAgICBiYXRjaE1heCA9IGJhdGNoTWF4KCk7XG5cbiAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXgoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF90b0FycmF5KHRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgIGZvciAocCBpbiB2YXJzQ29weSkge1xuICAgICAgY29uZmlnW3BdID0gdmFyc0NvcHlbcF07XG4gICAgfVxuXG4gICAgY29uZmlnLnRyaWdnZXIgPSB0YXJnZXQ7XG4gICAgcmVzdWx0LnB1c2goU2Nyb2xsVHJpZ2dlci5jcmVhdGUoY29uZmlnKSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59OyAvLyB0byByZWR1Y2UgZmlsZSBzaXplLiBjbGFtcHMgdGhlIHNjcm9sbCBhbmQgYWxzbyByZXR1cm5zIGEgZHVyYXRpb24gbXVsdGlwbGllciBzbyB0aGF0IGlmIHRoZSBzY3JvbGwgZ2V0cyBjaG9wcGVkIHNob3J0ZXIsIHRoZSBkdXJhdGlvbiBnZXRzIGN1cnRhaWxlZCBhcyB3ZWxsIChvdGhlcndpc2UgaWYgeW91J3JlIHZlcnkgY2xvc2UgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSwgZm9yIGV4YW1wbGUsIGFuZCBzd2lwZSB1cCByZWFsbHkgZmFzdCwgaXQnbGwgc3VkZGVubHkgc2xvdyBkb3duIGFuZCB0YWtlIGEgbG9uZyB0aW1lIHRvIHJlYWNoIHRoZSB0b3ApLlxuXG5cbnZhciBfY2xhbXBTY3JvbGxBbmRHZXREdXJhdGlvbk11bHRpcGxpZXIgPSBmdW5jdGlvbiBfY2xhbXBTY3JvbGxBbmRHZXREdXJhdGlvbk11bHRpcGxpZXIoc2Nyb2xsRnVuYywgY3VycmVudCwgZW5kLCBtYXgpIHtcbiAgY3VycmVudCAIG1heCA/IHNjcm9sbEZ1bmMobWF4KSA6IGN1cnJlbnQgPCAwICYmIHNjcm9sbEZ1bmMoMCk7XG4gIHJldHVybiBlbmQgPiBtYXggPyAobWF4IC0gY3VycmVudCkgLyAoZW5kIC0gY3VycmVudCkgOiBlbmQgPCAwID8gY3VycmVudCAvIChjdXJyZW50IC0gZW5kKSA6IDE7XG59LFxuICAgIF9hbGxvd05hdGl2ZVBhbm5pbmcgPSBmdW5jdGlvbiBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IHRydWUpIHtcbiAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0b3VjaC1hY3Rpb25cIik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnN0eWxlLnRvdWNoQWN0aW9uID0gZGlyZWN0aW9uID09PSB0cnVlID8gXCJhdXRvXCIgOiBkaXJlY3Rpb24gPyBcInBhbi1cIiArIGRpcmVjdGlvbiArIChPYnNlcnZlci5pc1RvdWNoID8gXCIgcGluY2gtem9vbVwiIDogXCJcIikgOiBcIm5vbmVcIjsgLy8gbm90ZTogRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgaXQgcGluY2gtem9vbSBwcm9wZXJseSwgYXQgbGVhc3QgaW4gYWRkaXRpb24gdG8gYSBwYW4teCBvciBwYW4teS5cbiAgfVxuXG4gIHRhcmdldCA9PT0gX2RvY0VsICYmIF9hbGxvd05hdGl2ZVBhbm5pbmcoX2JvZHksIGRpcmVjdGlvbik7XG59LFxuICAgIF9vdmVyZmxvdyA9IHtcbiAgYXV0bzogMSxcbiAgc2Nyb2xsOiAxXG59LFxuICAgIF9uZXN0ZWRTY3JvbGwgPSBmdW5jdGlvbiBfbmVzdGVkU2Nyb2xsKF9yZWY1KSB7XG4gIHZhciBldmVudCA9IF9yZWY1LmV2ZW50LFxuICAgICAgdGFyZ2V0ID0gX3JlZjUudGFyZ2V0LFxuICAgICAgYXhpcyA9IF9yZWY1LmF4aXM7XG5cbiAgdmFyIG5vZGUgPSAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50KS50YXJnZXQsXG4gICAgICBjYWNoZSA9IG5vZGUuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKG5vZGUpLFxuICAgICAgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICBjcztcblxuICBpZiAoIWNhY2hlLl9pc1Njcm9sbFQgfHwgdGltZSAtIGNhY2hlLl9pc1Njcm9sbFQgPiAyMDAwKSB7XG4gICAgLy8gY2FjaGUgZm9yIDIgc2Vjb25kcyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgIHdoaWxlIChub2RlICYmIG5vZGUuc2Nyb2xsSGVpZ2h0IDw9IG5vZGUuY2xpZW50SGVpZ2h0KSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGNhY2hlLl9pc1Njcm9sbCA9IG5vZGUgJiYgIV9pc1ZpZXdwb3J0KG5vZGUpICYmIG5vZGUgIT09IHRhcmdldCAmJiAoX292ZXJmbG93WyhjcyA9IF9nZXRDb21wdXRlZFN0eWxlKG5vZGUpKS5vdmVyZmxvd1ldIHx8IF9vdmVyZmxvd1tjcy5vdmVyZmxvd1hdKTtcbiAgICBjYWNoZS5faXNTY3JvbGxUID0gdGltZTtcbiAgfVxuXG4gIChjYWNoZS5faXNTY3JvbGwgfHwgYXhpcyA9PT0gXCJ4XCIpICYmIChldmVudC5fZ3NhcEFsbG93ID0gdHJ1ZSk7XG59LFxuICAgIC8vIGNhcHR1cmUgZXZlbnRzIG9uIHNjcm9sbGFibGUgZWxlbWVudHMgSU5TSURFIHRoZSA8Ym9keT4gYW5kIGFsbG93IHRob3NlIGJ5IGNhbGxpbmcgc3RvcFByb3BhZ2F0aW9uKCkgd2hlbiB3ZSBmaW5kIGEgc2Nyb2xsYWJsZSBhbmNlc3RvclxuX2lucHV0T2JzZXJ2ZXIgPSBmdW5jdGlvbiBfaW5wdXRPYnNlcnZlcih0YXJnZXQsIHR5cGUsIGlucHV0cywgbmVzdGVkKSB7XG4gIHJldHVybiBPYnNlcnZlci5jcmVhdGUoe1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgZGVib3VuY2U6IGZhbHNlLFxuICAgIGxvY2tBeGlzOiB0cnVlLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgb25XaGVlbDogbmVzdGVkID0gbmVzdGVkICYmIF9uZXN0ZWRTY3JvbGwsXG4gICAgb25QcmVzczogbmVzdGVkLFxuICAgIG9uRHJhZzogbmVzdGVkLFxuICAgIG9uU2Nyb2xsOiBuZXN0ZWQsXG4gICAgb25FbmFibGU6IGZ1bmN0aW9uIG9uRW5hYmxlKCkge1xuICAgICAgcmV0dXJuIGlucHV0cyAmJiBfYWRkTGlzdGVuZXIoX2RvYywgT2JzZXJ2ZXIuZXZlbnRUeXBlc1swXSwgX2NhcHR1cmVJbnB1dHMsIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uRGlzYWJsZTogZnVuY3Rpb24gb25EaXNhYmxlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihfZG9jLCBPYnNlcnZlci5ldmVudFR5cGVzWzBdLCBfY2FwdHVyZUlucHV0cywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn0sXG4gICAgX2lucHV0RXhwID0gLyhpbnB1dHxsYWJlbHxzZWxlY3R8dGV4dGFyZWEpL2ksXG4gICAgX2lucHV0SXNGb2N1c2VkLFxuICAgIF9jYXB0dXJlSW5wdXRzID0gZnVuY3Rpb24gX2NhcHR1cmVJbnB1dHMoZSkge1xuICB2YXIgaXNJbnB1dCA9IF9pbnB1dEV4cC50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpO1xuXG4gIGlmIChpc0lucHV0IHx8IF9pbnB1dElzRm9jdXNlZCkge1xuICAgIGUuX2dzYXBBbGxvdyA9IHRydWU7XG4gICAgX2lucHV0SXNGb2N1c2VkID0gaXNJbnB1dDtcbiAgfVxufSxcbiAgICBfZ2V0U2Nyb2xsTm9ybWFsaXplciA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxOb3JtYWxpemVyKHZhcnMpIHtcbiAgX2lzT2JqZWN0KHZhcnMpIHx8ICh2YXJzID0ge30pO1xuICB2YXJzLnByZXZlbnREZWZhdWx0ID0gdmFycy5pc05vcm1hbGl6ZXIgPSB2YXJzLmFsbG93Q2xpY2tzID0gdHJ1ZTtcbiAgdmFycy50eXBlIHx8ICh2YXJzLnR5cGUgPSBcIndoZWVsLHRvdWNoXCIpO1xuICB2YXJzLmRlYm91bmNlID0gISF2YXJzLmRlYm91bmNlO1xuICB2YXJzLmlkID0gdmFycy5pZCB8fCBcIm5vcm1hbGl6ZXJcIjtcblxuICB2YXIgX3ZhcnMyID0gdmFycyxcbiAgICAgIG5vcm1hbGl6ZVNjcm9sbFggPSBfdmFyczIubm9ybWFsaXplU2Nyb2xsWCxcbiAgICAgIG1vbWVudHVtID0gX3ZhcnMyLm1vbWVudHVtLFxuICAgICAgYWxsb3dOZXN0ZWRTY3JvbGwgPSBfdmFyczIuYWxsb3dOZXN0ZWRTY3JvbGwsXG4gICAgICBzZWxmLFxuICAgICAgbWF4WSxcbiAgICAgIHRhcmdldCA9IF9nZXRUYXJnZXQodmFycy50YXJnZXQpIHx8IF9kb2NFbCxcbiAgICAgIHNtb290aGVyID0gZ3NhcC5jb3JlLmdsb2JhbHMoKS5TY3JvbGxTbW9vdGhlcixcbiAgICAgIGNvbnRlbnQgPSBfZml4SU9TQnVnICYmICh2YXJzLmNvbnRlbnQgJiYgX2dldFRhcmdldCh2YXJzLmNvbnRlbnQpIHx8IHNtb290aGVyICYmIHNtb290aGVyLmdldCgpICYmIHNtb290aGVyLmdldCgpLmNvbnRlbnQoKSksXG4gICAgICBzY3JvbGxGdW5jWSA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX3ZlcnRpY2FsKSxcbiAgICAgIHNjcm9sbEZ1bmNYID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfaG9yaXpvbnRhbCksXG4gICAgICBzY2FsZSA9IDEsXG4gICAgICBpbml0aWFsU2NhbGUgPSAoT2JzZXJ2ZXIuaXNUb3VjaCAmJiBfd2luLnZpc3VhbFZpZXdwb3J0ID8gX3dpbi52aXN1YWxWaWV3cG9ydC5zY2FsZSAqIF93aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiBfd2luLm91dGVyV2lkdGgpIC8gX3dpbi5pbm5lcldpZHRoLFxuICAgICAgd2hlZWxSZWZyZXNoID0gMCxcbiAgICAgIHJlc29sdmVNb21lbnR1bUR1cmF0aW9uID0gX2lzRnVuY3Rpb24obW9tZW50dW0pID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtb21lbnR1bShzZWxmKTtcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9tZW50dW0gfHwgMi44O1xuICB9LFxuICAgICAgc2tpcFRvdWNoTW92ZSxcbiAgICAgIGxhc3RSZWZyZXNoSUQsXG4gICAgICBpbnB1dE9ic2VydmVyID0gX2lucHV0T2JzZXJ2ZXIodGFyZ2V0LCB2YXJzLnR5cGUsIHRydWUsIGFsbG93TmVzdGVkU2Nyb2xsKSxcbiAgICAgIHJlc3VtZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIHJlc3VtZVRvdWNoTW92ZSgpIHtcbiAgICByZXR1cm4gc2tpcFRvdWNoTW92ZSA9IGZhbHNlO1xuICB9LFxuICAgICAgc2Nyb2xsQ2xhbXBYID0gX3Bhc3NUaHJvdWdoLFxuICAgICAgc2Nyb2xsQ2xhbXBZID0gX3Bhc3NUaHJvdWdoLFxuICAgICAgdXBkYXRlQ2xhbXBzID0gZnVuY3Rpb24gdXBkYXRlQ2xhbXBzKCkge1xuICAgIG1heFkgPSBfbWF4U2Nyb2xsKHRhcmdldCwgX3ZlcnRpY2FsKTtcbiAgICBzY3JvbGxDbGFtcFkgPSBfY2xhbXAoX2ZpeElPU0J1ZyA/IDEgOiAwLCBtYXhZKTtcbiAgICBub3JtYWxpemVTY3JvbGxYICYmIChzY3JvbGxDbGFtcFggPSBfY2xhbXAoMCwgX21heFNjcm9sbCh0YXJnZXQsIF9ob3Jpem9udGFsKSkpO1xuICAgIGxhc3RSZWZyZXNoSUQgPSBfcmVmcmVzaElEO1xuICB9LFxuICAgICAgaWdub3JlRHJhZyA9IGZ1bmN0aW9uIGlnbm9yZURyYWcoKSB7XG4gICAgaWYgKHNraXBUb3VjaE1vdmUpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWVUb3VjaE1vdmUpOyAvLyB3ZSBNVVNUIHdhaXQgZm9yIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBvdGhlcndpc2UgaU9TIHdpbGwgbWlzcmVwb3J0IHRoZSB2YWx1ZS5cblxuICAgICAgdmFyIG9mZnNldCA9IF9yb3VuZChzZWxmLmRlbHRhWSAvIDIpLFxuICAgICAgICAgIHNjcm9sbCA9IHNjcm9sbENsYW1wWShzY3JvbGxGdW5jWS52IC0gb2Zmc2V0KTtcblxuICAgICAgaWYgKGNvbnRlbnQgJiYgc2Nyb2xsICE9PSBzY3JvbGxGdW5jWS52ICsgc2Nyb2xsRnVuY1kub2Zmc2V0KSB7XG4gICAgICAgIHNjcm9sbEZ1bmNZLm9mZnNldCA9IHNjcm9sbCAtIHNjcm9sbEZ1bmNZLnY7XG4gICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKFwiICsgLXNjcm9sbEZ1bmNZLm9mZnNldCArIFwicHgpXCI7XG4gICAgICAgIGNvbnRlbnQuX2dzYXAgJiYgKGNvbnRlbnQuX2dzYXAueSA9IC1zY3JvbGxGdW5jWS5vZmZzZXQgKyBcInB4XCIpO1xuICAgICAgICBzY3JvbGxGdW5jWS5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcblxuICAgICAgICBfdXBkYXRlQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBjb250ZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgwcHgpXCI7XG4gICAgICBzY3JvbGxGdW5jWS5vZmZzZXQgPSBzY3JvbGxGdW5jWS5jYWNoZUlEID0gMDtcbiAgICAgIGNvbnRlbnQuX2dzYXAgJiYgKGNvbnRlbnQuX2dzYXAueSA9IFwiMHB4XCIpO1xuICAgIH1cblxuICAgIHNraXBUb3VjaE1vdmUgPSB0cnVlO1xuICB9LFxuICAgICAgdHdlZW4sXG4gICAgICBzdGFydFNjcm9sbFgsXG4gICAgICBzdGFydFNjcm9sbFksXG4gICAgICBvblN0b3BEZWxheWVkQ2FsbCxcbiAgICAgIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgLy8gaWYgdGhlIHdpbmRvdyByZXNpemVzLCBsaWtlIG9uIGFuIGlQaG9uZSB3aGljaCBBcHBsZSBGT1JDRVMgdGhlIGFkZHJlc3MgYmFyIHRvIHNob3cvaGlkZSBldmVuIGlmIHdlIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGl0IG1heSBiZSBzY3JvbGxpbmcgdG9vIGZhciBub3cgdGhhdCB0aGUgYWRkcmVzcyBiYXIgaXMgc2hvd2luZywgc28gd2UgbXVzdCBkeW5hbWljYWxseSBhZGp1c3QgdGhlIG1vbWVudHVtIHR3ZWVuLlxuICAgIHVwZGF0ZUNsYW1wcygpO1xuXG4gICAgaWYgKHR3ZWVuLmlzQWN0aXZlKCkgJiYgdHdlZW4udmFycy5zY3JvbGxZID4gbWF4WSkge1xuICAgICAgc2Nyb2xsRnVuY1koKSAIG1heFkgPyB0d2Vlbi5wcm9ncmVzcygxKSAmJiBzY3JvbGxGdW5jWShtYXhZKSA6IHR3ZWVuLnJlc2V0VG8oXCJzY3JvbGxZXCIsIG1heFkpO1xuICAgIH1cbiAgfTtcblxuICB2YXJzLmlnbm9yZUNoZWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gX2ZpeElPU0J1ZyAmJiBlLnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgaWdub3JlRHJhZyhlKSB8fCBzY2FsZSAIDEuMDUgJiYgZS50eXBlICE9PSBcInRvdWNoc3RhcnRcIiB8fCBzZWxmLmlzR2VzdHVyaW5nIHx8IGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMTtcbiAgfTtcblxuICB2YXJzLm9uUHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZTY2FsZSA9IHNjYWxlO1xuICAgIHNjYWxlID0gX3JvdW5kKChfd2luLnZpc3VhbFZpZXdwb3J0ICYmIF93aW4udmlzdWFsVmlld3BvcnQuc2NhbGUgfHwgMSkgLyBpbml0aWFsU2NhbGUpO1xuICAgIHR3ZWVuLnBhdXNlKCk7XG4gICAgcHJldlNjYWxlICE9PSBzY2FsZSAmJiBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgc2NhbGUgPiAxLjAxID8gdHJ1ZSA6IG5vcm1hbGl6ZVNjcm9sbFggPyBmYWxzZSA6IFwieFwiKTtcbiAgICBza2lwVG91Y2hNb3ZlID0gZmFsc2U7XG4gICAgc3RhcnRTY3JvbGxYID0gc2Nyb2xsRnVuY1goKTtcbiAgICBzdGFydFNjcm9sbFkgPSBzY3JvbGxGdW5jWSgpO1xuICAgIHVwZGF0ZUNsYW1wcygpO1xuICAgIGxhc3RSZWZyZXNoSUQgPSBfcmVmcmVzaElEO1xuICB9O1xuXG4gIHZhcnMub25SZWxlYXNlID0gdmFycy5vbkdlc3R1cmVTdGFydCA9IGZ1bmN0aW9uIChzZWxmLCB3YXNEcmFnZ2luZykge1xuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBjb250ZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgwcHgpXCI7XG4gICAgICBzY3JvbGxGdW5jWS5vZmZzZXQgPSBzY3JvbGxGdW5jWS5jYWNoZUlEID0gMDtcbiAgICAgIGNvbnRlbnQuX2dzYXAgJiYgKGNvbnRlbnQuX2dzYXAueSA9IFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmICghd2FzRHJhZ2dpbmcpIHtcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zY3JvbGxlcnMuY2FjaGUrKzsgLy8gbWFrZSBzdXJlIHdlJ3JlIHB1bGxpbmcgdGhlIG5vbi1jYWNoZWQgdmFsdWVcbiAgICAgIC8vIGFsdGVybmF0ZSBhbGdvcml0aG06IGR1clggPSBNYXRoLm1pbig2LCBNYXRoLmFicyhzZWxmLnZlbG9jaXR5WCAvIDgwMCkpLFx0ZHVyID0gTWF0aC5tYXgoZHVyWCwgTWF0aC5taW4oNiwgTWF0aC5hYnMoc2VsZi52ZWxvY2l0eVkgLyA4MDApKSk7IGR1ciA9IGR1ciAqICgwLjQgKyAoMSAtIF9wb3dlcjRJbihkdXIgLyA2KSkgKiAwLjYpKSAqIChtb21lbnR1bVNwZWVkIHx8IDEpXG5cbiAgICAgIHZhciBkdXIgPSByZXNvbHZlTW9tZW50dW1EdXJhdGlvbigpLFxuICAgICAgICAgIGN1cnJlbnRTY3JvbGwsXG4gICAgICAgICAgZW5kU2Nyb2xsO1xuXG4gICAgICBpZiAobm9ybWFsaXplU2Nyb2xsWCkge1xuICAgICAgICBjdXJyZW50U2Nyb2xsID0gc2Nyb2xsRnVuY1goKTtcbiAgICAgICAgZW5kU2Nyb2xsID0gY3VycmVudFNjcm9sbCArIGR1ciAqIDAuMDUgKiAtc2VsZi52ZWxvY2l0eVggLyAwLjIyNzsgLy8gdGhlIGNvbnN0YW50IC4yMjcgaXMgZnJvbSBwb3dlcjQoMC4wNSkuIHZlbG9jaXR5IGlzIGludmVydGVkIGJlY2F1c2Ugc2Nyb2xsaW5nIGdvZXMgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cblxuICAgICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNYLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfaG9yaXpvbnRhbCkpO1xuICAgICAgICB0d2Vlbi52YXJzLnNjcm9sbFggPSBzY3JvbGxDbGFtcFgoZW5kU2Nyb2xsKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFNjcm9sbCA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgICBlbmRTY3JvbGwgPSBjdXJyZW50U2Nyb2xsICsgZHVyICogMC4wNSAqIC1zZWxmLnZlbG9jaXR5WSAvIDAuMjI3OyAvLyB0aGUgY29uc3RhbnQgLjIyNyBpcyBmcm9tIHBvd2VyNCgwLjA1KVxuXG4gICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNZLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfdmVydGljYWwpKTtcbiAgICAgIHR3ZWVuLnZhcnMuc2Nyb2xsWSA9IHNjcm9sbENsYW1wWShlbmRTY3JvbGwpO1xuICAgICAgdHdlZW4uaW52YWxpZGF0ZSgpLmR1cmF0aW9uKGR1cikucGxheSgwLjAxKTtcblxuICAgICAgaWYgKF9maXhJT1NCdWcgJiYgdHdlZW4udmFycy5zY3JvbGxZID49IG1heFkgfHwgY3VycmVudFNjcm9sbCAPSBtYXhZIC0gMSkge1xuICAgICAgICAvLyBpT1MgYnVnOiBpdCdsbCBzaG93IHRoZSBhZGRyZXNzIGJhciBidXQgTk9UIGZpcmUgdGhlIHdpbmRvdyBcInJlc2l6ZVwiIGV2ZW50IHVudGlsIHRoZSBhbmltYXRpb24gaXMgZG9uZSBidXQgd2UgbXVzdCBwcm90ZWN0IGFnYWluc3Qgb3ZlcnNob290IHNvIHdlIGxldmVyYWdlIGFuIG9uVXBkYXRlIHRvIGRvIHNvLlxuICAgICAgICBnc2FwLnRvKHt9LCB7XG4gICAgICAgICAgb25VcGRhdGU6IG9uUmVzaXplLFxuICAgICAgICAgIGR1cmF0aW9uOiBkdXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhcnMub25XaGVlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0d2Vlbi5fdHMgJiYgdHdlZW4ucGF1c2UoKTtcblxuICAgIGlmIChfZ2V0VGltZSgpIC0gd2hlZWxSZWZyZXNoID4gMTAwMCkge1xuICAgICAgLy8gYWZ0ZXIgMSBzZWNvbmQsIHJlZnJlc2ggdGhlIGNsYW1wcyBvdGhlcndpc2UgdGhhdCdsbCBvbmx5IGhhcHBlbiB3aGVuIFNjcm9sbFRyaWdnZXIucmVmcmVzaCgpIGlzIGNhbGxlZCBvciBmb3IgdG91Y2gtc2Nyb2xsaW5nLlxuICAgICAgbGFzdFJlZnJlc2hJRCA9IDA7XG4gICAgICB3aGVlbFJlZnJlc2ggPSBfZ2V0VGltZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXJzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHNlbGYsIGR4LCBkeSwgeEFycmF5LCB5QXJyYXkpIHtcbiAgICBfcmVmcmVzaElEICE9PSBsYXN0UmVmcmVzaElEICYmIHVwZGF0ZUNsYW1wcygpO1xuICAgIGR4ICYmIG5vcm1hbGl6ZVNjcm9sbFggJiYgc2Nyb2xsRnVuY1goc2Nyb2xsQ2xhbXBYKHhBcnJheVsyXSA9PT0gZHggPyBzdGFydFNjcm9sbFggKyAoc2VsZi5zdGFydFggLSBzZWxmLngpIDogc2Nyb2xsRnVuY1goKSArIGR4IC0geEFycmF5WzFdKSk7IC8vIGZvciBtb3JlIHByZWNpc2lvbiwgd2UgdHJhY2sgcG9pbnRlci90b3VjaCBtb3ZlbWVudCBmcm9tIHRoZSBzdGFydCwgb3RoZXJ3aXNlIGl0J2xsIGRyaWZ0LlxuXG4gICAgZHkgJiYgc2Nyb2xsRnVuY1koc2Nyb2xsQ2xhbXBZKHlBcnJheVsyXSA9PT0gZHkgPyBzdGFydFNjcm9sbFkgKyAoc2VsZi5zdGFydFkgLSBzZWxmLnkpIDogc2Nyb2xsRnVuY1koKSArIGR5IC0geUFycmF5WzFdKSk7XG5cbiAgICBfdXBkYXRlQWxsKCk7XG4gIH07XG5cbiAgdmFycy5vbkVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgbm9ybWFsaXplU2Nyb2xsWCA/IGZhbHNlIDogXCJ4XCIpO1xuXG4gICAgX2FkZExpc3RlbmVyKF93aW4sIFwicmVzaXplXCIsIG9uUmVzaXplKTtcblxuICAgIGlucHV0T2JzZXJ2ZXIuZW5hYmxlKCk7XG4gIH07XG5cbiAgdmFycy5vbkRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2FsbG93TmF0aXZlUGFubmluZyh0YXJnZXQsIHRydWUpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF93aW4sIFwicmVzaXplXCIsIG9uUmVzaXplKTtcblxuICAgIGlucHV0T2JzZXJ2ZXIua2lsbCgpO1xuICB9O1xuXG4gIHNlbGYgPSBuZXcgT2JzZXJ2ZXIodmFycyk7XG4gIHNlbGYuaU9TID0gX2ZpeElPU0J1ZzsgLy8gdXNlZCBpbiB0aGUgT2JzZXJ2ZXIgZ2V0Q2FjaGVkU2Nyb2xsKCkgZnVuY3Rpb24gdG8gd29yayBhcm91bmQgYW4gaU9TIGJ1ZyB0aGF0IHdyZWFrcyBoYXZvYyB3aXRoIFRvdWNoRXZlbnQuY2xpZW50WSBpZiB3ZSBhbGxvdyBzY3JvbGwgdG8gZ28gYWxsIHRoZSB3YXkgYmFjayB0byAwLlxuXG4gIF9maXhJT1NCdWcgJiYgIXNjcm9sbEZ1bmNZKCkgJiYgc2Nyb2xsRnVuY1koMSk7IC8vIGlPUyBidWcgY2F1c2VzIGV2ZW50LmNsaWVudFkgdmFsdWVzIHRvIGZyZWFrIG91dCAod2lsZGx5IGluYWNjdXJhdGUpIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgZXhhY3RseSAwLlxuXG4gIG9uU3RvcERlbGF5ZWRDYWxsID0gc2VsZi5fZGM7XG4gIHR3ZWVuID0gZ3NhcC50byhzZWxmLCB7XG4gICAgZWFzZTogXCJwb3dlcjRcIixcbiAgICBwYXVzZWQ6IHRydWUsXG4gICAgc2Nyb2xsWDogbm9ybWFsaXplU2Nyb2xsWCA/IFwiKz0wLjFcIiA6IFwiKz0wXCIsXG4gICAgc2Nyb2xsWTogXCIrPTAuMVwiLFxuICAgIG9uQ29tcGxldGU6IG9uU3RvcERlbGF5ZWRDYWxsLnZhcnMub25Db21wbGV0ZVxuICB9KTtcbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnNvcnQgPSBmdW5jdGlvbiAoZnVuYykge1xuICByZXR1cm4gX3RyaWdnZXJzLnNvcnQoZnVuYyB8fCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAoYS52YXJzLnJlZnJlc2hQcmlvcml0eSB8fCAwKSAqIC0xZTYgKyBhLnN0YXJ0IC0gKGIuc3RhcnQgKyAoYi52YXJzLnJlZnJlc2hQcmlvcml0eSB8fCAwKSAqIC0xZTYpO1xuICB9KTtcbn07XG5cblNjcm9sbFRyaWdnZXIub2JzZXJ2ZSA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIodmFycyk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLm5vcm1hbGl6ZVNjcm9sbCA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gIGlmICh0eXBlb2YgdmFycyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBfbm9ybWFsaXplcjtcbiAgfVxuXG4gIGlmICh2YXJzID09PSB0cnVlICYmIF9ub3JtYWxpemVyKSB7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVyLmVuYWJsZSgpO1xuICB9XG5cbiAgaWYgKHZhcnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmtpbGwoKTtcbiAgfVxuXG4gIHZhciBub3JtYWxpemVyID0gdmFycyBpbnN0YW5jZW9mIE9ic2VydmVyID8gdmFycyA6IF9nZXRTY3JvbGxOb3JtYWxpemVyKHZhcnMpO1xuICBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci50YXJnZXQgPT09IG5vcm1hbGl6ZXIudGFyZ2V0ICYmIF9ub3JtYWxpemVyLmtpbGwoKTtcbiAgX2lzVmlld3BvcnQobm9ybWFsaXplci50YXJnZXQpICYmIChfbm9ybWFsaXplciA9IG5vcm1hbGl6ZXIpO1xuICByZXR1cm4gbm9ybWFsaXplcjtcbn07XG5cblNjcm9sbFRyaWdnZXIuY29yZSA9IHtcbiAgLy8gc21hbGxlciBmaWxlIHNpemUgd2F5IHRvIGxldmVyYWdlIGluIFNjcm9sbFNtb290aGVyIGFuZCBPYnNlcnZlclxuICBfZ2V0VmVsb2NpdHlQcm9wOiBfZ2V0VmVsb2NpdHlQcm9wLFxuICBfaW5wdXRPYnNlcnZlcjogX2lucHV0T2JzZXJ2ZXIsXG4gIF9zY3JvbGxlcnM6IF9zY3JvbGxlcnMsXG4gIF9wcm94aWVzOiBfcHJveGllcyxcbiAgYnJpZGdlOiB7XG4gICAgLy8gd2hlbiBub3JtYWxpemVTY3JvbGwgc2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIChzcyA9IHNldFNjcm9sbClcbiAgICBzczogZnVuY3Rpb24gc3MoKSB7XG4gICAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XG4gICAgICBfbGFzdFNjcm9sbFRpbWUgPSBfZ2V0VGltZSgpO1xuICAgIH0sXG4gICAgLy8gYSB3YXkgdG8gZ2V0IHRoZSBfcmVmcmVzaGluZyB2YWx1ZSBpbiBPYnNlcnZlclxuICAgIHJlZjogZnVuY3Rpb24gcmVmKCkge1xuICAgICAgcmV0dXJuIF9yZWZyZXNoaW5nO1xuICAgIH1cbiAgfVxufTtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKTtcbmV4cG9ydCB7IFNjcm9sbFRyaWdnZXIgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/ScrollTrigger.js\n");

/***/ }),

/***/ "./node_modules/gsap/dist/gsap.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/dist/gsap.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  0;\n}(this, (function (exports) { 'use strict';\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  /*!\n   * GSAP 3.10.4\n   * https://greensock.com\n   *\n   * @license Copyright 2008-2022, GreenSock. All rights reserved.\n   * Subject to the terms at https://greensock.com/standard-license or for\n   * Club GreenSock members, the agreement issued with that membership.\n   * @author: Jack Doyle, jack@greensock.com\n  */\n  var _config = {\n    autoSleep: 120,\n    force3D: \"auto\",\n    nullTargetWarn: 1,\n    units: {\n      lineHeight: \"\"\n    }\n  },\n      _defaults = {\n    duration: .5,\n    overwrite: false,\n    delay: 0\n  },\n      _suppressOverwrites,\n      _bigNum = 1e8,\n      _tinyNum = 1 / _bigNum,\n      _2PI = Math.PI * 2,\n      _HALF_PI = _2PI / 4,\n      _gsID = 0,\n      _sqrt = Math.sqrt,\n      _cos = Math.cos,\n      _sin = Math.sin,\n      _isString = function _isString(value) {\n    return typeof value === \"string\";\n  },\n      _isFunction = function _isFunction(value) {\n    return typeof value === \"function\";\n  },\n      _isNumber = function _isNumber(value) {\n    return typeof value === \"number\";\n  },\n      _isUndefined = function _isUndefined(value) {\n    return typeof value === \"undefined\";\n  },\n      _isObject = function _isObject(value) {\n    return typeof value === \"object\";\n  },\n      _isNotFalse = function _isNotFalse(value) {\n    return value !== false;\n  },\n      _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n  },\n      _isFuncOrString = function _isFuncOrString(value) {\n    return _isFunction(value) || _isString(value);\n  },\n      _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function () {},\n      _isArray = Array.isArray,\n      _strictNumExp = /(?:-?\\.?\\d|\\.)/gi,\n      _numExp = /[-=.]*\\d[.e\\-]*\\d*[e\\-]*\\d*/g,\n      _numWithUnitExp = /[-=.]*\\d[.e-]*\\d*[a-z%]*/g,\n      _complexStringNumExp = /[-=.]*\\d\\.?\\d*(?:e-|e\\)?\\d*/gi,\n      _relExp = /[-]=-?[.\\d]/,\n      _delimitedValueExp = /[^,'\"\\[\\]\\s]/gi,\n      _unitExp = /^[\\-=e\\s\\d]*\\d[.\\d]*([a-z]*|%)\\s*$/i,\n      _globalTimeline,\n      _win,\n      _coreInitted,\n      _doc,\n      _globals = {},\n      _installScope = {},\n      _coreReady,\n      _install = function _install(scope) {\n    return (_installScope = _merge(scope, _globals)) && gsap;\n  },\n      _missingPlugin = function _missingPlugin(property, value) {\n    return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\n  },\n      _warn = function _warn(message, suppress) {\n    return !suppress && console.warn(message);\n  },\n      _addGlobal = function _addGlobal(name, obj) {\n    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n  },\n      _emptyFunc = function _emptyFunc() {\n    return 0;\n  },\n      _reservedProps = {},\n      _lazyTweens = [],\n      _lazyLookup = {},\n      _lastRenderedFrame,\n      _plugins = {},\n      _effects = {},\n      _nextGCFrame = 30,\n      _harnessPlugins = [],\n      _callbackNames = \"\",\n      _harness = function _harness(targets) {\n    var target = targets[0],\n        harnessPlugin,\n        i;\n    _isObject(target) || _isFunction(target) || (targets = [targets]);\n\n    if (!(harnessPlugin = (target._gsap || {}).harness)) {\n      i = _harnessPlugins.length;\n\n      while (i-- && !_harnessPlugins[i].targetTest(target)) {}\n\n      harnessPlugin = _harnessPlugins[i];\n    }\n\n    i = targets.length;\n\n    while (i--) {\n      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n    }\n\n    return targets;\n  },\n      _getCache = function _getCache(target) {\n    return target._gsap || _harness(toArray(target))[0]._gsap;\n  },\n      _getProperty = function _getProperty(target, property, v) {\n    return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n  },\n      _forEachName = function _forEachName(names, func) {\n    return (names = names.split(\",\")).forEach(func) || names;\n  },\n      _round = function _round(value) {\n    return Math.round(value * 100000) / 100000 || 0;\n  },\n      _roundPrecise = function _roundPrecise(value) {\n    return Math.round(value * 10000000) / 10000000 || 0;\n  },\n      _parseRelative = function _parseRelative(start, value) {\n    var operator = value.charAt(0),\n        end = parseFloat(value.substr(2));\n    start = parseFloat(start);\n    return operator === \"\" ? start  end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\n  },\n      _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n    var l = toFind.length,\n        i = 0;\n\n    for (; toSearch.indexOf(toFind[i]) < 0 && i < l;) {}\n\n    return i < l;\n  },\n      _lazyRender = function _lazyRender() {\n    var l = _lazyTweens.length,\n        a = _lazyTweens.slice(0),\n        i,\n        tween;\n\n    _lazyLookup = {};\n    _lazyTweens.length = 0;\n\n    for (i = 0; i < l; i) {\n      tween = a[i];\n      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n    }\n  },\n      _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n    _lazyTweens.length && _lazyRender();\n    animation.render(time, suppressEvents, force);\n    _lazyTweens.length && _lazyRender();\n  },\n      _numericIfPossible = function _numericIfPossible(value) {\n    var n = parseFloat(value);\n    return (n || n === 0) && (value  \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n  },\n      _passThrough = function _passThrough(p) {\n    return p;\n  },\n      _setDefaults = function _setDefaults(obj, defaults) {\n    for (var p in defaults) {\n      p in obj || (obj[p] = defaults[p]);\n    }\n\n    return obj;\n  },\n      _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {\n    return function (obj, defaults) {\n      for (var p in defaults) {\n        p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults[p]);\n      }\n    };\n  },\n      _merge = function _merge(base, toMerge) {\n    for (var p in toMerge) {\n      base[p] = toMerge[p];\n    }\n\n    return base;\n  },\n      _mergeDeep = function _mergeDeep(base, toMerge) {\n    for (var p in toMerge) {\n      p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n    }\n\n    return base;\n  },\n      _copyExcluding = function _copyExcluding(obj, excluding) {\n    var copy = {},\n        p;\n\n    for (p in obj) {\n      p in excluding || (copy[p] = obj[p]);\n    }\n\n    return copy;\n  },\n      _inheritDefaults = function _inheritDefaults(vars) {\n    var parent = vars.parent || _globalTimeline,\n        func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\n\n    if (_isNotFalse(vars.inherit)) {\n      while (parent) {\n        func(vars, parent.vars.defaults);\n        parent = parent.parent || parent._dp;\n      }\n    }\n\n    return vars;\n  },\n      _arraysMatch = function _arraysMatch(a1, a2) {\n    var i = a1.length,\n        match = i === a2.length;\n\n    while (match && i-- && a1[i] === a2[i]) {}\n\n    return i < 0;\n  },\n      _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n    if (firstProp === void 0) {\n      firstProp = \"_first\";\n    }\n\n    if (lastProp === void 0) {\n      lastProp = \"_last\";\n    }\n\n    var prev = parent[lastProp],\n        t;\n\n    if (sortBy) {\n      t = child[sortBy];\n\n      while (prev && prev[sortBy] > t) {\n        prev = prev._prev;\n      }\n    }\n\n    if (prev) {\n      child._next = prev._next;\n      prev._next = child;\n    } else {\n      child._next = parent[firstProp];\n      parent[firstProp] = child;\n    }\n\n    if (child._next) {\n      child._next._prev = child;\n    } else {\n      parent[lastProp] = child;\n    }\n\n    child._prev = prev;\n    child.parent = child._dp = parent;\n    return child;\n  },\n      _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n    if (firstProp === void 0) {\n      firstProp = \"_first\";\n    }\n\n    if (lastProp === void 0) {\n      lastProp = \"_last\";\n    }\n\n    var prev = child._prev,\n        next = child._next;\n\n    if (prev) {\n      prev._next = next;\n    } else if (parent[firstProp] === child) {\n      parent[firstProp] = next;\n    }\n\n    if (next) {\n      next._prev = prev;\n    } else if (parent[lastProp] === child) {\n      parent[lastProp] = prev;\n    }\n\n    child._next = child._prev = child.parent = null;\n  },\n      _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);\n    child._act = 0;\n  },\n      _uncache = function _uncache(animation, child) {\n    if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n      var a = animation;\n\n      while (a) {\n        a._dirty = 1;\n        a = a.parent;\n      }\n    }\n\n    return animation;\n  },\n      _recacheAncestors = function _recacheAncestors(animation) {\n    var parent = animation.parent;\n\n    while (parent && parent.parent) {\n      parent._dirty = 1;\n      parent.totalDuration();\n      parent = parent.parent;\n    }\n\n    return animation;\n  },\n      _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n    return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n  },\n      _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration()  animation._rDelay) * animation : 0;\n  },\n      _animationCycle = function _animationCycle(tTime, cycleDuration) {\n    var whole = Math.floor(tTime /= cycleDuration);\n    return tTime && whole === tTime ? whole - 1 : whole;\n  },\n      _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n    return (parentTime - child._start) * child._ts  (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n  },\n      _setEnd = function _setEnd(animation) {\n    return animation._end = _roundPrecise(animation._start  (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n  },\n      _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n    var parent = animation._dp;\n\n    if (parent && parent.smoothChildTiming && animation._ts) {\n      animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n\n      _setEnd(animation);\n\n      parent._dirty || _uncache(parent, animation);\n    }\n\n    return animation;\n  },\n      _postAddChecks = function _postAddChecks(timeline, child) {\n    var t;\n\n    if (child._time || child._initted && !child._dur) {\n      t = _parentToChildTotalTime(timeline.rawTime(), child);\n\n      if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n        child.render(t, true);\n      }\n    }\n\n    if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n      if (timeline._dur < timeline.duration()) {\n        t = timeline;\n\n        while (t._dp) {\n          t.rawTime() >= 0 && t.totalTime(t._tTime);\n          t = t._dp;\n        }\n      }\n\n      timeline._zTime = -_tinyNum;\n    }\n  },\n      _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n    child.parent && _removeFromParent(child);\n    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time)  child._delay);\n    child._end = _roundPrecise(child._start  (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n\n    _addLinkedListItem(timeline, child, \"_first\", \"_last\", timeline._sort ? \"_start\" : 0);\n\n    _isFromOrFromStart(child) || (timeline._recent = child);\n    skipChecks || _postAddChecks(timeline, child);\n    return timeline;\n  },\n      _scrollTrigger = function _scrollTrigger(animation, trigger) {\n    return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n  },\n      _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {\n    _initTween(tween, totalTime);\n\n    if (!tween._initted) {\n      return 1;\n    }\n\n    if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n      _lazyTweens.push(tween);\n\n      tween._lazy = [totalTime, suppressEvents];\n      return 1;\n    }\n  },\n      _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\n    var parent = _ref.parent;\n    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n  },\n      _isFromOrFromStart = function _isFromOrFromStart(_ref2) {\n    var data = _ref2.data;\n    return data === \"isFromStart\" || data === \"isStart\";\n  },\n      _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n    var prevRatio = tween.ratio,\n        ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,\n        repeatDelay = tween._rDelay,\n        tTime = 0,\n        pt,\n        iteration,\n        prevIteration;\n\n    if (repeatDelay && tween._repeat) {\n      tTime = _clamp(0, tween._tDur, totalTime);\n      iteration = _animationCycle(tTime, repeatDelay);\n      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n\n      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\n        prevRatio = 1 - ratio;\n        tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n      }\n    }\n\n    if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {\n        return;\n      }\n\n      prevIteration = tween._zTime;\n      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);\n      suppressEvents || (suppressEvents = totalTime && !prevIteration);\n      tween.ratio = ratio;\n      tween._from && (ratio = 1 - ratio);\n      tween._time = 0;\n      tween._tTime = tTime;\n      pt = tween._pt;\n\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n\n      tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);\n      tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\n      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\n\n      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n        ratio && _removeFromParent(tween, 1);\n\n        if (!suppressEvents) {\n          _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\n\n          tween._prom && tween._prom();\n        }\n      }\n    } else if (!tween._zTime) {\n      tween._zTime = totalTime;\n    }\n  },\n      _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n    var child;\n\n    if (time > prevTime) {\n      child = animation._first;\n\n      while (child && child._start <= time) {\n        if (child.data === \"isPause\" && child._start > prevTime) {\n          return child;\n        }\n\n        child = child._next;\n      }\n    } else {\n      child = animation._last;\n\n      while (child && child._start >= time) {\n        if (child.data === \"isPause\" && child._start < prevTime) {\n          return child;\n        }\n\n        child = child._prev;\n      }\n    }\n  },\n      _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\n    var repeat = animation._repeat,\n        dur = _roundPrecise(duration) || 0,\n        totalProgress = animation._tTime / animation._tDur;\n    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n    animation._dur = dur;\n    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat  1)  animation._rDelay * repeat);\n    totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);\n    skipUncache || _uncache(animation.parent, animation);\n    return animation;\n  },\n      _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n  },\n      _zeroPosition = {\n    _start: 0,\n    endTime: _emptyFunc,\n    totalDuration: _emptyFunc\n  },\n      _parsePosition = function _parsePosition(animation, position, percentAnimation) {\n    var labels = animation.labels,\n        recent = animation._recent || _zeroPosition,\n        clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,\n        i,\n        offset,\n        isPercent;\n\n    if (_isString(position) && (isNaN(position) || position in labels)) {\n      offset = position.charAt(0);\n      isPercent = position.substr(-1) === \"%\";\n      i = position.indexOf(\"=\");\n\n      if (offset === \"<\" || offset === \">\") {\n        i >= 0 && (position = position.replace(/=/, \"\"));\n        return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0))  (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\n      }\n\n      if (i < 0) {\n        position in labels || (labels[position] = clippedDuration);\n        return labels[position];\n      }\n\n      offset = parseFloat(position.charAt(i - 1)  position.substr(i  1));\n\n      if (isPercent && percentAnimation) {\n        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\n      }\n\n      return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation)  offset : clippedDuration  offset;\n    }\n\n    return position == null ? clippedDuration : position;\n  },\n      _createTweenType = function _createTweenType(type, params, timeline) {\n    var isLegacy = _isNumber(params[1]),\n        varsIndex = (isLegacy ? 2 : 1)  (type < 2 ? 0 : 1),\n        vars = params[varsIndex],\n        irVars,\n        parent;\n\n    isLegacy && (vars.duration = params[1]);\n    vars.parent = timeline;\n\n    if (type) {\n      irVars = vars;\n      parent = timeline;\n\n      while (parent && !(\"immediateRender\" in irVars)) {\n        irVars = parent.vars.defaults || {};\n        parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n      }\n\n      vars.immediateRender = _isNotFalse(irVars.immediateRender);\n      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];\n    }\n\n    return new Tween(params[0], vars, params[varsIndex  1]);\n  },\n      _conditionalReturn = function _conditionalReturn(value, func) {\n    return value || value === 0 ? func(value) : func;\n  },\n      _clamp = function _clamp(min, max, value) {\n    return value < min ? min : value > max ? max : value;\n  },\n      getUnit = function getUnit(value, v) {\n    return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\n  },\n      clamp = function clamp(min, max, value) {\n    return _conditionalReturn(value, function (v) {\n      return _clamp(min, max, v);\n    });\n  },\n      _slice = [].slice,\n      _isArrayLike = function _isArrayLike(value, nonEmpty) {\n    return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n  },\n      _flatten = function _flatten(ar, leaveStrings, accumulator) {\n    if (accumulator === void 0) {\n      accumulator = [];\n    }\n\n    return ar.forEach(function (value) {\n      var _accumulator;\n\n      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n    }) || accumulator;\n  },\n      toArray = function toArray(value, scope, leaveStrings) {\n    return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];\n  },\n      selector = function selector(value) {\n    value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\n    return function (v) {\n      var el = value.current || value.nativeElement || value;\n      return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\n    };\n  },\n      shuffle = function shuffle(a) {\n    return a.sort(function () {\n      return .5 - Math.random();\n    });\n  },\n      distribute = function distribute(v) {\n    if (_isFunction(v)) {\n      return v;\n    }\n\n    var vars = _isObject(v) ? v : {\n      each: v\n    },\n        ease = _parseEase(vars.ease),\n        from = vars.from || 0,\n        base = parseFloat(vars.base) || 0,\n        cache = {},\n        isDecimal = from > 0 && from < 1,\n        ratios = isNaN(from) || isDecimal,\n        axis = vars.axis,\n        ratioX = from,\n        ratioY = from;\n\n    if (_isString(from)) {\n      ratioX = ratioY = {\n        center: .5,\n        edges: .5,\n        end: 1\n      }[from] || 0;\n    } else if (!isDecimal && ratios) {\n      ratioX = from[0];\n      ratioY = from[1];\n    }\n\n    return function (i, target, a) {\n      var l = (a || vars).length,\n          distances = cache[l],\n          originX,\n          originY,\n          x,\n          y,\n          d,\n          j,\n          max,\n          min,\n          wrapAt;\n\n      if (!distances) {\n        wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [1, _bigNum])[1];\n\n        if (!wrapAt) {\n          max = -_bigNum;\n\n          while (max < (max = a[wrapAt].getBoundingClientRect().left) && wrapAt < l) {}\n\n          wrapAt--;\n        }\n\n        distances = cache[l] = [];\n        originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n        originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n        max = 0;\n        min = _bigNum;\n\n        for (j = 0; j < l; j) {\n          x = j % wrapAt - originX;\n          y = originY - (j / wrapAt | 0);\n          distances[j] = d = !axis ? _sqrt(x * x  y * y) : Math.abs(axis === \"y\" ? y : x);\n          d > max && (max = d);\n          d < min && (min = d);\n        }\n\n        from === \"random\" && shuffle(distances);\n        distances.max = max - min;\n        distances.min = min;\n        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\n        distances.b = l < 0 ? base - l : base;\n        distances.u = getUnit(vars.amount || vars.each) || 0;\n        ease = ease && l < 0 ? _invertEase(ease) : ease;\n      }\n\n      l = (distances[i] - distances.min) / distances.max || 0;\n      return _roundPrecise(distances.b  (ease ? ease(l) : l) * distances.v)  distances.u;\n    };\n  },\n      _roundModifier = function _roundModifier(v) {\n    var p = Math.pow(10, ((v  \"\").split(\".\")[1] || \"\").length);\n    return function (raw) {\n      var n = Math.round(parseFloat(raw) / v) * v * p;\n      return (n - n % 1) / p  (_isNumber(raw) ? 0 : getUnit(raw));\n    };\n  },\n      snap = function snap(snapTo, value) {\n    var isArray = _isArray(snapTo),\n        radius,\n        is2D;\n\n    if (!isArray && _isObject(snapTo)) {\n      radius = isArray = snapTo.radius || _bigNum;\n\n      if (snapTo.values) {\n        snapTo = toArray(snapTo.values);\n\n        if (is2D = !_isNumber(snapTo[0])) {\n          radius *= radius;\n        }\n      } else {\n        snapTo = _roundModifier(snapTo.increment);\n      }\n    }\n\n    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {\n      is2D = snapTo(raw);\n      return Math.abs(is2D - raw) <= radius ? is2D : raw;\n    } : function (raw) {\n      var x = parseFloat(is2D ? raw.x : raw),\n          y = parseFloat(is2D ? raw.y : 0),\n          min = _bigNum,\n          closest = 0,\n          i = snapTo.length,\n          dx,\n          dy;\n\n      while (i--) {\n        if (is2D) {\n          dx = snapTo[i].x - x;\n          dy = snapTo[i].y - y;\n          dx = dx * dx  dy * dy;\n        } else {\n          dx = Math.abs(snapTo[i] - x);\n        }\n\n        if (dx < min) {\n          min = dx;\n          closest = i;\n        }\n      }\n\n      closest = !radius || min <= radius ? snapTo[closest] : raw;\n      return is2D || closest === raw || _isNumber(raw) ? closest : closest  getUnit(raw);\n    });\n  },\n      random = function random(min, max, roundingIncrement, returnFunction) {\n    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {\n      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement  \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2  Math.random() * (max - min  roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n    });\n  },\n      pipe = function pipe() {\n    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key) {\n      functions[_key] = arguments[_key];\n    }\n\n    return function (value) {\n      return functions.reduce(function (v, f) {\n        return f(v);\n      }, value);\n    };\n  },\n      unitize = function unitize(func, unit) {\n    return function (value) {\n      return func(parseFloat(value))  (unit || getUnit(value));\n    };\n  },\n      normalize = function normalize(min, max, value) {\n    return mapRange(min, max, 0, 1, value);\n  },\n      _wrapArray = function _wrapArray(a, wrapper, value) {\n    return _conditionalReturn(value, function (index) {\n      return a[~~wrapper(index)];\n    });\n  },\n      wrap = function wrap(min, max, value) {\n    var range = max - min;\n    return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {\n      return (range  (value - min) % range) % range  min;\n    });\n  },\n      wrapYoyo = function wrapYoyo(min, max, value) {\n    var range = max - min,\n        total = range * 2;\n    return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {\n      value = (total  (value - min) % total) % total || 0;\n      return min  (value > range ? total - value : value);\n    });\n  },\n      _replaceRandom = function _replaceRandom(value) {\n    var prev = 0,\n        s = \"\",\n        i,\n        nums,\n        end,\n        isArray;\n\n    while (~(i = value.indexOf(\"random(\", prev))) {\n      end = value.indexOf(\")\", i);\n      isArray = value.charAt(i  7) === \"[\";\n      nums = value.substr(i  7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n      s = value.substr(prev, i - prev)  random(isArray ? nums : nums[0], isArray ? 0 : nums[1], nums[2] || 1e-5);\n      prev = end  1;\n    }\n\n    return s  value.substr(prev, value.length - prev);\n  },\n      mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n    var inRange = inMax - inMin,\n        outRange = outMax - outMin;\n    return _conditionalReturn(value, function (value) {\n      return outMin  ((value - inMin) / inRange * outRange || 0);\n    });\n  },\n      interpolate = function interpolate(start, end, progress, mutate) {\n    var func = isNaN(start  end) ? 0 : function (p) {\n      return (1 - p) * start  p * end;\n    };\n\n    if (!func) {\n      var isString = _isString(start),\n          master = {},\n          p,\n          i,\n          interpolators,\n          l,\n          il;\n\n      progress === true && (mutate = 1) && (progress = null);\n\n      if (isString) {\n        start = {\n          p: start\n        };\n        end = {\n          p: end\n        };\n      } else if (_isArray(start) && !_isArray(end)) {\n        interpolators = [];\n        l = start.length;\n        il = l - 2;\n\n        for (i = 1; i < l; i) {\n          interpolators.push(interpolate(start[i - 1], start[i]));\n        }\n\n        l--;\n\n        func = function func(p) {\n          p *= l;\n          var i = Math.min(il, ~~p);\n          return interpolators[i](p - i);\n        };\n\n        progress = end;\n      } else if (!mutate) {\n        start = _merge(_isArray(start) ? [] : {}, start);\n      }\n\n      if (!interpolators) {\n        for (p in end) {\n          _addPropTween.call(master, start, p, \"get\", end[p]);\n        }\n\n        func = function func(p) {\n          return _renderPropTweens(p, master) || (isString ? start.p : start);\n        };\n      }\n    }\n\n    return _conditionalReturn(progress, func);\n  },\n      _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n    var labels = timeline.labels,\n        min = _bigNum,\n        p,\n        distance,\n        label;\n\n    for (p in labels) {\n      distance = labels[p] - fromTime;\n\n      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n        label = p;\n        min = distance;\n      }\n    }\n\n    return label;\n  },\n      _callback = function _callback(animation, type, executeLazyFirst) {\n    var v = animation.vars,\n        callback = v[type],\n        params,\n        scope;\n\n    if (!callback) {\n      return;\n    }\n\n    params = v[type  \"Params\"];\n    scope = v.callbackScope || animation;\n    executeLazyFirst && _lazyTweens.length && _lazyRender();\n    return params ? callback.apply(scope, params) : callback.call(scope);\n  },\n      _interrupt = function _interrupt(animation) {\n    _removeFromParent(animation);\n\n    animation.scrollTrigger && animation.scrollTrigger.kill(false);\n    animation.progress() < 1 && _callback(animation, \"onInterrupt\");\n    return animation;\n  },\n      _quickTween,\n      _createPlugin = function _createPlugin(config) {\n    config = !config.name && config[\"default\"] || config;\n\n    var name = config.name,\n        isFunc = _isFunction(config),\n        Plugin = name && !isFunc && config.init ? function () {\n      this._props = [];\n    } : config,\n        instanceDefaults = {\n      init: _emptyFunc,\n      render: _renderPropTweens,\n      add: _addPropTween,\n      kill: _killPropTweensOf,\n      modifier: _addPluginModifier,\n      rawVars: 0\n    },\n        statics = {\n      targetTest: 0,\n      get: 0,\n      getSetter: _getSetter,\n      aliases: {},\n      register: 0\n    };\n\n    _wake();\n\n    if (config !== Plugin) {\n      if (_plugins[name]) {\n        return;\n      }\n\n      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));\n\n      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));\n\n      _plugins[Plugin.prop = name] = Plugin;\n\n      if (config.targetTest) {\n        _harnessPlugins.push(Plugin);\n\n        _reservedProps[name] = 1;\n      }\n\n      name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase()  name.substr(1))  \"Plugin\";\n    }\n\n    _addGlobal(name, Plugin);\n\n    config.register && config.register(gsap, Plugin, PropTween);\n  },\n      _255 = 255,\n      _colorLookup = {\n    aqua: [0, _255, _255],\n    lime: [0, _255, 0],\n    silver: [192, 192, 192],\n    black: [0, 0, 0],\n    maroon: [128, 0, 0],\n    teal: [0, 128, 128],\n    blue: [0, 0, _255],\n    navy: [0, 0, 128],\n    white: [_255, _255, _255],\n    olive: [128, 128, 0],\n    yellow: [_255, _255, 0],\n    orange: [_255, 165, 0],\n    gray: [128, 128, 128],\n    purple: [128, 0, 128],\n    green: [0, 128, 0],\n    red: [_255, 0, 0],\n    pink: [_255, 192, 203],\n    cyan: [0, _255, _255],\n    transparent: [_255, _255, _255, 0]\n  },\n      _hue = function _hue(h, m1, m2) {\n    h = h < 0 ? 1 : h > 1 ? -1 : 0;\n    return (h * 6 < 1 ? m1  (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1  (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255  .5 | 0;\n  },\n      splitColor = function splitColor(v, toHSL, forceAlpha) {\n    var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,\n        r,\n        g,\n        b,\n        h,\n        s,\n        l,\n        max,\n        min,\n        d,\n        wasHSL;\n\n    if (!a) {\n      if (v.substr(-1) === \",\") {\n        v = v.substr(0, v.length - 1);\n      }\n\n      if (_colorLookup[v]) {\n        a = _colorLookup[v];\n      } else if (v.charAt(0) === \"#\") {\n        if (v.length < 6) {\n          r = v.charAt(1);\n          g = v.charAt(2);\n          b = v.charAt(3);\n          v = \"#\"  r  r  g  g  b  b  (v.length === 5 ? v.charAt(4)  v.charAt(4) : \"\");\n        }\n\n        if (v.length === 9) {\n          a = parseInt(v.substr(1, 6), 16);\n          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];\n        }\n\n        v = parseInt(v.substr(1), 16);\n        a = [v >> 16, v >> 8 & _255, v & _255];\n      } else if (v.substr(0, 3) === \"hsl\") {\n        a = wasHSL = v.match(_strictNumExp);\n\n        if (!toHSL) {\n          h = a[0] % 360 / 360;\n          s = a[1] / 100;\n          l = a[2] / 100;\n          g = l <= .5 ? l * (s  1) : l  s - l * s;\n          r = l * 2 - g;\n          a.length > 3 && (a[3] *= 1);\n          a[0] = _hue(h  1 / 3, r, g);\n          a[1] = _hue(h, r, g);\n          a[2] = _hue(h - 1 / 3, r, g);\n        } else if (~v.indexOf(\"=\")) {\n          a = v.match(_numExp);\n          forceAlpha && a.length < 4 && (a[3] = 1);\n          return a;\n        }\n      } else {\n        a = v.match(_strictNumExp) || _colorLookup.transparent;\n      }\n\n      a = a.map(Number);\n    }\n\n    if (toHSL && !wasHSL) {\n      r = a[0] / _255;\n      g = a[1] / _255;\n      b = a[2] / _255;\n      max = Math.max(r, g, b);\n      min = Math.min(r, g, b);\n      l = (max  min) / 2;\n\n      if (max === min) {\n        h = s = 0;\n      } else {\n        d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max  min);\n        h = max === r ? (g - b) / d  (g < b ? 6 : 0) : max === g ? (b - r) / d  2 : (r - g) / d  4;\n        h *= 60;\n      }\n\n      a[0] = ~~(h  .5);\n      a[1] = ~~(s * 100  .5);\n      a[2] = ~~(l * 100  .5);\n    }\n\n    forceAlpha && a.length < 4 && (a[3] = 1);\n    return a;\n  },\n      _colorOrderData = function _colorOrderData(v) {\n    var values = [],\n        c = [],\n        i = -1;\n    v.split(_colorExp).forEach(function (v) {\n      var a = v.match(_numWithUnitExp) || [];\n      values.push.apply(values, a);\n      c.push(i = a.length  1);\n    });\n    values.c = c;\n    return values;\n  },\n      _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n    var result = \"\",\n        colors = (s  result).match(_colorExp),\n        type = toHSL ? \"hsla(\" : \"rgba(\",\n        i = 0,\n        c,\n        shell,\n        d,\n        l;\n\n    if (!colors) {\n      return s;\n    }\n\n    colors = colors.map(function (color) {\n      return (color = splitColor(color, toHSL, 1)) && type  (toHSL ? color[0]  \",\"  color[1]  \"%,\"  color[2]  \"%,\"  color[3] : color.join(\",\"))  \")\";\n    });\n\n    if (orderMatchData) {\n      d = _colorOrderData(s);\n      c = orderMatchData.c;\n\n      if (c.join(result) !== d.c.join(result)) {\n        shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\n        l = shell.length - 1;\n\n        for (; i < l; i) {\n          result = shell[i]  (~c.indexOf(i) ? colors.shift() || type  \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n        }\n      }\n    }\n\n    if (!shell) {\n      shell = s.split(_colorExp);\n      l = shell.length - 1;\n\n      for (; i < l; i) {\n        result = shell[i]  colors[i];\n      }\n    }\n\n    return result  shell[l];\n  },\n      _colorExp = function () {\n    var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\",\n        p;\n\n    for (p in _colorLookup) {\n      s = \"|\"  p  \"\\\\b\";\n    }\n\n    return new RegExp(s  \")\", \"gi\");\n  }(),\n      _hslExp = /hsl[a]?\\(/,\n      _colorStringFilter = function _colorStringFilter(a) {\n    var combined = a.join(\" \"),\n        toHSL;\n    _colorExp.lastIndex = 0;\n\n    if (_colorExp.test(combined)) {\n      toHSL = _hslExp.test(combined);\n      a[1] = _formatColors(a[1], toHSL);\n      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));\n      return true;\n    }\n  },\n      _tickerActive,\n      _ticker = function () {\n    var _getTime = Date.now,\n        _lagThreshold = 500,\n        _adjustedLag = 33,\n        _startTime = _getTime(),\n        _lastUpdate = _startTime,\n        _gap = 1000 / 240,\n        _nextTime = _gap,\n        _listeners = [],\n        _id,\n        _req,\n        _raf,\n        _self,\n        _delta,\n        _i,\n        _tick = function _tick(v) {\n      var elapsed = _getTime() - _lastUpdate,\n          manual = v === true,\n          overlap,\n          dispatch,\n          time,\n          frame;\n\n      elapsed > _lagThreshold && (_startTime = elapsed - _adjustedLag);\n      _lastUpdate = elapsed;\n      time = _lastUpdate - _startTime;\n      overlap = time - _nextTime;\n\n      if (overlap > 0 || manual) {\n        frame = _self.frame;\n        _delta = time - _self.time * 1000;\n        _self.time = time = time / 1000;\n        _nextTime = overlap  (overlap >= _gap ? 4 : _gap - overlap);\n        dispatch = 1;\n      }\n\n      manual || (_id = _req(_tick));\n\n      if (dispatch) {\n        for (_i = 0; _i < _listeners.length; _i) {\n          _listeners[_i](time, _delta, frame, v);\n        }\n      }\n    };\n\n    _self = {\n      time: 0,\n      frame: 0,\n      tick: function tick() {\n        _tick(true);\n      },\n      deltaRatio: function deltaRatio(fps) {\n        return _delta / (1000 / (fps || 60));\n      },\n      wake: function wake() {\n        if (_coreReady) {\n          if (!_coreInitted && _windowExists()) {\n            _win = _coreInitted = window;\n            _doc = _win.document || {};\n            _globals.gsap = gsap;\n            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n\n            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n\n            _raf = _win.requestAnimationFrame;\n          }\n\n          _id && _self.sleep();\n\n          _req = _raf || function (f) {\n            return setTimeout(f, _nextTime - _self.time * 1000  1 | 0);\n          };\n\n          _tickerActive = 1;\n\n          _tick(2);\n        }\n      },\n      sleep: function sleep() {\n        (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);\n        _tickerActive = 0;\n        _req = _emptyFunc;\n      },\n      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n        _lagThreshold = threshold || 1 / _tinyNum;\n        _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);\n      },\n      fps: function fps(_fps) {\n        _gap = 1000 / (_fps || 240);\n        _nextTime = _self.time * 1000  _gap;\n      },\n      add: function add(callback, once, prioritize) {\n        var func = once ? function (t, d, f, v) {\n          callback(t, d, f, v);\n\n          _self.remove(func);\n        } : callback;\n\n        _self.remove(callback);\n\n        _listeners[prioritize ? \"unshift\" : \"push\"](func);\n\n        _wake();\n\n        return func;\n      },\n      remove: function remove(callback, i) {\n        ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n      },\n      _listeners: _listeners\n    };\n    return _self;\n  }(),\n      _wake = function _wake() {\n    return !_tickerActive && _ticker.wake();\n  },\n      _easeMap = {},\n      _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/,\n      _quotesExp = /[\"']/g,\n      _parseObjectInString = function _parseObjectInString(value) {\n    var obj = {},\n        split = value.substr(1, value.length - 3).split(\":\"),\n        key = split[0],\n        i = 1,\n        l = split.length,\n        index,\n        val,\n        parsedVal;\n\n    for (; i < l; i) {\n      val = split[i];\n      index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\n      parsedVal = val.substr(0, index);\n      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : parsedVal;\n      key = val.substr(index  1).trim();\n    }\n\n    return obj;\n  },\n      _valueInParentheses = function _valueInParentheses(value) {\n    var open = value.indexOf(\"(\")  1,\n        close = value.indexOf(\")\"),\n        nested = value.indexOf(\"(\", open);\n    return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close  1) : close);\n  },\n      _configEaseFromString = function _configEaseFromString(name) {\n    var split = (name  \"\").split(\"(\"),\n        ease = _easeMap[split[0]];\n    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\n  },\n      _invertEase = function _invertEase(ease) {\n    return function (p) {\n      return 1 - ease(1 - p);\n    };\n  },\n      _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n    var child = timeline._first,\n        ease;\n\n    while (child) {\n      if (child instanceof Timeline) {\n        _propagateYoyoEase(child, isYoyo);\n      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n        if (child.timeline) {\n          _propagateYoyoEase(child.timeline, isYoyo);\n        } else {\n          ease = child._ease;\n          child._ease = child._yEase;\n          child._yEase = ease;\n          child._yoyo = isYoyo;\n        }\n      }\n\n      child = child._next;\n    }\n  },\n      _parseEase = function _parseEase(ease, defaultEase) {\n    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n  },\n      _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n    if (easeOut === void 0) {\n      easeOut = function easeOut(p) {\n        return 1 - easeIn(1 - p);\n      };\n    }\n\n    if (easeInOut === void 0) {\n      easeInOut = function easeInOut(p) {\n        return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n      };\n    }\n\n    var ease = {\n      easeIn: easeIn,\n      easeOut: easeOut,\n      easeInOut: easeInOut\n    },\n        lowercaseName;\n\n    _forEachName(names, function (name) {\n      _easeMap[name] = _globals[name] = ease;\n      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n\n      for (var p in ease) {\n        _easeMap[lowercaseName  (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name  \".\"  p] = ease[p];\n      }\n    });\n\n    return ease;\n  },\n      _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n    return function (p) {\n      return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5  easeOut((p - .5) * 2) / 2;\n    };\n  },\n      _configElastic = function _configElastic(type, amplitude, period) {\n    var p1 = amplitude >= 1 ? amplitude : 1,\n        p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),\n        p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),\n        easeOut = function easeOut(p) {\n      return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2)  1;\n    },\n        ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\n      return 1 - easeOut(1 - p);\n    } : _easeInOutFromOut(easeOut);\n\n    p2 = _2PI / p2;\n\n    ease.config = function (amplitude, period) {\n      return _configElastic(type, amplitude, period);\n    };\n\n    return ease;\n  },\n      _configBack = function _configBack(type, overshoot) {\n    if (overshoot === void 0) {\n      overshoot = 1.70158;\n    }\n\n    var easeOut = function easeOut(p) {\n      return p ? --p * p * ((overshoot  1) * p  overshoot)  1 : 0;\n    },\n        ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\n      return 1 - easeOut(1 - p);\n    } : _easeInOutFromOut(easeOut);\n\n    ease.config = function (overshoot) {\n      return _configBack(type, overshoot);\n    };\n\n    return ease;\n  };\n\n  _forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function (name, i) {\n    var power = i < 5 ? i  1 : i;\n\n    _insertEase(name  \",Power\"  (power - 1), i ? function (p) {\n      return Math.pow(p, power);\n    } : function (p) {\n      return p;\n    }, function (p) {\n      return 1 - Math.pow(1 - p, power);\n    }, function (p) {\n      return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n    });\n  });\n\n  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n\n  _insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\n\n  (function (n, c) {\n    var n1 = 1 / c,\n        n2 = 2 * n1,\n        n3 = 2.5 * n1,\n        easeOut = function easeOut(p) {\n      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2)  .75 : p < n3 ? n * (p -= 2.25 / c) * p  .9375 : n * Math.pow(p - 2.625 / c, 2)  .984375;\n    };\n\n    _insertEase(\"Bounce\", function (p) {\n      return 1 - easeOut(1 - p);\n    }, easeOut);\n  })(7.5625, 2.75);\n\n  _insertEase(\"Expo\", function (p) {\n    return p ? Math.pow(2, 10 * (p - 1)) : 0;\n  });\n\n  _insertEase(\"Circ\", function (p) {\n    return -(_sqrt(1 - p * p) - 1);\n  });\n\n  _insertEase(\"Sine\", function (p) {\n    return p === 1 ? 1 : -_cos(p * _HALF_PI)  1;\n  });\n\n  _insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\n\n  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n    config: function config(steps, immediateStart) {\n      if (steps === void 0) {\n        steps = 1;\n      }\n\n      var p1 = 1 / steps,\n          p2 = steps  (immediateStart ? 0 : 1),\n          p3 = immediateStart ? 1 : 0,\n          max = 1 - _tinyNum;\n      return function (p) {\n        return ((p2 * _clamp(0, max, p) | 0)  p3) * p1;\n      };\n    }\n  };\n  _defaults.ease = _easeMap[\"quad.out\"];\n\n  _forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function (name) {\n    return _callbackNames = name  \",\"  name  \"Params,\";\n  });\n\n  var GSCache = function GSCache(target, harness) {\n    this.id = _gsID;\n    target._gsap = this;\n    this.target = target;\n    this.harness = harness;\n    this.get = harness ? harness.get : _getProperty;\n    this.set = harness ? harness.getSetter : _getSetter;\n  };\n  var Animation = function () {\n    function Animation(vars) {\n      this.vars = vars;\n      this._delay = vars.delay || 0;\n\n      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n        this._rDelay = vars.repeatDelay || 0;\n        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n      }\n\n      this._ts = 1;\n\n      _setDuration(this, vars.duration, 1, 1);\n\n      this.data = vars.data;\n      _tickerActive || _ticker.wake();\n    }\n\n    var _proto = Animation.prototype;\n\n    _proto.delay = function delay(value) {\n      if (value || value === 0) {\n        this.parent && this.parent.smoothChildTiming && this.startTime(this._start  value - this._delay);\n        this._delay = value;\n        return this;\n      }\n\n      return this._delay;\n    };\n\n    _proto.duration = function duration(value) {\n      return arguments.length ? this.totalDuration(this._repeat > 0 ? value  (value  this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n    };\n\n    _proto.totalDuration = function totalDuration(value) {\n      if (!arguments.length) {\n        return this._tDur;\n      }\n\n      this._dirty = 0;\n      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat  1));\n    };\n\n    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n      _wake();\n\n      if (!arguments.length) {\n        return this._tTime;\n      }\n\n      var parent = this._dp;\n\n      if (parent && parent.smoothChildTiming && this._ts) {\n        _alignPlayhead(this, _totalTime);\n\n        !parent._dp || parent.parent || _postAddChecks(parent, this);\n\n        while (parent && parent.parent) {\n          if (parent.parent._time !== parent._start  (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n            parent.totalTime(parent._tTime, true);\n          }\n\n          parent = parent.parent;\n        }\n\n        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n          _addToTimeline(this._dp, this, this._start - this._delay);\n        }\n      }\n\n      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n        this._ts || (this._pTime = _totalTime);\n\n        _lazySafeRender(this, _totalTime, suppressEvents);\n      }\n\n      return this;\n    };\n\n    _proto.time = function time(value, suppressEvents) {\n      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value  _elapsedCycleDuration(this)) % (this._dur  this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;\n    };\n\n    _proto.totalProgress = function totalProgress(value, suppressEvents) {\n      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;\n    };\n\n    _proto.progress = function progress(value, suppressEvents) {\n      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value)  _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;\n    };\n\n    _proto.iteration = function iteration(value, suppressEvents) {\n      var cycleDuration = this.duration()  this._rDelay;\n\n      return arguments.length ? this.totalTime(this._time  (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration)  1 : 1;\n    };\n\n    _proto.timeScale = function timeScale(value) {\n      if (!arguments.length) {\n        return this._rts === -_tinyNum ? 0 : this._rts;\n      }\n\n      if (this._rts === value) {\n        return this;\n      }\n\n      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;\n      this._rts = value || 0;\n      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;\n      this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);\n\n      _setEnd(this);\n\n      return _recacheAncestors(this);\n    };\n\n    _proto.paused = function paused(value) {\n      if (!arguments.length) {\n        return this._ps;\n      }\n\n      if (this._ps !== value) {\n        this._ps = value;\n\n        if (value) {\n          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());\n          this._ts = this._act = 0;\n        } else {\n          _wake();\n\n          this._ts = this._rts;\n          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));\n        }\n      }\n\n      return this;\n    };\n\n    _proto.startTime = function startTime(value) {\n      if (arguments.length) {\n        this._start = value;\n        var parent = this.parent || this._dp;\n        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n        return this;\n      }\n\n      return this._start;\n    };\n\n    _proto.endTime = function endTime(includeRepeats) {\n      return this._start  (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\n    };\n\n    _proto.rawTime = function rawTime(wrapRepeats) {\n      var parent = this.parent || this._dp;\n      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur  this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n    };\n\n    _proto.globalTime = function globalTime(rawTime) {\n      var animation = this,\n          time = arguments.length ? rawTime : animation.rawTime();\n\n      while (animation) {\n        time = animation._start  time / (animation._ts || 1);\n        animation = animation._dp;\n      }\n\n      return time;\n    };\n\n    _proto.repeat = function repeat(value) {\n      if (arguments.length) {\n        this._repeat = value === Infinity ? -2 : value;\n        return _onUpdateTotalDuration(this);\n      }\n\n      return this._repeat === -2 ? Infinity : this._repeat;\n    };\n\n    _proto.repeatDelay = function repeatDelay(value) {\n      if (arguments.length) {\n        var time = this._time;\n        this._rDelay = value;\n\n        _onUpdateTotalDuration(this);\n\n        return time ? this.time(time) : this;\n      }\n\n      return this._rDelay;\n    };\n\n    _proto.yoyo = function yoyo(value) {\n      if (arguments.length) {\n        this._yoyo = value;\n        return this;\n      }\n\n      return this._yoyo;\n    };\n\n    _proto.seek = function seek(position, suppressEvents) {\n      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n    };\n\n    _proto.restart = function restart(includeDelay, suppressEvents) {\n      return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n    };\n\n    _proto.play = function play(from, suppressEvents) {\n      from != null && this.seek(from, suppressEvents);\n      return this.reversed(false).paused(false);\n    };\n\n    _proto.reverse = function reverse(from, suppressEvents) {\n      from != null && this.seek(from || this.totalDuration(), suppressEvents);\n      return this.reversed(true).paused(false);\n    };\n\n    _proto.pause = function pause(atTime, suppressEvents) {\n      atTime != null && this.seek(atTime, suppressEvents);\n      return this.paused(true);\n    };\n\n    _proto.resume = function resume() {\n      return this.paused(false);\n    };\n\n    _proto.reversed = function reversed(value) {\n      if (arguments.length) {\n        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));\n        return this;\n      }\n\n      return this._rts < 0;\n    };\n\n    _proto.invalidate = function invalidate() {\n      this._initted = this._act = 0;\n      this._zTime = -_tinyNum;\n      return this;\n    };\n\n    _proto.isActive = function isActive() {\n      var parent = this.parent || this._dp,\n          start = this._start,\n          rawTime;\n      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n    };\n\n    _proto.eventCallback = function eventCallback(type, callback, params) {\n      var vars = this.vars;\n\n      if (arguments.length > 1) {\n        if (!callback) {\n          delete vars[type];\n        } else {\n          vars[type] = callback;\n          params && (vars[type  \"Params\"] = params);\n          type === \"onUpdate\" && (this._onUpdate = callback);\n        }\n\n        return this;\n      }\n\n      return vars[type];\n    };\n\n    _proto.then = function then(onFulfilled) {\n      var self = this;\n      return new Promise(function (resolve) {\n        var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,\n            _resolve = function _resolve() {\n          var _then = self.then;\n          self.then = null;\n          _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n          resolve(f);\n          self.then = _then;\n        };\n\n        if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n          _resolve();\n        } else {\n          self._prom = _resolve;\n        }\n      });\n    };\n\n    _proto.kill = function kill() {\n      _interrupt(this);\n    };\n\n    return Animation;\n  }();\n\n  _setDefaults(Animation.prototype, {\n    _time: 0,\n    _start: 0,\n    _end: 0,\n    _tTime: 0,\n    _tDur: 0,\n    _dirty: 0,\n    _repeat: 0,\n    _yoyo: false,\n    parent: null,\n    _initted: false,\n    _rDelay: 0,\n    _ts: 1,\n    _dp: 0,\n    ratio: 0,\n    _zTime: -_tinyNum,\n    _prom: 0,\n    _ps: false,\n    _rts: 1\n  });\n\n  var Timeline = function (_Animation) {\n    _inheritsLoose(Timeline, _Animation);\n\n    function Timeline(vars, position) {\n      var _this;\n\n      if (vars === void 0) {\n        vars = {};\n      }\n\n      _this = _Animation.call(this, vars) || this;\n      _this.labels = {};\n      _this.smoothChildTiming = !!vars.smoothChildTiming;\n      _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n      _this._sort = _isNotFalse(vars.sortChildren);\n      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\n      vars.reversed && _this.reverse();\n      vars.paused && _this.paused(true);\n      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n      return _this;\n    }\n\n    var _proto2 = Timeline.prototype;\n\n    _proto2.to = function to(targets, vars, position) {\n      _createTweenType(0, arguments, this);\n\n      return this;\n    };\n\n    _proto2.from = function from(targets, vars, position) {\n      _createTweenType(1, arguments, this);\n\n      return this;\n    };\n\n    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n      _createTweenType(2, arguments, this);\n\n      return this;\n    };\n\n    _proto2.set = function set(targets, vars, position) {\n      vars.duration = 0;\n      vars.parent = this;\n      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n      vars.immediateRender = !!vars.immediateRender;\n      new Tween(targets, vars, _parsePosition(this, position), 1);\n      return this;\n    };\n\n    _proto2.call = function call(callback, params, position) {\n      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\n    };\n\n    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n      vars.duration = duration;\n      vars.stagger = vars.stagger || stagger;\n      vars.onComplete = onCompleteAll;\n      vars.onCompleteParams = onCompleteAllParams;\n      vars.parent = this;\n      new Tween(targets, vars, _parsePosition(this, position));\n      return this;\n    };\n\n    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n      vars.runBackwards = 1;\n      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n    };\n\n    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n      toVars.startAt = fromVars;\n      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n    };\n\n    _proto2.render = function render(totalTime, suppressEvents, force) {\n      var prevTime = this._time,\n          tDur = this._dirty ? this.totalDuration() : this._tDur,\n          dur = this._dur,\n          tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),\n          crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),\n          time,\n          child,\n          next,\n          iteration,\n          cycleDuration,\n          prevPaused,\n          pauseTween,\n          timeScale,\n          prevStart,\n          prevIteration,\n          yoyo,\n          isYoyo;\n      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\n\n      if (tTime !== this._tTime || force || crossingStart) {\n        if (prevTime !== this._time && dur) {\n          tTime = this._time - prevTime;\n          totalTime = this._time - prevTime;\n        }\n\n        time = tTime;\n        prevStart = this._start;\n        timeScale = this._ts;\n        prevPaused = !timeScale;\n\n        if (crossingStart) {\n          dur || (prevTime = this._zTime);\n          (totalTime || !suppressEvents) && (this._zTime = totalTime);\n        }\n\n        if (this._repeat) {\n          yoyo = this._yoyo;\n          cycleDuration = dur  this._rDelay;\n\n          if (this._repeat < -1 && totalTime < 0) {\n            return this.totalTime(cycleDuration * 100  totalTime, suppressEvents, force);\n          }\n\n          time = _roundPrecise(tTime % cycleDuration);\n\n          if (tTime === tDur) {\n            iteration = this._repeat;\n            time = dur;\n          } else {\n            iteration = ~~(tTime / cycleDuration);\n\n            if (iteration && iteration === tTime / cycleDuration) {\n              time = dur;\n              iteration--;\n            }\n\n            time > dur && (time = dur);\n          }\n\n          prevIteration = _animationCycle(this._tTime, cycleDuration);\n          !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration);\n\n          if (yoyo && iteration & 1) {\n            time = dur - time;\n            isYoyo = 1;\n          }\n\n          if (iteration !== prevIteration && !this._lock) {\n            var rewinding = yoyo && prevIteration & 1,\n                doesWrap = rewinding === (yoyo && iteration & 1);\n            iteration < prevIteration && (rewinding = !rewinding);\n            prevTime = rewinding ? 0 : dur;\n            this._lock = 1;\n            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n            this._tTime = tTime;\n            !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n\n            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n              return this;\n            }\n\n            dur = this._dur;\n            tDur = this._tDur;\n\n            if (doesWrap) {\n              this._lock = 2;\n              prevTime = rewinding ? dur : -0.0001;\n              this.render(prevTime, true);\n              this.vars.repeatRefresh && !isYoyo && this.invalidate();\n            }\n\n            this._lock = 0;\n\n            if (!this._ts && !prevPaused) {\n              return this;\n            }\n\n            _propagateYoyoEase(this, isYoyo);\n          }\n        }\n\n        if (this._hasPause && !this._forcing && this._lock < 2) {\n          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\n\n          if (pauseTween) {\n            tTime -= time - (time = pauseTween._start);\n          }\n        }\n\n        this._tTime = tTime;\n        this._time = time;\n        this._act = !timeScale;\n\n        if (!this._initted) {\n          this._onUpdate = this.vars.onUpdate;\n          this._initted = 1;\n          this._zTime = totalTime;\n          prevTime = 0;\n        }\n\n        if (!prevTime && time && !suppressEvents) {\n          _callback(this, \"onStart\");\n\n          if (this._tTime !== tTime) {\n            return this;\n          }\n        }\n\n        if (time >= prevTime && totalTime >= 0) {\n          child = this._first;\n\n          while (child) {\n            next = child._next;\n\n            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n              if (child.parent !== this) {\n                return this.render(totalTime, suppressEvents, force);\n              }\n\n              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur)  (time - child._start) * child._ts, suppressEvents, force);\n\n              if (time !== this._time || !this._ts && !prevPaused) {\n                pauseTween = 0;\n                next && (tTime = this._zTime = -_tinyNum);\n                break;\n              }\n            }\n\n            child = next;\n          }\n        } else {\n          child = this._last;\n          var adjustedTime = totalTime < 0 ? totalTime : time;\n\n          while (child) {\n            next = child._prev;\n\n            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n              if (child.parent !== this) {\n                return this.render(totalTime, suppressEvents, force);\n              }\n\n              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur)  (adjustedTime - child._start) * child._ts, suppressEvents, force);\n\n              if (time !== this._time || !this._ts && !prevPaused) {\n                pauseTween = 0;\n                next && (tTime = this._zTime = adjustedTime ? -_tinyNum : _tinyNum);\n                break;\n              }\n            }\n\n            child = next;\n          }\n        }\n\n        if (pauseTween && !suppressEvents) {\n          this.pause();\n          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n\n          if (this._ts) {\n            this._start = prevStart;\n\n            _setEnd(this);\n\n            return this.render(totalTime, suppressEvents, force);\n          }\n        }\n\n        this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\n        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {\n          (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);\n\n          if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\n            _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\n\n            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n          }\n        }\n      }\n\n      return this;\n    };\n\n    _proto2.add = function add(child, position) {\n      var _this2 = this;\n\n      _isNumber(position) || (position = _parsePosition(this, position, child));\n\n      if (!(child instanceof Animation)) {\n        if (_isArray(child)) {\n          child.forEach(function (obj) {\n            return _this2.add(obj, position);\n          });\n          return this;\n        }\n\n        if (_isString(child)) {\n          return this.addLabel(child, position);\n        }\n\n        if (_isFunction(child)) {\n          child = Tween.delayedCall(0, child);\n        } else {\n          return this;\n        }\n      }\n\n      return this !== child ? _addToTimeline(this, child, position) : this;\n    };\n\n    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n      if (nested === void 0) {\n        nested = true;\n      }\n\n      if (tweens === void 0) {\n        tweens = true;\n      }\n\n      if (timelines === void 0) {\n        timelines = true;\n      }\n\n      if (ignoreBeforeTime === void 0) {\n        ignoreBeforeTime = -_bigNum;\n      }\n\n      var a = [],\n          child = this._first;\n\n      while (child) {\n        if (child._start >= ignoreBeforeTime) {\n          if (child instanceof Tween) {\n            tweens && a.push(child);\n          } else {\n            timelines && a.push(child);\n            nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n          }\n        }\n\n        child = child._next;\n      }\n\n      return a;\n    };\n\n    _proto2.getById = function getById(id) {\n      var animations = this.getChildren(1, 1, 1),\n          i = animations.length;\n\n      while (i--) {\n        if (animations[i].vars.id === id) {\n          return animations[i];\n        }\n      }\n    };\n\n    _proto2.remove = function remove(child) {\n      if (_isString(child)) {\n        return this.removeLabel(child);\n      }\n\n      if (_isFunction(child)) {\n        return this.killTweensOf(child);\n      }\n\n      _removeLinkedListItem(this, child);\n\n      if (child === this._recent) {\n        this._recent = this._last;\n      }\n\n      return _uncache(this);\n    };\n\n    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n      if (!arguments.length) {\n        return this._tTime;\n      }\n\n      this._forcing = 1;\n\n      if (!this._dp && this._ts) {\n        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n      }\n\n      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n\n      this._forcing = 0;\n      return this;\n    };\n\n    _proto2.addLabel = function addLabel(label, position) {\n      this.labels[label] = _parsePosition(this, position);\n      return this;\n    };\n\n    _proto2.removeLabel = function removeLabel(label) {\n      delete this.labels[label];\n      return this;\n    };\n\n    _proto2.addPause = function addPause(position, callback, params) {\n      var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n      t.data = \"isPause\";\n      this._hasPause = 1;\n      return _addToTimeline(this, t, _parsePosition(this, position));\n    };\n\n    _proto2.removePause = function removePause(position) {\n      var child = this._first;\n      position = _parsePosition(this, position);\n\n      while (child) {\n        if (child._start === position && child.data === \"isPause\") {\n          _removeFromParent(child);\n        }\n\n        child = child._next;\n      }\n    };\n\n    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n      var tweens = this.getTweensOf(targets, onlyActive),\n          i = tweens.length;\n\n      while (i--) {\n        _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n      }\n\n      return this;\n    };\n\n    _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n      var a = [],\n          parsedTargets = toArray(targets),\n          child = this._first,\n          isGlobalTime = _isNumber(onlyActive),\n          children;\n\n      while (child) {\n        if (child instanceof Tween) {\n          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n            a.push(child);\n          }\n        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n          a.push.apply(a, children);\n        }\n\n        child = child._next;\n      }\n\n      return a;\n    };\n\n    _proto2.tweenTo = function tweenTo(position, vars) {\n      vars = vars || {};\n\n      var tl = this,\n          endTime = _parsePosition(tl, position),\n          _vars = vars,\n          startAt = _vars.startAt,\n          _onStart = _vars.onStart,\n          onStartParams = _vars.onStartParams,\n          immediateRender = _vars.immediateRender,\n          initted,\n          tween = Tween.to(tl, _setDefaults({\n        ease: vars.ease || \"none\",\n        lazy: false,\n        immediateRender: false,\n        time: endTime,\n        overwrite: \"auto\",\n        duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n        onStart: function onStart() {\n          tl.pause();\n\n          if (!initted) {\n            var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\n            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n            initted = 1;\n          }\n\n          _onStart && _onStart.apply(tween, onStartParams || []);\n        }\n      }, vars));\n\n      return immediateRender ? tween.render(0) : tween;\n    };\n\n    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n      return this.tweenTo(toPosition, _setDefaults({\n        startAt: {\n          time: _parsePosition(this, fromPosition)\n        }\n      }, vars));\n    };\n\n    _proto2.recent = function recent() {\n      return this._recent;\n    };\n\n    _proto2.nextLabel = function nextLabel(afterTime) {\n      if (afterTime === void 0) {\n        afterTime = this._time;\n      }\n\n      return _getLabelInDirection(this, _parsePosition(this, afterTime));\n    };\n\n    _proto2.previousLabel = function previousLabel(beforeTime) {\n      if (beforeTime === void 0) {\n        beforeTime = this._time;\n      }\n\n      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n    };\n\n    _proto2.currentLabel = function currentLabel(value) {\n      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time  _tinyNum);\n    };\n\n    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n      if (ignoreBeforeTime === void 0) {\n        ignoreBeforeTime = 0;\n      }\n\n      var child = this._first,\n          labels = this.labels,\n          p;\n\n      while (child) {\n        if (child._start >= ignoreBeforeTime) {\n          child._start = amount;\n          child._end = amount;\n        }\n\n        child = child._next;\n      }\n\n      if (adjustLabels) {\n        for (p in labels) {\n          if (labels[p] >= ignoreBeforeTime) {\n            labels[p] = amount;\n          }\n        }\n      }\n\n      return _uncache(this);\n    };\n\n    _proto2.invalidate = function invalidate() {\n      var child = this._first;\n      this._lock = 0;\n\n      while (child) {\n        child.invalidate();\n        child = child._next;\n      }\n\n      return _Animation.prototype.invalidate.call(this);\n    };\n\n    _proto2.clear = function clear(includeLabels) {\n      if (includeLabels === void 0) {\n        includeLabels = true;\n      }\n\n      var child = this._first,\n          next;\n\n      while (child) {\n        next = child._next;\n        this.remove(child);\n        child = next;\n      }\n\n      this._dp && (this._time = this._tTime = this._pTime = 0);\n      includeLabels && (this.labels = {});\n      return _uncache(this);\n    };\n\n    _proto2.totalDuration = function totalDuration(value) {\n      var max = 0,\n          self = this,\n          child = self._last,\n          prevStart = _bigNum,\n          prev,\n          start,\n          parent;\n\n      if (arguments.length) {\n        return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n      }\n\n      if (self._dirty) {\n        parent = self.parent;\n\n        while (child) {\n          prev = child._prev;\n          child._dirty && child.totalDuration();\n          start = child._start;\n\n          if (start > prevStart && self._sort && child._ts && !self._lock) {\n            self._lock = 1;\n            _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n          } else {\n            prevStart = start;\n          }\n\n          if (start < 0 && child._ts) {\n            max -= start;\n\n            if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n              self._start = start / self._ts;\n              self._time -= start;\n              self._tTime -= start;\n            }\n\n            self.shiftChildren(-start, false, -1e999);\n            prevStart = 0;\n          }\n\n          child._end > max && child._ts && (max = child._end);\n          child = prev;\n        }\n\n        _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n\n        self._dirty = 0;\n      }\n\n      return self._tDur;\n    };\n\n    Timeline.updateRoot = function updateRoot(time) {\n      if (_globalTimeline._ts) {\n        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n\n        _lastRenderedFrame = _ticker.frame;\n      }\n\n      if (_ticker.frame >= _nextGCFrame) {\n        _nextGCFrame = _config.autoSleep || 120;\n        var child = _globalTimeline._first;\n        if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {\n          while (child && !child._ts) {\n            child = child._next;\n          }\n\n          child || _ticker.sleep();\n        }\n      }\n    };\n\n    return Timeline;\n  }(Animation);\n\n  _setDefaults(Timeline.prototype, {\n    _lock: 0,\n    _hasPause: 0,\n    _forcing: 0\n  });\n\n  var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),\n        index = 0,\n        matchIndex = 0,\n        result,\n        startNums,\n        color,\n        endNum,\n        chunk,\n        startNum,\n        hasRandom,\n        a;\n    pt.b = start;\n    pt.e = end;\n    start = \"\";\n    end = \"\";\n\n    if (hasRandom = ~end.indexOf(\"random(\")) {\n      end = _replaceRandom(end);\n    }\n\n    if (stringFilter) {\n      a = [start, end];\n      stringFilter(a, target, prop);\n      start = a[0];\n      end = a[1];\n    }\n\n    startNums = start.match(_complexStringNumExp) || [];\n\n    while (result = _complexStringNumExp.exec(end)) {\n      endNum = result[0];\n      chunk = end.substring(index, result.index);\n\n      if (color) {\n        color = (color  1) % 5;\n      } else if (chunk.substr(-5) === \"rgba(\") {\n        color = 1;\n      }\n\n      if (endNum !== startNums[matchIndex]) {\n        startNum = parseFloat(startNums[matchIndex - 1]) || 0;\n        pt._pt = {\n          _next: pt._pt,\n          p: chunk || matchIndex === 1 ? chunk : \",\",\n          s: startNum,\n          c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\n          m: color && color < 4 ? Math.round : 0\n        };\n        index = _complexStringNumExp.lastIndex;\n      }\n    }\n\n    pt.c = index < end.length ? end.substring(index, end.length) : \"\";\n    pt.fp = funcParam;\n\n    if (_relExp.test(end) || hasRandom) {\n      pt.e = 0;\n    }\n\n    this._pt = pt;\n    return pt;\n  },\n      _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {\n    _isFunction(end) && (end = end(index || 0, target, targets));\n    var currentValue = target[prop],\n        parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\"  prop.substr(3)]) ? prop : \"get\"  prop.substr(3)](funcParam) : target[prop](),\n        setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,\n        pt;\n\n    if (_isString(end)) {\n      if (~end.indexOf(\"random(\")) {\n        end = _replaceRandom(end);\n      }\n\n      if (end.charAt(1) === \"=\") {\n        pt = _parseRelative(parsedStart, end)  (getUnit(parsedStart) || 0);\n\n        if (pt || pt === 0) {\n          end = pt;\n        }\n      }\n    }\n\n    if (parsedStart !== end || _forceAllPropTweens) {\n      if (!isNaN(parsedStart * end) && end !== \"\") {\n        pt = new PropTween(this._pt, target, prop, parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\n        funcParam && (pt.fp = funcParam);\n        modifier && pt.modifier(modifier, this, target);\n        return this._pt = pt;\n      }\n\n      !currentValue && !(prop in target) && _missingPlugin(prop, end);\n      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n    }\n  },\n      _processVars = function _processVars(vars, index, target, targets, tween) {\n    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n\n    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n    }\n\n    var copy = {},\n        p;\n\n    for (p in vars) {\n      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n    }\n\n    return copy;\n  },\n      _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n    var plugin, pt, ptLookup, i;\n\n    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n      if (tween !== _quickTween) {\n        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];\n        i = plugin._props.length;\n\n        while (i--) {\n          ptLookup[plugin._props[i]] = pt;\n        }\n      }\n    }\n\n    return plugin;\n  },\n      _overwritingTween,\n      _forceAllPropTweens,\n      _initTween = function _initTween(tween, time) {\n    var vars = tween.vars,\n        ease = vars.ease,\n        startAt = vars.startAt,\n        immediateRender = vars.immediateRender,\n        lazy = vars.lazy,\n        onUpdate = vars.onUpdate,\n        onUpdateParams = vars.onUpdateParams,\n        callbackScope = vars.callbackScope,\n        runBackwards = vars.runBackwards,\n        yoyoEase = vars.yoyoEase,\n        keyframes = vars.keyframes,\n        autoRevert = vars.autoRevert,\n        dur = tween._dur,\n        prevStartAt = tween._startAt,\n        targets = tween._targets,\n        parent = tween.parent,\n        fullTargets = parent && parent.data === \"nested\" ? parent.parent._targets : targets,\n        autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites,\n        tl = tween.timeline,\n        cleanVars,\n        i,\n        p,\n        pt,\n        target,\n        hasPriority,\n        gsData,\n        harness,\n        plugin,\n        ptLookup,\n        index,\n        harnessVars,\n        overwritten;\n    tl && (!keyframes || !ease) && (ease = \"none\");\n    tween._ease = _parseEase(ease, _defaults.ease);\n    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n\n    if (yoyoEase && tween._yoyo && !tween._repeat) {\n      yoyoEase = tween._yEase;\n      tween._yEase = tween._ease;\n      tween._ease = yoyoEase;\n    }\n\n    tween._from = !tl && !!vars.runBackwards;\n\n    if (!tl || keyframes && !vars.stagger) {\n      harness = targets[0] ? _getCache(targets[0]).harness : 0;\n      harnessVars = harness && vars[harness.prop];\n      cleanVars = _copyExcluding(vars, _reservedProps);\n\n      if (prevStartAt) {\n        _removeFromParent(prevStartAt.render(-1, true));\n\n        prevStartAt._lazy = 0;\n      }\n\n      if (startAt) {\n        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n          data: \"isStart\",\n          overwrite: false,\n          parent: parent,\n          immediateRender: true,\n          lazy: _isNotFalse(lazy),\n          startAt: null,\n          delay: 0,\n          onUpdate: onUpdate,\n          onUpdateParams: onUpdateParams,\n          callbackScope: callbackScope,\n          stagger: 0\n        }, startAt)));\n\n        time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true);\n\n        if (immediateRender) {\n          time > 0 && !autoRevert && (tween._startAt = 0);\n\n          if (dur && time <= 0) {\n            time && (tween._zTime = time);\n            return;\n          }\n        } else if (autoRevert === false) {\n          tween._startAt = 0;\n        }\n      } else if (runBackwards && dur) {\n        if (prevStartAt) {\n          !autoRevert && (tween._startAt = 0);\n        } else {\n          time && (immediateRender = false);\n          p = _setDefaults({\n            overwrite: false,\n            data: \"isFromStart\",\n            lazy: immediateRender && _isNotFalse(lazy),\n            immediateRender: immediateRender,\n            stagger: 0,\n            parent: parent\n          }, cleanVars);\n          harnessVars && (p[harness.prop] = harnessVars);\n\n          _removeFromParent(tween._startAt = Tween.set(targets, p));\n\n          time < 0 && tween._startAt.render(-1, true);\n          tween._zTime = time;\n\n          if (!immediateRender) {\n            _initTween(tween._startAt, _tinyNum);\n          } else if (!time) {\n            return;\n          }\n        }\n      }\n\n      tween._pt = tween._ptCache = 0;\n      lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n\n      for (i = 0; i < targets.length; i) {\n        target = targets[i];\n        gsData = target._gsap || _harness(targets)[i]._gsap;\n        tween._ptLookup[i] = ptLookup = {};\n        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();\n        index = fullTargets === targets ? i : fullTargets.indexOf(target);\n\n        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n          plugin._props.forEach(function (name) {\n            ptLookup[name] = pt;\n          });\n\n          plugin.priority && (hasPriority = 1);\n        }\n\n        if (!harness || harnessVars) {\n          for (p in cleanVars) {\n            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n              plugin.priority && (hasPriority = 1);\n            } else {\n              ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n            }\n          }\n        }\n\n        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n\n        if (autoOverwrite && tween._pt) {\n          _overwritingTween = tween;\n\n          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));\n\n          overwritten = !tween.parent;\n          _overwritingTween = 0;\n        }\n\n        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n      }\n\n      hasPriority && _sortPropTweensByPriority(tween);\n      tween._onInit && tween._onInit(tween);\n    }\n\n    tween._onUpdate = onUpdate;\n    tween._initted = (!tween._op || tween._pt) && !overwritten;\n    keyframes && time <= 0 && tl.render(_bigNum, true, true);\n  },\n      _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {\n    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],\n        pt,\n        lookup,\n        i;\n\n    if (!ptCache) {\n      ptCache = tween._ptCache[property] = [];\n      lookup = tween._ptLookup;\n      i = tween._targets.length;\n\n      while (i--) {\n        pt = lookup[i][property];\n\n        if (pt && pt.d && pt.d._pt) {\n          pt = pt.d._pt;\n\n          while (pt && pt.p !== property) {\n            pt = pt._next;\n          }\n        }\n\n        if (!pt) {\n          _forceAllPropTweens = 1;\n          tween.vars[property] = \"=0\";\n\n          _initTween(tween, time);\n\n          _forceAllPropTweens = 0;\n          return 1;\n        }\n\n        ptCache.push(pt);\n      }\n    }\n\n    i = ptCache.length;\n\n    while (i--) {\n      pt = ptCache[i];\n      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s  (start || 0)  ratio * pt.c;\n      pt.c = value - pt.s;\n      pt.e && (pt.e = _round(value)  getUnit(pt.e));\n      pt.b && (pt.b = pt.s  getUnit(pt.b));\n    }\n  },\n      _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n    var harness = targets[0] ? _getCache(targets[0]).harness : 0,\n        propertyAliases = harness && harness.aliases,\n        copy,\n        p,\n        i,\n        aliases;\n\n    if (!propertyAliases) {\n      return vars;\n    }\n\n    copy = _merge({}, vars);\n\n    for (p in propertyAliases) {\n      if (p in copy) {\n        aliases = propertyAliases[p].split(\",\");\n        i = aliases.length;\n\n        while (i--) {\n          copy[aliases[i]] = copy[p];\n        }\n      }\n    }\n\n    return copy;\n  },\n      _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {\n    var ease = obj.ease || easeEach || \"power1.inOut\",\n        p,\n        a;\n\n    if (_isArray(obj)) {\n      a = allProps[prop] || (allProps[prop] = []);\n      obj.forEach(function (value, i) {\n        return a.push({\n          t: i / (obj.length - 1) * 100,\n          v: value,\n          e: ease\n        });\n      });\n    } else {\n      for (p in obj) {\n        a = allProps[p] || (allProps[p] = []);\n        p === \"ease\" || a.push({\n          t: parseFloat(prop),\n          v: obj[p],\n          e: ease\n        });\n      }\n    }\n  },\n      _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\n  },\n      _staggerTweenProps = _callbackNames  \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\",\n      _staggerPropsToSkip = {};\n\n  _forEachName(_staggerTweenProps  \",id,stagger,delay,duration,paused,scrollTrigger\", function (name) {\n    return _staggerPropsToSkip[name] = 1;\n  });\n\n  var Tween = function (_Animation2) {\n    _inheritsLoose(Tween, _Animation2);\n\n    function Tween(targets, vars, position, skipInherit) {\n      var _this3;\n\n      if (typeof vars === \"number\") {\n        position.duration = vars;\n        vars = position;\n        position = null;\n      }\n\n      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\n      var _this3$vars = _this3.vars,\n          duration = _this3$vars.duration,\n          delay = _this3$vars.delay,\n          immediateRender = _this3$vars.immediateRender,\n          stagger = _this3$vars.stagger,\n          overwrite = _this3$vars.overwrite,\n          keyframes = _this3$vars.keyframes,\n          defaults = _this3$vars.defaults,\n          scrollTrigger = _this3$vars.scrollTrigger,\n          yoyoEase = _this3$vars.yoyoEase,\n          parent = vars.parent || _globalTimeline,\n          parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [targets] : toArray(targets),\n          tl,\n          i,\n          copy,\n          l,\n          p,\n          curTarget,\n          staggerFunc,\n          staggerVarsToMerge;\n      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \"  targets  \" not found. https://greensock.com\", !_config.nullTargetWarn) || [];\n      _this3._ptLookup = [];\n      _this3._overwrite = overwrite;\n\n      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n        vars = _this3.vars;\n        tl = _this3.timeline = new Timeline({\n          data: \"nested\",\n          defaults: defaults || {}\n        });\n        tl.kill();\n        tl.parent = tl._dp = _assertThisInitialized(_this3);\n        tl._start = 0;\n\n        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n          l = parsedTargets.length;\n          staggerFunc = stagger && distribute(stagger);\n\n          if (_isObject(stagger)) {\n            for (p in stagger) {\n              if (~_staggerTweenProps.indexOf(p)) {\n                staggerVarsToMerge || (staggerVarsToMerge = {});\n                staggerVarsToMerge[p] = stagger[p];\n              }\n            }\n          }\n\n          for (i = 0; i < l; i) {\n            copy = _copyExcluding(vars, _staggerPropsToSkip);\n            copy.stagger = 0;\n            yoyoEase && (copy.yoyoEase = yoyoEase);\n            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n            curTarget = parsedTargets[i];\n            copy.duration = _parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n            copy.delay = (_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n\n            if (!stagger && l === 1 && copy.delay) {\n              _this3._delay = delay = copy.delay;\n              _this3._start = delay;\n              copy.delay = 0;\n            }\n\n            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\n            tl._ease = _easeMap.none;\n          }\n\n          tl.duration() ? duration = delay = 0 : _this3.timeline = 0;\n        } else if (keyframes) {\n          _inheritDefaults(_setDefaults(tl.vars.defaults, {\n            ease: \"none\"\n          }));\n\n          tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\n          var time = 0,\n              a,\n              kf,\n              v;\n\n          if (_isArray(keyframes)) {\n            keyframes.forEach(function (frame) {\n              return tl.to(parsedTargets, frame, \">\");\n            });\n          } else {\n            copy = {};\n\n            for (p in keyframes) {\n              p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\n            }\n\n            for (p in copy) {\n              a = copy[p].sort(function (a, b) {\n                return a.t - b.t;\n              });\n              time = 0;\n\n              for (i = 0; i < a.length; i) {\n                kf = a[i];\n                v = {\n                  ease: kf.e,\n                  duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\n                };\n                v[p] = kf.v;\n                tl.to(parsedTargets, v, time);\n                time = v.duration;\n              }\n            }\n\n            tl.duration() < duration && tl.to({}, {\n              duration: duration - tl.duration()\n            });\n          }\n        }\n\n        duration || _this3.duration(duration = tl.duration());\n      } else {\n        _this3.timeline = 0;\n      }\n\n      if (overwrite === true && !_suppressOverwrites) {\n        _overwritingTween = _assertThisInitialized(_this3);\n\n        _globalTimeline.killTweensOf(parsedTargets);\n\n        _overwritingTween = 0;\n      }\n\n      _addToTimeline(parent, _assertThisInitialized(_this3), position);\n\n      vars.reversed && _this3.reverse();\n      vars.paused && _this3.paused(true);\n\n      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\n        _this3._tTime = -_tinyNum;\n\n        _this3.render(Math.max(0, -delay));\n      }\n\n      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n      return _this3;\n    }\n\n    var _proto3 = Tween.prototype;\n\n    _proto3.render = function render(totalTime, suppressEvents, force) {\n      var prevTime = this._time,\n          tDur = this._tDur,\n          dur = this._dur,\n          tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n          time,\n          pt,\n          iteration,\n          cycleDuration,\n          prevIteration,\n          isYoyo,\n          ratio,\n          timeline,\n          yoyoEase;\n\n      if (!dur) {\n        _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {\n        time = tTime;\n        timeline = this.timeline;\n\n        if (this._repeat) {\n          cycleDuration = dur  this._rDelay;\n\n          if (this._repeat < -1 && totalTime < 0) {\n            return this.totalTime(cycleDuration * 100  totalTime, suppressEvents, force);\n          }\n\n          time = _roundPrecise(tTime % cycleDuration);\n\n          if (tTime === tDur) {\n            iteration = this._repeat;\n            time = dur;\n          } else {\n            iteration = ~~(tTime / cycleDuration);\n\n            if (iteration && iteration === tTime / cycleDuration) {\n              time = dur;\n              iteration--;\n            }\n\n            time > dur && (time = dur);\n          }\n\n          isYoyo = this._yoyo && iteration & 1;\n\n          if (isYoyo) {\n            yoyoEase = this._yEase;\n            time = dur - time;\n          }\n\n          prevIteration = _animationCycle(this._tTime, cycleDuration);\n\n          if (time === prevTime && !force && this._initted) {\n            this._tTime = tTime;\n            return this;\n          }\n\n          if (iteration !== prevIteration) {\n            timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);\n\n            if (this.vars.repeatRefresh && !isYoyo && !this._lock) {\n              this._lock = force = 1;\n              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\n            }\n          }\n        }\n\n        if (!this._initted) {\n          if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {\n            this._tTime = 0;\n            return this;\n          }\n\n          if (prevTime !== this._time) {\n            return this;\n          }\n\n          if (dur !== this._dur) {\n            return this.render(totalTime, suppressEvents, force);\n          }\n        }\n\n        this._tTime = tTime;\n        this._time = time;\n\n        if (!this._act && this._ts) {\n          this._act = 1;\n          this._lazy = 0;\n        }\n\n        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n\n        if (this._from) {\n          this.ratio = ratio = 1 - ratio;\n        }\n\n        if (time && !prevTime && !suppressEvents) {\n          _callback(this, \"onStart\");\n\n          if (this._tTime !== tTime) {\n            return this;\n          }\n        }\n\n        pt = this._pt;\n\n        while (pt) {\n          pt.r(ratio, pt.d);\n          pt = pt._next;\n        }\n\n        timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n\n        if (this._onUpdate && !suppressEvents) {\n          totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force);\n\n          _callback(this, \"onUpdate\");\n        }\n\n        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n\n        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n          totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);\n          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);\n\n          if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {\n            _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\n\n            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n          }\n        }\n      }\n\n      return this;\n    };\n\n    _proto3.targets = function targets() {\n      return this._targets;\n    };\n\n    _proto3.invalidate = function invalidate() {\n      this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;\n      this._ptLookup = [];\n      this.timeline && this.timeline.invalidate();\n      return _Animation2.prototype.invalidate.call(this);\n    };\n\n    _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {\n      _tickerActive || _ticker.wake();\n      this._ts || this.play();\n      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),\n          ratio;\n      this._initted || _initTween(this, time);\n      ratio = this._ease(time / this._dur);\n\n      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {\n        return this.resetTo(property, value, start, startIsRelative);\n      }\n\n      _alignPlayhead(this, 0);\n\n      this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\n      return this.render(0);\n    };\n\n    _proto3.kill = function kill(targets, vars) {\n      if (vars === void 0) {\n        vars = \"all\";\n      }\n\n      if (!targets && (!vars || vars === \"all\")) {\n        this._lazy = this._pt = 0;\n        return this.parent ? _interrupt(this) : this;\n      }\n\n      if (this.timeline) {\n        var tDur = this.timeline.totalDuration();\n        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);\n        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);\n        return this;\n      }\n\n      var parsedTargets = this._targets,\n          killingTargets = targets ? toArray(targets) : parsedTargets,\n          propTweenLookup = this._ptLookup,\n          firstPT = this._pt,\n          overwrittenProps,\n          curLookup,\n          curOverwriteProps,\n          props,\n          p,\n          pt,\n          i;\n\n      if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\n        vars === \"all\" && (this._pt = 0);\n        return _interrupt(this);\n      }\n\n      overwrittenProps = this._op = this._op || [];\n\n      if (vars !== \"all\") {\n        if (_isString(vars)) {\n          p = {};\n\n          _forEachName(vars, function (name) {\n            return p[name] = 1;\n          });\n\n          vars = p;\n        }\n\n        vars = _addAliasesToVars(parsedTargets, vars);\n      }\n\n      i = parsedTargets.length;\n\n      while (i--) {\n        if (~killingTargets.indexOf(parsedTargets[i])) {\n          curLookup = propTweenLookup[i];\n\n          if (vars === \"all\") {\n            overwrittenProps[i] = vars;\n            props = curLookup;\n            curOverwriteProps = {};\n          } else {\n            curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n            props = vars;\n          }\n\n          for (p in props) {\n            pt = curLookup && curLookup[p];\n\n            if (pt) {\n              if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\n                _removeLinkedListItem(this, pt, \"_pt\");\n              }\n\n              delete curLookup[p];\n            }\n\n            if (curOverwriteProps !== \"all\") {\n              curOverwriteProps[p] = 1;\n            }\n          }\n        }\n      }\n\n      this._initted && !this._pt && firstPT && _interrupt(this);\n      return this;\n    };\n\n    Tween.to = function to(targets, vars) {\n      return new Tween(targets, vars, arguments[2]);\n    };\n\n    Tween.from = function from(targets, vars) {\n      return _createTweenType(1, arguments);\n    };\n\n    Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n      return new Tween(callback, 0, {\n        immediateRender: false,\n        lazy: false,\n        overwrite: false,\n        delay: delay,\n        onComplete: callback,\n        onReverseComplete: callback,\n        onCompleteParams: params,\n        onReverseCompleteParams: params,\n        callbackScope: scope\n      });\n    };\n\n    Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n      return _createTweenType(2, arguments);\n    };\n\n    Tween.set = function set(targets, vars) {\n      vars.duration = 0;\n      vars.repeatDelay || (vars.repeat = 0);\n      return new Tween(targets, vars);\n    };\n\n    Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n      return _globalTimeline.killTweensOf(targets, props, onlyActive);\n    };\n\n    return Tween;\n  }(Animation);\n\n  _setDefaults(Tween.prototype, {\n    _targets: [],\n    _lazy: 0,\n    _startAt: 0,\n    _op: 0,\n    _onInit: 0\n  });\n\n  _forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function (name) {\n    Tween[name] = function () {\n      var tl = new Timeline(),\n          params = _slice.call(arguments, 0);\n\n      params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\n      return tl[name].apply(tl, params);\n    };\n  });\n\n  var _setterPlain = function _setterPlain(target, property, value) {\n    return target[property] = value;\n  },\n      _setterFunc = function _setterFunc(target, property, value) {\n    return target[property](value);\n  },\n      _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n    return target[property](data.fp, value);\n  },\n      _setterAttribute = function _setterAttribute(target, property, value) {\n    return target.setAttribute(property, value);\n  },\n      _getSetter = function _getSetter(target, property) {\n    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n  },\n      _renderPlain = function _renderPlain(ratio, data) {\n    return data.set(data.t, data.p, Math.round((data.s  data.c * ratio) * 1000000) / 1000000, data);\n  },\n      _renderBoolean = function _renderBoolean(ratio, data) {\n    return data.set(data.t, data.p, !!(data.s  data.c * ratio), data);\n  },\n      _renderComplexString = function _renderComplexString(ratio, data) {\n    var pt = data._pt,\n        s = \"\";\n\n    if (!ratio && data.b) {\n      s = data.b;\n    } else if (ratio === 1 && data.e) {\n      s = data.e;\n    } else {\n      while (pt) {\n        s = pt.p  (pt.m ? pt.m(pt.s  pt.c * ratio) : Math.round((pt.s  pt.c * ratio) * 10000) / 10000)  s;\n        pt = pt._next;\n      }\n\n      s = data.c;\n    }\n\n    data.set(data.t, data.p, s, data);\n  },\n      _renderPropTweens = function _renderPropTweens(ratio, data) {\n    var pt = data._pt;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n  },\n      _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n    var pt = this._pt,\n        next;\n\n    while (pt) {\n      next = pt._next;\n      pt.p === property && pt.modifier(modifier, tween, target);\n      pt = next;\n    }\n  },\n      _killPropTweensOf = function _killPropTweensOf(property) {\n    var pt = this._pt,\n        hasNonDependentRemaining,\n        next;\n\n    while (pt) {\n      next = pt._next;\n\n      if (pt.p === property && !pt.op || pt.op === property) {\n        _removeLinkedListItem(this, pt, \"_pt\");\n      } else if (!pt.dep) {\n        hasNonDependentRemaining = 1;\n      }\n\n      pt = next;\n    }\n\n    return !hasNonDependentRemaining;\n  },\n      _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n  },\n      _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n    var pt = parent._pt,\n        next,\n        pt2,\n        first,\n        last;\n\n    while (pt) {\n      next = pt._next;\n      pt2 = first;\n\n      while (pt2 && pt2.pr > pt.pr) {\n        pt2 = pt2._next;\n      }\n\n      if (pt._prev = pt2 ? pt2._prev : last) {\n        pt._prev._next = pt;\n      } else {\n        first = pt;\n      }\n\n      if (pt._next = pt2) {\n        pt2._prev = pt;\n      } else {\n        last = pt;\n      }\n\n      pt = next;\n    }\n\n    parent._pt = first;\n  };\n\n  var PropTween = function () {\n    function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n      this.t = target;\n      this.s = start;\n      this.c = change;\n      this.p = prop;\n      this.r = renderer || _renderPlain;\n      this.d = data || this;\n      this.set = setter || _setterPlain;\n      this.pr = priority || 0;\n      this._next = next;\n\n      if (next) {\n        next._prev = this;\n      }\n    }\n\n    var _proto4 = PropTween.prototype;\n\n    _proto4.modifier = function modifier(func, tween, target) {\n      this.mSet = this.mSet || this.set;\n      this.set = _setterWithModifier;\n      this.m = func;\n      this.mt = target;\n      this.tween = tween;\n    };\n\n    return PropTween;\n  }();\n\n  _forEachName(_callbackNames  \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function (name) {\n    return _reservedProps[name] = 1;\n  });\n\n  _globals.TweenMax = _globals.TweenLite = Tween;\n  _globals.TimelineLite = _globals.TimelineMax = Timeline;\n  _globalTimeline = new Timeline({\n    sortChildren: false,\n    defaults: _defaults,\n    autoRemoveChildren: true,\n    id: \"root\",\n    smoothChildTiming: true\n  });\n  _config.stringFilter = _colorStringFilter;\n  var _gsap = {\n    registerPlugin: function registerPlugin() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2) {\n        args[_key2] = arguments[_key2];\n      }\n\n      args.forEach(function (config) {\n        return _createPlugin(config);\n      });\n    },\n    timeline: function timeline(vars) {\n      return new Timeline(vars);\n    },\n    getTweensOf: function getTweensOf(targets, onlyActive) {\n      return _globalTimeline.getTweensOf(targets, onlyActive);\n    },\n    getProperty: function getProperty(target, property, unit, uncache) {\n      _isString(target) && (target = toArray(target)[0]);\n\n      var getter = _getCache(target || {}).get,\n          format = unit ? _passThrough : _numericIfPossible;\n\n      unit === \"native\" && (unit = \"\");\n      return !target ? target : !property ? function (property, unit, uncache) {\n        return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n    },\n    quickSetter: function quickSetter(target, property, unit) {\n      target = toArray(target);\n\n      if (target.length > 1) {\n        var setters = target.map(function (t) {\n          return gsap.quickSetter(t, property, unit);\n        }),\n            l = setters.length;\n        return function (value) {\n          var i = l;\n\n          while (i--) {\n            setters[i](value);\n          }\n        };\n      }\n\n      target = target[0] || {};\n\n      var Plugin = _plugins[property],\n          cache = _getCache(target),\n          p = cache.harness && (cache.harness.aliases || {})[property] || property,\n          setter = Plugin ? function (value) {\n        var p = new Plugin();\n        _quickTween._pt = 0;\n        p.init(target, unit ? value  unit : value, _quickTween, 0, [target]);\n        p.render(1, p);\n        _quickTween._pt && _renderPropTweens(1, _quickTween);\n      } : cache.set(target, p);\n\n      return Plugin ? setter : function (value) {\n        return setter(target, p, unit ? value  unit : value, cache, 1);\n      };\n    },\n    quickTo: function quickTo(target, property, vars) {\n      var _merge2;\n\n      var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = \"=0.1\", _merge2.paused = true, _merge2), vars || {})),\n          func = function func(value, start, startIsRelative) {\n        return tween.resetTo(property, value, start, startIsRelative);\n      };\n\n      func.tween = tween;\n      return func;\n    },\n    isTweening: function isTweening(targets) {\n      return _globalTimeline.getTweensOf(targets, true).length > 0;\n    },\n    defaults: function defaults(value) {\n      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n      return _mergeDeep(_defaults, value || {});\n    },\n    config: function config(value) {\n      return _mergeDeep(_config, value || {});\n    },\n    registerEffect: function registerEffect(_ref3) {\n      var name = _ref3.name,\n          effect = _ref3.effect,\n          plugins = _ref3.plugins,\n          defaults = _ref3.defaults,\n          extendTimeline = _ref3.extendTimeline;\n      (plugins || \"\").split(\",\").forEach(function (pluginName) {\n        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name  \" effect requires \"  pluginName  \" plugin.\");\n      });\n\n      _effects[name] = function (targets, vars, tl) {\n        return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n      };\n\n      if (extendTimeline) {\n        Timeline.prototype[name] = function (targets, vars, position) {\n          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n        };\n      }\n    },\n    registerEase: function registerEase(name, ease) {\n      _easeMap[name] = _parseEase(ease);\n    },\n    parseEase: function parseEase(ease, defaultEase) {\n      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n    },\n    getById: function getById(id) {\n      return _globalTimeline.getById(id);\n    },\n    exportRoot: function exportRoot(vars, includeDelayedCalls) {\n      if (vars === void 0) {\n        vars = {};\n      }\n\n      var tl = new Timeline(vars),\n          child,\n          next;\n      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n\n      _globalTimeline.remove(tl);\n\n      tl._dp = 0;\n      tl._time = tl._tTime = _globalTimeline._time;\n      child = _globalTimeline._first;\n\n      while (child) {\n        next = child._next;\n\n        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n          _addToTimeline(tl, child, child._start - child._delay);\n        }\n\n        child = next;\n      }\n\n      _addToTimeline(_globalTimeline, tl, 0);\n\n      return tl;\n    },\n    utils: {\n      wrap: wrap,\n      wrapYoyo: wrapYoyo,\n      distribute: distribute,\n      random: random,\n      snap: snap,\n      normalize: normalize,\n      getUnit: getUnit,\n      clamp: clamp,\n      splitColor: splitColor,\n      toArray: toArray,\n      selector: selector,\n      mapRange: mapRange,\n      pipe: pipe,\n      unitize: unitize,\n      interpolate: interpolate,\n      shuffle: shuffle\n    },\n    install: _install,\n    effects: _effects,\n    ticker: _ticker,\n    updateRoot: Timeline.updateRoot,\n    plugins: _plugins,\n    globalTimeline: _globalTimeline,\n    core: {\n      PropTween: PropTween,\n      globals: _addGlobal,\n      Tween: Tween,\n      Timeline: Timeline,\n      Animation: Animation,\n      getCache: _getCache,\n      _removeLinkedListItem: _removeLinkedListItem,\n      suppressOverwrites: function suppressOverwrites(value) {\n        return _suppressOverwrites = value;\n      }\n    }\n  };\n\n  _forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function (name) {\n    return _gsap[name] = Tween[name];\n  });\n\n  _ticker.add(Timeline.updateRoot);\n\n  _quickTween = _gsap.to({}, {\n    duration: 0\n  });\n\n  var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n    var pt = plugin._pt;\n\n    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {\n      pt = pt._next;\n    }\n\n    return pt;\n  },\n      _addModifiers = function _addModifiers(tween, modifiers) {\n    var targets = tween._targets,\n        p,\n        i,\n        pt;\n\n    for (p in modifiers) {\n      i = targets.length;\n\n      while (i--) {\n        pt = tween._ptLookup[i][p];\n\n        if (pt && (pt = pt.d)) {\n          if (pt._pt) {\n            pt = _getPluginPropTween(pt, p);\n          }\n\n          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n        }\n      }\n    }\n  },\n      _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n    return {\n      name: name,\n      rawVars: 1,\n      init: function init(target, vars, tween) {\n        tween._onInit = function (tween) {\n          var temp, p;\n\n          if (_isString(vars)) {\n            temp = {};\n\n            _forEachName(vars, function (name) {\n              return temp[name] = 1;\n            });\n\n            vars = temp;\n          }\n\n          if (modifier) {\n            temp = {};\n\n            for (p in vars) {\n              temp[p] = modifier(vars[p]);\n            }\n\n            vars = temp;\n          }\n\n          _addModifiers(tween, vars);\n        };\n      }\n    };\n  };\n\n  var gsap = _gsap.registerPlugin({\n    name: \"attr\",\n    init: function init(target, vars, tween, index, targets) {\n      var p, pt;\n\n      for (p in vars) {\n        pt = this.add(target, \"setAttribute\", (target.getAttribute(p) || 0)  \"\", vars[p], index, targets, 0, 0, p);\n        pt && (pt.op = p);\n\n        this._props.push(p);\n      }\n    }\n  }, {\n    name: \"endArray\",\n    init: function init(target, value) {\n      var i = value.length;\n\n      while (i--) {\n        this.add(target, i, target[i] || 0, value[i]);\n      }\n    }\n  }, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap;\n  Tween.version = Timeline.version = gsap.version = \"3.10.4\";\n  _coreReady = 1;\n  _windowExists() && _wake();\n  var Power0 = _easeMap.Power0,\n      Power1 = _easeMap.Power1,\n      Power2 = _easeMap.Power2,\n      Power3 = _easeMap.Power3,\n      Power4 = _easeMap.Power4,\n      Linear = _easeMap.Linear,\n      Quad = _easeMap.Quad,\n      Cubic = _easeMap.Cubic,\n      Quart = _easeMap.Quart,\n      Quint = _easeMap.Quint,\n      Strong = _easeMap.Strong,\n      Elastic = _easeMap.Elastic,\n      Back = _easeMap.Back,\n      SteppedEase = _easeMap.SteppedEase,\n      Bounce = _easeMap.Bounce,\n      Sine = _easeMap.Sine,\n      Expo = _easeMap.Expo,\n      Circ = _easeMap.Circ;\n\n  var _win$1,\n      _doc$1,\n      _docElement,\n      _pluginInitted,\n      _tempDiv,\n      _tempDivStyler,\n      _recentSetterPlugin,\n      _windowExists$1 = function _windowExists() {\n    return typeof window !== \"undefined\";\n  },\n      _transformProps = {},\n      _RAD2DEG = 180 / Math.PI,\n      _DEG2RAD = Math.PI / 180,\n      _atan2 = Math.atan2,\n      _bigNum$1 = 1e8,\n      _capsExp = /([A-Z])/g,\n      _horizontalExp = /(left|right|width|margin|padding|x)/i,\n      _complexExp = /[\\s,\\(]\\S/,\n      _propertyAliases = {\n    autoAlpha: \"opacity,visibility\",\n    scale: \"scaleX,scaleY\",\n    alpha: \"opacity\"\n  },\n      _renderCSSProp = function _renderCSSProp(ratio, data) {\n    return data.set(data.t, data.p, Math.round((data.s  data.c * ratio) * 10000) / 10000  data.u, data);\n  },\n      _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s  data.c * ratio) * 10000) / 10000  data.u, data);\n  },\n      _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n    return data.set(data.t, data.p, ratio ? Math.round((data.s  data.c * ratio) * 10000) / 10000  data.u : data.b, data);\n  },\n      _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n    var value = data.s  data.c * ratio;\n    data.set(data.t, data.p, ~~(value  (value < 0 ? -.5 : .5))  data.u, data);\n  },\n      _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n    return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n  },\n      _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n  },\n      _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n    return target.style[property] = value;\n  },\n      _setterCSSProp = function _setterCSSProp(target, property, value) {\n    return target.style.setProperty(property, value);\n  },\n      _setterTransform = function _setterTransform(target, property, value) {\n    return target._gsap[property] = value;\n  },\n      _setterScale = function _setterScale(target, property, value) {\n    return target._gsap.scaleX = target._gsap.scaleY = value;\n  },\n      _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n    var cache = target._gsap;\n    cache.scaleX = cache.scaleY = value;\n    cache.renderTransform(ratio, cache);\n  },\n      _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n    var cache = target._gsap;\n    cache[property] = value;\n    cache.renderTransform(ratio, cache);\n  },\n      _transformProp = \"transform\",\n      _transformOriginProp = _transformProp  \"Origin\",\n      _supports3D,\n      _createElement = function _createElement(type, ns) {\n    var e = _doc$1.createElementNS ? _doc$1.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc$1.createElement(type);\n    return e.style ? e : _doc$1.createElement(type);\n  },\n      _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n    var cs = getComputedStyle(target);\n    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || \"\";\n  },\n      _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\"),\n      _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n    var e = element || _tempDiv,\n        s = e.style,\n        i = 5;\n\n    if (property in s && !preferPrefix) {\n      return property;\n    }\n\n    property = property.charAt(0).toUpperCase()  property.substr(1);\n\n    while (i-- && !(_prefixes[i]  property in s)) {}\n\n    return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\")  property;\n  },\n      _initCore = function _initCore() {\n    if (_windowExists$1() && window.document) {\n      _win$1 = window;\n      _doc$1 = _win$1.document;\n      _docElement = _doc$1.documentElement;\n      _tempDiv = _createElement(\"div\") || {\n        style: {}\n      };\n      _tempDivStyler = _createElement(\"div\");\n      _transformProp = _checkPropPrefix(_transformProp);\n      _transformOriginProp = _transformProp  \"Origin\";\n      _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\";\n      _supports3D = !!_checkPropPrefix(\"perspective\");\n      _pluginInitted = 1;\n    }\n  },\n      _getBBoxHack = function _getBBoxHack(swapIfPossible) {\n    var svg = _createElement(\"svg\", this.ownerSVGElement && this.ownerSVGElement.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"),\n        oldParent = this.parentNode,\n        oldSibling = this.nextSibling,\n        oldCSS = this.style.cssText,\n        bbox;\n\n    _docElement.appendChild(svg);\n\n    svg.appendChild(this);\n    this.style.display = \"block\";\n\n    if (swapIfPossible) {\n      try {\n        bbox = this.getBBox();\n        this._gsapBBox = this.getBBox;\n        this.getBBox = _getBBoxHack;\n      } catch (e) {}\n    } else if (this._gsapBBox) {\n      bbox = this._gsapBBox();\n    }\n\n    if (oldParent) {\n      if (oldSibling) {\n        oldParent.insertBefore(this, oldSibling);\n      } else {\n        oldParent.appendChild(this);\n      }\n    }\n\n    _docElement.removeChild(svg);\n\n    this.style.cssText = oldCSS;\n    return bbox;\n  },\n      _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n    var i = attributesArray.length;\n\n    while (i--) {\n      if (target.hasAttribute(attributesArray[i])) {\n        return target.getAttribute(attributesArray[i]);\n      }\n    }\n  },\n      _getBBox = function _getBBox(target) {\n    var bounds;\n\n    try {\n      bounds = target.getBBox();\n    } catch (error) {\n      bounds = _getBBoxHack.call(target, true);\n    }\n\n    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));\n    return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n      x: _getAttributeFallbacks(target, [\"x\", \"cx\", \"x1\"]) || 0,\n      y: _getAttributeFallbacks(target, [\"y\", \"cy\", \"y1\"]) || 0,\n      width: 0,\n      height: 0\n    } : bounds;\n  },\n      _isSVG = function _isSVG(e) {\n    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n  },\n      _removeProperty = function _removeProperty(target, property) {\n    if (property) {\n      var style = target.style;\n\n      if (property in _transformProps && property !== _transformOriginProp) {\n        property = _transformProp;\n      }\n\n      if (style.removeProperty) {\n        if (property.substr(0, 2) === \"ms\" || property.substr(0, 6) === \"webkit\") {\n          property = \"-\"  property;\n        }\n\n        style.removeProperty(property.replace(_capsExp, \"-$1\").toLowerCase());\n      } else {\n        style.removeAttribute(property);\n      }\n    }\n  },\n      _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n    plugin._pt = pt;\n    pt.b = beginning;\n    pt.e = end;\n\n    plugin._props.push(property);\n\n    return pt;\n  },\n      _nonConvertibleUnits = {\n    deg: 1,\n    rad: 1,\n    turn: 1\n  },\n      _convertToUnit = function _convertToUnit(target, property, value, unit) {\n    var curValue = parseFloat(value) || 0,\n        curUnit = (value  \"\").trim().substr((curValue  \"\").length) || \"px\",\n        style = _tempDiv.style,\n        horizontal = _horizontalExp.test(property),\n        isRootSVG = target.tagName.toLowerCase() === \"svg\",\n        measureProperty = (isRootSVG ? \"client\" : \"offset\")  (horizontal ? \"Width\" : \"Height\"),\n        amount = 100,\n        toPixels = unit === \"px\",\n        toPercent = unit === \"%\",\n        px,\n        parent,\n        cache,\n        isSVG;\n\n    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n      return curValue;\n    }\n\n    curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit(target, property, value, \"px\"));\n    isSVG = target.getCTM && _isSVG(target);\n\n    if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\n      px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\n      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);\n    }\n\n    style[horizontal ? \"width\" : \"height\"] = amount  (toPixels ? curUnit : unit);\n    parent = ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\n\n    if (isSVG) {\n      parent = (target.ownerSVGElement || {}).parentNode;\n    }\n\n    if (!parent || parent === _doc$1 || !parent.appendChild) {\n      parent = _doc$1.body;\n    }\n\n    cache = parent._gsap;\n\n    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time) {\n      return _round(curValue / cache.width * amount);\n    } else {\n      (toPercent || curUnit === \"%\") && (style.position = _getComputedProperty(target, \"position\"));\n      parent === target && (style.position = \"static\");\n      parent.appendChild(_tempDiv);\n      px = _tempDiv[measureProperty];\n      parent.removeChild(_tempDiv);\n      style.position = \"absolute\";\n\n      if (horizontal && toPercent) {\n        cache = _getCache(parent);\n        cache.time = _ticker.time;\n        cache.width = parent[measureProperty];\n      }\n    }\n\n    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n  },\n      _get = function _get(target, property, unit, uncache) {\n    var value;\n    _pluginInitted || _initCore();\n\n    if (property in _propertyAliases && property !== \"transform\") {\n      property = _propertyAliases[property];\n\n      if (~property.indexOf(\",\")) {\n        property = property.split(\",\")[0];\n      }\n    }\n\n    if (_transformProps[property] && property !== \"transform\") {\n      value = _parseTransform(target, uncache);\n      value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp))  \" \"  value.zOrigin  \"px\";\n    } else {\n      value = target.style[property];\n\n      if (!value || value === \"auto\" || uncache || ~(value  \"\").indexOf(\"calc(\")) {\n        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === \"opacity\" ? 1 : 0);\n      }\n    }\n\n    return unit && !~(value  \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit)  unit : value;\n  },\n      _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n    if (!start || start === \"none\") {\n      var p = _checkPropPrefix(prop, target, 1),\n          s = p && _getComputedProperty(target, p, 1);\n\n      if (s && s !== start) {\n        prop = p;\n        start = s;\n      } else if (prop === \"borderColor\") {\n        start = _getComputedProperty(target, \"borderTopColor\");\n      }\n    }\n\n    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),\n        index = 0,\n        matchIndex = 0,\n        a,\n        result,\n        startValues,\n        startNum,\n        color,\n        startValue,\n        endValue,\n        endNum,\n        chunk,\n        endUnit,\n        startUnit,\n        endValues;\n    pt.b = start;\n    pt.e = end;\n    start = \"\";\n    end = \"\";\n\n    if (end === \"auto\") {\n      target.style[prop] = end;\n      end = _getComputedProperty(target, prop) || end;\n      target.style[prop] = start;\n    }\n\n    a = [start, end];\n\n    _colorStringFilter(a);\n\n    start = a[0];\n    end = a[1];\n    startValues = start.match(_numWithUnitExp) || [];\n    endValues = end.match(_numWithUnitExp) || [];\n\n    if (endValues.length) {\n      while (result = _numWithUnitExp.exec(end)) {\n        endValue = result[0];\n        chunk = end.substring(index, result.index);\n\n        if (color) {\n          color = (color  1) % 5;\n        } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\n          color = 1;\n        }\n\n        if (endValue !== (startValue = startValues[matchIndex] || \"\")) {\n          startNum = parseFloat(startValue) || 0;\n          startUnit = startValue.substr((startNum  \"\").length);\n          endValue.charAt(1) === \"=\" && (endValue = _parseRelative(startNum, endValue)  startUnit);\n          endNum = parseFloat(endValue);\n          endUnit = endValue.substr((endNum  \"\").length);\n          index = _numWithUnitExp.lastIndex - endUnit.length;\n\n          if (!endUnit) {\n            endUnit = endUnit || _config.units[prop] || startUnit;\n\n            if (index === end.length) {\n              end = endUnit;\n              pt.e = endUnit;\n            }\n          }\n\n          if (startUnit !== endUnit) {\n            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n          }\n\n          pt._pt = {\n            _next: pt._pt,\n            p: chunk || matchIndex === 1 ? chunk : \",\",\n            s: startNum,\n            c: endNum - startNum,\n            m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\n          };\n        }\n      }\n\n      pt.c = index < end.length ? end.substring(index, end.length) : \"\";\n    } else {\n      pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n    }\n\n    _relExp.test(end) && (pt.e = 0);\n    this._pt = pt;\n    return pt;\n  },\n      _keywordToPercent = {\n    top: \"0%\",\n    bottom: \"100%\",\n    left: \"0%\",\n    right: \"100%\",\n    center: \"50%\"\n  },\n      _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n    var split = value.split(\" \"),\n        x = split[0],\n        y = split[1] || \"50%\";\n\n    if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\n      value = x;\n      x = y;\n      y = value;\n    }\n\n    split[0] = _keywordToPercent[x] || x;\n    split[1] = _keywordToPercent[y] || y;\n    return split.join(\" \");\n  },\n      _renderClearProps = function _renderClearProps(ratio, data) {\n    if (data.tween && data.tween._time === data.tween._dur) {\n      var target = data.t,\n          style = target.style,\n          props = data.u,\n          cache = target._gsap,\n          prop,\n          clearTransforms,\n          i;\n\n      if (props === \"all\" || props === true) {\n        style.cssText = \"\";\n        clearTransforms = 1;\n      } else {\n        props = props.split(\",\");\n        i = props.length;\n\n        while (--i > -1) {\n          prop = props[i];\n\n          if (_transformProps[prop]) {\n            clearTransforms = 1;\n            prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\n          }\n\n          _removeProperty(target, prop);\n        }\n      }\n\n      if (clearTransforms) {\n        _removeProperty(target, _transformProp);\n\n        if (cache) {\n          cache.svg && target.removeAttribute(\"transform\");\n\n          _parseTransform(target, 1);\n\n          cache.uncache = 1;\n        }\n      }\n    }\n  },\n      _specialProps = {\n    clearProps: function clearProps(plugin, target, property, endValue, tween) {\n      if (tween.data !== \"isFromStart\") {\n        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n        pt.u = endValue;\n        pt.pr = -10;\n        pt.tween = tween;\n\n        plugin._props.push(property);\n\n        return 1;\n      }\n    }\n  },\n      _identity2DMatrix = [1, 0, 0, 1, 0, 0],\n      _rotationalProperties = {},\n      _isNullTransform = function _isNullTransform(value) {\n    return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\n  },\n      _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n    var matrixString = _getComputedProperty(target, _transformProp);\n\n    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);\n  },\n      _getMatrix = function _getMatrix(target, force2D) {\n    var cache = target._gsap || _getCache(target),\n        style = target.style,\n        matrix = _getComputedTransformMatrixAsArray(target),\n        parent,\n        nextSibling,\n        temp,\n        addedToDOM;\n\n    if (cache.svg && target.getAttribute(\"transform\")) {\n      temp = target.transform.baseVal.consolidate().matrix;\n      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];\n      return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\n    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n      temp = style.display;\n      style.display = \"block\";\n      parent = target.parentNode;\n\n      if (!parent || !target.offsetParent) {\n        addedToDOM = 1;\n        nextSibling = target.nextSibling;\n\n        _docElement.appendChild(target);\n      }\n\n      matrix = _getComputedTransformMatrixAsArray(target);\n      temp ? style.display = temp : _removeProperty(target, \"display\");\n\n      if (addedToDOM) {\n        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n      }\n    }\n\n    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;\n  },\n      _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n    var cache = target._gsap,\n        matrix = matrixArray || _getMatrix(target, true),\n        xOriginOld = cache.xOrigin || 0,\n        yOriginOld = cache.yOrigin || 0,\n        xOffsetOld = cache.xOffset || 0,\n        yOffsetOld = cache.yOffset || 0,\n        a = matrix[0],\n        b = matrix[1],\n        c = matrix[2],\n        d = matrix[3],\n        tx = matrix[4],\n        ty = matrix[5],\n        originSplit = origin.split(\" \"),\n        xOrigin = parseFloat(originSplit[0]) || 0,\n        yOrigin = parseFloat(originSplit[1]) || 0,\n        bounds,\n        determinant,\n        x,\n        y;\n\n    if (!originIsAbsolute) {\n      bounds = _getBBox(target);\n      xOrigin = bounds.x  (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\n      yOrigin = bounds.y  (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin);\n    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n      x = xOrigin * (d / determinant)  yOrigin * (-c / determinant)  (c * ty - d * tx) / determinant;\n      y = xOrigin * (-b / determinant)  yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n      xOrigin = x;\n      yOrigin = y;\n    }\n\n    if (smooth || smooth !== false && cache.smooth) {\n      tx = xOrigin - xOriginOld;\n      ty = yOrigin - yOriginOld;\n      cache.xOffset = xOffsetOld  (tx * a  ty * c) - tx;\n      cache.yOffset = yOffsetOld  (tx * b  ty * d) - ty;\n    } else {\n      cache.xOffset = cache.yOffset = 0;\n    }\n\n    cache.xOrigin = xOrigin;\n    cache.yOrigin = yOrigin;\n    cache.smooth = !!smooth;\n    cache.origin = origin;\n    cache.originIsAbsolute = !!originIsAbsolute;\n    target.style[_transformOriginProp] = \"0px 0px\";\n\n    if (pluginToAddPropTweensTo) {\n      _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\n\n      _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\n\n      _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\n\n      _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\n    }\n\n    target.setAttribute(\"data-svg-origin\", xOrigin  \" \"  yOrigin);\n  },\n      _parseTransform = function _parseTransform(target, uncache) {\n    var cache = target._gsap || new GSCache(target);\n\n    if (\"x\" in cache && !uncache && !cache.uncache) {\n      return cache;\n    }\n\n    var style = target.style,\n        invertedScaleX = cache.scaleX < 0,\n        px = \"px\",\n        deg = \"deg\",\n        origin = _getComputedProperty(target, _transformOriginProp) || \"0\",\n        x,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        rotation,\n        rotationX,\n        rotationY,\n        skewX,\n        skewY,\n        perspective,\n        xOrigin,\n        yOrigin,\n        matrix,\n        angle,\n        cos,\n        sin,\n        a,\n        b,\n        c,\n        d,\n        a12,\n        a22,\n        t1,\n        t2,\n        t3,\n        a13,\n        a23,\n        a33,\n        a42,\n        a43,\n        a32;\n    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n    scaleX = scaleY = 1;\n    cache.svg = !!(target.getCTM && _isSVG(target));\n    matrix = _getMatrix(target, cache.svg);\n\n    if (cache.svg) {\n      t1 = (!cache.uncache || origin === \"0px 0px\") && !uncache && target.getAttribute(\"data-svg-origin\");\n\n      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n    }\n\n    xOrigin = cache.xOrigin || 0;\n    yOrigin = cache.yOrigin || 0;\n\n    if (matrix !== _identity2DMatrix) {\n      a = matrix[0];\n      b = matrix[1];\n      c = matrix[2];\n      d = matrix[3];\n      x = a12 = matrix[4];\n      y = a22 = matrix[5];\n\n      if (matrix.length === 6) {\n        scaleX = Math.sqrt(a * a  b * b);\n        scaleY = Math.sqrt(d * d  c * c);\n        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;\n        skewX = c || d ? _atan2(c, d) * _RAD2DEG  rotation : 0;\n        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n\n        if (cache.svg) {\n          x -= xOrigin - (xOrigin * a  yOrigin * c);\n          y -= yOrigin - (xOrigin * b  yOrigin * d);\n        }\n      } else {\n        a32 = matrix[6];\n        a42 = matrix[7];\n        a13 = matrix[8];\n        a23 = matrix[9];\n        a33 = matrix[10];\n        a43 = matrix[11];\n        x = matrix[12];\n        y = matrix[13];\n        z = matrix[14];\n        angle = _atan2(a32, a33);\n        rotationX = angle * _RAD2DEG;\n\n        if (angle) {\n          cos = Math.cos(-angle);\n          sin = Math.sin(-angle);\n          t1 = a12 * cos  a13 * sin;\n          t2 = a22 * cos  a23 * sin;\n          t3 = a32 * cos  a33 * sin;\n          a13 = a12 * -sin  a13 * cos;\n          a23 = a22 * -sin  a23 * cos;\n          a33 = a32 * -sin  a33 * cos;\n          a43 = a42 * -sin  a43 * cos;\n          a12 = t1;\n          a22 = t2;\n          a32 = t3;\n        }\n\n        angle = _atan2(-c, a33);\n        rotationY = angle * _RAD2DEG;\n\n        if (angle) {\n          cos = Math.cos(-angle);\n          sin = Math.sin(-angle);\n          t1 = a * cos - a13 * sin;\n          t2 = b * cos - a23 * sin;\n          t3 = c * cos - a33 * sin;\n          a43 = d * sin  a43 * cos;\n          a = t1;\n          b = t2;\n          c = t3;\n        }\n\n        angle = _atan2(b, a);\n        rotation = angle * _RAD2DEG;\n\n        if (angle) {\n          cos = Math.cos(angle);\n          sin = Math.sin(angle);\n          t1 = a * cos  b * sin;\n          t2 = a12 * cos  a22 * sin;\n          b = b * cos - a * sin;\n          a22 = a22 * cos - a12 * sin;\n          a = t1;\n          a12 = t2;\n        }\n\n        if (rotationX && Math.abs(rotationX)  Math.abs(rotation) > 359.9) {\n          rotationX = rotation = 0;\n          rotationY = 180 - rotationY;\n        }\n\n        scaleX = _round(Math.sqrt(a * a  b * b  c * c));\n        scaleY = _round(Math.sqrt(a22 * a22  a32 * a32));\n        angle = _atan2(a12, a22);\n        skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n      }\n\n      if (cache.svg) {\n        t1 = target.getAttribute(\"transform\");\n        cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n        t1 && target.setAttribute(\"transform\", t1);\n      }\n    }\n\n    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n      if (invertedScaleX) {\n        scaleX *= -1;\n        skewX = rotation <= 0 ? 180 : -180;\n        rotation = rotation <= 0 ? 180 : -180;\n      } else {\n        scaleY *= -1;\n        skewX = skewX <= 0 ? 180 : -180;\n      }\n    }\n\n    uncache = uncache || cache.uncache;\n    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0)  px;\n    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0)  px;\n    cache.z = z  px;\n    cache.scaleX = _round(scaleX);\n    cache.scaleY = _round(scaleY);\n    cache.rotation = _round(rotation)  deg;\n    cache.rotationX = _round(rotationX)  deg;\n    cache.rotationY = _round(rotationY)  deg;\n    cache.skewX = skewX  deg;\n    cache.skewY = skewY  deg;\n    cache.transformPerspective = perspective  px;\n\n    if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || 0) {\n      style[_transformOriginProp] = _firstTwoOnly(origin);\n    }\n\n    cache.xOffset = cache.yOffset = 0;\n    cache.force3D = _config.force3D;\n    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n    cache.uncache = 0;\n    return cache;\n  },\n      _firstTwoOnly = function _firstTwoOnly(value) {\n    return (value = value.split(\" \"))[0]  \" \"  value[1];\n  },\n      _addPxTranslate = function _addPxTranslate(target, start, value) {\n    var unit = getUnit(start);\n    return _round(parseFloat(start)  parseFloat(_convertToUnit(target, \"x\", value  \"px\", unit)))  unit;\n  },\n      _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n    cache.z = \"0px\";\n    cache.rotationY = cache.rotationX = \"0deg\";\n    cache.force3D = 0;\n\n    _renderCSSTransforms(ratio, cache);\n  },\n      _zeroDeg = \"0deg\",\n      _zeroPx = \"0px\",\n      _endParenthesis = \") \",\n      _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n    var _ref = cache || this,\n        xPercent = _ref.xPercent,\n        yPercent = _ref.yPercent,\n        x = _ref.x,\n        y = _ref.y,\n        z = _ref.z,\n        rotation = _ref.rotation,\n        rotationY = _ref.rotationY,\n        rotationX = _ref.rotationX,\n        skewX = _ref.skewX,\n        skewY = _ref.skewY,\n        scaleX = _ref.scaleX,\n        scaleY = _ref.scaleY,\n        transformPerspective = _ref.transformPerspective,\n        force3D = _ref.force3D,\n        target = _ref.target,\n        zOrigin = _ref.zOrigin,\n        transforms = \"\",\n        use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true;\n\n    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n      var angle = parseFloat(rotationY) * _DEG2RAD,\n          a13 = Math.sin(angle),\n          a33 = Math.cos(angle),\n          cos;\n\n      angle = parseFloat(rotationX) * _DEG2RAD;\n      cos = Math.cos(angle);\n      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n      z = _addPxTranslate(target, z, a33 * cos * -zOrigin  zOrigin);\n    }\n\n    if (transformPerspective !== _zeroPx) {\n      transforms = \"perspective(\"  transformPerspective  _endParenthesis;\n    }\n\n    if (xPercent || yPercent) {\n      transforms = \"translate(\"  xPercent  \"%, \"  yPercent  \"%) \";\n    }\n\n    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n      transforms = z !== _zeroPx || use3D ? \"translate3d(\"  x  \", \"  y  \", \"  z  \") \" : \"translate(\"  x  \", \"  y  _endParenthesis;\n    }\n\n    if (rotation !== _zeroDeg) {\n      transforms = \"rotate(\"  rotation  _endParenthesis;\n    }\n\n    if (rotationY !== _zeroDeg) {\n      transforms = \"rotateY(\"  rotationY  _endParenthesis;\n    }\n\n    if (rotationX !== _zeroDeg) {\n      transforms = \"rotateX(\"  rotationX  _endParenthesis;\n    }\n\n    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n      transforms = \"skew(\"  skewX  \", \"  skewY  _endParenthesis;\n    }\n\n    if (scaleX !== 1 || scaleY !== 1) {\n      transforms = \"scale(\"  scaleX  \", \"  scaleY  _endParenthesis;\n    }\n\n    target.style[_transformProp] = transforms || \"translate(0, 0)\";\n  },\n      _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n    var _ref2 = cache || this,\n        xPercent = _ref2.xPercent,\n        yPercent = _ref2.yPercent,\n        x = _ref2.x,\n        y = _ref2.y,\n        rotation = _ref2.rotation,\n        skewX = _ref2.skewX,\n        skewY = _ref2.skewY,\n        scaleX = _ref2.scaleX,\n        scaleY = _ref2.scaleY,\n        target = _ref2.target,\n        xOrigin = _ref2.xOrigin,\n        yOrigin = _ref2.yOrigin,\n        xOffset = _ref2.xOffset,\n        yOffset = _ref2.yOffset,\n        forceCSS = _ref2.forceCSS,\n        tx = parseFloat(x),\n        ty = parseFloat(y),\n        a11,\n        a21,\n        a12,\n        a22,\n        temp;\n\n    rotation = parseFloat(rotation);\n    skewX = parseFloat(skewX);\n    skewY = parseFloat(skewY);\n\n    if (skewY) {\n      skewY = parseFloat(skewY);\n      skewX = skewY;\n      rotation = skewY;\n    }\n\n    if (rotation || skewX) {\n      rotation *= _DEG2RAD;\n      skewX *= _DEG2RAD;\n      a11 = Math.cos(rotation) * scaleX;\n      a21 = Math.sin(rotation) * scaleX;\n      a12 = Math.sin(rotation - skewX) * -scaleY;\n      a22 = Math.cos(rotation - skewX) * scaleY;\n\n      if (skewX) {\n        skewY *= _DEG2RAD;\n        temp = Math.tan(skewX - skewY);\n        temp = Math.sqrt(1  temp * temp);\n        a12 *= temp;\n        a22 *= temp;\n\n        if (skewY) {\n          temp = Math.tan(skewY);\n          temp = Math.sqrt(1  temp * temp);\n          a11 *= temp;\n          a21 *= temp;\n        }\n      }\n\n      a11 = _round(a11);\n      a21 = _round(a21);\n      a12 = _round(a12);\n      a22 = _round(a22);\n    } else {\n      a11 = scaleX;\n      a22 = scaleY;\n      a21 = a12 = 0;\n    }\n\n    if (tx && !~(x  \"\").indexOf(\"px\") || ty && !~(y  \"\").indexOf(\"px\")) {\n      tx = _convertToUnit(target, \"x\", x, \"px\");\n      ty = _convertToUnit(target, \"y\", y, \"px\");\n    }\n\n    if (xOrigin || yOrigin || xOffset || yOffset) {\n      tx = _round(tx  xOrigin - (xOrigin * a11  yOrigin * a12)  xOffset);\n      ty = _round(ty  yOrigin - (xOrigin * a21  yOrigin * a22)  yOffset);\n    }\n\n    if (xPercent || yPercent) {\n      temp = target.getBBox();\n      tx = _round(tx  xPercent / 100 * temp.width);\n      ty = _round(ty  yPercent / 100 * temp.height);\n    }\n\n    temp = \"matrix(\"  a11  \",\"  a21  \",\"  a12  \",\"  a22  \",\"  tx  \",\"  ty  \")\";\n    target.setAttribute(\"transform\", temp);\n    forceCSS && (target.style[_transformProp] = temp);\n  },\n      _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {\n    var cap = 360,\n        isString = _isString(endValue),\n        endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1),\n        change = endNum - startNum,\n        finalValue = startNum  change  \"deg\",\n        direction,\n        pt;\n\n    if (isString) {\n      direction = endValue.split(\"_\")[1];\n\n      if (direction === \"short\") {\n        change %= cap;\n\n        if (change !== change % (cap / 2)) {\n          change = change < 0 ? cap : -cap;\n        }\n      }\n\n      if (direction === \"cw\" && change < 0) {\n        change = (change  cap * _bigNum$1) % cap - ~~(change / cap) * cap;\n      } else if (direction === \"ccw\" && change > 0) {\n        change = (change - cap * _bigNum$1) % cap - ~~(change / cap) * cap;\n      }\n    }\n\n    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n    pt.e = finalValue;\n    pt.u = \"deg\";\n\n    plugin._props.push(property);\n\n    return pt;\n  },\n      _assign = function _assign(target, source) {\n    for (var p in source) {\n      target[p] = source[p];\n    }\n\n    return target;\n  },\n      _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n    var startCache = _assign({}, target._gsap),\n        exclude = \"perspective,force3D,transformOrigin,svgOrigin\",\n        style = target.style,\n        endCache,\n        p,\n        startValue,\n        endValue,\n        startNum,\n        endNum,\n        startUnit,\n        endUnit;\n\n    if (startCache.svg) {\n      startValue = target.getAttribute(\"transform\");\n      target.setAttribute(\"transform\", \"\");\n      style[_transformProp] = transforms;\n      endCache = _parseTransform(target, 1);\n\n      _removeProperty(target, _transformProp);\n\n      target.setAttribute(\"transform\", startValue);\n    } else {\n      startValue = getComputedStyle(target)[_transformProp];\n      style[_transformProp] = transforms;\n      endCache = _parseTransform(target, 1);\n      style[_transformProp] = startValue;\n    }\n\n    for (p in _transformProps) {\n      startValue = startCache[p];\n      endValue = endCache[p];\n\n      if (startValue !== endValue && exclude.indexOf(p) < 0) {\n        startUnit = getUnit(startValue);\n        endUnit = getUnit(endValue);\n        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n        endNum = parseFloat(endValue);\n        plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n        plugin._pt.u = endUnit || 0;\n\n        plugin._props.push(p);\n      }\n    }\n\n    _assign(endCache, startCache);\n  };\n\n  _forEachName(\"padding,margin,Width,Radius\", function (name, index) {\n    var t = \"Top\",\n        r = \"Right\",\n        b = \"Bottom\",\n        l = \"Left\",\n        props = (index < 3 ? [t, r, b, l] : [t  l, t  r, b  r, b  l]).map(function (side) {\n      return index < 2 ? name  side : \"border\"  side  name;\n    });\n\n    _specialProps[index > 1 ? \"border\"  name : name] = function (plugin, target, property, endValue, tween) {\n      var a, vars;\n\n      if (arguments.length < 4) {\n        a = props.map(function (prop) {\n          return _get(plugin, prop, property);\n        });\n        vars = a.join(\" \");\n        return vars.split(a[0]).length === 5 ? a[0] : vars;\n      }\n\n      a = (endValue  \"\").split(\" \");\n      vars = {};\n      props.forEach(function (prop, i) {\n        return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n      });\n      plugin.init(target, vars, tween);\n    };\n  });\n\n  var CSSPlugin = {\n    name: \"css\",\n    register: _initCore,\n    targetTest: function targetTest(target) {\n      return target.style && target.nodeType;\n    },\n    init: function init(target, vars, tween, index, targets) {\n      var props = this._props,\n          style = target.style,\n          startAt = tween.vars.startAt,\n          startValue,\n          endValue,\n          endNum,\n          startNum,\n          type,\n          specialProp,\n          p,\n          startUnit,\n          endUnit,\n          relative,\n          isTransformRelated,\n          transformPropTween,\n          cache,\n          smooth,\n          hasPriority;\n      _pluginInitted || _initCore();\n\n      for (p in vars) {\n        if (p === \"autoRound\") {\n          continue;\n        }\n\n        endValue = vars[p];\n\n        if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {\n          continue;\n        }\n\n        type = typeof endValue;\n        specialProp = _specialProps[p];\n\n        if (type === \"function\") {\n          endValue = endValue.call(tween, index, target, targets);\n          type = typeof endValue;\n        }\n\n        if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\n          endValue = _replaceRandom(endValue);\n        }\n\n        if (specialProp) {\n          specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n        } else if (p.substr(0, 2) === \"--\") {\n          startValue = (getComputedStyle(target).getPropertyValue(p)  \"\").trim();\n          endValue = \"\";\n          _colorExp.lastIndex = 0;\n\n          if (!_colorExp.test(startValue)) {\n            startUnit = getUnit(startValue);\n            endUnit = getUnit(endValue);\n          }\n\n          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit)  endUnit) : startUnit && (endValue = startUnit);\n          this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\n          props.push(p);\n        } else if (type !== \"undefined\") {\n          if (startAt && p in startAt) {\n            startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n            _isString(startValue) && ~startValue.indexOf(\"random(\") && (startValue = _replaceRandom(startValue));\n            getUnit(startValue  \"\") || (startValue = _config.units[p] || getUnit(_get(target, p)) || \"\");\n            (startValue  \"\").charAt(1) === \"=\" && (startValue = _get(target, p));\n          } else {\n            startValue = _get(target, p);\n          }\n\n          startNum = parseFloat(startValue);\n          relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\n          relative && (endValue = endValue.substr(2));\n          endNum = parseFloat(endValue);\n\n          if (p in _propertyAliases) {\n            if (p === \"autoAlpha\") {\n              if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\n                startNum = 0;\n              }\n\n              _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\n            }\n\n            if (p !== \"scale\" && p !== \"transform\") {\n              p = _propertyAliases[p];\n              ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\n            }\n          }\n\n          isTransformRelated = p in _transformProps;\n\n          if (isTransformRelated) {\n            if (!transformPropTween) {\n              cache = target._gsap;\n              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);\n              smooth = vars.smoothOrigin !== false && cache.smooth;\n              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);\n              transformPropTween.dep = 1;\n            }\n\n            if (p === \"scale\") {\n              this._pt = new PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative  endNum) : endNum) - cache.scaleY || 0);\n              props.push(\"scaleY\", p);\n              p = \"X\";\n            } else if (p === \"transformOrigin\") {\n              endValue = _convertKeywordsToPercentages(endValue);\n\n              if (cache.svg) {\n                _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n              } else {\n                endUnit = parseFloat(endValue.split(\" \")[2]) || 0;\n                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\n\n                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n              }\n\n              continue;\n            } else if (p === \"svgOrigin\") {\n              _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n\n              continue;\n            } else if (p in _rotationalProperties) {\n              _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative  endValue) : endValue);\n\n              continue;\n            } else if (p === \"smoothOrigin\") {\n              _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\n\n              continue;\n            } else if (p === \"force3D\") {\n              cache[p] = endValue;\n              continue;\n            } else if (p === \"transform\") {\n              _addRawTransformPTs(this, endValue, target);\n\n              continue;\n            }\n          } else if (!(p in style)) {\n            p = _checkPropPrefix(p) || p;\n          }\n\n          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n            startUnit = (startValue  \"\").substr((startNum  \"\").length);\n            endNum || (endNum = 0);\n            endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);\n            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative  endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n            this._pt.u = endUnit || 0;\n\n            if (startUnit !== endUnit && endUnit !== \"%\") {\n              this._pt.b = startValue;\n              this._pt.r = _renderCSSPropWithBeginning;\n            }\n          } else if (!(p in style)) {\n            if (p in target) {\n              this.add(target, p, startValue || target[p], relative ? relative  endValue : endValue, index, targets);\n            } else {\n              _missingPlugin(p, endValue);\n\n              continue;\n            }\n          } else {\n            _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative  endValue : endValue);\n          }\n\n          props.push(p);\n        }\n      }\n\n      hasPriority && _sortPropTweensByPriority(this);\n    },\n    get: _get,\n    aliases: _propertyAliases,\n    getSetter: function getSetter(target, property, plugin) {\n      var p = _propertyAliases[property];\n      p && p.indexOf(\",\") < 0 && (property = p);\n      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : _getSetter(target, property);\n    },\n    core: {\n      _removeProperty: _removeProperty,\n      _getMatrix: _getMatrix\n    }\n  };\n  gsap.utils.checkPrefix = _checkPropPrefix;\n\n  (function (positionAndScale, rotation, others, aliases) {\n    var all = _forEachName(positionAndScale  \",\"  rotation  \",\"  others, function (name) {\n      _transformProps[name] = 1;\n    });\n\n    _forEachName(rotation, function (name) {\n      _config.units[name] = \"deg\";\n      _rotationalProperties[name] = 1;\n    });\n\n    _propertyAliases[all[13]] = positionAndScale  \",\"  rotation;\n\n    _forEachName(aliases, function (name) {\n      var split = name.split(\":\");\n      _propertyAliases[split[1]] = all[split[0]];\n    });\n  })(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\n\n  _forEachName(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function (name) {\n    _config.units[name] = \"px\";\n  });\n\n  gsap.registerPlugin(CSSPlugin);\n\n  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,\n      TweenMaxWithCSS = gsapWithCSS.core.Tween;\n\n  exports.Back = Back;\n  exports.Bounce = Bounce;\n  exports.CSSPlugin = CSSPlugin;\n  exports.Circ = Circ;\n  exports.Cubic = Cubic;\n  exports.Elastic = Elastic;\n  exports.Expo = Expo;\n  exports.Linear = Linear;\n  exports.Power0 = Power0;\n  exports.Power1 = Power1;\n  exports.Power2 = Power2;\n  exports.Power3 = Power3;\n  exports.Power4 = Power4;\n  exports.Quad = Quad;\n  exports.Quart = Quart;\n  exports.Quint = Quint;\n  exports.Sine = Sine;\n  exports.SteppedEase = SteppedEase;\n  exports.Strong = Strong;\n  exports.TimelineLite = Timeline;\n  exports.TimelineMax = Timeline;\n  exports.TweenLite = Tween;\n  exports.TweenMax = TweenMaxWithCSS;\n  exports.default = gsapWithCSS;\n  exports.gsap = gsapWithCSS;\n\n  if (typeof(window) === 'undefined' || window !== exports) {Object.defineProperty(exports, '__esModule', { value: true });} else {delete window.default;}\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9kaXN0L2dzYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDdUU7QUFDekUsQ0FBQyw2QkFBNkI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsV0FBVywyQ0FBMkM7O0FBRXREO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2SUFBNkk7QUFDN0k7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSw2RUFBNkUsYUFBYTtBQUMxRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1IsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNFQUFzRSxJQUFJLEVBQUUsSUFBSTtBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVGQUF1Rjs7QUFFdkY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0YsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHNEQUFzRCwwRUFBMEU7QUFDaEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLEtBQUs7QUFDTDtBQUNBLDRDQUE0QztBQUM1QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjLGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdRQUFnUTtBQUNoUSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZEQUE2RCwrQ0FBK0MsYUFBYSxJQUFJLE1BQU07O0FBRW5JLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvZ3NhcC9kaXN0L2dzYXAuanM/MTdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwud2luZG93ID0gZ2xvYmFsLndpbmRvdyB8fCB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qIVxuICAgKiBHU0FQIDMuMTAuNFxuICAgKiBodHRwczovL2dyZWVuc29jay5jb21cbiAgICpcbiAgICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAgICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gICAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICAqL1xuICB2YXIgX2NvbmZpZyA9IHtcbiAgICBhdXRvU2xlZXA6IDEyMCxcbiAgICBmb3JjZTNEOiBcImF1dG9cIixcbiAgICBudWxsVGFyZ2V0V2FybjogMSxcbiAgICB1bml0czoge1xuICAgICAgbGluZUhlaWdodDogXCJcIlxuICAgIH1cbiAgfSxcbiAgICAgIF9kZWZhdWx0cyA9IHtcbiAgICBkdXJhdGlvbjogLjUsXG4gICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICBkZWxheTogMFxuICB9LFxuICAgICAgX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICAgIF9iaWdOdW0gPSAxZTgsXG4gICAgICBfdGlueU51bSA9IDEgLyBfYmlnTnVtLFxuICAgICAgXzJQSSA9IE1hdGguUEkgKiAyLFxuICAgICAgX0hBTEZfUEkgPSBfMlBJIC8gNCxcbiAgICAgIF9nc0lEID0gMCxcbiAgICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgX2NvcyA9IE1hdGguY29zLFxuICAgICAgX3NpbiA9IE1hdGguc2luLFxuICAgICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbiAgfSxcbiAgICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG4gIH0sXG4gICAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xuICB9LFxuICAgICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgfSxcbiAgICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG4gIH0sXG4gICAgICBfaXNOb3RGYWxzZSA9IGZ1bmN0aW9uIF9pc05vdEZhbHNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBmYWxzZTtcbiAgfSxcbiAgICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICB9LFxuICAgICAgX2lzRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX2lzRnVuY09yU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSB8fCBfaXNTdHJpbmcodmFsdWUpO1xuICB9LFxuICAgICAgX2lzVHlwZWRBcnJheSA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIF9zdHJpY3ROdW1FeHAgPSAvKD86LT9cXC4/XFxkfFxcLikrL2dpLFxuICAgICAgX251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLStdKlxcZCovZyxcbiAgICAgIF9udW1XaXRoVW5pdEV4cCA9IC9bLSs9Ll0qXFxkK1suZS1dKlxcZCpbYS16JV0qL2csXG4gICAgICBfY29tcGxleFN0cmluZ051bUV4cCA9IC9bLSs9Ll0qXFxkK1xcLj9cXGQqKD86ZS18ZVxcKyk/XFxkKi9naSxcbiAgICAgIF9yZWxFeHAgPSAvWystXT0tP1suXFxkXSsvLFxuICAgICAgX2RlbGltaXRlZFZhbHVlRXhwID0gL1teLCdcIlxcW1xcXVxcc10rL2dpLFxuICAgICAgX3VuaXRFeHAgPSAvXlsrXFwtPWVcXHNcXGRdKlxcZCtbLlxcZF0qKFthLXpdKnwlKVxccyokL2ksXG4gICAgICBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICBfd2luLFxuICAgICAgX2NvcmVJbml0dGVkLFxuICAgICAgX2RvYyxcbiAgICAgIF9nbG9iYWxzID0ge30sXG4gICAgICBfaW5zdGFsbFNjb3BlID0ge30sXG4gICAgICBfY29yZVJlYWR5LFxuICAgICAgX2luc3RhbGwgPSBmdW5jdGlvbiBfaW5zdGFsbChzY29wZSkge1xuICAgIHJldHVybiAoX2luc3RhbGxTY29wZSA9IF9tZXJnZShzY29wZSwgX2dsb2JhbHMpKSAmJiBnc2FwO1xuICB9LFxuICAgICAgX21pc3NpbmdQbHVnaW4gPSBmdW5jdGlvbiBfbWlzc2luZ1BsdWdpbihwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgXCJzZXQgdG9cIiwgdmFsdWUsIFwiTWlzc2luZyBwbHVnaW4/IGdzYXAucmVnaXN0ZXJQbHVnaW4oKVwiKTtcbiAgfSxcbiAgICAgIF93YXJuID0gZnVuY3Rpb24gX3dhcm4obWVzc2FnZSwgc3VwcHJlc3MpIHtcbiAgICByZXR1cm4gIXN1cHByZXNzICYmIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgfSxcbiAgICAgIF9hZGRHbG9iYWwgPSBmdW5jdGlvbiBfYWRkR2xvYmFsKG5hbWUsIG9iaikge1xuICAgIHJldHVybiBuYW1lICYmIChfZ2xvYmFsc1tuYW1lXSA9IG9iaikgJiYgX2luc3RhbGxTY29wZSAmJiAoX2luc3RhbGxTY29wZVtuYW1lXSA9IG9iaikgfHwgX2dsb2JhbHM7XG4gIH0sXG4gICAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYygpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgICAgIF9yZXNlcnZlZFByb3BzID0ge30sXG4gICAgICBfbGF6eVR3ZWVucyA9IFtdLFxuICAgICAgX2xhenlMb29rdXAgPSB7fSxcbiAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSxcbiAgICAgIF9wbHVnaW5zID0ge30sXG4gICAgICBfZWZmZWN0cyA9IHt9LFxuICAgICAgX25leHRHQ0ZyYW1lID0gMzAsXG4gICAgICBfaGFybmVzc1BsdWdpbnMgPSBbXSxcbiAgICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcbiAgICAgIF9oYXJuZXNzID0gZnVuY3Rpb24gX2hhcm5lc3ModGFyZ2V0cykge1xuICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdLFxuICAgICAgICBoYXJuZXNzUGx1Z2luLFxuICAgICAgICBpO1xuICAgIF9pc09iamVjdCh0YXJnZXQpIHx8IF9pc0Z1bmN0aW9uKHRhcmdldCkgfHwgKHRhcmdldHMgPSBbdGFyZ2V0c10pO1xuXG4gICAgaWYgKCEoaGFybmVzc1BsdWdpbiA9ICh0YXJnZXQuX2dzYXAgfHwge30pLmhhcm5lc3MpKSB7XG4gICAgICBpID0gX2hhcm5lc3NQbHVnaW5zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSAmJiAhX2hhcm5lc3NQbHVnaW5zW2ldLnRhcmdldFRlc3QodGFyZ2V0KSkge31cblxuICAgICAgaGFybmVzc1BsdWdpbiA9IF9oYXJuZXNzUGx1Z2luc1tpXTtcbiAgICB9XG5cbiAgICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0YXJnZXRzW2ldICYmICh0YXJnZXRzW2ldLl9nc2FwIHx8ICh0YXJnZXRzW2ldLl9nc2FwID0gbmV3IEdTQ2FjaGUodGFyZ2V0c1tpXSwgaGFybmVzc1BsdWdpbikpKSB8fCB0YXJnZXRzLnNwbGljZShpLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0cztcbiAgfSxcbiAgICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0Ll9nc2FwIHx8IF9oYXJuZXNzKHRvQXJyYXkodGFyZ2V0KSlbMF0uX2dzYXA7XG4gIH0sXG4gICAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdikge1xuICAgIHJldHVybiAodiA9IHRhcmdldFtwcm9wZXJ0eV0pICYmIF9pc0Z1bmN0aW9uKHYpID8gdGFyZ2V0W3Byb3BlcnR5XSgpIDogX2lzVW5kZWZpbmVkKHYpICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShwcm9wZXJ0eSkgfHwgdjtcbiAgfSxcbiAgICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xuICAgIHJldHVybiAobmFtZXMgPSBuYW1lcy5zcGxpdChcIixcIikpLmZvckVhY2goZnVuYykgfHwgbmFtZXM7XG4gIH0sXG4gICAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMCkgLyAxMDAwMDAgfHwgMDtcbiAgfSxcbiAgICAgIF9yb3VuZFByZWNpc2UgPSBmdW5jdGlvbiBfcm91bmRQcmVjaXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDAwMCkgLyAxMDAwMDAwMCB8fCAwO1xuICB9LFxuICAgICAgX3BhcnNlUmVsYXRpdmUgPSBmdW5jdGlvbiBfcGFyc2VSZWxhdGl2ZShzdGFydCwgdmFsdWUpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSB2YWx1ZS5jaGFyQXQoMCksXG4gICAgICAgIGVuZCA9IHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKTtcbiAgICBzdGFydCA9IHBhcnNlRmxvYXQoc3RhcnQpO1xuICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCIrXCIgPyBzdGFydCArIGVuZCA6IG9wZXJhdG9yID09PSBcIi1cIiA/IHN0YXJ0IC0gZW5kIDogb3BlcmF0b3IgPT09IFwiKlwiID8gc3RhcnQgKiBlbmQgOiBzdGFydCAvIGVuZDtcbiAgfSxcbiAgICAgIF9hcnJheUNvbnRhaW5zQW55ID0gZnVuY3Rpb24gX2FycmF5Q29udGFpbnNBbnkodG9TZWFyY2gsIHRvRmluZCkge1xuICAgIHZhciBsID0gdG9GaW5kLmxlbmd0aCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICAgIHJldHVybiBpIDwgbDtcbiAgfSxcbiAgICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gICAgdmFyIGwgPSBfbGF6eVR3ZWVucy5sZW5ndGgsXG4gICAgICAgIGEgPSBfbGF6eVR3ZWVucy5zbGljZSgwKSxcbiAgICAgICAgaSxcbiAgICAgICAgdHdlZW47XG5cbiAgICBfbGF6eUxvb2t1cCA9IHt9O1xuICAgIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0d2VlbiA9IGFbaV07XG4gICAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgICB9XG4gIH0sXG4gICAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTtcbiAgICBhbmltYXRpb24ucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7XG4gIH0sXG4gICAgICBfbnVtZXJpY0lmUG9zc2libGUgPSBmdW5jdGlvbiBfbnVtZXJpY0lmUG9zc2libGUodmFsdWUpIHtcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xuICB9LFxuICAgICAgX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24gX3Bhc3NUaHJvdWdoKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgICAgIF9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgICAgcCBpbiBvYmogfHwgKG9ialtwXSA9IGRlZmF1bHRzW3BdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuICAgICAgX3NldEtleWZyYW1lRGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0S2V5ZnJhbWVEZWZhdWx0cyhleGNsdWRlRHVyYXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgcCBpbiBvYmogfHwgcCA9PT0gXCJkdXJhdGlvblwiICYmIGV4Y2x1ZGVEdXJhdGlvbiB8fCBwID09PSBcImVhc2VcIiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gICAgICBfbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UoYmFzZSwgdG9NZXJnZSkge1xuICAgIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgICAgYmFzZVtwXSA9IHRvTWVyZ2VbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH0sXG4gICAgICBfbWVyZ2VEZWVwID0gZnVuY3Rpb24gX21lcmdlRGVlcChiYXNlLCB0b01lcmdlKSB7XG4gICAgZm9yICh2YXIgcCBpbiB0b01lcmdlKSB7XG4gICAgICBwICE9PSBcIl9fcHJvdG9fX1wiICYmIHAgIT09IFwiY29uc3RydWN0b3JcIiAmJiBwICE9PSBcInByb3RvdHlwZVwiICYmIChiYXNlW3BdID0gX2lzT2JqZWN0KHRvTWVyZ2VbcF0pID8gX21lcmdlRGVlcChiYXNlW3BdIHx8IChiYXNlW3BdID0ge30pLCB0b01lcmdlW3BdKSA6IHRvTWVyZ2VbcF0pO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xuICB9LFxuICAgICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICAgIHZhciBjb3B5ID0ge30sXG4gICAgICAgIHA7XG5cbiAgICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgICBwIGluIGV4Y2x1ZGluZyB8fCAoY29weVtwXSA9IG9ialtwXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHk7XG4gIH0sXG4gICAgICBfaW5oZXJpdERlZmF1bHRzID0gZnVuY3Rpb24gX2luaGVyaXREZWZhdWx0cyh2YXJzKSB7XG4gICAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgICAgZnVuYyA9IHZhcnMua2V5ZnJhbWVzID8gX3NldEtleWZyYW1lRGVmYXVsdHMoX2lzQXJyYXkodmFycy5rZXlmcmFtZXMpKSA6IF9zZXREZWZhdWx0cztcblxuICAgIGlmIChfaXNOb3RGYWxzZSh2YXJzLmluaGVyaXQpKSB7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGZ1bmModmFycywgcGFyZW50LnZhcnMuZGVmYXVsdHMpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50IHx8IHBhcmVudC5fZHA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhcnM7XG4gIH0sXG4gICAgICBfYXJyYXlzTWF0Y2ggPSBmdW5jdGlvbiBfYXJyYXlzTWF0Y2goYTEsIGEyKSB7XG4gICAgdmFyIGkgPSBhMS5sZW5ndGgsXG4gICAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG1hdGNoICYmIGktLSAmJiBhMVtpXSA9PT0gYTJbaV0pIHt9XG5cbiAgICByZXR1cm4gaSA8IDA7XG4gIH0sXG4gICAgICBfYWRkTGlua2VkTGlzdEl0ZW0gPSBmdW5jdGlvbiBfYWRkTGlua2VkTGlzdEl0ZW0ocGFyZW50LCBjaGlsZCwgZmlyc3RQcm9wLCBsYXN0UHJvcCwgc29ydEJ5KSB7XG4gICAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICAgIH1cblxuICAgIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IHBhcmVudFtsYXN0UHJvcF0sXG4gICAgICAgIHQ7XG5cbiAgICBpZiAoc29ydEJ5KSB7XG4gICAgICB0ID0gY2hpbGRbc29ydEJ5XTtcblxuICAgICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgICBwcmV2ID0gcHJldi5fcHJldjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldikge1xuICAgICAgY2hpbGQuX25leHQgPSBwcmV2Ll9uZXh0O1xuICAgICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZC5fbmV4dCA9IHBhcmVudFtmaXJzdFByb3BdO1xuICAgICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQuX25leHQpIHtcbiAgICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudFtsYXN0UHJvcF0gPSBjaGlsZDtcbiAgICB9XG5cbiAgICBjaGlsZC5fcHJldiA9IHByZXY7XG4gICAgY2hpbGQucGFyZW50ID0gY2hpbGQuX2RwID0gcGFyZW50O1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSxcbiAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSA9IGZ1bmN0aW9uIF9yZW1vdmVMaW5rZWRMaXN0SXRlbShwYXJlbnQsIGNoaWxkLCBmaXJzdFByb3AsIGxhc3RQcm9wKSB7XG4gICAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICAgIH1cblxuICAgIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICBpZiAocHJldikge1xuICAgICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRbZmlyc3RQcm9wXSA9PT0gY2hpbGQpIHtcbiAgICAgIHBhcmVudFtmaXJzdFByb3BdID0gbmV4dDtcbiAgICB9XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgbmV4dC5fcHJldiA9IHByZXY7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgICAgcGFyZW50W2xhc3RQcm9wXSA9IHByZXY7XG4gICAgfVxuXG4gICAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7XG4gIH0sXG4gICAgICBfcmVtb3ZlRnJvbVBhcmVudCA9IGZ1bmN0aW9uIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkLCBvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlKSB7XG4gICAgY2hpbGQucGFyZW50ICYmICghb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSB8fCBjaGlsZC5wYXJlbnQuYXV0b1JlbW92ZUNoaWxkcmVuKSAmJiBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICBjaGlsZC5fYWN0ID0gMDtcbiAgfSxcbiAgICAgIF91bmNhY2hlID0gZnVuY3Rpb24gX3VuY2FjaGUoYW5pbWF0aW9uLCBjaGlsZCkge1xuICAgIGlmIChhbmltYXRpb24gJiYgKCFjaGlsZCB8fCBjaGlsZC5fZW5kID4gYW5pbWF0aW9uLl9kdXIgfHwgY2hpbGQuX3N0YXJ0IDwgMCkpIHtcbiAgICAgIHZhciBhID0gYW5pbWF0aW9uO1xuXG4gICAgICB3aGlsZSAoYSkge1xuICAgICAgICBhLl9kaXJ0eSA9IDE7XG4gICAgICAgIGEgPSBhLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9LFxuICAgICAgX3JlY2FjaGVBbmNlc3RvcnMgPSBmdW5jdGlvbiBfcmVjYWNoZUFuY2VzdG9ycyhhbmltYXRpb24pIHtcbiAgICB2YXIgcGFyZW50ID0gYW5pbWF0aW9uLnBhcmVudDtcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgcGFyZW50Ll9kaXJ0eSA9IDE7XG4gICAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9LFxuICAgICAgX2hhc05vUGF1c2VkQW5jZXN0b3JzID0gZnVuY3Rpb24gX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbikge1xuICAgIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xuICB9LFxuICAgICAgX2VsYXBzZWRDeWNsZUR1cmF0aW9uID0gZnVuY3Rpb24gX2VsYXBzZWRDeWNsZUR1cmF0aW9uKGFuaW1hdGlvbikge1xuICAgIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XG4gIH0sXG4gICAgICBfYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcbiAgICB2YXIgd2hvbGUgPSBNYXRoLmZsb29yKHRUaW1lIC89IGN5Y2xlRHVyYXRpb24pO1xuICAgIHJldHVybiB0VGltZSAmJiB3aG9sZSA9PT0gdFRpbWUgPyB3aG9sZSAtIDEgOiB3aG9sZTtcbiAgfSxcbiAgICAgIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lID0gZnVuY3Rpb24gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50VGltZSwgY2hpbGQpIHtcbiAgICByZXR1cm4gKHBhcmVudFRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzICsgKGNoaWxkLl90cyAPSAwID8gMCA6IGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKTtcbiAgfSxcbiAgICAgIF9zZXRFbmQgPSBmdW5jdGlvbiBfc2V0RW5kKGFuaW1hdGlvbikge1xuICAgIHJldHVybiBhbmltYXRpb24uX2VuZCA9IF9yb3VuZFByZWNpc2UoYW5pbWF0aW9uLl9zdGFydCArIChhbmltYXRpb24uX3REdXIgLyBNYXRoLmFicyhhbmltYXRpb24uX3RzIHx8IGFuaW1hdGlvbi5fcnRzIHx8IF90aW55TnVtKSB8fCAwKSk7XG4gIH0sXG4gICAgICBfYWxpZ25QbGF5aGVhZCA9IGZ1bmN0aW9uIF9hbGlnblBsYXloZWFkKGFuaW1hdGlvbiwgdG90YWxUaW1lKSB7XG4gICAgdmFyIHBhcmVudCA9IGFuaW1hdGlvbi5fZHA7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiBhbmltYXRpb24uX3RzKSB7XG4gICAgICBhbmltYXRpb24uX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShwYXJlbnQuX3RpbWUgLSAoYW5pbWF0aW9uLl90cyAIDAgPyB0b3RhbFRpbWUgLyBhbmltYXRpb24uX3RzIDogKChhbmltYXRpb24uX2RpcnR5ID8gYW5pbWF0aW9uLnRvdGFsRHVyYXRpb24oKSA6IGFuaW1hdGlvbi5fdER1cikgLSB0b3RhbFRpbWUpIC8gLWFuaW1hdGlvbi5fdHMpKTtcblxuICAgICAgX3NldEVuZChhbmltYXRpb24pO1xuXG4gICAgICBwYXJlbnQuX2RpcnR5IHx8IF91bmNhY2hlKHBhcmVudCwgYW5pbWF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9LFxuICAgICAgX3Bvc3RBZGRDaGVja3MgPSBmdW5jdGlvbiBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpIHtcbiAgICB2YXIgdDtcblxuICAgIGlmIChjaGlsZC5fdGltZSB8fCBjaGlsZC5faW5pdHRlZCAmJiAhY2hpbGQuX2R1cikge1xuICAgICAgdCA9IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWVsaW5lLnJhd1RpbWUoKSwgY2hpbGQpO1xuXG4gICAgICBpZiAoIWNoaWxkLl9kdXIgfHwgX2NsYW1wKDAsIGNoaWxkLnRvdGFsRHVyYXRpb24oKSwgdCkgLSBjaGlsZC5fdFRpbWUgPiBfdGlueU51bSkge1xuICAgICAgICBjaGlsZC5yZW5kZXIodCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF91bmNhY2hlKHRpbWVsaW5lLCBjaGlsZCkuX2RwICYmIHRpbWVsaW5lLl9pbml0dGVkICYmIHRpbWVsaW5lLl90aW1lID49IHRpbWVsaW5lLl9kdXIgJiYgdGltZWxpbmUuX3RzKSB7XG4gICAgICBpZiAodGltZWxpbmUuX2R1ciA8IHRpbWVsaW5lLmR1cmF0aW9uKCkpIHtcbiAgICAgICAgdCA9IHRpbWVsaW5lO1xuXG4gICAgICAgIHdoaWxlICh0Ll9kcCkge1xuICAgICAgICAgIHQucmF3VGltZSgpID49IDAgJiYgdC50b3RhbFRpbWUodC5fdFRpbWUpO1xuICAgICAgICAgIHQgPSB0Ll9kcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aW1lbGluZS5felRpbWUgPSAtX3RpbnlOdW07XG4gICAgfVxuICB9LFxuICAgICAgX2FkZFRvVGltZWxpbmUgPSBmdW5jdGlvbiBfYWRkVG9UaW1lbGluZSh0aW1lbGluZSwgY2hpbGQsIHBvc2l0aW9uLCBza2lwQ2hlY2tzKSB7XG4gICAgY2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgICBjaGlsZC5fc3RhcnQgPSBfcm91bmRQcmVjaXNlKChfaXNOdW1iZXIocG9zaXRpb24pID8gcG9zaXRpb24gOiBwb3NpdGlvbiB8fCB0aW1lbGluZSAhPT0gX2dsb2JhbFRpbWVsaW5lID8gX3BhcnNlUG9zaXRpb24odGltZWxpbmUsIHBvc2l0aW9uLCBjaGlsZCkgOiB0aW1lbGluZS5fdGltZSkgKyBjaGlsZC5fZGVsYXkpO1xuICAgIGNoaWxkLl9lbmQgPSBfcm91bmRQcmVjaXNlKGNoaWxkLl9zdGFydCArIChjaGlsZC50b3RhbER1cmF0aW9uKCkgLyBNYXRoLmFicyhjaGlsZC50aW1lU2NhbGUoKSkgfHwgMCkpO1xuXG4gICAgX2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblxuICAgIF9pc0Zyb21PckZyb21TdGFydChjaGlsZCkgfHwgKHRpbWVsaW5lLl9yZWNlbnQgPSBjaGlsZCk7XG4gICAgc2tpcENoZWNrcyB8fCBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpO1xuICAgIHJldHVybiB0aW1lbGluZTtcbiAgfSxcbiAgICAgIF9zY3JvbGxUcmlnZ2VyID0gZnVuY3Rpb24gX3Njcm9sbFRyaWdnZXIoYW5pbWF0aW9uLCB0cmlnZ2VyKSB7XG4gICAgcmV0dXJuIChfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyIHx8IF9taXNzaW5nUGx1Z2luKFwic2Nyb2xsVHJpZ2dlclwiLCB0cmlnZ2VyKSkgJiYgX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlci5jcmVhdGUodHJpZ2dlciwgYW5pbWF0aW9uKTtcbiAgfSxcbiAgICAgIF9hdHRlbXB0SW5pdFR3ZWVuID0gZnVuY3Rpb24gX2F0dGVtcHRJbml0VHdlZW4odHdlZW4sIHRvdGFsVGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgX2luaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lKTtcblxuICAgIGlmICghdHdlZW4uX2luaXR0ZWQpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghZm9yY2UgJiYgdHdlZW4uX3B0ICYmICh0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSAhPT0gZmFsc2UgfHwgIXR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5KSAmJiBfbGFzdFJlbmRlcmVkRnJhbWUgIT09IF90aWNrZXIuZnJhbWUpIHtcbiAgICAgIF9sYXp5VHdlZW5zLnB1c2godHdlZW4pO1xuXG4gICAgICB0d2Vlbi5fbGF6eSA9IFt0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzXTtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSxcbiAgICAgIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQgPSBmdW5jdGlvbiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KF9yZWYpIHtcbiAgICB2YXIgcGFyZW50ID0gX3JlZi5wYXJlbnQ7XG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQuX3RzICYmIHBhcmVudC5faW5pdHRlZCAmJiAhcGFyZW50Ll9sb2NrICYmIChwYXJlbnQucmF3VGltZSgpIDwgMCB8fCBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHBhcmVudCkpO1xuICB9LFxuICAgICAgX2lzRnJvbU9yRnJvbVN0YXJ0ID0gZnVuY3Rpb24gX2lzRnJvbU9yRnJvbVN0YXJ0KF9yZWYyKSB7XG4gICAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhO1xuICAgIHJldHVybiBkYXRhID09PSBcImlzRnJvbVN0YXJ0XCIgfHwgZGF0YSA9PT0gXCJpc1N0YXJ0XCI7XG4gIH0sXG4gICAgICBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4gPSBmdW5jdGlvbiBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZSYXRpbyA9IHR3ZWVuLnJhdGlvLFxuICAgICAgICByYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgIXRvdGFsVGltZSAmJiAoIXR3ZWVuLl9zdGFydCAmJiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHR3ZWVuKSAmJiAhKCF0d2Vlbi5faW5pdHRlZCAmJiBfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSB8fCAodHdlZW4uX3RzIDwgMCB8fCB0d2Vlbi5fZHAuX3RzIDwgMCkgJiYgIV9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpID8gMCA6IDEsXG4gICAgICAgIHJlcGVhdERlbGF5ID0gdHdlZW4uX3JEZWxheSxcbiAgICAgICAgdFRpbWUgPSAwLFxuICAgICAgICBwdCxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBwcmV2SXRlcmF0aW9uO1xuXG4gICAgaWYgKHJlcGVhdERlbGF5ICYmIHR3ZWVuLl9yZXBlYXQpIHtcbiAgICAgIHRUaW1lID0gX2NsYW1wKDAsIHR3ZWVuLl90RHVyLCB0b3RhbFRpbWUpO1xuICAgICAgaXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRUaW1lLCByZXBlYXREZWxheSk7XG4gICAgICB0d2Vlbi5feW95byAmJiBpdGVyYXRpb24gJiAxICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG5cbiAgICAgIGlmIChpdGVyYXRpb24gIT09IF9hbmltYXRpb25DeWNsZSh0d2Vlbi5fdFRpbWUsIHJlcGVhdERlbGF5KSkge1xuICAgICAgICBwcmV2UmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICAgIHR3ZWVuLnZhcnMucmVwZWF0UmVmcmVzaCAmJiB0d2Vlbi5faW5pdHRlZCAmJiB0d2Vlbi5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJhdGlvICE9PSBwcmV2UmF0aW8gfHwgZm9yY2UgfHwgdHdlZW4uX3pUaW1lID09PSBfdGlueU51bSB8fCAhdG90YWxUaW1lICYmIHR3ZWVuLl96VGltZSkge1xuICAgICAgaWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJldkl0ZXJhdGlvbiA9IHR3ZWVuLl96VGltZTtcbiAgICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZSB8fCAoc3VwcHJlc3NFdmVudHMgPyBfdGlueU51bSA6IDApO1xuICAgICAgc3VwcHJlc3NFdmVudHMgfHwgKHN1cHByZXNzRXZlbnRzID0gdG90YWxUaW1lICYmICFwcmV2SXRlcmF0aW9uKTtcbiAgICAgIHR3ZWVuLnJhdGlvID0gcmF0aW87XG4gICAgICB0d2Vlbi5fZnJvbSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuICAgICAgdHdlZW4uX3RpbWUgPSAwO1xuICAgICAgdHdlZW4uX3RUaW1lID0gdFRpbWU7XG4gICAgICBwdCA9IHR3ZWVuLl9wdDtcblxuICAgICAgd2hpbGUgKHB0KSB7XG4gICAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fc3RhcnRBdCAmJiB0b3RhbFRpbWUgPCAwICYmIHR3ZWVuLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIHRydWUpO1xuICAgICAgdHdlZW4uX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25VcGRhdGVcIik7XG4gICAgICB0VGltZSAmJiB0d2Vlbi5fcmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0d2Vlbi5wYXJlbnQgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgICBpZiAoKHRvdGFsVGltZSAPSB0d2Vlbi5fdER1ciB8fCB0b3RhbFRpbWUgPCAwKSAmJiB0d2Vlbi5yYXRpbyA9PT0gcmF0aW8pIHtcbiAgICAgICAgcmF0aW8gJiYgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4sIDEpO1xuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgICBfY2FsbGJhY2sodHdlZW4sIHJhdGlvID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdHdlZW4uX3Byb20gJiYgdHdlZW4uX3Byb20oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXR3ZWVuLl96VGltZSkge1xuICAgICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lO1xuICAgIH1cbiAgfSxcbiAgICAgIF9maW5kTmV4dFBhdXNlVHdlZW4gPSBmdW5jdGlvbiBfZmluZE5leHRQYXVzZVR3ZWVuKGFuaW1hdGlvbiwgcHJldlRpbWUsIHRpbWUpIHtcbiAgICB2YXIgY2hpbGQ7XG5cbiAgICBpZiAodGltZSAIHByZXZUaW1lKSB7XG4gICAgICBjaGlsZCA9IGFuaW1hdGlvbi5fZmlyc3Q7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5fc3RhcnQgPD0gdGltZSkge1xuICAgICAgICBpZiAoY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0ID4gcHJldlRpbWUpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZCA9IGFuaW1hdGlvbi5fbGFzdDtcblxuICAgICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCAPSB0aW1lKSB7XG4gICAgICAgIGlmIChjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPCBwcmV2VGltZSkge1xuICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQuX3ByZXY7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAgICAgX3NldER1cmF0aW9uID0gZnVuY3Rpb24gX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgZHVyYXRpb24sIHNraXBVbmNhY2hlLCBsZWF2ZVBsYXloZWFkKSB7XG4gICAgdmFyIHJlcGVhdCA9IGFuaW1hdGlvbi5fcmVwZWF0LFxuICAgICAgICBkdXIgPSBfcm91bmRQcmVjaXNlKGR1cmF0aW9uKSB8fCAwLFxuICAgICAgICB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cjtcbiAgICB0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkICYmIChhbmltYXRpb24uX3RpbWUgKj0gZHVyIC8gYW5pbWF0aW9uLl9kdXIpO1xuICAgIGFuaW1hdGlvbi5fZHVyID0gZHVyO1xuICAgIGFuaW1hdGlvbi5fdER1ciA9ICFyZXBlYXQgPyBkdXIgOiByZXBlYXQgPCAwID8gMWUxMCA6IF9yb3VuZFByZWNpc2UoZHVyICogKHJlcGVhdCArIDEpICsgYW5pbWF0aW9uLl9yRGVsYXkgKiByZXBlYXQpO1xuICAgIHRvdGFsUHJvZ3Jlc3MgPiAwICYmICFsZWF2ZVBsYXloZWFkID8gX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCBhbmltYXRpb24uX3RUaW1lID0gYW5pbWF0aW9uLl90RHVyICogdG90YWxQcm9ncmVzcykgOiBhbmltYXRpb24ucGFyZW50ICYmIF9zZXRFbmQoYW5pbWF0aW9uKTtcbiAgICBza2lwVW5jYWNoZSB8fCBfdW5jYWNoZShhbmltYXRpb24ucGFyZW50LCBhbmltYXRpb24pO1xuICAgIHJldHVybiBhbmltYXRpb247XG4gIH0sXG4gICAgICBfb25VcGRhdGVUb3RhbER1cmF0aW9uID0gZnVuY3Rpb24gX29uVXBkYXRlVG90YWxEdXJhdGlvbihhbmltYXRpb24pIHtcbiAgICByZXR1cm4gYW5pbWF0aW9uIGluc3RhbmNlb2YgVGltZWxpbmUgPyBfdW5jYWNoZShhbmltYXRpb24pIDogX3NldER1cmF0aW9uKGFuaW1hdGlvbiwgYW5pbWF0aW9uLl9kdXIpO1xuICB9LFxuICAgICAgX3plcm9Qb3NpdGlvbiA9IHtcbiAgICBfc3RhcnQ6IDAsXG4gICAgZW5kVGltZTogX2VtcHR5RnVuYyxcbiAgICB0b3RhbER1cmF0aW9uOiBfZW1wdHlGdW5jXG4gIH0sXG4gICAgICBfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24sIHBlcmNlbnRBbmltYXRpb24pIHtcbiAgICB2YXIgbGFiZWxzID0gYW5pbWF0aW9uLmxhYmVscyxcbiAgICAgICAgcmVjZW50ID0gYW5pbWF0aW9uLl9yZWNlbnQgfHwgX3plcm9Qb3NpdGlvbixcbiAgICAgICAgY2xpcHBlZER1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgPj0gX2JpZ051bSA/IHJlY2VudC5lbmRUaW1lKGZhbHNlKSA6IGFuaW1hdGlvbi5fZHVyLFxuICAgICAgICBpLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGlzUGVyY2VudDtcblxuICAgIGlmIChfaXNTdHJpbmcocG9zaXRpb24pICYmIChpc05hTihwb3NpdGlvbikgfHwgcG9zaXRpb24gaW4gbGFiZWxzKSkge1xuICAgICAgb2Zmc2V0ID0gcG9zaXRpb24uY2hhckF0KDApO1xuICAgICAgaXNQZXJjZW50ID0gcG9zaXRpb24uc3Vic3RyKC0xKSA9PT0gXCIlXCI7XG4gICAgICBpID0gcG9zaXRpb24uaW5kZXhPZihcIj1cIik7XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IFwiPFwiIHx8IG9mZnNldCA9PT0gXCIXCIpIHtcbiAgICAgICAgaSAPSAwICYmIChwb3NpdGlvbiA9IHBvc2l0aW9uLnJlcGxhY2UoLz0vLCBcIlwiKSk7XG4gICAgICAgIHJldHVybiAob2Zmc2V0ID09PSBcIjxcIiA/IHJlY2VudC5fc3RhcnQgOiByZWNlbnQuZW5kVGltZShyZWNlbnQuX3JlcGVhdCAPSAwKSkgKyAocGFyc2VGbG9hdChwb3NpdGlvbi5zdWJzdHIoMSkpIHx8IDApICogKGlzUGVyY2VudCA/IChpIDwgMCA/IHJlY2VudCA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKSAvIDEwMCA6IDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgcG9zaXRpb24gaW4gbGFiZWxzIHx8IChsYWJlbHNbcG9zaXRpb25dID0gY2xpcHBlZER1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsc1twb3NpdGlvbl07XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCA9IHBhcnNlRmxvYXQocG9zaXRpb24uY2hhckF0KGkgLSAxKSArIHBvc2l0aW9uLnN1YnN0cihpICsgMSkpO1xuXG4gICAgICBpZiAoaXNQZXJjZW50ICYmIHBlcmNlbnRBbmltYXRpb24pIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IC8gMTAwICogKF9pc0FycmF5KHBlcmNlbnRBbmltYXRpb24pID8gcGVyY2VudEFuaW1hdGlvblswXSA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGkgPiAxID8gX3BhcnNlUG9zaXRpb24oYW5pbWF0aW9uLCBwb3NpdGlvbi5zdWJzdHIoMCwgaSAtIDEpLCBwZXJjZW50QW5pbWF0aW9uKSArIG9mZnNldCA6IGNsaXBwZWREdXJhdGlvbiArIG9mZnNldDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb24gPT0gbnVsbCA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcbiAgfSxcbiAgICAgIF9jcmVhdGVUd2VlblR5cGUgPSBmdW5jdGlvbiBfY3JlYXRlVHdlZW5UeXBlKHR5cGUsIHBhcmFtcywgdGltZWxpbmUpIHtcbiAgICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcbiAgICAgICAgdmFyc0luZGV4ID0gKGlzTGVnYWN5ID8gMiA6IDEpICsgKHR5cGUgPCAyID8gMCA6IDEpLFxuICAgICAgICB2YXJzID0gcGFyYW1zW3ZhcnNJbmRleF0sXG4gICAgICAgIGlyVmFycyxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgaXNMZWdhY3kgJiYgKHZhcnMuZHVyYXRpb24gPSBwYXJhbXNbMV0pO1xuICAgIHZhcnMucGFyZW50ID0gdGltZWxpbmU7XG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgaXJWYXJzID0gdmFycztcbiAgICAgIHBhcmVudCA9IHRpbWVsaW5lO1xuXG4gICAgICB3aGlsZSAocGFyZW50ICYmICEoXCJpbW1lZGlhdGVSZW5kZXJcIiBpbiBpclZhcnMpKSB7XG4gICAgICAgIGlyVmFycyA9IHBhcmVudC52YXJzLmRlZmF1bHRzIHx8IHt9O1xuICAgICAgICBwYXJlbnQgPSBfaXNOb3RGYWxzZShwYXJlbnQudmFycy5pbmhlcml0KSAmJiBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKGlyVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgICAgdHlwZSA8IDIgPyB2YXJzLnJ1bkJhY2t3YXJkcyA9IDEgOiB2YXJzLnN0YXJ0QXQgPSBwYXJhbXNbdmFyc0luZGV4IC0gMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUd2VlbihwYXJhbXNbMF0sIHZhcnMsIHBhcmFtc1t2YXJzSW5kZXggKyAxXSk7XG4gIH0sXG4gICAgICBfY29uZGl0aW9uYWxSZXR1cm4gPSBmdW5jdGlvbiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmMpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyBmdW5jKHZhbHVlKSA6IGZ1bmM7XG4gIH0sXG4gICAgICBfY2xhbXAgPSBmdW5jdGlvbiBfY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbiAgfSxcbiAgICAgIGdldFVuaXQgPSBmdW5jdGlvbiBnZXRVbml0KHZhbHVlLCB2KSB7XG4gICAgcmV0dXJuICFfaXNTdHJpbmcodmFsdWUpIHx8ICEodiA9IF91bml0RXhwLmV4ZWModmFsdWUpKSA/IFwiXCIgOiB2WzFdO1xuICB9LFxuICAgICAgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIF9jbGFtcChtaW4sIG1heCwgdik7XG4gICAgfSk7XG4gIH0sXG4gICAgICBfc2xpY2UgPSBbXS5zbGljZSxcbiAgICAgIF9pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIF9pc0FycmF5TGlrZSh2YWx1ZSwgbm9uRW1wdHkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgX2lzT2JqZWN0KHZhbHVlKSAmJiBcImxlbmd0aFwiIGluIHZhbHVlICYmICghbm9uRW1wdHkgJiYgIXZhbHVlLmxlbmd0aCB8fCB2YWx1ZS5sZW5ndGggLSAxIGluIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZVswXSkpICYmICF2YWx1ZS5ub2RlVHlwZSAmJiB2YWx1ZSAhPT0gX3dpbjtcbiAgfSxcbiAgICAgIF9mbGF0dGVuID0gZnVuY3Rpb24gX2ZsYXR0ZW4oYXIsIGxlYXZlU3RyaW5ncywgYWNjdW11bGF0b3IpIHtcbiAgICBpZiAoYWNjdW11bGF0b3IgPT09IHZvaWQgMCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBfYWNjdW11bGF0b3I7XG5cbiAgICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgfHwgX2lzQXJyYXlMaWtlKHZhbHVlLCAxKSA/IChfYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcikucHVzaC5hcHBseShfYWNjdW11bGF0b3IsIHRvQXJyYXkodmFsdWUpKSA6IGFjY3VtdWxhdG9yLnB1c2godmFsdWUpO1xuICAgIH0pIHx8IGFjY3VtdWxhdG9yO1xuICB9LFxuICAgICAgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUsIHNjb3BlLCBsZWF2ZVN0cmluZ3MpIHtcbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzICYmIChfY29yZUluaXR0ZWQgfHwgIV93YWtlKCkpID8gX3NsaWNlLmNhbGwoKHNjb3BlIHx8IF9kb2MpLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xuICB9LFxuICAgICAgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3Rvcih2YWx1ZSkge1xuICAgIHZhbHVlID0gdG9BcnJheSh2YWx1ZSlbMF0gfHwgX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgdmFyIGVsID0gdmFsdWUuY3VycmVudCB8fCB2YWx1ZS5uYXRpdmVFbGVtZW50IHx8IHZhbHVlO1xuICAgICAgcmV0dXJuIHRvQXJyYXkodiwgZWwucXVlcnlTZWxlY3RvckFsbCA/IGVsIDogZWwgPT09IHZhbHVlID8gX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSA6IHZhbHVlKTtcbiAgICB9O1xuICB9LFxuICAgICAgc2h1ZmZsZSA9IGZ1bmN0aW9uIHNodWZmbGUoYSkge1xuICAgIHJldHVybiBhLnNvcnQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIC41IC0gTWF0aC5yYW5kb20oKTtcbiAgICB9KTtcbiAgfSxcbiAgICAgIGRpc3RyaWJ1dGUgPSBmdW5jdGlvbiBkaXN0cmlidXRlKHYpIHtcbiAgICBpZiAoX2lzRnVuY3Rpb24odikpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIHZhciB2YXJzID0gX2lzT2JqZWN0KHYpID8gdiA6IHtcbiAgICAgIGVhY2g6IHZcbiAgICB9LFxuICAgICAgICBlYXNlID0gX3BhcnNlRWFzZSh2YXJzLmVhc2UpLFxuICAgICAgICBmcm9tID0gdmFycy5mcm9tIHx8IDAsXG4gICAgICAgIGJhc2UgPSBwYXJzZUZsb2F0KHZhcnMuYmFzZSkgfHwgMCxcbiAgICAgICAgY2FjaGUgPSB7fSxcbiAgICAgICAgaXNEZWNpbWFsID0gZnJvbSAIDAgJiYgZnJvbSA8IDEsXG4gICAgICAgIHJhdGlvcyA9IGlzTmFOKGZyb20pIHx8IGlzRGVjaW1hbCxcbiAgICAgICAgYXhpcyA9IHZhcnMuYXhpcyxcbiAgICAgICAgcmF0aW9YID0gZnJvbSxcbiAgICAgICAgcmF0aW9ZID0gZnJvbTtcblxuICAgIGlmIChfaXNTdHJpbmcoZnJvbSkpIHtcbiAgICAgIHJhdGlvWCA9IHJhdGlvWSA9IHtcbiAgICAgICAgY2VudGVyOiAuNSxcbiAgICAgICAgZWRnZXM6IC41LFxuICAgICAgICBlbmQ6IDFcbiAgICAgIH1bZnJvbV0gfHwgMDtcbiAgICB9IGVsc2UgaWYgKCFpc0RlY2ltYWwgJiYgcmF0aW9zKSB7XG4gICAgICByYXRpb1ggPSBmcm9tWzBdO1xuICAgICAgcmF0aW9ZID0gZnJvbVsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGksIHRhcmdldCwgYSkge1xuICAgICAgdmFyIGwgPSAoYSB8fCB2YXJzKS5sZW5ndGgsXG4gICAgICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0sXG4gICAgICAgICAgb3JpZ2luWCxcbiAgICAgICAgICBvcmlnaW5ZLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBkLFxuICAgICAgICAgIGosXG4gICAgICAgICAgbWF4LFxuICAgICAgICAgIG1pbixcbiAgICAgICAgICB3cmFwQXQ7XG5cbiAgICAgIGlmICghZGlzdGFuY2VzKSB7XG4gICAgICAgIHdyYXBBdCA9IHZhcnMuZ3JpZCA9PT0gXCJhdXRvXCIgPyAwIDogKHZhcnMuZ3JpZCB8fCBbMSwgX2JpZ051bV0pWzFdO1xuXG4gICAgICAgIGlmICghd3JhcEF0KSB7XG4gICAgICAgICAgbWF4ID0gLV9iaWdOdW07XG5cbiAgICAgICAgICB3aGlsZSAobWF4IDwgKG1heCA9IGFbd3JhcEF0KytdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICYmIHdyYXBBdCA8IGwpIHt9XG5cbiAgICAgICAgICB3cmFwQXQtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdID0gW107XG4gICAgICAgIG9yaWdpblggPSByYXRpb3MgPyBNYXRoLm1pbih3cmFwQXQsIGwpICogcmF0aW9YIC0gLjUgOiBmcm9tICUgd3JhcEF0O1xuICAgICAgICBvcmlnaW5ZID0gd3JhcEF0ID09PSBfYmlnTnVtID8gMCA6IHJhdGlvcyA/IGwgKiByYXRpb1kgLyB3cmFwQXQgLSAuNSA6IGZyb20gLyB3cmFwQXQgfCAwO1xuICAgICAgICBtYXggPSAwO1xuICAgICAgICBtaW4gPSBfYmlnTnVtO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICB4ID0gaiAlIHdyYXBBdCAtIG9yaWdpblg7XG4gICAgICAgICAgeSA9IG9yaWdpblkgLSAoaiAvIHdyYXBBdCB8IDApO1xuICAgICAgICAgIGRpc3RhbmNlc1tqXSA9IGQgPSAhYXhpcyA/IF9zcXJ0KHggKiB4ICsgeSAqIHkpIDogTWF0aC5hYnMoYXhpcyA9PT0gXCJ5XCIgPyB5IDogeCk7XG4gICAgICAgICAgZCAIG1heCAmJiAobWF4ID0gZCk7XG4gICAgICAgICAgZCA8IG1pbiAmJiAobWluID0gZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcm9tID09PSBcInJhbmRvbVwiICYmIHNodWZmbGUoZGlzdGFuY2VzKTtcbiAgICAgICAgZGlzdGFuY2VzLm1heCA9IG1heCAtIG1pbjtcbiAgICAgICAgZGlzdGFuY2VzLm1pbiA9IG1pbjtcbiAgICAgICAgZGlzdGFuY2VzLnYgPSBsID0gKHBhcnNlRmxvYXQodmFycy5hbW91bnQpIHx8IHBhcnNlRmxvYXQodmFycy5lYWNoKSAqICh3cmFwQXQgPiBsID8gbCAtIDEgOiAhYXhpcyA/IE1hdGgubWF4KHdyYXBBdCwgbCAvIHdyYXBBdCkgOiBheGlzID09PSBcInlcIiA/IGwgLyB3cmFwQXQgOiB3cmFwQXQpIHx8IDApICogKGZyb20gPT09IFwiZWRnZXNcIiA/IC0xIDogMSk7XG4gICAgICAgIGRpc3RhbmNlcy5iID0gbCA8IDAgPyBiYXNlIC0gbCA6IGJhc2U7XG4gICAgICAgIGRpc3RhbmNlcy51ID0gZ2V0VW5pdCh2YXJzLmFtb3VudCB8fCB2YXJzLmVhY2gpIHx8IDA7XG4gICAgICAgIGVhc2UgPSBlYXNlICYmIGwgPCAwID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xuICAgICAgfVxuXG4gICAgICBsID0gKGRpc3RhbmNlc1tpXSAtIGRpc3RhbmNlcy5taW4pIC8gZGlzdGFuY2VzLm1heCB8fCAwO1xuICAgICAgcmV0dXJuIF9yb3VuZFByZWNpc2UoZGlzdGFuY2VzLmIgKyAoZWFzZSA/IGVhc2UobCkgOiBsKSAqIGRpc3RhbmNlcy52KSArIGRpc3RhbmNlcy51O1xuICAgIH07XG4gIH0sXG4gICAgICBfcm91bmRNb2RpZmllciA9IGZ1bmN0aW9uIF9yb3VuZE1vZGlmaWVyKHYpIHtcbiAgICB2YXIgcCA9IE1hdGgucG93KDEwLCAoKHYgKyBcIlwiKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJhdykge1xuICAgICAgdmFyIG4gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQocmF3KSAvIHYpICogdiAqIHA7XG4gICAgICByZXR1cm4gKG4gLSBuICUgMSkgLyBwICsgKF9pc051bWJlcihyYXcpID8gMCA6IGdldFVuaXQocmF3KSk7XG4gICAgfTtcbiAgfSxcbiAgICAgIHNuYXAgPSBmdW5jdGlvbiBzbmFwKHNuYXBUbywgdmFsdWUpIHtcbiAgICB2YXIgaXNBcnJheSA9IF9pc0FycmF5KHNuYXBUbyksXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgaXMyRDtcblxuICAgIGlmICghaXNBcnJheSAmJiBfaXNPYmplY3Qoc25hcFRvKSkge1xuICAgICAgcmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcblxuICAgICAgaWYgKHNuYXBUby52YWx1ZXMpIHtcbiAgICAgICAgc25hcFRvID0gdG9BcnJheShzbmFwVG8udmFsdWVzKTtcblxuICAgICAgICBpZiAoaXMyRCA9ICFfaXNOdW1iZXIoc25hcFRvWzBdKSkge1xuICAgICAgICAgIHJhZGl1cyAqPSByYWRpdXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNuYXBUbyA9IF9yb3VuZE1vZGlmaWVyKHNuYXBUby5pbmNyZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsICFpc0FycmF5ID8gX3JvdW5kTW9kaWZpZXIoc25hcFRvKSA6IF9pc0Z1bmN0aW9uKHNuYXBUbykgPyBmdW5jdGlvbiAocmF3KSB7XG4gICAgICBpczJEID0gc25hcFRvKHJhdyk7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdztcbiAgICB9IDogZnVuY3Rpb24gKHJhdykge1xuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueCA6IHJhdyksXG4gICAgICAgICAgeSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXG4gICAgICAgICAgbWluID0gX2JpZ051bSxcbiAgICAgICAgICBjbG9zZXN0ID0gMCxcbiAgICAgICAgICBpID0gc25hcFRvLmxlbmd0aCxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeTtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoaXMyRCkge1xuICAgICAgICAgIGR4ID0gc25hcFRvW2ldLnggLSB4O1xuICAgICAgICAgIGR5ID0gc25hcFRvW2ldLnkgLSB5O1xuICAgICAgICAgIGR4ID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHggPSBNYXRoLmFicyhzbmFwVG9baV0gLSB4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkeCA8IG1pbikge1xuICAgICAgICAgIG1pbiA9IGR4O1xuICAgICAgICAgIGNsb3Nlc3QgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNsb3Nlc3QgPSAhcmFkaXVzIHx8IG1pbiA8PSByYWRpdXMgPyBzbmFwVG9bY2xvc2VzdF0gOiByYXc7XG4gICAgICByZXR1cm4gaXMyRCB8fCBjbG9zZXN0ID09PSByYXcgfHwgX2lzTnVtYmVyKHJhdykgPyBjbG9zZXN0IDogY2xvc2VzdCArIGdldFVuaXQocmF3KTtcbiAgICB9KTtcbiAgfSxcbiAgICAgIHJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgcm91bmRpbmdJbmNyZW1lbnQsIHJldHVybkZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBtaW5bfn4oTWF0aC5yYW5kb20oKSAqIG1pbi5sZW5ndGgpXSA6IChyb3VuZGluZ0luY3JlbWVudCA9IHJvdW5kaW5nSW5jcmVtZW50IHx8IDFlLTUpICYmIChyZXR1cm5GdW5jdGlvbiA9IHJvdW5kaW5nSW5jcmVtZW50IDwgMSA/IE1hdGgucG93KDEwLCAocm91bmRpbmdJbmNyZW1lbnQgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDEpICYmIE1hdGguZmxvb3IoTWF0aC5yb3VuZCgobWluIC0gcm91bmRpbmdJbmNyZW1lbnQgLyAyICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyByb3VuZGluZ0luY3JlbWVudCAqIC45OSkpIC8gcm91bmRpbmdJbmNyZW1lbnQpICogcm91bmRpbmdJbmNyZW1lbnQgKiByZXR1cm5GdW5jdGlvbikgLyByZXR1cm5GdW5jdGlvbjtcbiAgICB9KTtcbiAgfSxcbiAgICAgIHBpcGUgPSBmdW5jdGlvbiBwaXBlKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBmdW5jdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHYsIGYpIHtcbiAgICAgICAgcmV0dXJuIGYodik7XG4gICAgICB9LCB2YWx1ZSk7XG4gICAgfTtcbiAgfSxcbiAgICAgIHVuaXRpemUgPSBmdW5jdGlvbiB1bml0aXplKGZ1bmMsIHVuaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyhwYXJzZUZsb2F0KHZhbHVlKSkgKyAodW5pdCB8fCBnZXRVbml0KHZhbHVlKSk7XG4gICAgfTtcbiAgfSxcbiAgICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgICByZXR1cm4gbWFwUmFuZ2UobWluLCBtYXgsIDAsIDEsIHZhbHVlKTtcbiAgfSxcbiAgICAgIF93cmFwQXJyYXkgPSBmdW5jdGlvbiBfd3JhcEFycmF5KGEsIHdyYXBwZXIsIHZhbHVlKSB7XG4gICAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gYVtfndyYXBwZXIoaW5kZXgpXTtcbiAgICB9KTtcbiAgfSxcbiAgICAgIHdyYXAgPSBmdW5jdGlvbiB3cmFwKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwKDAsIG1pbi5sZW5ndGgpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiAocmFuZ2UgKyAodmFsdWUgLSBtaW4pICUgcmFuZ2UpICUgcmFuZ2UgKyBtaW47XG4gICAgfSk7XG4gIH0sXG4gICAgICB3cmFwWW95byA9IGZ1bmN0aW9uIHdyYXBZb3lvKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHZhciByYW5nZSA9IG1heCAtIG1pbixcbiAgICAgICAgdG90YWwgPSByYW5nZSAqIDI7XG4gICAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcFlveW8oMCwgbWluLmxlbmd0aCAtIDEpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsIHx8IDA7XG4gICAgICByZXR1cm4gbWluICsgKHZhbHVlID4gcmFuZ2UgPyB0b3RhbCAtIHZhbHVlIDogdmFsdWUpO1xuICAgIH0pO1xuICB9LFxuICAgICAgX3JlcGxhY2VSYW5kb20gPSBmdW5jdGlvbiBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkge1xuICAgIHZhciBwcmV2ID0gMCxcbiAgICAgICAgcyA9IFwiXCIsXG4gICAgICAgIGksXG4gICAgICAgIG51bXMsXG4gICAgICAgIGVuZCxcbiAgICAgICAgaXNBcnJheTtcblxuICAgIHdoaWxlIChKGkgPSB2YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiLCBwcmV2KSkpIHtcbiAgICAgIGVuZCA9IHZhbHVlLmluZGV4T2YoXCIpXCIsIGkpO1xuICAgICAgaXNBcnJheSA9IHZhbHVlLmNoYXJBdChpICsgNykgPT09IFwiW1wiO1xuICAgICAgbnVtcyA9IHZhbHVlLnN1YnN0cihpICsgNywgZW5kIC0gaSAtIDcpLm1hdGNoKGlzQXJyYXkgPyBfZGVsaW1pdGVkVmFsdWVFeHAgOiBfc3RyaWN0TnVtRXhwKTtcbiAgICAgIHMgKz0gdmFsdWUuc3Vic3RyKHByZXYsIGkgLSBwcmV2KSArIHJhbmRvbShpc0FycmF5ID8gbnVtcyA6ICtudW1zWzBdLCBpc0FycmF5ID8gMCA6ICtudW1zWzFdLCArbnVtc1syXSB8fCAxZS01KTtcbiAgICAgIHByZXYgPSBlbmQgKyAxO1xuICAgIH1cblxuICAgIHJldHVybiBzICsgdmFsdWUuc3Vic3RyKHByZXYsIHZhbHVlLmxlbmd0aCAtIHByZXYpO1xuICB9LFxuICAgICAgbWFwUmFuZ2UgPSBmdW5jdGlvbiBtYXBSYW5nZShpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4LCB2YWx1ZSkge1xuICAgIHZhciBpblJhbmdlID0gaW5NYXggLSBpbk1pbixcbiAgICAgICAgb3V0UmFuZ2UgPSBvdXRNYXggLSBvdXRNaW47XG4gICAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gb3V0TWluICsgKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UgKiBvdXRSYW5nZSB8fCAwKTtcbiAgICB9KTtcbiAgfSxcbiAgICAgIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIG11dGF0ZSkge1xuICAgIHZhciBmdW5jID0gaXNOYU4oc3RhcnQgKyBlbmQpID8gMCA6IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gKDEgLSBwKSAqIHN0YXJ0ICsgcCAqIGVuZDtcbiAgICB9O1xuXG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSBfaXNTdHJpbmcoc3RhcnQpLFxuICAgICAgICAgIG1hc3RlciA9IHt9LFxuICAgICAgICAgIHAsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBpbnRlcnBvbGF0b3JzLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgaWw7XG5cbiAgICAgIHByb2dyZXNzID09PSB0cnVlICYmIChtdXRhdGUgPSAxKSAmJiAocHJvZ3Jlc3MgPSBudWxsKTtcblxuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgIHA6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIGVuZCA9IHtcbiAgICAgICAgICBwOiBlbmRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoX2lzQXJyYXkoc3RhcnQpICYmICFfaXNBcnJheShlbmQpKSB7XG4gICAgICAgIGludGVycG9sYXRvcnMgPSBbXTtcbiAgICAgICAgbCA9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgaWwgPSBsIC0gMjtcblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaW50ZXJwb2xhdG9ycy5wdXNoKGludGVycG9sYXRlKHN0YXJ0W2kgLSAxXSwgc3RhcnRbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGwtLTtcblxuICAgICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgICAgcCAqPSBsO1xuICAgICAgICAgIHZhciBpID0gTWF0aC5taW4oaWwsIH5cCk7XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRvcnNbaV0ocCAtIGkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByb2dyZXNzID0gZW5kO1xuICAgICAgfSBlbHNlIGlmICghbXV0YXRlKSB7XG4gICAgICAgIHN0YXJ0ID0gX21lcmdlKF9pc0FycmF5KHN0YXJ0KSA/IFtdIDoge30sIHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpbnRlcnBvbGF0b3JzKSB7XG4gICAgICAgIGZvciAocCBpbiBlbmQpIHtcbiAgICAgICAgICBfYWRkUHJvcFR3ZWVuLmNhbGwobWFzdGVyLCBzdGFydCwgcCwgXCJnZXRcIiwgZW5kW3BdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgICByZXR1cm4gX3JlbmRlclByb3BUd2VlbnMocCwgbWFzdGVyKSB8fCAoaXNTdHJpbmcgPyBzdGFydC5wIDogc3RhcnQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4ocHJvZ3Jlc3MsIGZ1bmMpO1xuICB9LFxuICAgICAgX2dldExhYmVsSW5EaXJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aW1lbGluZSwgZnJvbVRpbWUsIGJhY2t3YXJkKSB7XG4gICAgdmFyIGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcbiAgICAgICAgbWluID0gX2JpZ051bSxcbiAgICAgICAgcCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGxhYmVsO1xuXG4gICAgZm9yIChwIGluIGxhYmVscykge1xuICAgICAgZGlzdGFuY2UgPSBsYWJlbHNbcF0gLSBmcm9tVGltZTtcblxuICAgICAgaWYgKGRpc3RhbmNlIDwgMCA9PT0gISFiYWNrd2FyZCAmJiBkaXN0YW5jZSAmJiBtaW4gPiAoZGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZSkpKSB7XG4gICAgICAgIGxhYmVsID0gcDtcbiAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuICAgICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKGFuaW1hdGlvbiwgdHlwZSwgZXhlY3V0ZUxhenlGaXJzdCkge1xuICAgIHZhciB2ID0gYW5pbWF0aW9uLnZhcnMsXG4gICAgICAgIGNhbGxiYWNrID0gdlt0eXBlXSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBzY29wZTtcblxuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYXJhbXMgPSB2W3R5cGUgKyBcIlBhcmFtc1wiXTtcbiAgICBzY29wZSA9IHYuY2FsbGJhY2tTY29wZSB8fCBhbmltYXRpb247XG4gICAgZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTtcbiAgICByZXR1cm4gcGFyYW1zID8gY2FsbGJhY2suYXBwbHkoc2NvcGUsIHBhcmFtcykgOiBjYWxsYmFjay5jYWxsKHNjb3BlKTtcbiAgfSxcbiAgICAgIF9pbnRlcnJ1cHQgPSBmdW5jdGlvbiBfaW50ZXJydXB0KGFuaW1hdGlvbikge1xuICAgIF9yZW1vdmVGcm9tUGFyZW50KGFuaW1hdGlvbik7XG5cbiAgICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciAmJiBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5raWxsKGZhbHNlKTtcbiAgICBhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEgJiYgX2NhbGxiYWNrKGFuaW1hdGlvbiwgXCJvbkludGVycnVwdFwiKTtcbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9LFxuICAgICAgX3F1aWNrVHdlZW4sXG4gICAgICBfY3JlYXRlUGx1Z2luID0gZnVuY3Rpb24gX2NyZWF0ZVBsdWdpbihjb25maWcpIHtcbiAgICBjb25maWcgPSAhY29uZmlnLm5hbWUgJiYgY29uZmlnW1wiZGVmYXVsdFwiXSB8fCBjb25maWc7XG5cbiAgICB2YXIgbmFtZSA9IGNvbmZpZy5uYW1lLFxuICAgICAgICBpc0Z1bmMgPSBfaXNGdW5jdGlvbihjb25maWcpLFxuICAgICAgICBQbHVnaW4gPSBuYW1lICYmICFpc0Z1bmMgJiYgY29uZmlnLmluaXQgPyBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9wcm9wcyA9IFtdO1xuICAgIH0gOiBjb25maWcsXG4gICAgICAgIGluc3RhbmNlRGVmYXVsdHMgPSB7XG4gICAgICBpbml0OiBfZW1wdHlGdW5jLFxuICAgICAgcmVuZGVyOiBfcmVuZGVyUHJvcFR3ZWVucyxcbiAgICAgIGFkZDogX2FkZFByb3BUd2VlbixcbiAgICAgIGtpbGw6IF9raWxsUHJvcFR3ZWVuc09mLFxuICAgICAgbW9kaWZpZXI6IF9hZGRQbHVnaW5Nb2RpZmllcixcbiAgICAgIHJhd1ZhcnM6IDBcbiAgICB9LFxuICAgICAgICBzdGF0aWNzID0ge1xuICAgICAgdGFyZ2V0VGVzdDogMCxcbiAgICAgIGdldDogMCxcbiAgICAgIGdldFNldHRlcjogX2dldFNldHRlcixcbiAgICAgIGFsaWFzZXM6IHt9LFxuICAgICAgcmVnaXN0ZXI6IDBcbiAgICB9O1xuXG4gICAgX3dha2UoKTtcblxuICAgIGlmIChjb25maWcgIT09IFBsdWdpbikge1xuICAgICAgaWYgKF9wbHVnaW5zW25hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3NldERlZmF1bHRzKFBsdWdpbiwgX3NldERlZmF1bHRzKF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgaW5zdGFuY2VEZWZhdWx0cyksIHN0YXRpY3MpKTtcblxuICAgICAgX21lcmdlKFBsdWdpbi5wcm90b3R5cGUsIF9tZXJnZShpbnN0YW5jZURlZmF1bHRzLCBfY29weUV4Y2x1ZGluZyhjb25maWcsIHN0YXRpY3MpKSk7XG5cbiAgICAgIF9wbHVnaW5zW1BsdWdpbi5wcm9wID0gbmFtZV0gPSBQbHVnaW47XG5cbiAgICAgIGlmIChjb25maWcudGFyZ2V0VGVzdCkge1xuICAgICAgICBfaGFybmVzc1BsdWdpbnMucHVzaChQbHVnaW4pO1xuXG4gICAgICAgIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcbiAgICAgIH1cblxuICAgICAgbmFtZSA9IChuYW1lID09PSBcImNzc1wiID8gXCJDU1NcIiA6IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKSkgKyBcIlBsdWdpblwiO1xuICAgIH1cblxuICAgIF9hZGRHbG9iYWwobmFtZSwgUGx1Z2luKTtcblxuICAgIGNvbmZpZy5yZWdpc3RlciAmJiBjb25maWcucmVnaXN0ZXIoZ3NhcCwgUGx1Z2luLCBQcm9wVHdlZW4pO1xuICB9LFxuICAgICAgXzI1NSA9IDI1NSxcbiAgICAgIF9jb2xvckxvb2t1cCA9IHtcbiAgICBhcXVhOiBbMCwgXzI1NSwgXzI1NV0sXG4gICAgbGltZTogWzAsIF8yNTUsIDBdLFxuICAgIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICAgIGJsdWU6IFswLCAwLCBfMjU1XSxcbiAgICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgICB3aGl0ZTogW18yNTUsIF8yNTUsIF8yNTVdLFxuICAgIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICAgIHllbGxvdzogW18yNTUsIF8yNTUsIDBdLFxuICAgIG9yYW5nZTogW18yNTUsIDE2NSwgMF0sXG4gICAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICAgIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgICBncmVlbjogWzAsIDEyOCwgMF0sXG4gICAgcmVkOiBbXzI1NSwgMCwgMF0sXG4gICAgcGluazogW18yNTUsIDE5MiwgMjAzXSxcbiAgICBjeWFuOiBbMCwgXzI1NSwgXzI1NV0sXG4gICAgdHJhbnNwYXJlbnQ6IFtfMjU1LCBfMjU1LCBfMjU1LCAwXVxuICB9LFxuICAgICAgX2h1ZSA9IGZ1bmN0aW9uIF9odWUoaCwgbTEsIG0yKSB7XG4gICAgaCArPSBoIDwgMCA/IDEgOiBoID4gMSA/IC0xIDogMDtcbiAgICByZXR1cm4gKGggKiA2IDwgMSA/IG0xICsgKG0yIC0gbTEpICogaCAqIDYgOiBoIDwgLjUgPyBtMiA6IGggKiAzIDwgMiA/IG0xICsgKG0yIC0gbTEpICogKDIgLyAzIC0gaCkgKiA2IDogbTEpICogXzI1NSArIC41IHwgMDtcbiAgfSxcbiAgICAgIHNwbGl0Q29sb3IgPSBmdW5jdGlvbiBzcGxpdENvbG9yKHYsIHRvSFNMLCBmb3JjZUFscGhhKSB7XG4gICAgdmFyIGEgPSAhdiA/IF9jb2xvckxvb2t1cC5ibGFjayA6IF9pc051bWJlcih2KSA/IFt2ID4IDE2LCB2ID4IDggJiBfMjU1LCB2ICYgXzI1NV0gOiAwLFxuICAgICAgICByLFxuICAgICAgICBnLFxuICAgICAgICBiLFxuICAgICAgICBoLFxuICAgICAgICBzLFxuICAgICAgICBsLFxuICAgICAgICBtYXgsXG4gICAgICAgIG1pbixcbiAgICAgICAgZCxcbiAgICAgICAgd2FzSFNMO1xuXG4gICAgaWYgKCFhKSB7XG4gICAgICBpZiAodi5zdWJzdHIoLTEpID09PSBcIixcIikge1xuICAgICAgICB2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9jb2xvckxvb2t1cFt2XSkge1xuICAgICAgICBhID0gX2NvbG9yTG9va3VwW3ZdO1xuICAgICAgfSBlbHNlIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgaWYgKHYubGVuZ3RoIDwgNikge1xuICAgICAgICAgIHIgPSB2LmNoYXJBdCgxKTtcbiAgICAgICAgICBnID0gdi5jaGFyQXQoMik7XG4gICAgICAgICAgYiA9IHYuY2hhckF0KDMpO1xuICAgICAgICAgIHYgPSBcIiNcIiArIHIgKyByICsgZyArIGcgKyBiICsgYiArICh2Lmxlbmd0aCA9PT0gNSA/IHYuY2hhckF0KDQpICsgdi5jaGFyQXQoNCkgOiBcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2Lmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgIGEgPSBwYXJzZUludCh2LnN1YnN0cigxLCA2KSwgMTYpO1xuICAgICAgICAgIHJldHVybiBbYSAPiAxNiwgYSAPiA4ICYgXzI1NSwgYSAmIF8yNTUsIHBhcnNlSW50KHYuc3Vic3RyKDcpLCAxNikgLyAyNTVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdiA9IHBhcnNlSW50KHYuc3Vic3RyKDEpLCAxNik7XG4gICAgICAgIGEgPSBbdiAPiAxNiwgdiAPiA4ICYgXzI1NSwgdiAmIF8yNTVdO1xuICAgICAgfSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuICAgICAgICBhID0gd2FzSFNMID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKTtcblxuICAgICAgICBpZiAoIXRvSFNMKSB7XG4gICAgICAgICAgaCA9ICthWzBdICUgMzYwIC8gMzYwO1xuICAgICAgICAgIHMgPSArYVsxXSAvIDEwMDtcbiAgICAgICAgICBsID0gK2FbMl0gLyAxMDA7XG4gICAgICAgICAgZyA9IGwgPD0gLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgICAgciA9IGwgKiAyIC0gZztcbiAgICAgICAgICBhLmxlbmd0aCAIDMgJiYgKGFbM10gKj0gMSk7XG4gICAgICAgICAgYVswXSA9IF9odWUoaCArIDEgLyAzLCByLCBnKTtcbiAgICAgICAgICBhWzFdID0gX2h1ZShoLCByLCBnKTtcbiAgICAgICAgICBhWzJdID0gX2h1ZShoIC0gMSAvIDMsIHIsIGcpO1xuICAgICAgICB9IGVsc2UgaWYgKH52LmluZGV4T2YoXCI9XCIpKSB7XG4gICAgICAgICAgYSA9IHYubWF0Y2goX251bUV4cCk7XG4gICAgICAgICAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IHYubWF0Y2goX3N0cmljdE51bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuICAgICAgfVxuXG4gICAgICBhID0gYS5tYXAoTnVtYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodG9IU0wgJiYgIXdhc0hTTCkge1xuICAgICAgciA9IGFbMF0gLyBfMjU1O1xuICAgICAgZyA9IGFbMV0gLyBfMjU1O1xuICAgICAgYiA9IGFbMl0gLyBfMjU1O1xuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICBoID0gcyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCAIDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICAgIGggPSBtYXggPT09IHIgPyAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKSA6IG1heCA9PT0gZyA/IChiIC0gcikgLyBkICsgMiA6IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgaCAqPSA2MDtcbiAgICAgIH1cblxuICAgICAgYVswXSA9IH5KGggKyAuNSk7XG4gICAgICBhWzFdID0gfn4ocyAqIDEwMCArIC41KTtcbiAgICAgIGFbMl0gPSBfihsICogMTAwICsgLjUpO1xuICAgIH1cblxuICAgIGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gICAgICBfY29sb3JPcmRlckRhdGEgPSBmdW5jdGlvbiBfY29sb3JPcmRlckRhdGEodikge1xuICAgIHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgICAgYyA9IFtdLFxuICAgICAgICBpID0gLTE7XG4gICAgdi5zcGxpdChfY29sb3JFeHApLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIHZhciBhID0gdi5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICAgICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBhKTtcbiAgICAgIGMucHVzaChpICs9IGEubGVuZ3RoICsgMSk7XG4gICAgfSk7XG4gICAgdmFsdWVzLmMgPSBjO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0sXG4gICAgICBfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24gX2Zvcm1hdENvbG9ycyhzLCB0b0hTTCwgb3JkZXJNYXRjaERhdGEpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgICAgY29sb3JzID0gKHMgKyByZXN1bHQpLm1hdGNoKF9jb2xvckV4cCksXG4gICAgICAgIHR5cGUgPSB0b0hTTCA/IFwiaHNsYShcIiA6IFwicmdiYShcIixcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGMsXG4gICAgICAgIHNoZWxsLFxuICAgICAgICBkLFxuICAgICAgICBsO1xuXG4gICAgaWYgKCFjb2xvcnMpIHtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICByZXR1cm4gKGNvbG9yID0gc3BsaXRDb2xvcihjb2xvciwgdG9IU0wsIDEpKSAmJiB0eXBlICsgKHRvSFNMID8gY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIlLFwiICsgY29sb3JbMl0gKyBcIiUsXCIgKyBjb2xvclszXSA6IGNvbG9yLmpvaW4oXCIsXCIpKSArIFwiKVwiO1xuICAgIH0pO1xuXG4gICAgaWYgKG9yZGVyTWF0Y2hEYXRhKSB7XG4gICAgICBkID0gX2NvbG9yT3JkZXJEYXRhKHMpO1xuICAgICAgYyA9IG9yZGVyTWF0Y2hEYXRhLmM7XG5cbiAgICAgIGlmIChjLmpvaW4ocmVzdWx0KSAhPT0gZC5jLmpvaW4ocmVzdWx0KSkge1xuICAgICAgICBzaGVsbCA9IHMucmVwbGFjZShfY29sb3JFeHAsIFwiMVwiKS5zcGxpdChfbnVtV2l0aFVuaXRFeHApO1xuICAgICAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcblxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHJlc3VsdCArPSBzaGVsbFtpXSArIChYy5pbmRleE9mKGkpID8gY29sb3JzLnNoaWZ0KCkgfHwgdHlwZSArIFwiMCwwLDAsMClcIiA6IChkLmxlbmd0aCA/IGQgOiBjb2xvcnMubGVuZ3RoID8gY29sb3JzIDogb3JkZXJNYXRjaERhdGEpLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzaGVsbCkge1xuICAgICAgc2hlbGwgPSBzLnNwbGl0KF9jb2xvckV4cCk7XG4gICAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgY29sb3JzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgKyBzaGVsbFtsXTtcbiAgfSxcbiAgICAgIF9jb2xvckV4cCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszLDR9KXsxLDJ9XFxcXGJcIixcbiAgICAgICAgcDtcblxuICAgIGZvciAocCBpbiBfY29sb3JMb29rdXApIHtcbiAgICAgIHMgKz0gXCJ8XCIgKyBwICsgXCJcXFxcYlwiO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVnRXhwKHMgKyBcIilcIiwgXCJnaVwiKTtcbiAgfSgpLFxuICAgICAgX2hzbEV4cCA9IC9oc2xbYV0/XFwoLyxcbiAgICAgIF9jb2xvclN0cmluZ0ZpbHRlciA9IGZ1bmN0aW9uIF9jb2xvclN0cmluZ0ZpbHRlcihhKSB7XG4gICAgdmFyIGNvbWJpbmVkID0gYS5qb2luKFwiIFwiKSxcbiAgICAgICAgdG9IU0w7XG4gICAgX2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cbiAgICBpZiAoX2NvbG9yRXhwLnRlc3QoY29tYmluZWQpKSB7XG4gICAgICB0b0hTTCA9IF9oc2xFeHAudGVzdChjb21iaW5lZCk7XG4gICAgICBhWzFdID0gX2Zvcm1hdENvbG9ycyhhWzFdLCB0b0hTTCk7XG4gICAgICBhWzBdID0gX2Zvcm1hdENvbG9ycyhhWzBdLCB0b0hTTCwgX2NvbG9yT3JkZXJEYXRhKGFbMV0pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcbiAgICAgIF90aWNrZXJBY3RpdmUsXG4gICAgICBfdGlja2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfZ2V0VGltZSA9IERhdGUubm93LFxuICAgICAgICBfbGFnVGhyZXNob2xkID0gNTAwLFxuICAgICAgICBfYWRqdXN0ZWRMYWcgPSAzMyxcbiAgICAgICAgX3N0YXJ0VGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgIF9sYXN0VXBkYXRlID0gX3N0YXJ0VGltZSxcbiAgICAgICAgX2dhcCA9IDEwMDAgLyAyNDAsXG4gICAgICAgIF9uZXh0VGltZSA9IF9nYXAsXG4gICAgICAgIF9saXN0ZW5lcnMgPSBbXSxcbiAgICAgICAgX2lkLFxuICAgICAgICBfcmVxLFxuICAgICAgICBfcmFmLFxuICAgICAgICBfc2VsZixcbiAgICAgICAgX2RlbHRhLFxuICAgICAgICBfaSxcbiAgICAgICAgX3RpY2sgPSBmdW5jdGlvbiBfdGljayh2KSB7XG4gICAgICB2YXIgZWxhcHNlZCA9IF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSxcbiAgICAgICAgICBtYW51YWwgPSB2ID09PSB0cnVlLFxuICAgICAgICAgIG92ZXJsYXAsXG4gICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgdGltZSxcbiAgICAgICAgICBmcmFtZTtcblxuICAgICAgZWxhcHNlZCAIF9sYWdUaHJlc2hvbGQgJiYgKF9zdGFydFRpbWUgKz0gZWxhcHNlZCAtIF9hZGp1c3RlZExhZyk7XG4gICAgICBfbGFzdFVwZGF0ZSArPSBlbGFwc2VkO1xuICAgICAgdGltZSA9IF9sYXN0VXBkYXRlIC0gX3N0YXJ0VGltZTtcbiAgICAgIG92ZXJsYXAgPSB0aW1lIC0gX25leHRUaW1lO1xuXG4gICAgICBpZiAob3ZlcmxhcCAIDAgfHwgbWFudWFsKSB7XG4gICAgICAgIGZyYW1lID0gKytfc2VsZi5mcmFtZTtcbiAgICAgICAgX2RlbHRhID0gdGltZSAtIF9zZWxmLnRpbWUgKiAxMDAwO1xuICAgICAgICBfc2VsZi50aW1lID0gdGltZSA9IHRpbWUgLyAxMDAwO1xuICAgICAgICBfbmV4dFRpbWUgKz0gb3ZlcmxhcCArIChvdmVybGFwID49IF9nYXAgPyA0IDogX2dhcCAtIG92ZXJsYXApO1xuICAgICAgICBkaXNwYXRjaCA9IDE7XG4gICAgICB9XG5cbiAgICAgIG1hbnVhbCB8fCAoX2lkID0gX3JlcShfdGljaykpO1xuXG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgZm9yIChfaSA9IDA7IF9pIDwgX2xpc3RlbmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBfbGlzdGVuZXJzW19pXSh0aW1lLCBfZGVsdGEsIGZyYW1lLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfc2VsZiA9IHtcbiAgICAgIHRpbWU6IDAsXG4gICAgICBmcmFtZTogMCxcbiAgICAgIHRpY2s6IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICAgIF90aWNrKHRydWUpO1xuICAgICAgfSxcbiAgICAgIGRlbHRhUmF0aW86IGZ1bmN0aW9uIGRlbHRhUmF0aW8oZnBzKSB7XG4gICAgICAgIHJldHVybiBfZGVsdGEgLyAoMTAwMCAvIChmcHMgfHwgNjApKTtcbiAgICAgIH0sXG4gICAgICB3YWtlOiBmdW5jdGlvbiB3YWtlKCkge1xuICAgICAgICBpZiAoX2NvcmVSZWFkeSkge1xuICAgICAgICAgIGlmICghX2NvcmVJbml0dGVkICYmIF93aW5kb3dFeGlzdHMoKSkge1xuICAgICAgICAgICAgX3dpbiA9IF9jb3JlSW5pdHRlZCA9IHdpbmRvdztcbiAgICAgICAgICAgIF9kb2MgPSBfd2luLmRvY3VtZW50IHx8IHt9O1xuICAgICAgICAgICAgX2dsb2JhbHMuZ3NhcCA9IGdzYXA7XG4gICAgICAgICAgICAoX3dpbi5nc2FwVmVyc2lvbnMgfHwgKF93aW4uZ3NhcFZlcnNpb25zID0gW10pKS5wdXNoKGdzYXAudmVyc2lvbik7XG5cbiAgICAgICAgICAgIF9pbnN0YWxsKF9pbnN0YWxsU2NvcGUgfHwgX3dpbi5HcmVlblNvY2tHbG9iYWxzIHx8ICFfd2luLmdzYXAgJiYgX3dpbiB8fCB7fSk7XG5cbiAgICAgICAgICAgIF9yYWYgPSBfd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfaWQgJiYgX3NlbGYuc2xlZXAoKTtcblxuICAgICAgICAgIF9yZXEgPSBfcmFmIHx8IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmLCBfbmV4dFRpbWUgLSBfc2VsZi50aW1lICogMTAwMCArIDEgfCAwKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RpY2tlckFjdGl2ZSA9IDE7XG5cbiAgICAgICAgICBfdGljaygyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNsZWVwOiBmdW5jdGlvbiBzbGVlcCgpIHtcbiAgICAgICAgKF9yYWYgPyBfd2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lIDogY2xlYXJUaW1lb3V0KShfaWQpO1xuICAgICAgICBfdGlja2VyQWN0aXZlID0gMDtcbiAgICAgICAgX3JlcSA9IF9lbXB0eUZ1bmM7XG4gICAgICB9LFxuICAgICAgbGFnU21vb3RoaW5nOiBmdW5jdGlvbiBsYWdTbW9vdGhpbmcodGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuICAgICAgICBfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEgLyBfdGlueU51bTtcbiAgICAgICAgX2FkanVzdGVkTGFnID0gTWF0aC5taW4oYWRqdXN0ZWRMYWcsIF9sYWdUaHJlc2hvbGQsIDApO1xuICAgICAgfSxcbiAgICAgIGZwczogZnVuY3Rpb24gZnBzKF9mcHMpIHtcbiAgICAgICAgX2dhcCA9IDEwMDAgLyAoX2ZwcyB8fCAyNDApO1xuICAgICAgICBfbmV4dFRpbWUgPSBfc2VsZi50aW1lICogMTAwMCArIF9nYXA7XG4gICAgICB9LFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoY2FsbGJhY2ssIG9uY2UsIHByaW9yaXRpemUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBvbmNlID8gZnVuY3Rpb24gKHQsIGQsIGYsIHYpIHtcbiAgICAgICAgICBjYWxsYmFjayh0LCBkLCBmLCB2KTtcblxuICAgICAgICAgIF9zZWxmLnJlbW92ZShmdW5jKTtcbiAgICAgICAgfSA6IGNhbGxiYWNrO1xuXG4gICAgICAgIF9zZWxmLnJlbW92ZShjYWxsYmFjayk7XG5cbiAgICAgICAgX2xpc3RlbmVyc1twcmlvcml0aXplID8gXCJ1bnNoaWZ0XCIgOiBcInB1c2hcIl0oZnVuYyk7XG5cbiAgICAgICAgX3dha2UoKTtcblxuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjYWxsYmFjaywgaSkge1xuICAgICAgICBKGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSAPSBpICYmIF9pLS07XG4gICAgICB9LFxuICAgICAgX2xpc3RlbmVyczogX2xpc3RlbmVyc1xuICAgIH07XG4gICAgcmV0dXJuIF9zZWxmO1xuICB9KCksXG4gICAgICBfd2FrZSA9IGZ1bmN0aW9uIF93YWtlKCkge1xuICAgIHJldHVybiAhX3RpY2tlckFjdGl2ZSAmJiBfdGlja2VyLndha2UoKTtcbiAgfSxcbiAgICAgIF9lYXNlTWFwID0ge30sXG4gICAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuICAgICAgX3F1b3Rlc0V4cCA9IC9bXCInXS9nLFxuICAgICAgX3BhcnNlT2JqZWN0SW5TdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VPYmplY3RJblN0cmluZyh2YWx1ZSkge1xuICAgIHZhciBvYmogPSB7fSxcbiAgICAgICAgc3BsaXQgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMykuc3BsaXQoXCI6XCIpLFxuICAgICAgICBrZXkgPSBzcGxpdFswXSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIGwgPSBzcGxpdC5sZW5ndGgsXG4gICAgICAgIGluZGV4LFxuICAgICAgICB2YWwsXG4gICAgICAgIHBhcnNlZFZhbDtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YWwgPSBzcGxpdFtpXTtcbiAgICAgIGluZGV4ID0gaSAhPT0gbCAtIDEgPyB2YWwubGFzdEluZGV4T2YoXCIsXCIpIDogdmFsLmxlbmd0aDtcbiAgICAgIHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgb2JqW2tleV0gPSBpc05hTihwYXJzZWRWYWwpID8gcGFyc2VkVmFsLnJlcGxhY2UoX3F1b3Rlc0V4cCwgXCJcIikudHJpbSgpIDogK3BhcnNlZFZhbDtcbiAgICAgIGtleSA9IHZhbC5zdWJzdHIoaW5kZXggKyAxKS50cmltKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfSxcbiAgICAgIF92YWx1ZUluUGFyZW50aGVzZXMgPSBmdW5jdGlvbiBfdmFsdWVJblBhcmVudGhlc2VzKHZhbHVlKSB7XG4gICAgdmFyIG9wZW4gPSB2YWx1ZS5pbmRleE9mKFwiKFwiKSArIDEsXG4gICAgICAgIGNsb3NlID0gdmFsdWUuaW5kZXhPZihcIilcIiksXG4gICAgICAgIG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcob3Blbiwgfm5lc3RlZCAmJiBuZXN0ZWQgPCBjbG9zZSA/IHZhbHVlLmluZGV4T2YoXCIpXCIsIGNsb3NlICsgMSkgOiBjbG9zZSk7XG4gIH0sXG4gICAgICBfY29uZmlnRWFzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiBfY29uZmlnRWFzZUZyb21TdHJpbmcobmFtZSkge1xuICAgIHZhciBzcGxpdCA9IChuYW1lICsgXCJcIikuc3BsaXQoXCIoXCIpLFxuICAgICAgICBlYXNlID0gX2Vhc2VNYXBbc3BsaXRbMF1dO1xuICAgIHJldHVybiBlYXNlICYmIHNwbGl0Lmxlbmd0aCAIDEgJiYgZWFzZS5jb25maWcgPyBlYXNlLmNvbmZpZy5hcHBseShudWxsLCBbmFtZS5pbmRleE9mKFwie1wiKSA/IFtfcGFyc2VPYmplY3RJblN0cmluZyhzcGxpdFsxXSldIDogX3ZhbHVlSW5QYXJlbnRoZXNlcyhuYW1lKS5zcGxpdChcIixcIikubWFwKF9udW1lcmljSWZQb3NzaWJsZSkpIDogX2Vhc2VNYXAuX0NFICYmIF9jdXN0b21FYXNlRXhwLnRlc3QobmFtZSkgPyBfZWFzZU1hcC5fQ0UoXCJcIiwgbmFtZSkgOiBlYXNlO1xuICB9LFxuICAgICAgX2ludmVydEVhc2UgPSBmdW5jdGlvbiBfaW52ZXJ0RWFzZShlYXNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHApO1xuICAgIH07XG4gIH0sXG4gICAgICBfcHJvcGFnYXRlWW95b0Vhc2UgPSBmdW5jdGlvbiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95bykge1xuICAgIHZhciBjaGlsZCA9IHRpbWVsaW5lLl9maXJzdCxcbiAgICAgICAgZWFzZTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGltZWxpbmUpIHtcbiAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC52YXJzLnlveW9FYXNlICYmICghY2hpbGQuX3lveW8gfHwgIWNoaWxkLl9yZXBlYXQpICYmIGNoaWxkLl95b3lvICE9PSBpc1lveW8pIHtcbiAgICAgICAgaWYgKGNoaWxkLnRpbWVsaW5lKSB7XG4gICAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVhc2UgPSBjaGlsZC5fZWFzZTtcbiAgICAgICAgICBjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbiAgICAgICAgICBjaGlsZC5feUVhc2UgPSBlYXNlO1xuICAgICAgICAgIGNoaWxkLl95b3lvID0gaXNZb3lvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuICB9LFxuICAgICAgX3BhcnNlRWFzZSA9IGZ1bmN0aW9uIF9wYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcbiAgICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xuICB9LFxuICAgICAgX2luc2VydEVhc2UgPSBmdW5jdGlvbiBfaW5zZXJ0RWFzZShuYW1lcywgZWFzZUluLCBlYXNlT3V0LCBlYXNlSW5PdXQpIHtcbiAgICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgICAgIHJldHVybiAxIC0gZWFzZUluKDEgLSBwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGVhc2VJbk91dCA9PT0gdm9pZCAwKSB7XG4gICAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgICByZXR1cm4gcCA8IC41ID8gZWFzZUluKHAgKiAyKSAvIDIgOiAxIC0gZWFzZUluKCgxIC0gcCkgKiAyKSAvIDI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBlYXNlID0ge1xuICAgICAgZWFzZUluOiBlYXNlSW4sXG4gICAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgICAgZWFzZUluT3V0OiBlYXNlSW5PdXRcbiAgICB9LFxuICAgICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gICAgX2ZvckVhY2hOYW1lKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX2Vhc2VNYXBbbmFtZV0gPSBfZ2xvYmFsc1tuYW1lXSA9IGVhc2U7XG4gICAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICAgIGZvciAodmFyIHAgaW4gZWFzZSkge1xuICAgICAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lICsgKHAgPT09IFwiZWFzZUluXCIgPyBcIi5pblwiIDogcCA9PT0gXCJlYXNlT3V0XCIgPyBcIi5vdXRcIiA6IFwiLmluT3V0XCIpXSA9IF9lYXNlTWFwW25hbWUgKyBcIi5cIiArIHBdID0gZWFzZVtwXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlYXNlO1xuICB9LFxuICAgICAgX2Vhc2VJbk91dEZyb21PdXQgPSBmdW5jdGlvbiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgICB9O1xuICB9LFxuICAgICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICAgIHZhciBwMSA9IGFtcGxpdHVkZSAPSAxID8gYW1wbGl0dWRlIDogMSxcbiAgICAgICAgcDIgPSAocGVyaW9kIHx8ICh0eXBlID8gLjMgOiAuNDUpKSAvIChhbXBsaXR1ZGUgPCAxID8gYW1wbGl0dWRlIDogMSksXG4gICAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgICByZXR1cm4gcCA9PT0gMSA/IDEgOiBwMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogX3NpbigocCAtIHAzKSAqIHAyKSArIDE7XG4gICAgfSxcbiAgICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gICAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gICAgcDIgPSBfMlBJIC8gcDI7XG5cbiAgICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICAgICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGVhc2U7XG4gIH0sXG4gICAgICBfY29uZmlnQmFjayA9IGZ1bmN0aW9uIF9jb25maWdCYWNrKHR5cGUsIG92ZXJzaG9vdCkge1xuICAgIGlmIChvdmVyc2hvb3QgPT09IHZvaWQgMCkge1xuICAgICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgICB9XG5cbiAgICB2YXIgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gICAgfSxcbiAgICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gICAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gICAgZWFzZS5jb25maWcgPSBmdW5jdGlvbiAob3ZlcnNob290KSB7XG4gICAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGVhc2U7XG4gIH07XG5cbiAgX2ZvckVhY2hOYW1lKFwiTGluZWFyLFF1YWQsQ3ViaWMsUXVhcnQsUXVpbnQsU3Ryb25nXCIsIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgdmFyIHBvd2VyID0gaSA8IDUgPyBpICsgMSA6IGk7XG5cbiAgICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhwLCBwb3dlcik7XG4gICAgfSA6IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gcCwgcG93ZXIpO1xuICAgIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcCA8IC41ID8gTWF0aC5wb3cocCAqIDIsIHBvd2VyKSAvIDIgOiAxIC0gTWF0aC5wb3coKDEgLSBwKSAqIDIsIHBvd2VyKSAvIDI7XG4gICAgfSk7XG4gIH0pO1xuXG4gIF9lYXNlTWFwLkxpbmVhci5lYXNlTm9uZSA9IF9lYXNlTWFwLm5vbmUgPSBfZWFzZU1hcC5MaW5lYXIuZWFzZUluO1xuXG4gIF9pbnNlcnRFYXNlKFwiRWxhc3RpY1wiLCBfY29uZmlnRWxhc3RpYyhcImluXCIpLCBfY29uZmlnRWxhc3RpYyhcIm91dFwiKSwgX2NvbmZpZ0VsYXN0aWMoKSk7XG5cbiAgKGZ1bmN0aW9uIChuLCBjKSB7XG4gICAgdmFyIG4xID0gMSAvIGMsXG4gICAgICAgIG4yID0gMiAqIG4xLFxuICAgICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgICByZXR1cm4gcCA8IG4xID8gbiAqIHAgKiBwIDogcCA8IG4yID8gbiAqIE1hdGgucG93KHAgLSAxLjUgLyBjLCAyKSArIC43NSA6IHAgPCBuMyA/IG4gKiAocCAtPSAyLjI1IC8gYykgKiBwICsgLjkzNzUgOiBuICogTWF0aC5wb3cocCAtIDIuNjI1IC8gYywgMikgKyAuOTg0Mzc1O1xuICAgIH07XG5cbiAgICBfaW5zZXJ0RWFzZShcIkJvdW5jZVwiLCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgICB9LCBlYXNlT3V0KTtcbiAgfSkoNy41NjI1LCAyLjc1KTtcblxuICBfaW5zZXJ0RWFzZShcIkV4cG9cIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA/IE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwO1xuICB9KTtcblxuICBfaW5zZXJ0RWFzZShcIkNpcmNcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG4gIH0pO1xuXG4gIF9pbnNlcnRFYXNlKFwiU2luZVwiLCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IC1fY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xuICB9KTtcblxuICBfaW5zZXJ0RWFzZShcIkJhY2tcIiwgX2NvbmZpZ0JhY2soXCJpblwiKSwgX2NvbmZpZ0JhY2soXCJvdXRcIiksIF9jb25maWdCYWNrKCkpO1xuXG4gIF9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcbiAgICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyhzdGVwcywgaW1tZWRpYXRlU3RhcnQpIHtcbiAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0ZXBzID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHAxID0gMSAvIHN0ZXBzLFxuICAgICAgICAgIHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG4gICAgICAgICAgcDMgPSBpbW1lZGlhdGVTdGFydCA/IDEgOiAwLFxuICAgICAgICAgIG1heCA9IDEgLSBfdGlueU51bTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gKChwMiAqIF9jbGFtcCgwLCBtYXgsIHApIHwgMCkgKyBwMykgKiBwMTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfZGVmYXVsdHMuZWFzZSA9IF9lYXNlTWFwW1wicXVhZC5vdXRcIl07XG5cbiAgX2ZvckVhY2hOYW1lKFwib25Db21wbGV0ZSxvblVwZGF0ZSxvblN0YXJ0LG9uUmVwZWF0LG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIF9jYWxsYmFja05hbWVzICs9IG5hbWUgKyBcIixcIiArIG5hbWUgKyBcIlBhcmFtcyxcIjtcbiAgfSk7XG5cbiAgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xuICAgIHRoaXMuaWQgPSBfZ3NJRCsrO1xuICAgIHRhcmdldC5fZ3NhcCA9IHRoaXM7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5oYXJuZXNzID0gaGFybmVzcztcbiAgICB0aGlzLmdldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldCA6IF9nZXRQcm9wZXJ0eTtcbiAgICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG4gIH07XG4gIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKHZhcnMpIHtcbiAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgICB0aGlzLl9kZWxheSA9ICt2YXJzLmRlbGF5IHx8IDA7XG5cbiAgICAgIGlmICh0aGlzLl9yZXBlYXQgPSB2YXJzLnJlcGVhdCA9PT0gSW5maW5pdHkgPyAtMiA6IHZhcnMucmVwZWF0IHx8IDApIHtcbiAgICAgICAgdGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xuICAgICAgICB0aGlzLl95b3lvID0gISF2YXJzLnlveW8gfHwgISF2YXJzLnlveW9FYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90cyA9IDE7XG5cbiAgICAgIF9zZXREdXJhdGlvbih0aGlzLCArdmFycy5kdXJhdGlvbiwgMSwgMSk7XG5cbiAgICAgIHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcbiAgICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIHRoaXMuc3RhcnRUaW1lKHRoaXMuX3N0YXJ0ICsgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gICAgfTtcblxuICAgIF9wcm90by5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxEdXJhdGlvbih0aGlzLl9yZXBlYXQgPiAwID8gdmFsdWUgKyAodmFsdWUgKyB0aGlzLl9yRGVsYXkpICogdGhpcy5fcmVwZWF0IDogdmFsdWUpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgJiYgdGhpcy5fZHVyO1xuICAgIH07XG5cbiAgICBfcHJvdG8udG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdER1cjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGlydHkgPSAwO1xuICAgICAgcmV0dXJuIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9yZXBlYXQgPCAwID8gdmFsdWUgOiAodmFsdWUgLSB0aGlzLl9yZXBlYXQgKiB0aGlzLl9yRGVsYXkpIC8gKHRoaXMuX3JlcGVhdCArIDEpKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgICAgX3dha2UoKTtcblxuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX2RwO1xuXG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLl90cykge1xuICAgICAgICBfYWxpZ25QbGF5aGVhZCh0aGlzLCBfdG90YWxUaW1lKTtcblxuICAgICAgICAhcGFyZW50Ll9kcCB8fCBwYXJlbnQucGFyZW50IHx8IF9wb3N0QWRkQ2hlY2tzKHBhcmVudCwgdGhpcyk7XG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5wYXJlbnQuX3RpbWUgIT09IHBhcmVudC5fc3RhcnQgKyAocGFyZW50Ll90cyAPSAwID8gcGFyZW50Ll90VGltZSAvIHBhcmVudC5fdHMgOiAocGFyZW50LnRvdGFsRHVyYXRpb24oKSAtIHBhcmVudC5fdFRpbWUpIC8gLXBhcmVudC5fdHMpKSB7XG4gICAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGFyZW50ICYmIHRoaXMuX2RwLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiAodGhpcy5fdHMgPiAwICYmIF90b3RhbFRpbWUgPCB0aGlzLl90RHVyIHx8IHRoaXMuX3RzIDwgMCAmJiBfdG90YWxUaW1lID4gMCB8fCAhdGhpcy5fdER1ciAmJiAhX3RvdGFsVGltZSkpIHtcbiAgICAgICAgICBfYWRkVG9UaW1lbGluZSh0aGlzLl9kcCwgdGhpcywgdGhpcy5fc3RhcnQgLSB0aGlzLl9kZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3RUaW1lICE9PSBfdG90YWxUaW1lIHx8ICF0aGlzLl9kdXIgJiYgIXN1cHByZXNzRXZlbnRzIHx8IHRoaXMuX2luaXR0ZWQgJiYgTWF0aC5hYnModGhpcy5felRpbWUpID09PSBfdGlueU51bSB8fCAhX3RvdGFsVGltZSAmJiAhdGhpcy5faW5pdHRlZCAmJiAodGhpcy5hZGQgfHwgdGhpcy5fcHRMb29rdXApKSB7XG4gICAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpO1xuXG4gICAgICAgIF9sYXp5U2FmZVJlbmRlcih0aGlzLCBfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8udGltZSA9IGZ1bmN0aW9uIHRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKE1hdGgubWluKHRoaXMudG90YWxEdXJhdGlvbigpLCB2YWx1ZSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSkgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSB8fCAodmFsdWUgPyB0aGlzLl9kdXIgOiAwKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fdGltZTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbiB0b3RhbFByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RUaW1lIC8gdGhpcy5fdER1cikgOiB0aGlzLnJhdGlvO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBwcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpICogKHRoaXMuX3lveW8gJiYgISh0aGlzLml0ZXJhdGlvbigpICYgMSkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcyksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuZHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RpbWUgLyB0aGlzLl9kdXIpIDogdGhpcy5yYXRpbztcbiAgICB9O1xuXG4gICAgX3Byb3RvLml0ZXJhdGlvbiA9IGZ1bmN0aW9uIGl0ZXJhdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIHZhciBjeWNsZUR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWUgKyAodmFsdWUgLSAxKSAqIGN5Y2xlRHVyYXRpb24sIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbikgKyAxIDogMTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRpbWVTY2FsZSA9IGZ1bmN0aW9uIHRpbWVTY2FsZSh2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydHMgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgdFRpbWUgPSB0aGlzLnBhcmVudCAmJiB0aGlzLl90cyA/IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRoaXMucGFyZW50Ll90aW1lLCB0aGlzKSA6IHRoaXMuX3RUaW1lO1xuICAgICAgdGhpcy5fcnRzID0gK3ZhbHVlIHx8IDA7XG4gICAgICB0aGlzLl90cyA9IHRoaXMuX3BzIHx8IHZhbHVlID09PSAtX3RpbnlOdW0gPyAwIDogdGhpcy5fcnRzO1xuICAgICAgdGhpcy50b3RhbFRpbWUoX2NsYW1wKC10aGlzLl9kZWxheSwgdGhpcy5fdER1ciwgdFRpbWUpLCB0cnVlKTtcblxuICAgICAgX3NldEVuZCh0aGlzKTtcblxuICAgICAgcmV0dXJuIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucGF1c2VkID0gZnVuY3Rpb24gcGF1c2VkKHZhbHVlKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3BzID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTtcbiAgICAgICAgICB0aGlzLl90cyA9IHRoaXMuX2FjdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3dha2UoKTtcblxuICAgICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzO1xuICAgICAgICAgIHRoaXMudG90YWxUaW1lKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMucmF3VGltZSgpIDogdGhpcy5fdFRpbWUgfHwgdGhpcy5fcFRpbWUsIHRoaXMucHJvZ3Jlc3MoKSA9PT0gMSAmJiBNYXRoLmFicyh0aGlzLl96VGltZSkgIT09IF90aW55TnVtICYmICh0aGlzLl90VGltZSAtPSBfdGlueU51bSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9zdGFydCA9IHZhbHVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICAgIHBhcmVudCAmJiAocGFyZW50Ll9zb3J0IHx8ICF0aGlzLnBhcmVudCkgJiYgX2FkZFRvVGltZWxpbmUocGFyZW50LCB0aGlzLCB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zdGFydDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnQgKyAoX2lzTm90RmFsc2UoaW5jbHVkZVJlcGVhdHMpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLmR1cmF0aW9uKCkpIC8gTWF0aC5hYnModGhpcy5fdHMgfHwgMSk7XG4gICAgfTtcblxuICAgIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwO1xuICAgICAgcmV0dXJuICFwYXJlbnQgPyB0aGlzLl90VGltZSA6IHdyYXBSZXBlYXRzICYmICghdGhpcy5fdHMgfHwgdGhpcy5fcmVwZWF0ICYmIHRoaXMuX3RpbWUgJiYgdGhpcy50b3RhbFByb2dyZXNzKCkgPCAxKSA/IHRoaXMuX3RUaW1lICUgKHRoaXMuX2R1ciArIHRoaXMuX3JEZWxheSkgOiAhdGhpcy5fdHMgPyB0aGlzLl90VGltZSA6IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudC5yYXdUaW1lKHdyYXBSZXBlYXRzKSwgdGhpcyk7XG4gICAgfTtcblxuICAgIF9wcm90by5nbG9iYWxUaW1lID0gZnVuY3Rpb24gZ2xvYmFsVGltZShyYXdUaW1lKSB7XG4gICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcyxcbiAgICAgICAgICB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xuXG4gICAgICB3aGlsZSAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHRpbWUgPSBhbmltYXRpb24uX3N0YXJ0ICsgdGltZSAvIChhbmltYXRpb24uX3RzIHx8IDEpO1xuICAgICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGltZTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlcGVhdCA9IGZ1bmN0aW9uIHJlcGVhdCh2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdmFsdWUgPT09IEluZmluaXR5ID8gLTIgOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXBlYXQgPT09IC0yID8gSW5maW5pdHkgOiB0aGlzLl9yZXBlYXQ7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXBlYXREZWxheSA9IGZ1bmN0aW9uIHJlcGVhdERlbGF5KHZhbHVlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGltZSA9IHRoaXMuX3RpbWU7XG4gICAgICAgIHRoaXMuX3JEZWxheSA9IHZhbHVlO1xuXG4gICAgICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRpbWUgPyB0aGlzLnRpbWUodGltZSkgOiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fckRlbGF5O1xuICAgIH07XG5cbiAgICBfcHJvdG8ueW95byA9IGZ1bmN0aW9uIHlveW8odmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3lveW8gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl95b3lvO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc2VlayA9IGZ1bmN0aW9uIHNlZWsocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmVzdGFydCA9IGZ1bmN0aW9uIHJlc3RhcnQoaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuICAgICAgcmV0dXJuIHRoaXMucGxheSgpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucGxheSA9IGZ1bmN0aW9uIHBsYXkoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuICAgICAgZnJvbSAhPSBudWxsICYmIHRoaXMuc2Vlayhmcm9tIHx8IHRoaXMudG90YWxEdXJhdGlvbigpLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucGF1c2UgPSBmdW5jdGlvbiBwYXVzZShhdFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICBhdFRpbWUgIT0gbnVsbCAmJiB0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgICByZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmV2ZXJzZWQgPSBmdW5jdGlvbiByZXZlcnNlZCh2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgISF2YWx1ZSAhPT0gdGhpcy5yZXZlcnNlZCgpICYmIHRoaXMudGltZVNjYWxlKC10aGlzLl9ydHMgfHwgKHZhbHVlID8gLV90aW55TnVtIDogMCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3J0cyA8IDA7XG4gICAgfTtcblxuICAgIF9wcm90by5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICAgIHRoaXMuX2luaXR0ZWQgPSB0aGlzLl9hY3QgPSAwO1xuICAgICAgdGhpcy5felRpbWUgPSAtX3RpbnlOdW07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHAsXG4gICAgICAgICAgc3RhcnQgPSB0aGlzLl9zdGFydCxcbiAgICAgICAgICByYXdUaW1lO1xuICAgICAgcmV0dXJuICEhKCFwYXJlbnQgfHwgdGhpcy5fdHMgJiYgdGhpcy5faW5pdHRlZCAmJiBwYXJlbnQuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHBhcmVudC5yYXdUaW1lKHRydWUpKSAPSBzdGFydCAmJiByYXdUaW1lIDwgdGhpcy5lbmRUaW1lKHRydWUpIC0gX3RpbnlOdW0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIGV2ZW50Q2FsbGJhY2sodHlwZSwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgICAgdmFyIHZhcnMgPSB0aGlzLnZhcnM7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgZGVsZXRlIHZhcnNbdHlwZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyc1t0eXBlXSA9IGNhbGxiYWNrO1xuICAgICAgICAgIHBhcmFtcyAmJiAodmFyc1t0eXBlICsgXCJQYXJhbXNcIl0gPSBwYXJhbXMpO1xuICAgICAgICAgIHR5cGUgPT09IFwib25VcGRhdGVcIiAmJiAodGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhcnNbdHlwZV07XG4gICAgfTtcblxuICAgIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciBmID0gX2lzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiBfcGFzc1Rocm91Z2gsXG4gICAgICAgICAgICBfcmVzb2x2ZSA9IGZ1bmN0aW9uIF9yZXNvbHZlKCkge1xuICAgICAgICAgIHZhciBfdGhlbiA9IHNlbGYudGhlbjtcbiAgICAgICAgICBzZWxmLnRoZW4gPSBudWxsO1xuICAgICAgICAgIF9pc0Z1bmN0aW9uKGYpICYmIChmID0gZihzZWxmKSkgJiYgKGYudGhlbiB8fCBmID09PSBzZWxmKSAmJiAoc2VsZi50aGVuID0gX3RoZW4pO1xuICAgICAgICAgIHJlc29sdmUoZik7XG4gICAgICAgICAgc2VsZi50aGVuID0gX3RoZW47XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHNlbGYuX2luaXR0ZWQgJiYgc2VsZi50b3RhbFByb2dyZXNzKCkgPT09IDEgJiYgc2VsZi5fdHMgPj0gMCB8fCAhc2VsZi5fdFRpbWUgJiYgc2VsZi5fdHMgPCAwKSB7XG4gICAgICAgICAgX3Jlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLl9wcm9tID0gX3Jlc29sdmU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8ua2lsbCA9IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICBfaW50ZXJydXB0KHRoaXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQW5pbWF0aW9uO1xuICB9KCk7XG5cbiAgX3NldERlZmF1bHRzKEFuaW1hdGlvbi5wcm90b3R5cGUsIHtcbiAgICBfdGltZTogMCxcbiAgICBfc3RhcnQ6IDAsXG4gICAgX2VuZDogMCxcbiAgICBfdFRpbWU6IDAsXG4gICAgX3REdXI6IDAsXG4gICAgX2RpcnR5OiAwLFxuICAgIF9yZXBlYXQ6IDAsXG4gICAgX3lveW86IGZhbHNlLFxuICAgIHBhcmVudDogbnVsbCxcbiAgICBfaW5pdHRlZDogZmFsc2UsXG4gICAgX3JEZWxheTogMCxcbiAgICBfdHM6IDEsXG4gICAgX2RwOiAwLFxuICAgIHJhdGlvOiAwLFxuICAgIF96VGltZTogLV90aW55TnVtLFxuICAgIF9wcm9tOiAwLFxuICAgIF9wczogZmFsc2UsXG4gICAgX3J0czogMVxuICB9KTtcblxuICB2YXIgVGltZWxpbmUgPSBmdW5jdGlvbiAoX0FuaW1hdGlvbikge1xuICAgIF9pbmhlcml0c0xvb3NlKFRpbWVsaW5lLCBfQW5pbWF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIFRpbWVsaW5lKHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgICAgdmFycyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBfdGhpcyA9IF9BbmltYXRpb24uY2FsbCh0aGlzLCB2YXJzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMubGFiZWxzID0ge307XG4gICAgICBfdGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9ICEhdmFycy5zbW9vdGhDaGlsZFRpbWluZztcbiAgICAgIF90aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICEhdmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW47XG4gICAgICBfdGhpcy5fc29ydCA9IF9pc05vdEZhbHNlKHZhcnMuc29ydENoaWxkcmVuKTtcbiAgICAgIF9nbG9iYWxUaW1lbGluZSAmJiBfYWRkVG9UaW1lbGluZSh2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBwb3NpdGlvbik7XG4gICAgICB2YXJzLnJldmVyc2VkICYmIF90aGlzLnJldmVyc2UoKTtcbiAgICAgIHZhcnMucGF1c2VkICYmIF90aGlzLnBhdXNlZCh0cnVlKTtcbiAgICAgIHZhcnMuc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgdmFycy5zY3JvbGxUcmlnZ2VyKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvMiA9IFRpbWVsaW5lLnByb3RvdHlwZTtcblxuICAgIF9wcm90bzIudG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgICAgX2NyZWF0ZVR3ZWVuVHlwZSgwLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgICAgX2NyZWF0ZVR3ZWVuVHlwZSgxLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcbiAgICAgIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICAgIHZhcnMucGFyZW50ID0gdGhpcztcbiAgICAgIF9pbmhlcml0RGVmYXVsdHModmFycykucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICEhdmFycy5pbW1lZGlhdGVSZW5kZXI7XG4gICAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmNhbGwgPSBmdW5jdGlvbiBjYWxsKGNhbGxiYWNrLCBwYXJhbXMsIHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2ssIHBhcmFtcyksIHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5zdGFnZ2VyVG8gPSBmdW5jdGlvbiBzdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgICB2YXJzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICB2YXJzLnN0YWdnZXIgPSB2YXJzLnN0YWdnZXIgfHwgc3RhZ2dlcjtcbiAgICAgIHZhcnMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVBbGw7XG4gICAgICB2YXJzLm9uQ29tcGxldGVQYXJhbXMgPSBvbkNvbXBsZXRlQWxsUGFyYW1zO1xuICAgICAgdmFycy5wYXJlbnQgPSB0aGlzO1xuICAgICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgICAgdmFycy5ydW5CYWNrd2FyZHMgPSAxO1xuICAgICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZSh2YXJzLmltbWVkaWF0ZVJlbmRlcik7XG4gICAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24gc3RhZ2dlckZyb21Ubyh0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICAgIHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG4gICAgICBfaW5oZXJpdERlZmF1bHRzKHRvVmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodG9WYXJzLmltbWVkaWF0ZVJlbmRlcik7XG4gICAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgICB0RHVyID0gdGhpcy5fZGlydHkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuX3REdXIsXG4gICAgICAgICAgZHVyID0gdGhpcy5fZHVyLFxuICAgICAgICAgIHRUaW1lID0gdG90YWxUaW1lIDw9IDAgPyAwIDogX3JvdW5kUHJlY2lzZSh0b3RhbFRpbWUpLFxuICAgICAgICAgIGNyb3NzaW5nU3RhcnQgPSB0aGlzLl96VGltZSA8IDAgIT09IHRvdGFsVGltZSA8IDAgJiYgKHRoaXMuX2luaXR0ZWQgfHwgIWR1ciksXG4gICAgICAgICAgdGltZSxcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICBuZXh0LFxuICAgICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uLFxuICAgICAgICAgIHByZXZQYXVzZWQsXG4gICAgICAgICAgcGF1c2VUd2VlbixcbiAgICAgICAgICB0aW1lU2NhbGUsXG4gICAgICAgICAgcHJldlN0YXJ0LFxuICAgICAgICAgIHByZXZJdGVyYXRpb24sXG4gICAgICAgICAgeW95byxcbiAgICAgICAgICBpc1lveW87XG4gICAgICB0aGlzICE9PSBfZ2xvYmFsVGltZWxpbmUgJiYgdFRpbWUgPiB0RHVyICYmIHRvdGFsVGltZSAPSAwICYmICh0VGltZSA9IHREdXIpO1xuXG4gICAgICBpZiAodFRpbWUgIT09IHRoaXMuX3RUaW1lIHx8IGZvcmNlIHx8IGNyb3NzaW5nU3RhcnQpIHtcbiAgICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmIGR1cikge1xuICAgICAgICAgIHRUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgICAgICB0b3RhbFRpbWUgKz0gdGhpcy5fdGltZSAtIHByZXZUaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgICBwcmV2U3RhcnQgPSB0aGlzLl9zdGFydDtcbiAgICAgICAgdGltZVNjYWxlID0gdGhpcy5fdHM7XG4gICAgICAgIHByZXZQYXVzZWQgPSAhdGltZVNjYWxlO1xuXG4gICAgICAgIGlmIChjcm9zc2luZ1N0YXJ0KSB7XG4gICAgICAgICAgZHVyIHx8IChwcmV2VGltZSA9IHRoaXMuX3pUaW1lKTtcbiAgICAgICAgICAodG90YWxUaW1lIHx8ICFzdXBwcmVzc0V2ZW50cykgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgICB5b3lvID0gdGhpcy5feW95bztcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbiA9IH5KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuICAgICAgICAgICFwcmV2VGltZSAmJiB0aGlzLl90VGltZSAmJiBwcmV2SXRlcmF0aW9uICE9PSBpdGVyYXRpb24gJiYgKHByZXZJdGVyYXRpb24gPSBpdGVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKHlveW8gJiYgaXRlcmF0aW9uICYgMSkge1xuICAgICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgICBpc1lveW8gPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICAgIHZhciByZXdpbmRpbmcgPSB5b3lvICYmIHByZXZJdGVyYXRpb24gJiAxLFxuICAgICAgICAgICAgICAgIGRvZXNXcmFwID0gcmV3aW5kaW5nID09PSAoeW95byAmJiBpdGVyYXRpb24gJiAxKTtcbiAgICAgICAgICAgIGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuICAgICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyAwIDogZHVyO1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IDE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSB8fCAoaXNZb3lvID8gMCA6IF9yb3VuZFByZWNpc2UoaXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbikpLCBzdXBwcmVzc0V2ZW50cywgIWR1cikuX2xvY2sgPSAwO1xuICAgICAgICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgICAgICAgICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcbiAgICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2VGltZSAmJiBwcmV2VGltZSAhPT0gdGhpcy5fdGltZSB8fCBwcmV2UGF1c2VkICE9PSAhdGhpcy5fdHMgfHwgdGhpcy52YXJzLm9uUmVwZWF0ICYmICF0aGlzLnBhcmVudCAmJiAhdGhpcy5fYWN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkdXIgPSB0aGlzLl9kdXI7XG4gICAgICAgICAgICB0RHVyID0gdGhpcy5fdER1cjtcblxuICAgICAgICAgICAgaWYgKGRvZXNXcmFwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xvY2sgPSAyO1xuICAgICAgICAgICAgICBwcmV2VGltZSA9IHJld2luZGluZyA/IGR1ciA6IC0wLjAwMDE7XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZSh0aGlzLCBpc1lveW8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZyAmJiB0aGlzLl9sb2NrIDwgMikge1xuICAgICAgICAgIHBhdXNlVHdlZW4gPSBfZmluZE5leHRQYXVzZVR3ZWVuKHRoaXMsIF9yb3VuZFByZWNpc2UocHJldlRpbWUpLCBfcm91bmRQcmVjaXNlKHRpbWUpKTtcblxuICAgICAgICAgIGlmIChwYXVzZVR3ZWVuKSB7XG4gICAgICAgICAgICB0VGltZSAtPSB0aW1lIC0gKHRpbWUgPSBwYXVzZVR3ZWVuLl9zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMuX2FjdCA9ICF0aW1lU2NhbGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgICAgdGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG4gICAgICAgICAgdGhpcy5faW5pdHRlZCA9IDE7XG4gICAgICAgICAgdGhpcy5felRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICAgICAgcHJldlRpbWUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcmV2VGltZSAmJiB0aW1lICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uU3RhcnRcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGltZSAPSBwcmV2VGltZSAmJiB0b3RhbFRpbWUgPj0gMCkge1xuICAgICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cbiAgICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICAgICAgICAgICAgaWYgKChjaGlsZC5fYWN0IHx8IHRpbWUgPj0gY2hpbGQuX3N0YXJ0KSAmJiBjaGlsZC5fdHMgJiYgcGF1c2VUd2VlbiAhPT0gY2hpbGQpIHtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjaGlsZC5yZW5kZXIoY2hpbGQuX3RzID4gMCA/ICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSAtX3RpbnlOdW0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGQgPSB0aGlzLl9sYXN0O1xuICAgICAgICAgIHZhciBhZGp1c3RlZFRpbWUgPSB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZTtcblxuICAgICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgICAgbmV4dCA9IGNoaWxkLl9wcmV2O1xuXG4gICAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgYWRqdXN0ZWRUaW1lIDw9IGNoaWxkLl9lbmQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKGFkanVzdGVkVGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSBhZGp1c3RlZFRpbWUgPyAtX3RpbnlOdW0gOiBfdGlueU51bSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXVzZVR3ZWVuICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICBwYXVzZVR3ZWVuLnJlbmRlcih0aW1lID49IHByZXZUaW1lID8gMCA6IC1fdGlueU51bSkuX3pUaW1lID0gdGltZSAPSBwcmV2VGltZSA/IDEgOiAtMTtcblxuICAgICAgICAgIGlmICh0aGlzLl90cykge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBwcmV2U3RhcnQ7XG5cbiAgICAgICAgICAgIF9zZXRFbmQodGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIsIHRydWUpO1xuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIgJiYgdGhpcy5fdFRpbWUgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkgfHwgIXRUaW1lICYmIHByZXZUaW1lKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydCB8fCBNYXRoLmFicyh0aW1lU2NhbGUpICE9PSBNYXRoLmFicyh0aGlzLl90cykpIGlmICghdGhpcy5fbG9jaykge1xuICAgICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTtcblxuICAgICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lIHx8ICF0RHVyKSkge1xuICAgICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyICYmIHRvdGFsVGltZSAPSAwID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmFkZCA9IGZ1bmN0aW9uIGFkZChjaGlsZCwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uLCBjaGlsZCkpO1xuXG4gICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcbiAgICAgICAgaWYgKF9pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5hZGQob2JqLCBwb3NpdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFkZExhYmVsKGNoaWxkLCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgICAgY2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMgIT09IGNoaWxkID8gX2FkZFRvVGltZWxpbmUodGhpcywgY2hpbGQsIHBvc2l0aW9uKSA6IHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICBpZiAobmVzdGVkID09PSB2b2lkIDApIHtcbiAgICAgICAgbmVzdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR3ZWVucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHR3ZWVucyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lbGluZXMgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lbGluZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWdub3JlQmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAtX2JpZ051bTtcbiAgICAgIH1cblxuICAgICAgdmFyIGEgPSBbXSxcbiAgICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLl9zdGFydCAPSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgICAgIHR3ZWVucyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lbGluZXMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIG5lc3RlZCAmJiBhLnB1c2guYXBwbHkoYSwgY2hpbGQuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5nZXRCeUlkID0gZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmdldENoaWxkcmVuKDEsIDEsIDEpLFxuICAgICAgICAgIGkgPSBhbmltYXRpb25zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uc1tpXS52YXJzLmlkID09PSBpZCkge1xuICAgICAgICAgIHJldHVybiBhbmltYXRpb25zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90bzIucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gICAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVMYWJlbChjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2lsbFR3ZWVuc09mKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIGNoaWxkKTtcblxuICAgICAgaWYgKGNoaWxkID09PSB0aGlzLl9yZWNlbnQpIHtcbiAgICAgICAgdGhpcy5fcmVjZW50ID0gdGhpcy5fbGFzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdFRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ZvcmNpbmcgPSAxO1xuXG4gICAgICBpZiAoIXRoaXMuX2RwICYmIHRoaXMuX3RzKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gX3RvdGFsVGltZTIgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIF90b3RhbFRpbWUyKSAvIC10aGlzLl90cykpO1xuICAgICAgfVxuXG4gICAgICBfQW5pbWF0aW9uLnByb3RvdHlwZS50b3RhbFRpbWUuY2FsbCh0aGlzLCBfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpO1xuXG4gICAgICB0aGlzLl9mb3JjaW5nID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmFkZExhYmVsID0gZnVuY3Rpb24gYWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG4gICAgICB0aGlzLmxhYmVsc1tsYWJlbF0gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5yZW1vdmVMYWJlbCA9IGZ1bmN0aW9uIHJlbW92ZUxhYmVsKGxhYmVsKSB7XG4gICAgICBkZWxldGUgdGhpcy5sYWJlbHNbbGFiZWxdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuYWRkUGF1c2UgPSBmdW5jdGlvbiBhZGRQYXVzZShwb3NpdGlvbiwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuICAgICAgdC5kYXRhID0gXCJpc1BhdXNlXCI7XG4gICAgICB0aGlzLl9oYXNQYXVzZSA9IDE7XG4gICAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5yZW1vdmVQYXVzZSA9IGZ1bmN0aW9uIHJlbW92ZVBhdXNlKHBvc2l0aW9uKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICAgIHBvc2l0aW9uID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLl9zdGFydCA9PT0gcG9zaXRpb24gJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcbiAgICAgICAgICBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8yLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgICAgdmFyIHR3ZWVucyA9IHRoaXMuZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSksXG4gICAgICAgICAgaSA9IHR3ZWVucy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gIT09IHR3ZWVuc1tpXSAmJiB0d2VlbnNbaV0ua2lsbCh0YXJnZXRzLCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmdldFR3ZWVuc09mID0gZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgICAgdmFyIGEgPSBbXSxcbiAgICAgICAgICBwYXJzZWRUYXJnZXRzID0gdG9BcnJheSh0YXJnZXRzKSxcbiAgICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICAgIGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSxcbiAgICAgICAgICBjaGlsZHJlbjtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuKSB7XG4gICAgICAgICAgaWYgKF9hcnJheUNvbnRhaW5zQW55KGNoaWxkLl90YXJnZXRzLCBwYXJzZWRUYXJnZXRzKSAmJiAoaXNHbG9iYWxUaW1lID8gKCFfb3ZlcndyaXRpbmdUd2VlbiB8fCBjaGlsZC5faW5pdHRlZCAmJiBjaGlsZC5fdHMpICYmIGNoaWxkLmdsb2JhbFRpbWUoMCkgPD0gb25seUFjdGl2ZSAmJiBjaGlsZC5nbG9iYWxUaW1lKGNoaWxkLnRvdGFsRHVyYXRpb24oKSkgPiBvbmx5QWN0aXZlIDogIW9ubHlBY3RpdmUgfHwgY2hpbGQuaXNBY3RpdmUoKSkpIHtcbiAgICAgICAgICAgIGEucHVzaChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChjaGlsZHJlbiA9IGNoaWxkLmdldFR3ZWVuc09mKHBhcnNlZFRhcmdldHMsIG9ubHlBY3RpdmUpKS5sZW5ndGgpIHtcbiAgICAgICAgICBhLnB1c2guYXBwbHkoYSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIF9wcm90bzIudHdlZW5UbyA9IGZ1bmN0aW9uIHR3ZWVuVG8ocG9zaXRpb24sIHZhcnMpIHtcbiAgICAgIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gICAgICB2YXIgdGwgPSB0aGlzLFxuICAgICAgICAgIGVuZFRpbWUgPSBfcGFyc2VQb3NpdGlvbih0bCwgcG9zaXRpb24pLFxuICAgICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcbiAgICAgICAgICBfb25TdGFydCA9IF92YXJzLm9uU3RhcnQsXG4gICAgICAgICAgb25TdGFydFBhcmFtcyA9IF92YXJzLm9uU3RhcnRQYXJhbXMsXG4gICAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3ZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICAgIGluaXR0ZWQsXG4gICAgICAgICAgdHdlZW4gPSBUd2Vlbi50byh0bCwgX3NldERlZmF1bHRzKHtcbiAgICAgICAgZWFzZTogdmFycy5lYXNlIHx8IFwibm9uZVwiLFxuICAgICAgICBsYXp5OiBmYWxzZSxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgICAgb3ZlcndyaXRlOiBcImF1dG9cIixcbiAgICAgICAgZHVyYXRpb246IHZhcnMuZHVyYXRpb24gfHwgTWF0aC5hYnMoKGVuZFRpbWUgLSAoc3RhcnRBdCAmJiBcInRpbWVcIiBpbiBzdGFydEF0ID8gc3RhcnRBdC50aW1lIDogdGwuX3RpbWUpKSAvIHRsLnRpbWVTY2FsZSgpKSB8fCBfdGlueU51bSxcbiAgICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgICB0bC5wYXVzZSgpO1xuXG4gICAgICAgICAgaWYgKCFpbml0dGVkKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSk7XG4gICAgICAgICAgICB0d2Vlbi5fZHVyICE9PSBkdXJhdGlvbiAmJiBfc2V0RHVyYXRpb24odHdlZW4sIGR1cmF0aW9uLCAwLCAxKS5yZW5kZXIodHdlZW4uX3RpbWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgaW5pdHRlZCA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX29uU3RhcnQgJiYgX29uU3RhcnQuYXBwbHkodHdlZW4sIG9uU3RhcnRQYXJhbXMgfHwgW10pO1xuICAgICAgICB9XG4gICAgICB9LCB2YXJzKSk7XG5cbiAgICAgIHJldHVybiBpbW1lZGlhdGVSZW5kZXIgPyB0d2Vlbi5yZW5kZXIoMCkgOiB0d2VlbjtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi50d2VlbkZyb21UbyA9IGZ1bmN0aW9uIHR3ZWVuRnJvbVRvKGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbiwgdmFycykge1xuICAgICAgcmV0dXJuIHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgICBzdGFydEF0OiB7XG4gICAgICAgICAgdGltZTogX3BhcnNlUG9zaXRpb24odGhpcywgZnJvbVBvc2l0aW9uKVxuICAgICAgICB9XG4gICAgICB9LCB2YXJzKSk7XG4gICAgfTtcblxuICAgIF9wcm90bzIucmVjZW50ID0gZnVuY3Rpb24gcmVjZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlY2VudDtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5uZXh0TGFiZWwgPSBmdW5jdGlvbiBuZXh0TGFiZWwoYWZ0ZXJUaW1lKSB7XG4gICAgICBpZiAoYWZ0ZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgYWZ0ZXJUaW1lID0gdGhpcy5fdGltZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGFmdGVyVGltZSkpO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLnByZXZpb3VzTGFiZWwgPSBmdW5jdGlvbiBwcmV2aW91c0xhYmVsKGJlZm9yZVRpbWUpIHtcbiAgICAgIGlmIChiZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgYmVmb3JlVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBiZWZvcmVUaW1lKSwgMSk7XG4gICAgfTtcblxuICAgIF9wcm90bzIuY3VycmVudExhYmVsID0gZnVuY3Rpb24gY3VycmVudExhYmVsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzTGFiZWwodGhpcy5fdGltZSArIF90aW55TnVtKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24gc2hpZnRDaGlsZHJlbihhbW91bnQsIGFkanVzdExhYmVscywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgICBpZ25vcmVCZWZvcmVUaW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgICAgbGFiZWxzID0gdGhpcy5sYWJlbHMsXG4gICAgICAgICAgcDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICAgIGNoaWxkLl9zdGFydCArPSBhbW91bnQ7XG4gICAgICAgICAgY2hpbGQuX2VuZCArPSBhbW91bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRqdXN0TGFiZWxzKSB7XG4gICAgICAgIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICAgICAgICBpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgICAgIGxhYmVsc1twXSArPSBhbW91bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuICAgICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfQW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIF9wcm90bzIuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihpbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAoaW5jbHVkZUxhYmVscyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluY2x1ZGVMYWJlbHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdCxcbiAgICAgICAgICBuZXh0O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuICAgICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZHAgJiYgKHRoaXMuX3RpbWUgPSB0aGlzLl90VGltZSA9IHRoaXMuX3BUaW1lID0gMCk7XG4gICAgICBpbmNsdWRlTGFiZWxzICYmICh0aGlzLmxhYmVscyA9IHt9KTtcbiAgICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG1heCA9IDAsXG4gICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgY2hpbGQgPSBzZWxmLl9sYXN0LFxuICAgICAgICAgIHByZXZTdGFydCA9IF9iaWdOdW0sXG4gICAgICAgICAgcHJldixcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBwYXJlbnQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRpbWVTY2FsZSgoc2VsZi5fcmVwZWF0IDwgMCA/IHNlbGYuZHVyYXRpb24oKSA6IHNlbGYudG90YWxEdXJhdGlvbigpKSAvIChzZWxmLnJldmVyc2VkKCkgPyAtdmFsdWUgOiB2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5fZGlydHkpIHtcbiAgICAgICAgcGFyZW50ID0gc2VsZi5wYXJlbnQ7XG5cbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgcHJldiA9IGNoaWxkLl9wcmV2O1xuICAgICAgICAgIGNoaWxkLl9kaXJ0eSAmJiBjaGlsZC50b3RhbER1cmF0aW9uKCk7XG4gICAgICAgICAgc3RhcnQgPSBjaGlsZC5fc3RhcnQ7XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPiBwcmV2U3RhcnQgJiYgc2VsZi5fc29ydCAmJiBjaGlsZC5fdHMgJiYgIXNlbGYuX2xvY2spIHtcbiAgICAgICAgICAgIHNlbGYuX2xvY2sgPSAxO1xuICAgICAgICAgICAgX2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFydCA8IDAgJiYgY2hpbGQuX3RzKSB7XG4gICAgICAgICAgICBtYXggLT0gc3RhcnQ7XG5cbiAgICAgICAgICAgIGlmICghcGFyZW50ICYmICFzZWxmLl9kcCB8fCBwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3N0YXJ0ICs9IHN0YXJ0IC8gc2VsZi5fdHM7XG4gICAgICAgICAgICAgIHNlbGYuX3RpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgICAgIHNlbGYuX3RUaW1lIC09IHN0YXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnNoaWZ0Q2hpbGRyZW4oLXN0YXJ0LCBmYWxzZSwgLTFlOTk5KTtcbiAgICAgICAgICAgIHByZXZTdGFydCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQuX2VuZCAIG1heCAmJiBjaGlsZC5fdHMgJiYgKG1heCA9IGNoaWxkLl9lbmQpO1xuICAgICAgICAgIGNoaWxkID0gcHJldjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXREdXJhdGlvbihzZWxmLCBzZWxmID09PSBfZ2xvYmFsVGltZWxpbmUgJiYgc2VsZi5fdGltZSAIG1heCA/IHNlbGYuX3RpbWUgOiBtYXgsIDEsIDEpO1xuXG4gICAgICAgIHNlbGYuX2RpcnR5ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuX3REdXI7XG4gICAgfTtcblxuICAgIFRpbWVsaW5lLnVwZGF0ZVJvb3QgPSBmdW5jdGlvbiB1cGRhdGVSb290KHRpbWUpIHtcbiAgICAgIGlmIChfZ2xvYmFsVGltZWxpbmUuX3RzKSB7XG4gICAgICAgIF9sYXp5U2FmZVJlbmRlcihfZ2xvYmFsVGltZWxpbmUsIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWUsIF9nbG9iYWxUaW1lbGluZSkpO1xuXG4gICAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSA9IF90aWNrZXIuZnJhbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkge1xuICAgICAgICBfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xuICAgICAgICB2YXIgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuICAgICAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5fdHMpIGlmIChfY29uZmlnLmF1dG9TbGVlcCAmJiBfdGlja2VyLl9saXN0ZW5lcnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkIHx8IF90aWNrZXIuc2xlZXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gVGltZWxpbmU7XG4gIH0oQW5pbWF0aW9uKTtcblxuICBfc2V0RGVmYXVsdHMoVGltZWxpbmUucHJvdG90eXBlLCB7XG4gICAgX2xvY2s6IDAsXG4gICAgX2hhc1BhdXNlOiAwLFxuICAgIF9mb3JjaW5nOiAwXG4gIH0pO1xuXG4gIHZhciBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICAgIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIG51bGwsIHNldHRlciksXG4gICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgc3RhcnROdW1zLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBjaHVuayxcbiAgICAgICAgc3RhcnROdW0sXG4gICAgICAgIGhhc1JhbmRvbSxcbiAgICAgICAgYTtcbiAgICBwdC5iID0gc3RhcnQ7XG4gICAgcHQuZSA9IGVuZDtcbiAgICBzdGFydCArPSBcIlwiO1xuICAgIGVuZCArPSBcIlwiO1xuXG4gICAgaWYgKGhhc1JhbmRvbSA9IH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmluZ0ZpbHRlcikge1xuICAgICAgYSA9IFtzdGFydCwgZW5kXTtcbiAgICAgIHN0cmluZ0ZpbHRlcihhLCB0YXJnZXQsIHByb3ApO1xuICAgICAgc3RhcnQgPSBhWzBdO1xuICAgICAgZW5kID0gYVsxXTtcbiAgICB9XG5cbiAgICBzdGFydE51bXMgPSBzdGFydC5tYXRjaChfY29tcGxleFN0cmluZ051bUV4cCkgfHwgW107XG5cbiAgICB3aGlsZSAocmVzdWx0ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAuZXhlYyhlbmQpKSB7XG4gICAgICBlbmROdW0gPSByZXN1bHRbMF07XG4gICAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG4gICAgICAgIGNvbG9yID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZE51bSAhPT0gc3RhcnROdW1zW21hdGNoSW5kZXgrK10pIHtcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0TnVtc1ttYXRjaEluZGV4IC0gMV0pIHx8IDA7XG4gICAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgICBfbmV4dDogcHQuX3B0LFxuICAgICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAgIHM6IHN0YXJ0TnVtLFxuICAgICAgICAgIGM6IGVuZE51bS5jaGFyQXQoMSkgPT09IFwiPVwiID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIGVuZE51bSkgLSBzdGFydE51bSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCA/IE1hdGgucm91bmQgOiAwXG4gICAgICAgIH07XG4gICAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7XG4gICAgcHQuZnAgPSBmdW5jUGFyYW07XG5cbiAgICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgICBwdC5lID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLl9wdCA9IHB0O1xuICAgIHJldHVybiBwdDtcbiAgfSxcbiAgICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICAgIF9pc0Z1bmN0aW9uKGVuZCkgJiYgKGVuZCA9IGVuZChpbmRleCB8fCAwLCB0YXJnZXQsIHRhcmdldHMpKTtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdLFxuICAgICAgICBwYXJzZWRTdGFydCA9IHN0YXJ0ICE9PSBcImdldFwiID8gc3RhcnQgOiAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IGZ1bmNQYXJhbSA/IHRhcmdldFtwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKGZ1bmNQYXJhbSkgOiB0YXJnZXRbcHJvcF0oKSxcbiAgICAgICAgc2V0dGVyID0gIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBfc2V0dGVyUGxhaW4gOiBmdW5jUGFyYW0gPyBfc2V0dGVyRnVuY1dpdGhQYXJhbSA6IF9zZXR0ZXJGdW5jLFxuICAgICAgICBwdDtcblxuICAgIGlmIChfaXNTdHJpbmcoZW5kKSkge1xuICAgICAgaWYgKH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICAgICAgZW5kID0gX3JlcGxhY2VSYW5kb20oZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG4gICAgICAgIHB0ID0gX3BhcnNlUmVsYXRpdmUocGFyc2VkU3RhcnQsIGVuZCkgKyAoZ2V0VW5pdChwYXJzZWRTdGFydCkgfHwgMCk7XG5cbiAgICAgICAgaWYgKHB0IHx8IHB0ID09PSAwKSB7XG4gICAgICAgICAgZW5kID0gcHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyc2VkU3RhcnQgIT09IGVuZCB8fCBfZm9yY2VBbGxQcm9wVHdlZW5zKSB7XG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZFN0YXJ0ICogZW5kKSAmJiBlbmQgIT09IFwiXCIpIHtcbiAgICAgICAgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHByb3AsICtwYXJzZWRTdGFydCB8fCAwLCBlbmQgLSAocGFyc2VkU3RhcnQgfHwgMCksIHR5cGVvZiBjdXJyZW50VmFsdWUgPT09IFwiYm9vbGVhblwiID8gX3JlbmRlckJvb2xlYW4gOiBfcmVuZGVyUGxhaW4sIDAsIHNldHRlcik7XG4gICAgICAgIGZ1bmNQYXJhbSAmJiAocHQuZnAgPSBmdW5jUGFyYW0pO1xuICAgICAgICBtb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdGhpcywgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B0ID0gcHQ7XG4gICAgICB9XG5cbiAgICAgICFjdXJyZW50VmFsdWUgJiYgIShwcm9wIGluIHRhcmdldCkgJiYgX21pc3NpbmdQbHVnaW4ocHJvcCwgZW5kKTtcbiAgICAgIHJldHVybiBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHRoaXMsIHRhcmdldCwgcHJvcCwgcGFyc2VkU3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIgfHwgX2NvbmZpZy5zdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSk7XG4gICAgfVxuICB9LFxuICAgICAgX3Byb2Nlc3NWYXJzID0gZnVuY3Rpb24gX3Byb2Nlc3NWYXJzKHZhcnMsIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSB7XG4gICAgX2lzRnVuY3Rpb24odmFycykgJiYgKHZhcnMgPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKTtcblxuICAgIGlmICghX2lzT2JqZWN0KHZhcnMpIHx8IHZhcnMuc3R5bGUgJiYgdmFycy5ub2RlVHlwZSB8fCBfaXNBcnJheSh2YXJzKSB8fCBfaXNUeXBlZEFycmF5KHZhcnMpKSB7XG4gICAgICByZXR1cm4gX2lzU3RyaW5nKHZhcnMpID8gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHZhcnM7XG4gICAgfVxuXG4gICAgdmFyIGNvcHkgPSB7fSxcbiAgICAgICAgcDtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBjb3B5W3BdID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnNbcF0sIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29weTtcbiAgfSxcbiAgICAgIF9jaGVja1BsdWdpbiA9IGZ1bmN0aW9uIF9jaGVja1BsdWdpbihwcm9wZXJ0eSwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgICB2YXIgcGx1Z2luLCBwdCwgcHRMb29rdXAsIGk7XG5cbiAgICBpZiAoX3BsdWdpbnNbcHJvcGVydHldICYmIChwbHVnaW4gPSBuZXcgX3BsdWdpbnNbcHJvcGVydHldKCkpLmluaXQodGFyZ2V0LCBwbHVnaW4ucmF3VmFycyA/IHZhcnNbcHJvcGVydHldIDogX3Byb2Nlc3NWYXJzKHZhcnNbcHJvcGVydHldLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzLCB0d2VlbiksIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykgIT09IGZhbHNlKSB7XG4gICAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICAgIGlmICh0d2VlbiAhPT0gX3F1aWNrVHdlZW4pIHtcbiAgICAgICAgcHRMb29rdXAgPSB0d2Vlbi5fcHRMb29rdXBbdHdlZW4uX3RhcmdldHMuaW5kZXhPZih0YXJnZXQpXTtcbiAgICAgICAgaSA9IHBsdWdpbi5fcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBwdExvb2t1cFtwbHVnaW4uX3Byb3BzW2ldXSA9IHB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbjtcbiAgfSxcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuLFxuICAgICAgX2ZvcmNlQWxsUHJvcFR3ZWVucyxcbiAgICAgIF9pbml0VHdlZW4gPSBmdW5jdGlvbiBfaW5pdFR3ZWVuKHR3ZWVuLCB0aW1lKSB7XG4gICAgdmFyIHZhcnMgPSB0d2Vlbi52YXJzLFxuICAgICAgICBlYXNlID0gdmFycy5lYXNlLFxuICAgICAgICBzdGFydEF0ID0gdmFycy5zdGFydEF0LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXIgPSB2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgbGF6eSA9IHZhcnMubGF6eSxcbiAgICAgICAgb25VcGRhdGUgPSB2YXJzLm9uVXBkYXRlLFxuICAgICAgICBvblVwZGF0ZVBhcmFtcyA9IHZhcnMub25VcGRhdGVQYXJhbXMsXG4gICAgICAgIGNhbGxiYWNrU2NvcGUgPSB2YXJzLmNhbGxiYWNrU2NvcGUsXG4gICAgICAgIHJ1bkJhY2t3YXJkcyA9IHZhcnMucnVuQmFja3dhcmRzLFxuICAgICAgICB5b3lvRWFzZSA9IHZhcnMueW95b0Vhc2UsXG4gICAgICAgIGtleWZyYW1lcyA9IHZhcnMua2V5ZnJhbWVzLFxuICAgICAgICBhdXRvUmV2ZXJ0ID0gdmFycy5hdXRvUmV2ZXJ0LFxuICAgICAgICBkdXIgPSB0d2Vlbi5fZHVyLFxuICAgICAgICBwcmV2U3RhcnRBdCA9IHR3ZWVuLl9zdGFydEF0LFxuICAgICAgICB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICAgIHBhcmVudCA9IHR3ZWVuLnBhcmVudCxcbiAgICAgICAgZnVsbFRhcmdldHMgPSBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQucGFyZW50Ll90YXJnZXRzIDogdGFyZ2V0cyxcbiAgICAgICAgYXV0b092ZXJ3cml0ZSA9IHR3ZWVuLl9vdmVyd3JpdGUgPT09IFwiYXV0b1wiICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgICAgICB0bCA9IHR3ZWVuLnRpbWVsaW5lLFxuICAgICAgICBjbGVhblZhcnMsXG4gICAgICAgIGksXG4gICAgICAgIHAsXG4gICAgICAgIHB0LFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGhhc1ByaW9yaXR5LFxuICAgICAgICBnc0RhdGEsXG4gICAgICAgIGhhcm5lc3MsXG4gICAgICAgIHBsdWdpbixcbiAgICAgICAgcHRMb29rdXAsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBoYXJuZXNzVmFycyxcbiAgICAgICAgb3ZlcndyaXR0ZW47XG4gICAgdGwgJiYgKCFrZXlmcmFtZXMgfHwgIWVhc2UpICYmIChlYXNlID0gXCJub25lXCIpO1xuICAgIHR3ZWVuLl9lYXNlID0gX3BhcnNlRWFzZShlYXNlLCBfZGVmYXVsdHMuZWFzZSk7XG4gICAgdHdlZW4uX3lFYXNlID0geW95b0Vhc2UgPyBfaW52ZXJ0RWFzZShfcGFyc2VFYXNlKHlveW9FYXNlID09PSB0cnVlID8gZWFzZSA6IHlveW9FYXNlLCBfZGVmYXVsdHMuZWFzZSkpIDogMDtcblxuICAgIGlmICh5b3lvRWFzZSAmJiB0d2Vlbi5feW95byAmJiAhdHdlZW4uX3JlcGVhdCkge1xuICAgICAgeW95b0Vhc2UgPSB0d2Vlbi5feUVhc2U7XG4gICAgICB0d2Vlbi5feUVhc2UgPSB0d2Vlbi5fZWFzZTtcbiAgICAgIHR3ZWVuLl9lYXNlID0geW95b0Vhc2U7XG4gICAgfVxuXG4gICAgdHdlZW4uX2Zyb20gPSAhdGwgJiYgISF2YXJzLnJ1bkJhY2t3YXJkcztcblxuICAgIGlmICghdGwgfHwga2V5ZnJhbWVzICYmICF2YXJzLnN0YWdnZXIpIHtcbiAgICAgIGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwO1xuICAgICAgaGFybmVzc1ZhcnMgPSBoYXJuZXNzICYmIHZhcnNbaGFybmVzcy5wcm9wXTtcbiAgICAgIGNsZWFuVmFycyA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9yZXNlcnZlZFByb3BzKTtcblxuICAgICAgaWYgKHByZXZTdGFydEF0KSB7XG4gICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KHByZXZTdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSkpO1xuXG4gICAgICAgIHByZXZTdGFydEF0Ll9sYXp5ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0QXQpIHtcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgX3NldERlZmF1bHRzKHtcbiAgICAgICAgICBkYXRhOiBcImlzU3RhcnRcIixcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIGltbWVkaWF0ZVJlbmRlcjogdHJ1ZSxcbiAgICAgICAgICBsYXp5OiBfaXNOb3RGYWxzZShsYXp5KSxcbiAgICAgICAgICBzdGFydEF0OiBudWxsLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIG9uVXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgICBvblVwZGF0ZVBhcmFtczogb25VcGRhdGVQYXJhbXMsXG4gICAgICAgICAgY2FsbGJhY2tTY29wZTogY2FsbGJhY2tTY29wZSxcbiAgICAgICAgICBzdGFnZ2VyOiAwXG4gICAgICAgIH0sIHN0YXJ0QXQpKSk7XG5cbiAgICAgICAgdGltZSA8IDAgJiYgIWltbWVkaWF0ZVJlbmRlciAmJiAhYXV0b1JldmVydCAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpO1xuXG4gICAgICAgIGlmIChpbW1lZGlhdGVSZW5kZXIpIHtcbiAgICAgICAgICB0aW1lID4gMCAmJiAhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTtcblxuICAgICAgICAgIGlmIChkdXIgJiYgdGltZSA8PSAwKSB7XG4gICAgICAgICAgICB0aW1lICYmICh0d2Vlbi5felRpbWUgPSB0aW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXV0b1JldmVydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0d2Vlbi5fc3RhcnRBdCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnVuQmFja3dhcmRzICYmIGR1cikge1xuICAgICAgICBpZiAocHJldlN0YXJ0QXQpIHtcbiAgICAgICAgICAhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lICYmIChpbW1lZGlhdGVSZW5kZXIgPSBmYWxzZSk7XG4gICAgICAgICAgcCA9IF9zZXREZWZhdWx0cyh7XG4gICAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgICAgZGF0YTogXCJpc0Zyb21TdGFydFwiLFxuICAgICAgICAgICAgbGF6eTogaW1tZWRpYXRlUmVuZGVyICYmIF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBpbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgICBzdGFnZ2VyOiAwLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgICB9LCBjbGVhblZhcnMpO1xuICAgICAgICAgIGhhcm5lc3NWYXJzICYmIChwW2hhcm5lc3MucHJvcF0gPSBoYXJuZXNzVmFycyk7XG5cbiAgICAgICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBwKSk7XG5cbiAgICAgICAgICB0aW1lIDwgMCAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpO1xuICAgICAgICAgIHR3ZWVuLl96VGltZSA9IHRpbWU7XG5cbiAgICAgICAgICBpZiAoIWltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICAgICAgX2luaXRUd2Vlbih0d2Vlbi5fc3RhcnRBdCwgX3RpbnlOdW0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHdlZW4uX3B0ID0gdHdlZW4uX3B0Q2FjaGUgPSAwO1xuICAgICAgbGF6eSA9IGR1ciAmJiBfaXNOb3RGYWxzZShsYXp5KSB8fCBsYXp5ICYmICFkdXI7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcbiAgICAgICAgdHdlZW4uX3B0TG9va3VwW2ldID0gcHRMb29rdXAgPSB7fTtcbiAgICAgICAgX2xhenlMb29rdXBbZ3NEYXRhLmlkXSAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTtcbiAgICAgICAgaW5kZXggPSBmdWxsVGFyZ2V0cyA9PT0gdGFyZ2V0cyA/IGkgOiBmdWxsVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgICAgaWYgKGhhcm5lc3MgJiYgKHBsdWdpbiA9IG5ldyBoYXJuZXNzKCkpLmluaXQodGFyZ2V0LCBoYXJuZXNzVmFycyB8fCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgZnVsbFRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcGx1Z2luLm5hbWUsIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblxuICAgICAgICAgIHBsdWdpbi5fcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcHRMb29rdXBbbmFtZV0gPSBwdDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFybmVzcyB8fCBoYXJuZXNzVmFycykge1xuICAgICAgICAgIGZvciAocCBpbiBjbGVhblZhcnMpIHtcbiAgICAgICAgICAgIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gX2NoZWNrUGx1Z2luKHAsIGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIGZ1bGxUYXJnZXRzKSkpIHtcbiAgICAgICAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHR3ZWVuLl9vcCAmJiB0d2Vlbi5fb3BbaV0gJiYgdHdlZW4ua2lsbCh0YXJnZXQsIHR3ZWVuLl9vcFtpXSk7XG5cbiAgICAgICAgaWYgKGF1dG9PdmVyd3JpdGUgJiYgdHdlZW4uX3B0KSB7XG4gICAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSB0d2VlbjtcblxuICAgICAgICAgIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0LCBwdExvb2t1cCwgdHdlZW4uZ2xvYmFsVGltZSh0aW1lKSk7XG5cbiAgICAgICAgICBvdmVyd3JpdHRlbiA9ICF0d2Vlbi5wYXJlbnQ7XG4gICAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdHdlZW4uX3B0ICYmIGxhenkgJiYgKF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gPSAxKTtcbiAgICAgIH1cblxuICAgICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0d2Vlbik7XG4gICAgICB0d2Vlbi5fb25Jbml0ICYmIHR3ZWVuLl9vbkluaXQodHdlZW4pO1xuICAgIH1cblxuICAgIHR3ZWVuLl9vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICAgIHR3ZWVuLl9pbml0dGVkID0gKCF0d2Vlbi5fb3AgfHwgdHdlZW4uX3B0KSAmJiAhb3ZlcndyaXR0ZW47XG4gICAga2V5ZnJhbWVzICYmIHRpbWUgPD0gMCAmJiB0bC5yZW5kZXIoX2JpZ051bSwgdHJ1ZSwgdHJ1ZSk7XG4gIH0sXG4gICAgICBfdXBkYXRlUHJvcFR3ZWVucyA9IGZ1bmN0aW9uIF91cGRhdGVQcm9wVHdlZW5zKHR3ZWVuLCBwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUsIHJhdGlvLCB0aW1lKSB7XG4gICAgdmFyIHB0Q2FjaGUgPSAodHdlZW4uX3B0ICYmIHR3ZWVuLl9wdENhY2hlIHx8ICh0d2Vlbi5fcHRDYWNoZSA9IHt9KSlbcHJvcGVydHldLFxuICAgICAgICBwdCxcbiAgICAgICAgbG9va3VwLFxuICAgICAgICBpO1xuXG4gICAgaWYgKCFwdENhY2hlKSB7XG4gICAgICBwdENhY2hlID0gdHdlZW4uX3B0Q2FjaGVbcHJvcGVydHldID0gW107XG4gICAgICBsb29rdXAgPSB0d2Vlbi5fcHRMb29rdXA7XG4gICAgICBpID0gdHdlZW4uX3RhcmdldHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHB0ID0gbG9va3VwW2ldW3Byb3BlcnR5XTtcblxuICAgICAgICBpZiAocHQgJiYgcHQuZCAmJiBwdC5kLl9wdCkge1xuICAgICAgICAgIHB0ID0gcHQuZC5fcHQ7XG5cbiAgICAgICAgICB3aGlsZSAocHQgJiYgcHQucCAhPT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgIF9mb3JjZUFsbFByb3BUd2VlbnMgPSAxO1xuICAgICAgICAgIHR3ZWVuLnZhcnNbcHJvcGVydHldID0gXCIrPTBcIjtcblxuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4sIHRpbWUpO1xuXG4gICAgICAgICAgX2ZvcmNlQWxsUHJvcFR3ZWVucyA9IDA7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBwdENhY2hlLnB1c2gocHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGkgPSBwdENhY2hlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHB0ID0gcHRDYWNoZVtpXTtcbiAgICAgIHB0LnMgPSAoc3RhcnQgfHwgc3RhcnQgPT09IDApICYmICFzdGFydElzUmVsYXRpdmUgPyBzdGFydCA6IHB0LnMgKyAoc3RhcnQgfHwgMCkgKyByYXRpbyAqIHB0LmM7XG4gICAgICBwdC5jID0gdmFsdWUgLSBwdC5zO1xuICAgICAgcHQuZSAmJiAocHQuZSA9IF9yb3VuZCh2YWx1ZSkgKyBnZXRVbml0KHB0LmUpKTtcbiAgICAgIHB0LmIgJiYgKHB0LmIgPSBwdC5zICsgZ2V0VW5pdChwdC5iKSk7XG4gICAgfVxuICB9LFxuICAgICAgX2FkZEFsaWFzZXNUb1ZhcnMgPSBmdW5jdGlvbiBfYWRkQWxpYXNlc1RvVmFycyh0YXJnZXRzLCB2YXJzKSB7XG4gICAgdmFyIGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwLFxuICAgICAgICBwcm9wZXJ0eUFsaWFzZXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyxcbiAgICAgICAgY29weSxcbiAgICAgICAgcCxcbiAgICAgICAgaSxcbiAgICAgICAgYWxpYXNlcztcblxuICAgIGlmICghcHJvcGVydHlBbGlhc2VzKSB7XG4gICAgICByZXR1cm4gdmFycztcbiAgICB9XG5cbiAgICBjb3B5ID0gX21lcmdlKHt9LCB2YXJzKTtcblxuICAgIGZvciAocCBpbiBwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICAgIGlmIChwIGluIGNvcHkpIHtcbiAgICAgICAgYWxpYXNlcyA9IHByb3BlcnR5QWxpYXNlc1twXS5zcGxpdChcIixcIik7XG4gICAgICAgIGkgPSBhbGlhc2VzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29weVthbGlhc2VzW2ldXSA9IGNvcHlbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weTtcbiAgfSxcbiAgICAgIF9wYXJzZUtleWZyYW1lID0gZnVuY3Rpb24gX3BhcnNlS2V5ZnJhbWUocHJvcCwgb2JqLCBhbGxQcm9wcywgZWFzZUVhY2gpIHtcbiAgICB2YXIgZWFzZSA9IG9iai5lYXNlIHx8IGVhc2VFYWNoIHx8IFwicG93ZXIxLmluT3V0XCIsXG4gICAgICAgIHAsXG4gICAgICAgIGE7XG5cbiAgICBpZiAoX2lzQXJyYXkob2JqKSkge1xuICAgICAgYSA9IGFsbFByb3BzW3Byb3BdIHx8IChhbGxQcm9wc1twcm9wXSA9IFtdKTtcbiAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICByZXR1cm4gYS5wdXNoKHtcbiAgICAgICAgICB0OiBpIC8gKG9iai5sZW5ndGggLSAxKSAqIDEwMCxcbiAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICBlOiBlYXNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAocCBpbiBvYmopIHtcbiAgICAgICAgYSA9IGFsbFByb3BzW3BdIHx8IChhbGxQcm9wc1twXSA9IFtdKTtcbiAgICAgICAgcCA9PT0gXCJlYXNlXCIgfHwgYS5wdXNoKHtcbiAgICAgICAgICB0OiBwYXJzZUZsb2F0KHByb3ApLFxuICAgICAgICAgIHY6IG9ialtwXSxcbiAgICAgICAgICBlOiBlYXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgICAgIF9wYXJzZUZ1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZUZ1bmNPclN0cmluZyh2YWx1ZSwgdHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykge1xuICAgIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKHR3ZWVuLCBpLCB0YXJnZXQsIHRhcmdldHMpIDogX2lzU3RyaW5nKHZhbHVlKSAmJiBdmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikgPyBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfSxcbiAgICAgIF9zdGFnZ2VyVHdlZW5Qcm9wcyA9IF9jYWxsYmFja05hbWVzICsgXCJyZXBlYXQscmVwZWF0RGVsYXkseW95byxyZXBlYXRSZWZyZXNoLHlveW9FYXNlLGF1dG9SZXZlcnRcIixcbiAgICAgIF9zdGFnZ2VyUHJvcHNUb1NraXAgPSB7fTtcblxuICBfZm9yRWFjaE5hbWUoX3N0YWdnZXJUd2VlblByb3BzICsgXCIsaWQsc3RhZ2dlcixkZWxheSxkdXJhdGlvbixwYXVzZWQsc2Nyb2xsVHJpZ2dlclwiLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBfc3RhZ2dlclByb3BzVG9Ta2lwW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgdmFyIFR3ZWVuID0gZnVuY3Rpb24gKF9BbmltYXRpb24yKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVHdlZW4sIF9BbmltYXRpb24yKTtcblxuICAgIGZ1bmN0aW9uIFR3ZWVuKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uLCBza2lwSW5oZXJpdCkge1xuICAgICAgdmFyIF90aGlzMztcblxuICAgICAgaWYgKHR5cGVvZiB2YXJzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHBvc2l0aW9uLmR1cmF0aW9uID0gdmFycztcbiAgICAgICAgdmFycyA9IHBvc2l0aW9uO1xuICAgICAgICBwb3NpdGlvbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIF90aGlzMyA9IF9BbmltYXRpb24yLmNhbGwodGhpcywgc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSkgfHwgdGhpcztcbiAgICAgIHZhciBfdGhpczMkdmFycyA9IF90aGlzMy52YXJzLFxuICAgICAgICAgIGR1cmF0aW9uID0gX3RoaXMzJHZhcnMuZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXkgPSBfdGhpczMkdmFycy5kZWxheSxcbiAgICAgICAgICBpbW1lZGlhdGVSZW5kZXIgPSBfdGhpczMkdmFycy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgc3RhZ2dlciA9IF90aGlzMyR2YXJzLnN0YWdnZXIsXG4gICAgICAgICAgb3ZlcndyaXRlID0gX3RoaXMzJHZhcnMub3ZlcndyaXRlLFxuICAgICAgICAgIGtleWZyYW1lcyA9IF90aGlzMyR2YXJzLmtleWZyYW1lcyxcbiAgICAgICAgICBkZWZhdWx0cyA9IF90aGlzMyR2YXJzLmRlZmF1bHRzLFxuICAgICAgICAgIHNjcm9sbFRyaWdnZXIgPSBfdGhpczMkdmFycy5zY3JvbGxUcmlnZ2VyLFxuICAgICAgICAgIHlveW9FYXNlID0gX3RoaXMzJHZhcnMueW95b0Vhc2UsXG4gICAgICAgICAgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxuICAgICAgICAgIHBhcnNlZFRhcmdldHMgPSAoX2lzQXJyYXkodGFyZ2V0cykgfHwgX2lzVHlwZWRBcnJheSh0YXJnZXRzKSA/IF9pc051bWJlcih0YXJnZXRzWzBdKSA6IFwibGVuZ3RoXCIgaW4gdmFycykgPyBbdGFyZ2V0c10gOiB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICAgIHRsLFxuICAgICAgICAgIGksXG4gICAgICAgICAgY29weSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgY3VyVGFyZ2V0LFxuICAgICAgICAgIHN0YWdnZXJGdW5jLFxuICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZTtcbiAgICAgIF90aGlzMy5fdGFyZ2V0cyA9IHBhcnNlZFRhcmdldHMubGVuZ3RoID8gX2hhcm5lc3MocGFyc2VkVGFyZ2V0cykgOiBfd2FybihcIkdTQVAgdGFyZ2V0IFwiICsgdGFyZ2V0cyArIFwiIG5vdCBmb3VuZC4gaHR0cHM6Ly9ncmVlbnNvY2suY29tXCIsICFfY29uZmlnLm51bGxUYXJnZXRXYXJuKSB8fCBbXTtcbiAgICAgIF90aGlzMy5fcHRMb29rdXAgPSBbXTtcbiAgICAgIF90aGlzMy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlO1xuXG4gICAgICBpZiAoa2V5ZnJhbWVzIHx8IHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XG4gICAgICAgIHZhcnMgPSBfdGhpczMudmFycztcbiAgICAgICAgdGwgPSBfdGhpczMudGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICAgICAgICAgIGRhdGE6IFwibmVzdGVkXCIsXG4gICAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzIHx8IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0bC5raWxsKCk7XG4gICAgICAgIHRsLnBhcmVudCA9IHRsLl9kcCA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKTtcbiAgICAgICAgdGwuX3N0YXJ0ID0gMDtcblxuICAgICAgICBpZiAoc3RhZ2dlciB8fCBfaXNGdW5jT3JTdHJpbmcoZHVyYXRpb24pIHx8IF9pc0Z1bmNPclN0cmluZyhkZWxheSkpIHtcbiAgICAgICAgICBsID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG4gICAgICAgICAgc3RhZ2dlckZ1bmMgPSBzdGFnZ2VyICYmIGRpc3RyaWJ1dGUoc3RhZ2dlcik7XG5cbiAgICAgICAgICBpZiAoX2lzT2JqZWN0KHN0YWdnZXIpKSB7XG4gICAgICAgICAgICBmb3IgKHAgaW4gc3RhZ2dlcikge1xuICAgICAgICAgICAgICBpZiAofl9zdGFnZ2VyVHdlZW5Qcm9wcy5pbmRleE9mKHApKSB7XG4gICAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlIHx8IChzdGFnZ2VyVmFyc1RvTWVyZ2UgPSB7fSk7XG4gICAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlW3BdID0gc3RhZ2dlcltwXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHkgPSBfY29weUV4Y2x1ZGluZyh2YXJzLCBfc3RhZ2dlclByb3BzVG9Ta2lwKTtcbiAgICAgICAgICAgIGNvcHkuc3RhZ2dlciA9IDA7XG4gICAgICAgICAgICB5b3lvRWFzZSAmJiAoY29weS55b3lvRWFzZSA9IHlveW9FYXNlKTtcbiAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSAmJiBfbWVyZ2UoY29weSwgc3RhZ2dlclZhcnNUb01lcmdlKTtcbiAgICAgICAgICAgIGN1clRhcmdldCA9IHBhcnNlZFRhcmdldHNbaV07XG4gICAgICAgICAgICBjb3B5LmR1cmF0aW9uID0gK19wYXJzZUZ1bmNPclN0cmluZyhkdXJhdGlvbiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpO1xuICAgICAgICAgICAgY29weS5kZWxheSA9ICgrX3BhcnNlRnVuY09yU3RyaW5nKGRlbGF5LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykgfHwgMCkgLSBfdGhpczMuX2RlbGF5O1xuXG4gICAgICAgICAgICBpZiAoIXN0YWdnZXIgJiYgbCA9PT0gMSAmJiBjb3B5LmRlbGF5KSB7XG4gICAgICAgICAgICAgIF90aGlzMy5fZGVsYXkgPSBkZWxheSA9IGNvcHkuZGVsYXk7XG4gICAgICAgICAgICAgIF90aGlzMy5fc3RhcnQgKz0gZGVsYXk7XG4gICAgICAgICAgICAgIGNvcHkuZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bC50byhjdXJUYXJnZXQsIGNvcHksIHN0YWdnZXJGdW5jID8gc3RhZ2dlckZ1bmMoaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKSA6IDApO1xuICAgICAgICAgICAgdGwuX2Vhc2UgPSBfZWFzZU1hcC5ub25lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRsLmR1cmF0aW9uKCkgPyBkdXJhdGlvbiA9IGRlbGF5ID0gMCA6IF90aGlzMy50aW1lbGluZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ZnJhbWVzKSB7XG4gICAgICAgICAgX2luaGVyaXREZWZhdWx0cyhfc2V0RGVmYXVsdHModGwudmFycy5kZWZhdWx0cywge1xuICAgICAgICAgICAgZWFzZTogXCJub25lXCJcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICB0bC5fZWFzZSA9IF9wYXJzZUVhc2Uoa2V5ZnJhbWVzLmVhc2UgfHwgdmFycy5lYXNlIHx8IFwibm9uZVwiKTtcbiAgICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgIGtmLFxuICAgICAgICAgICAgICB2O1xuXG4gICAgICAgICAgaWYgKF9pc0FycmF5KGtleWZyYW1lcykpIHtcbiAgICAgICAgICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGwudG8ocGFyc2VkVGFyZ2V0cywgZnJhbWUsIFwiPlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICAgIGZvciAocCBpbiBrZXlmcmFtZXMpIHtcbiAgICAgICAgICAgICAgcCA9PT0gXCJlYXNlXCIgfHwgcCA9PT0gXCJlYXNlRWFjaFwiIHx8IF9wYXJzZUtleWZyYW1lKHAsIGtleWZyYW1lc1twXSwgY29weSwga2V5ZnJhbWVzLmVhc2VFYWNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChwIGluIGNvcHkpIHtcbiAgICAgICAgICAgICAgYSA9IGNvcHlbcF0uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnQgLSBiLnQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aW1lID0gMDtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGtmID0gYVtpXTtcbiAgICAgICAgICAgICAgICB2ID0ge1xuICAgICAgICAgICAgICAgICAgZWFzZToga2YuZSxcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAoa2YudCAtIChpID8gYVtpIC0gMV0udCA6IDApKSAvIDEwMCAqIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2W3BdID0ga2YudjtcbiAgICAgICAgICAgICAgICB0bC50byhwYXJzZWRUYXJnZXRzLCB2LCB0aW1lKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IHYuZHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGwuZHVyYXRpb24oKSA8IGR1cmF0aW9uICYmIHRsLnRvKHt9LCB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAtIHRsLmR1cmF0aW9uKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGR1cmF0aW9uIHx8IF90aGlzMy5kdXJhdGlvbihkdXJhdGlvbiA9IHRsLmR1cmF0aW9uKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMzLnRpbWVsaW5lID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG92ZXJ3cml0ZSA9PT0gdHJ1ZSAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcykge1xuICAgICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKTtcblxuICAgICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHBhcnNlZFRhcmdldHMpO1xuXG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcbiAgICAgIH1cblxuICAgICAgX2FkZFRvVGltZWxpbmUocGFyZW50LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHBvc2l0aW9uKTtcblxuICAgICAgdmFycy5yZXZlcnNlZCAmJiBfdGhpczMucmV2ZXJzZSgpO1xuICAgICAgdmFycy5wYXVzZWQgJiYgX3RoaXMzLnBhdXNlZCh0cnVlKTtcblxuICAgICAgaWYgKGltbWVkaWF0ZVJlbmRlciB8fCAhZHVyYXRpb24gJiYgIWtleWZyYW1lcyAmJiBfdGhpczMuX3N0YXJ0ID09PSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSkgJiYgX2lzTm90RmFsc2UoaW1tZWRpYXRlUmVuZGVyKSAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgICBfdGhpczMuX3RUaW1lID0gLV90aW55TnVtO1xuXG4gICAgICAgIF90aGlzMy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSk7XG4gICAgICB9XG5cbiAgICAgIHNjcm9sbFRyaWdnZXIgJiYgX3Njcm9sbFRyaWdnZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBzY3JvbGxUcmlnZ2VyKTtcbiAgICAgIHJldHVybiBfdGhpczM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90bzMgPSBUd2Vlbi5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgICB0RHVyID0gdGhpcy5fdER1cixcbiAgICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgICAgdFRpbWUgPSB0b3RhbFRpbWUgPiB0RHVyIC0gX3RpbnlOdW0gJiYgdG90YWxUaW1lID49IDAgPyB0RHVyIDogdG90YWxUaW1lIDwgX3RpbnlOdW0gPyAwIDogdG90YWxUaW1lLFxuICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgcHQsXG4gICAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICAgIGN5Y2xlRHVyYXRpb24sXG4gICAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgICBpc1lveW8sXG4gICAgICAgICAgcmF0aW8sXG4gICAgICAgICAgdGltZWxpbmUsXG4gICAgICAgICAgeW95b0Vhc2U7XG5cbiAgICAgIGlmICghZHVyKSB7XG4gICAgICAgIF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICB9IGVsc2UgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCAhdG90YWxUaW1lIHx8IGZvcmNlIHx8ICF0aGlzLl9pbml0dGVkICYmIHRoaXMuX3RUaW1lIHx8IHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbiA9IH5KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzWW95byA9IHRoaXMuX3lveW8gJiYgaXRlcmF0aW9uICYgMTtcblxuICAgICAgICAgIGlmIChpc1lveW8pIHtcbiAgICAgICAgICAgIHlveW9FYXNlID0gdGhpcy5feUVhc2U7XG4gICAgICAgICAgICB0aW1lID0gZHVyIC0gdGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICAgIGlmICh0aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UgJiYgdGhpcy5faW5pdHRlZCkge1xuICAgICAgICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRpbWVsaW5lICYmIHRoaXMuX3lFYXNlICYmIF9wcm9wYWdhdGVZb3lvRWFzZSh0aW1lbGluZSwgaXNZb3lvKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTtcbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoX3JvdW5kUHJlY2lzZShjeWNsZUR1cmF0aW9uICogaXRlcmF0aW9uKSwgdHJ1ZSkuaW52YWxpZGF0ZSgpLl9sb2NrID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcbiAgICAgICAgICBpZiAoX2F0dGVtcHRJbml0VHdlZW4odGhpcywgdG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6IHRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RUaW1lID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGR1ciAhPT0gdGhpcy5fZHVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmICghdGhpcy5fYWN0ICYmIHRoaXMuX3RzKSB7XG4gICAgICAgICAgdGhpcy5fYWN0ID0gMTtcbiAgICAgICAgICB0aGlzLl9sYXp5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9ICh5b3lvRWFzZSB8fCB0aGlzLl9lYXNlKSh0aW1lIC8gZHVyKTtcblxuICAgICAgICBpZiAodGhpcy5fZnJvbSkge1xuICAgICAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9IDEgLSByYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lICYmICFwcmV2VGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3RUaW1lICE9PSB0VGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHQgPSB0aGlzLl9wdDtcblxuICAgICAgICB3aGlsZSAocHQpIHtcbiAgICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucmVuZGVyKHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiAhdGltZSAmJiBpc1lveW8gPyAtX3RpbnlOdW0gOiB0aW1lbGluZS5fZHVyICogdGltZWxpbmUuX2Vhc2UodGltZSAvIHRoaXMuX2R1ciksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgfHwgdGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXG4gICAgICAgIGlmICh0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgICB0b3RhbFRpbWUgPCAwICYmIHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCBmb3JjZSk7XG5cbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlcGVhdCAmJiBpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgdGhpcy52YXJzLm9uUmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcblxuICAgICAgICBpZiAoKHRUaW1lID09PSB0aGlzLl90RHVyIHx8ICF0VGltZSkgJiYgdGhpcy5fdFRpbWUgPT09IHRUaW1lKSB7XG4gICAgICAgICAgdG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0aGlzLl90RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTtcblxuICAgICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lKSkge1xuICAgICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8zLnRhcmdldHMgPSBmdW5jdGlvbiB0YXJnZXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldHM7XG4gICAgfTtcblxuICAgIF9wcm90bzMuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgICB0aGlzLl9wdCA9IHRoaXMuX29wID0gdGhpcy5fc3RhcnRBdCA9IHRoaXMuX29uVXBkYXRlID0gdGhpcy5fbGF6eSA9IHRoaXMucmF0aW8gPSAwO1xuICAgICAgdGhpcy5fcHRMb29rdXAgPSBbXTtcbiAgICAgIHRoaXMudGltZWxpbmUgJiYgdGhpcy50aW1lbGluZS5pbnZhbGlkYXRlKCk7XG4gICAgICByZXR1cm4gX0FuaW1hdGlvbjIucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMy5yZXNldFRvID0gZnVuY3Rpb24gcmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpIHtcbiAgICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gICAgICB0aGlzLl90cyB8fCB0aGlzLnBsYXkoKTtcbiAgICAgIHZhciB0aW1lID0gTWF0aC5taW4odGhpcy5fZHVyLCAodGhpcy5fZHAuX3RpbWUgLSB0aGlzLl9zdGFydCkgKiB0aGlzLl90cyksXG4gICAgICAgICAgcmF0aW87XG4gICAgICB0aGlzLl9pbml0dGVkIHx8IF9pbml0VHdlZW4odGhpcywgdGltZSk7XG4gICAgICByYXRpbyA9IHRoaXMuX2Vhc2UodGltZSAvIHRoaXMuX2R1cik7XG5cbiAgICAgIGlmIChfdXBkYXRlUHJvcFR3ZWVucyh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUsIHJhdGlvLCB0aW1lKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIF9hbGlnblBsYXloZWFkKHRoaXMsIDApO1xuXG4gICAgICB0aGlzLnBhcmVudCB8fCBfYWRkTGlua2VkTGlzdEl0ZW0odGhpcy5fZHAsIHRoaXMsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGhpcy5fZHAuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXIoMCk7XG4gICAgfTtcblxuICAgIF9wcm90bzMua2lsbCA9IGZ1bmN0aW9uIGtpbGwodGFyZ2V0cywgdmFycykge1xuICAgICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgICB2YXJzID0gXCJhbGxcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0YXJnZXRzICYmICghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSkge1xuICAgICAgICB0aGlzLl9sYXp5ID0gdGhpcy5fcHQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyBfaW50ZXJydXB0KHRoaXMpIDogdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGltZWxpbmUpIHtcbiAgICAgICAgdmFyIHREdXIgPSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgdmFycywgX292ZXJ3cml0aW5nVHdlZW4gJiYgX292ZXJ3cml0aW5nVHdlZW4udmFycy5vdmVyd3JpdGUgIT09IHRydWUpLl9maXJzdCB8fCBfaW50ZXJydXB0KHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudCAmJiB0RHVyICE9PSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKSAmJiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fZHVyICogdGhpcy50aW1lbGluZS5fdER1ciAvIHREdXIsIDAsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnNlZFRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICAgIGtpbGxpbmdUYXJnZXRzID0gdGFyZ2V0cyA/IHRvQXJyYXkodGFyZ2V0cykgOiBwYXJzZWRUYXJnZXRzLFxuICAgICAgICAgIHByb3BUd2Vlbkxvb2t1cCA9IHRoaXMuX3B0TG9va3VwLFxuICAgICAgICAgIGZpcnN0UFQgPSB0aGlzLl9wdCxcbiAgICAgICAgICBvdmVyd3JpdHRlblByb3BzLFxuICAgICAgICAgIGN1ckxvb2t1cCxcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBwLFxuICAgICAgICAgIHB0LFxuICAgICAgICAgIGk7XG5cbiAgICAgIGlmICgoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikgJiYgX2FycmF5c01hdGNoKHBhcnNlZFRhcmdldHMsIGtpbGxpbmdUYXJnZXRzKSkge1xuICAgICAgICB2YXJzID09PSBcImFsbFwiICYmICh0aGlzLl9wdCA9IDApO1xuICAgICAgICByZXR1cm4gX2ludGVycnVwdCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX29wID0gdGhpcy5fb3AgfHwgW107XG5cbiAgICAgIGlmICh2YXJzICE9PSBcImFsbFwiKSB7XG4gICAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgICBwID0ge307XG5cbiAgICAgICAgICBfZm9yRWFjaE5hbWUodmFycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwW25hbWVdID0gMTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhcnMgPSBwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFycyA9IF9hZGRBbGlhc2VzVG9WYXJzKHBhcnNlZFRhcmdldHMsIHZhcnMpO1xuICAgICAgfVxuXG4gICAgICBpID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKH5raWxsaW5nVGFyZ2V0cy5pbmRleE9mKHBhcnNlZFRhcmdldHNbaV0pKSB7XG4gICAgICAgICAgY3VyTG9va3VwID0gcHJvcFR3ZWVuTG9va3VwW2ldO1xuXG4gICAgICAgICAgaWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIG92ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzO1xuICAgICAgICAgICAgcHJvcHMgPSBjdXJMb29rdXA7XG4gICAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gPSBvdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9O1xuICAgICAgICAgICAgcHJvcHMgPSB2YXJzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAocCBpbiBwcm9wcykge1xuICAgICAgICAgICAgcHQgPSBjdXJMb29rdXAgJiYgY3VyTG9va3VwW3BdO1xuXG4gICAgICAgICAgICBpZiAocHQpIHtcbiAgICAgICAgICAgICAgaWYgKCEoXCJraWxsXCIgaW4gcHQuZCkgfHwgcHQuZC5raWxsKHApID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlbGV0ZSBjdXJMb29rdXBbcF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJPdmVyd3JpdGVQcm9wcyAhPT0gXCJhbGxcIikge1xuICAgICAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wc1twXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXR0ZWQgJiYgIXRoaXMuX3B0ICYmIGZpcnN0UFQgJiYgX2ludGVycnVwdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBUd2Vlbi50byA9IGZ1bmN0aW9uIHRvKHRhcmdldHMsIHZhcnMpIHtcbiAgICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgYXJndW1lbnRzWzJdKTtcbiAgICB9O1xuXG4gICAgVHdlZW4uZnJvbSA9IGZ1bmN0aW9uIGZyb20odGFyZ2V0cywgdmFycykge1xuICAgICAgcmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgVHdlZW4uZGVsYXllZENhbGwgPSBmdW5jdGlvbiBkZWxheWVkQ2FsbChkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcbiAgICAgIHJldHVybiBuZXcgVHdlZW4oY2FsbGJhY2ssIDAsIHtcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgbGF6eTogZmFsc2UsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgb25Db21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICAgIG9uUmV2ZXJzZUNvbXBsZXRlOiBjYWxsYmFjayxcbiAgICAgICAgb25Db21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgICBvblJldmVyc2VDb21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgICBjYWxsYmFja1Njb3BlOiBzY29wZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFR3ZWVuLmZyb21UbyA9IGZ1bmN0aW9uIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzKSB7XG4gICAgICByZXR1cm4gX2NyZWF0ZVR3ZWVuVHlwZSgyLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBUd2Vlbi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycykge1xuICAgICAgdmFycy5kdXJhdGlvbiA9IDA7XG4gICAgICB2YXJzLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzKTtcbiAgICB9O1xuXG4gICAgVHdlZW4ua2lsbFR3ZWVuc09mID0gZnVuY3Rpb24ga2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XG4gICAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUd2VlbjtcbiAgfShBbmltYXRpb24pO1xuXG4gIF9zZXREZWZhdWx0cyhUd2Vlbi5wcm90b3R5cGUsIHtcbiAgICBfdGFyZ2V0czogW10sXG4gICAgX2xhenk6IDAsXG4gICAgX3N0YXJ0QXQ6IDAsXG4gICAgX29wOiAwLFxuICAgIF9vbkluaXQ6IDBcbiAgfSk7XG5cbiAgX2ZvckVhY2hOYW1lKFwic3RhZ2dlclRvLHN0YWdnZXJGcm9tLHN0YWdnZXJGcm9tVG9cIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBUd2VlbltuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0bCA9IG5ldyBUaW1lbGluZSgpLFxuICAgICAgICAgIHBhcmFtcyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgIHBhcmFtcy5zcGxpY2UobmFtZSA9PT0gXCJzdGFnZ2VyRnJvbVRvXCIgPyA1IDogNCwgMCwgMCk7XG4gICAgICByZXR1cm4gdGxbbmFtZV0uYXBwbHkodGwsIHBhcmFtcyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIF9zZXR0ZXJQbGFpbiA9IGZ1bmN0aW9uIF9zZXR0ZXJQbGFpbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHldID0gdmFsdWU7XG4gIH0sXG4gICAgICBfc2V0dGVyRnVuYyA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0odmFsdWUpO1xuICB9LFxuICAgICAgX3NldHRlckZ1bmNXaXRoUGFyYW0gPSBmdW5jdGlvbiBfc2V0dGVyRnVuY1dpdGhQYXJhbSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHldKGRhdGEuZnAsIHZhbHVlKTtcbiAgfSxcbiAgICAgIF9zZXR0ZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfc2V0dGVyQXR0cmlidXRlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRhcmdldC5zZXRBdHRyaWJ1dGUocHJvcGVydHksIHZhbHVlKTtcbiAgfSxcbiAgICAgIF9nZXRTZXR0ZXIgPSBmdW5jdGlvbiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gX2lzRnVuY3Rpb24odGFyZ2V0W3Byb3BlcnR5XSkgPyBfc2V0dGVyRnVuYyA6IF9pc1VuZGVmaW5lZCh0YXJnZXRbcHJvcGVydHldKSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlID8gX3NldHRlckF0dHJpYnV0ZSA6IF9zZXR0ZXJQbGFpbjtcbiAgfSxcbiAgICAgIF9yZW5kZXJQbGFpbiA9IGZ1bmN0aW9uIF9yZW5kZXJQbGFpbihyYXRpbywgZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDAwMCkgLyAxMDAwMDAwLCBkYXRhKTtcbiAgfSxcbiAgICAgIF9yZW5kZXJCb29sZWFuID0gZnVuY3Rpb24gX3JlbmRlckJvb2xlYW4ocmF0aW8sIGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsICEhKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSwgZGF0YSk7XG4gIH0sXG4gICAgICBfcmVuZGVyQ29tcGxleFN0cmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDb21wbGV4U3RyaW5nKHJhdGlvLCBkYXRhKSB7XG4gICAgdmFyIHB0ID0gZGF0YS5fcHQsXG4gICAgICAgIHMgPSBcIlwiO1xuXG4gICAgaWYgKCFyYXRpbyAmJiBkYXRhLmIpIHtcbiAgICAgIHMgPSBkYXRhLmI7XG4gICAgfSBlbHNlIGlmIChyYXRpbyA9PT0gMSAmJiBkYXRhLmUpIHtcbiAgICAgIHMgPSBkYXRhLmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBzID0gcHQucCArIChwdC5tID8gcHQubShwdC5zICsgcHQuYyAqIHJhdGlvKSA6IE1hdGgucm91bmQoKHB0LnMgKyBwdC5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDApICsgcztcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgcyArPSBkYXRhLmM7XG4gICAgfVxuXG4gICAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHMsIGRhdGEpO1xuICB9LFxuICAgICAgX3JlbmRlclByb3BUd2VlbnMgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFR3ZWVucyhyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuICB9LFxuICAgICAgX2FkZFBsdWdpbk1vZGlmaWVyID0gZnVuY3Rpb24gX2FkZFBsdWdpbk1vZGlmaWVyKG1vZGlmaWVyLCB0d2VlbiwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgICBuZXh0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBuZXh0ID0gcHQuX25leHQ7XG4gICAgICBwdC5wID09PSBwcm9wZXJ0eSAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCk7XG4gICAgICBwdCA9IG5leHQ7XG4gICAgfVxuICB9LFxuICAgICAgX2tpbGxQcm9wVHdlZW5zT2YgPSBmdW5jdGlvbiBfa2lsbFByb3BUd2VlbnNPZihwcm9wZXJ0eSkge1xuICAgIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcsXG4gICAgICAgIG5leHQ7XG5cbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIG5leHQgPSBwdC5fbmV4dDtcblxuICAgICAgaWYgKHB0LnAgPT09IHByb3BlcnR5ICYmICFwdC5vcCB8fCBwdC5vcCA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoIXB0LmRlcCkge1xuICAgICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcgPSAxO1xuICAgICAgfVxuXG4gICAgICBwdCA9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICFoYXNOb25EZXBlbmRlbnRSZW1haW5pbmc7XG4gIH0sXG4gICAgICBfc2V0dGVyV2l0aE1vZGlmaWVyID0gZnVuY3Rpb24gX3NldHRlcldpdGhNb2RpZmllcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICAgIGRhdGEubVNldCh0YXJnZXQsIHByb3BlcnR5LCBkYXRhLm0uY2FsbChkYXRhLnR3ZWVuLCB2YWx1ZSwgZGF0YS5tdCksIGRhdGEpO1xuICB9LFxuICAgICAgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSA9IGZ1bmN0aW9uIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkocGFyZW50KSB7XG4gICAgdmFyIHB0ID0gcGFyZW50Ll9wdCxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgcHQyLFxuICAgICAgICBmaXJzdCxcbiAgICAgICAgbGFzdDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgICAgcHQyID0gZmlyc3Q7XG5cbiAgICAgIHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcbiAgICAgICAgcHQyID0gcHQyLl9uZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSB7XG4gICAgICAgIHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdCA9IHB0O1xuICAgICAgfVxuXG4gICAgICBpZiAocHQuX25leHQgPSBwdDIpIHtcbiAgICAgICAgcHQyLl9wcmV2ID0gcHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0ID0gcHQ7XG4gICAgICB9XG5cbiAgICAgIHB0ID0gbmV4dDtcbiAgICB9XG5cbiAgICBwYXJlbnQuX3B0ID0gZmlyc3Q7XG4gIH07XG5cbiAgdmFyIFByb3BUd2VlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9wVHdlZW4obmV4dCwgdGFyZ2V0LCBwcm9wLCBzdGFydCwgY2hhbmdlLCByZW5kZXJlciwgZGF0YSwgc2V0dGVyLCBwcmlvcml0eSkge1xuICAgICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgICAgdGhpcy5zID0gc3RhcnQ7XG4gICAgICB0aGlzLmMgPSBjaGFuZ2U7XG4gICAgICB0aGlzLnAgPSBwcm9wO1xuICAgICAgdGhpcy5yID0gcmVuZGVyZXIgfHwgX3JlbmRlclBsYWluO1xuICAgICAgdGhpcy5kID0gZGF0YSB8fCB0aGlzO1xuICAgICAgdGhpcy5zZXQgPSBzZXR0ZXIgfHwgX3NldHRlclBsYWluO1xuICAgICAgdGhpcy5wciA9IHByaW9yaXR5IHx8IDA7XG4gICAgICB0aGlzLl9uZXh0ID0gbmV4dDtcblxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgbmV4dC5fcHJldiA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9wcm90bzQgPSBQcm9wVHdlZW4ucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvNC5tb2RpZmllciA9IGZ1bmN0aW9uIG1vZGlmaWVyKGZ1bmMsIHR3ZWVuLCB0YXJnZXQpIHtcbiAgICAgIHRoaXMubVNldCA9IHRoaXMubVNldCB8fCB0aGlzLnNldDtcbiAgICAgIHRoaXMuc2V0ID0gX3NldHRlcldpdGhNb2RpZmllcjtcbiAgICAgIHRoaXMubSA9IGZ1bmM7XG4gICAgICB0aGlzLm10ID0gdGFyZ2V0O1xuICAgICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJvcFR3ZWVuO1xuICB9KCk7XG5cbiAgX2ZvckVhY2hOYW1lKF9jYWxsYmFja05hbWVzICsgXCJwYXJlbnQsZHVyYXRpb24sZWFzZSxkZWxheSxvdmVyd3JpdGUscnVuQmFja3dhcmRzLHN0YXJ0QXQseW95byxpbW1lZGlhdGVSZW5kZXIscmVwZWF0LHJlcGVhdERlbGF5LGRhdGEscGF1c2VkLHJldmVyc2VkLGxhenksY2FsbGJhY2tTY29wZSxzdHJpbmdGaWx0ZXIsaWQseW95b0Vhc2Usc3RhZ2dlcixpbmhlcml0LHJlcGVhdFJlZnJlc2gsa2V5ZnJhbWVzLGF1dG9SZXZlcnQsc2Nyb2xsVHJpZ2dlclwiLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG4gIH0pO1xuXG4gIF9nbG9iYWxzLlR3ZWVuTWF4ID0gX2dsb2JhbHMuVHdlZW5MaXRlID0gVHdlZW47XG4gIF9nbG9iYWxzLlRpbWVsaW5lTGl0ZSA9IF9nbG9iYWxzLlRpbWVsaW5lTWF4ID0gVGltZWxpbmU7XG4gIF9nbG9iYWxUaW1lbGluZSA9IG5ldyBUaW1lbGluZSh7XG4gICAgc29ydENoaWxkcmVuOiBmYWxzZSxcbiAgICBkZWZhdWx0czogX2RlZmF1bHRzLFxuICAgIGF1dG9SZW1vdmVDaGlsZHJlbjogdHJ1ZSxcbiAgICBpZDogXCJyb290XCIsXG4gICAgc21vb3RoQ2hpbGRUaW1pbmc6IHRydWVcbiAgfSk7XG4gIF9jb25maWcuc3RyaW5nRmlsdGVyID0gX2NvbG9yU3RyaW5nRmlsdGVyO1xuICB2YXIgX2dzYXAgPSB7XG4gICAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVQbHVnaW4oY29uZmlnKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdGltZWxpbmU6IGZ1bmN0aW9uIHRpbWVsaW5lKHZhcnMpIHtcbiAgICAgIHJldHVybiBuZXcgVGltZWxpbmUodmFycyk7XG4gICAgfSxcbiAgICBnZXRUd2VlbnNPZjogZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKTtcbiAgICB9LFxuICAgIGdldFByb3BlcnR5OiBmdW5jdGlvbiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgICBfaXNTdHJpbmcodGFyZ2V0KSAmJiAodGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpWzBdKTtcblxuICAgICAgdmFyIGdldHRlciA9IF9nZXRDYWNoZSh0YXJnZXQgfHwge30pLmdldCxcbiAgICAgICAgICBmb3JtYXQgPSB1bml0ID8gX3Bhc3NUaHJvdWdoIDogX251bWVyaWNJZlBvc3NpYmxlO1xuXG4gICAgICB1bml0ID09PSBcIm5hdGl2ZVwiICYmICh1bml0ID0gXCJcIik7XG4gICAgICByZXR1cm4gIXRhcmdldCA/IHRhcmdldCA6ICFwcm9wZXJ0eSA/IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgICAgIH0gOiBmb3JtYXQoKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiBfcGx1Z2luc1twcm9wZXJ0eV0uZ2V0IHx8IGdldHRlcikodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkpO1xuICAgIH0sXG4gICAgcXVpY2tTZXR0ZXI6IGZ1bmN0aW9uIHF1aWNrU2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHtcbiAgICAgIHRhcmdldCA9IHRvQXJyYXkodGFyZ2V0KTtcblxuICAgICAgaWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBzZXR0ZXJzID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBnc2FwLnF1aWNrU2V0dGVyKHQsIHByb3BlcnR5LCB1bml0KTtcbiAgICAgICAgfSksXG4gICAgICAgICAgICBsID0gc2V0dGVycy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgaSA9IGw7XG5cbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBzZXR0ZXJzW2ldKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRhcmdldCA9IHRhcmdldFswXSB8fCB7fTtcblxuICAgICAgdmFyIFBsdWdpbiA9IF9wbHVnaW5zW3Byb3BlcnR5XSxcbiAgICAgICAgICBjYWNoZSA9IF9nZXRDYWNoZSh0YXJnZXQpLFxuICAgICAgICAgIHAgPSBjYWNoZS5oYXJuZXNzICYmIChjYWNoZS5oYXJuZXNzLmFsaWFzZXMgfHwge30pW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eSxcbiAgICAgICAgICBzZXR0ZXIgPSBQbHVnaW4gPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHAgPSBuZXcgUGx1Z2luKCk7XG4gICAgICAgIF9xdWlja1R3ZWVuLl9wdCA9IDA7XG4gICAgICAgIHAuaW5pdCh0YXJnZXQsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgX3F1aWNrVHdlZW4sIDAsIFt0YXJnZXRdKTtcbiAgICAgICAgcC5yZW5kZXIoMSwgcCk7XG4gICAgICAgIF9xdWlja1R3ZWVuLl9wdCAmJiBfcmVuZGVyUHJvcFR3ZWVucygxLCBfcXVpY2tUd2Vlbik7XG4gICAgICB9IDogY2FjaGUuc2V0KHRhcmdldCwgcCk7XG5cbiAgICAgIHJldHVybiBQbHVnaW4gPyBzZXR0ZXIgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHNldHRlcih0YXJnZXQsIHAsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgY2FjaGUsIDEpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHF1aWNrVG86IGZ1bmN0aW9uIHF1aWNrVG8odGFyZ2V0LCBwcm9wZXJ0eSwgdmFycykge1xuICAgICAgdmFyIF9tZXJnZTI7XG5cbiAgICAgIHZhciB0d2VlbiA9IGdzYXAudG8odGFyZ2V0LCBfbWVyZ2UoKF9tZXJnZTIgPSB7fSwgX21lcmdlMltwcm9wZXJ0eV0gPSBcIis9MC4xXCIsIF9tZXJnZTIucGF1c2VkID0gdHJ1ZSwgX21lcmdlMiksIHZhcnMgfHwge30pKSxcbiAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyh2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSkge1xuICAgICAgICByZXR1cm4gdHdlZW4ucmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpO1xuICAgICAgfTtcblxuICAgICAgZnVuYy50d2VlbiA9IHR3ZWVuO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfSxcbiAgICBpc1R3ZWVuaW5nOiBmdW5jdGlvbiBpc1R3ZWVuaW5nKHRhcmdldHMpIHtcbiAgICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgdHJ1ZSkubGVuZ3RoID4gMDtcbiAgICB9LFxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbiBkZWZhdWx0cyh2YWx1ZSkge1xuICAgICAgdmFsdWUgJiYgdmFsdWUuZWFzZSAmJiAodmFsdWUuZWFzZSA9IF9wYXJzZUVhc2UodmFsdWUuZWFzZSwgX2RlZmF1bHRzLmVhc2UpKTtcbiAgICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICAgIH0sXG4gICAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcodmFsdWUpIHtcbiAgICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyRWZmZWN0OiBmdW5jdGlvbiByZWdpc3RlckVmZmVjdChfcmVmMykge1xuICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdCxcbiAgICAgICAgICBwbHVnaW5zID0gX3JlZjMucGx1Z2lucyxcbiAgICAgICAgICBkZWZhdWx0cyA9IF9yZWYzLmRlZmF1bHRzLFxuICAgICAgICAgIGV4dGVuZFRpbWVsaW5lID0gX3JlZjMuZXh0ZW5kVGltZWxpbmU7XG4gICAgICAocGx1Z2lucyB8fCBcIlwiKS5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xuICAgICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBfZWZmZWN0c1tuYW1lXSA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzLCB0bCkge1xuICAgICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChleHRlbmRUaW1lbGluZSkge1xuICAgICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoX2VmZmVjdHNbbmFtZV0odGFyZ2V0cywgX2lzT2JqZWN0KHZhcnMpID8gdmFycyA6IChwb3NpdGlvbiA9IHZhcnMpICYmIHt9LCB0aGlzKSwgcG9zaXRpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVnaXN0ZXJFYXNlOiBmdW5jdGlvbiByZWdpc3RlckVhc2UobmFtZSwgZWFzZSkge1xuICAgICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICAgIH0sXG4gICAgcGFyc2VFYXNlOiBmdW5jdGlvbiBwYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgICB9LFxuICAgIGdldEJ5SWQ6IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gICAgfSxcbiAgICBleHBvcnRSb290OiBmdW5jdGlvbiBleHBvcnRSb290KHZhcnMsIGluY2x1ZGVEZWxheWVkQ2FsbHMpIHtcbiAgICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgICAgdmFycyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgbmV4dDtcbiAgICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICAgIF9nbG9iYWxUaW1lbGluZS5yZW1vdmUodGwpO1xuXG4gICAgICB0bC5fZHAgPSAwO1xuICAgICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgICBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgICAgaWYgKGluY2x1ZGVEZWxheWVkQ2FsbHMgfHwgISghY2hpbGQuX2R1ciAmJiBjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuICYmIGNoaWxkLnZhcnMub25Db21wbGV0ZSA9PT0gY2hpbGQuX3RhcmdldHNbMF0pKSB7XG4gICAgICAgICAgX2FkZFRvVGltZWxpbmUodGwsIGNoaWxkLCBjaGlsZC5fc3RhcnQgLSBjaGlsZC5fZGVsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgICAgcmV0dXJuIHRsO1xuICAgIH0sXG4gICAgdXRpbHM6IHtcbiAgICAgIHdyYXA6IHdyYXAsXG4gICAgICB3cmFwWW95bzogd3JhcFlveW8sXG4gICAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxuICAgICAgcmFuZG9tOiByYW5kb20sXG4gICAgICBzbmFwOiBzbmFwLFxuICAgICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgICBnZXRVbml0OiBnZXRVbml0LFxuICAgICAgY2xhbXA6IGNsYW1wLFxuICAgICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcbiAgICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBtYXBSYW5nZTogbWFwUmFuZ2UsXG4gICAgICBwaXBlOiBwaXBlLFxuICAgICAgdW5pdGl6ZTogdW5pdGl6ZSxcbiAgICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICAgIHNodWZmbGU6IHNodWZmbGVcbiAgICB9LFxuICAgIGluc3RhbGw6IF9pbnN0YWxsLFxuICAgIGVmZmVjdHM6IF9lZmZlY3RzLFxuICAgIHRpY2tlcjogX3RpY2tlcixcbiAgICB1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxuICAgIHBsdWdpbnM6IF9wbHVnaW5zLFxuICAgIGdsb2JhbFRpbWVsaW5lOiBfZ2xvYmFsVGltZWxpbmUsXG4gICAgY29yZToge1xuICAgICAgUHJvcFR3ZWVuOiBQcm9wVHdlZW4sXG4gICAgICBnbG9iYWxzOiBfYWRkR2xvYmFsLFxuICAgICAgVHdlZW46IFR3ZWVuLFxuICAgICAgVGltZWxpbmU6IFRpbWVsaW5lLFxuICAgICAgQW5pbWF0aW9uOiBBbmltYXRpb24sXG4gICAgICBnZXRDYWNoZTogX2dldENhY2hlLFxuICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtOiBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sXG4gICAgICBzdXBwcmVzc092ZXJ3cml0ZXM6IGZ1bmN0aW9uIHN1cHByZXNzT3ZlcndyaXRlcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3N1cHByZXNzT3ZlcndyaXRlcyA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxkZWxheWVkQ2FsbCxzZXQsa2lsbFR3ZWVuc09mXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIF9nc2FwW25hbWVdID0gVHdlZW5bbmFtZV07XG4gIH0pO1xuXG4gIF90aWNrZXIuYWRkKFRpbWVsaW5lLnVwZGF0ZVJvb3QpO1xuXG4gIF9xdWlja1R3ZWVuID0gX2dzYXAudG8oe30sIHtcbiAgICBkdXJhdGlvbjogMFxuICB9KTtcblxuICB2YXIgX2dldFBsdWdpblByb3BUd2VlbiA9IGZ1bmN0aW9uIF9nZXRQbHVnaW5Qcm9wVHdlZW4ocGx1Z2luLCBwcm9wKSB7XG4gICAgdmFyIHB0ID0gcGx1Z2luLl9wdDtcblxuICAgIHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wICYmIHB0Lm9wICE9PSBwcm9wICYmIHB0LmZwICE9PSBwcm9wKSB7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBwdDtcbiAgfSxcbiAgICAgIF9hZGRNb2RpZmllcnMgPSBmdW5jdGlvbiBfYWRkTW9kaWZpZXJzKHR3ZWVuLCBtb2RpZmllcnMpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgICBwLFxuICAgICAgICBpLFxuICAgICAgICBwdDtcblxuICAgIGZvciAocCBpbiBtb2RpZmllcnMpIHtcbiAgICAgIGkgPSB0YXJnZXRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBwdCA9IHR3ZWVuLl9wdExvb2t1cFtpXVtwXTtcblxuICAgICAgICBpZiAocHQgJiYgKHB0ID0gcHQuZCkpIHtcbiAgICAgICAgICBpZiAocHQuX3B0KSB7XG4gICAgICAgICAgICBwdCA9IF9nZXRQbHVnaW5Qcm9wVHdlZW4ocHQsIHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHB0ICYmIHB0Lm1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyc1twXSwgdHdlZW4sIHRhcmdldHNbaV0sIHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAgICAgX2J1aWxkTW9kaWZpZXJQbHVnaW4gPSBmdW5jdGlvbiBfYnVpbGRNb2RpZmllclBsdWdpbihuYW1lLCBtb2RpZmllcikge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcmF3VmFyczogMSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuICAgICAgICB0d2Vlbi5fb25Jbml0ID0gZnVuY3Rpb24gKHR3ZWVuKSB7XG4gICAgICAgICAgdmFyIHRlbXAsIHA7XG5cbiAgICAgICAgICBpZiAoX2lzU3RyaW5nKHZhcnMpKSB7XG4gICAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGVtcFtuYW1lXSA9IDE7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgIHRlbXBbcF0gPSBtb2RpZmllcih2YXJzW3BdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2FkZE1vZGlmaWVycyh0d2VlbiwgdmFycyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ3NhcCA9IF9nc2FwLnJlZ2lzdGVyUGx1Z2luKHtcbiAgICBuYW1lOiBcImF0dHJcIixcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgICB2YXIgcCwgcHQ7XG5cbiAgICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICAgIHB0ID0gdGhpcy5hZGQodGFyZ2V0LCBcInNldEF0dHJpYnV0ZVwiLCAodGFyZ2V0LmdldEF0dHJpYnV0ZShwKSB8fCAwKSArIFwiXCIsIHZhcnNbcF0sIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcbiAgICAgICAgcHQgJiYgKHB0Lm9wID0gcCk7XG5cbiAgICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiBcImVuZEFycmF5XCIsXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIGksIHRhcmdldFtpXSB8fCAwLCB2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBfYnVpbGRNb2RpZmllclBsdWdpbihcInJvdW5kUHJvcHNcIiwgX3JvdW5kTW9kaWZpZXIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcIm1vZGlmaWVyc1wiKSwgX2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJzbmFwXCIsIHNuYXApKSB8fCBfZ3NhcDtcbiAgVHdlZW4udmVyc2lvbiA9IFRpbWVsaW5lLnZlcnNpb24gPSBnc2FwLnZlcnNpb24gPSBcIjMuMTAuNFwiO1xuICBfY29yZVJlYWR5ID0gMTtcbiAgX3dpbmRvd0V4aXN0cygpICYmIF93YWtlKCk7XG4gIHZhciBQb3dlcjAgPSBfZWFzZU1hcC5Qb3dlcjAsXG4gICAgICBQb3dlcjEgPSBfZWFzZU1hcC5Qb3dlcjEsXG4gICAgICBQb3dlcjIgPSBfZWFzZU1hcC5Qb3dlcjIsXG4gICAgICBQb3dlcjMgPSBfZWFzZU1hcC5Qb3dlcjMsXG4gICAgICBQb3dlcjQgPSBfZWFzZU1hcC5Qb3dlcjQsXG4gICAgICBMaW5lYXIgPSBfZWFzZU1hcC5MaW5lYXIsXG4gICAgICBRdWFkID0gX2Vhc2VNYXAuUXVhZCxcbiAgICAgIEN1YmljID0gX2Vhc2VNYXAuQ3ViaWMsXG4gICAgICBRdWFydCA9IF9lYXNlTWFwLlF1YXJ0LFxuICAgICAgUXVpbnQgPSBfZWFzZU1hcC5RdWludCxcbiAgICAgIFN0cm9uZyA9IF9lYXNlTWFwLlN0cm9uZyxcbiAgICAgIEVsYXN0aWMgPSBfZWFzZU1hcC5FbGFzdGljLFxuICAgICAgQmFjayA9IF9lYXNlTWFwLkJhY2ssXG4gICAgICBTdGVwcGVkRWFzZSA9IF9lYXNlTWFwLlN0ZXBwZWRFYXNlLFxuICAgICAgQm91bmNlID0gX2Vhc2VNYXAuQm91bmNlLFxuICAgICAgU2luZSA9IF9lYXNlTWFwLlNpbmUsXG4gICAgICBFeHBvID0gX2Vhc2VNYXAuRXhwbyxcbiAgICAgIENpcmMgPSBfZWFzZU1hcC5DaXJjO1xuXG4gIHZhciBfd2luJDEsXG4gICAgICBfZG9jJDEsXG4gICAgICBfZG9jRWxlbWVudCxcbiAgICAgIF9wbHVnaW5Jbml0dGVkLFxuICAgICAgX3RlbXBEaXYsXG4gICAgICBfdGVtcERpdlN0eWxlcixcbiAgICAgIF9yZWNlbnRTZXR0ZXJQbHVnaW4sXG4gICAgICBfd2luZG93RXhpc3RzJDEgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICB9LFxuICAgICAgX3RyYW5zZm9ybVByb3BzID0ge30sXG4gICAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgICBfYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgICAgX2JpZ051bSQxID0gMWU4LFxuICAgICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuICAgICAgX2hvcml6b250YWxFeHAgPSAvKGxlZnR8cmlnaHR8d2lkdGh8bWFyZ2lufHBhZGRpbmd8eCkvaSxcbiAgICAgIF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXVxcUy8sXG4gICAgICBfcHJvcGVydHlBbGlhc2VzID0ge1xuICAgIGF1dG9BbHBoYTogXCJvcGFjaXR5LHZpc2liaWxpdHlcIixcbiAgICBzY2FsZTogXCJzY2FsZVgsc2NhbGVZXCIsXG4gICAgYWxwaGE6IFwib3BhY2l0eVwiXG4gIH0sXG4gICAgICBfcmVuZGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XG4gIH0sXG4gICAgICBfcmVuZGVyUHJvcFdpdGhFbmQgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFdpdGhFbmQocmF0aW8sIGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID09PSAxID8gZGF0YS5lIDogTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xuICB9LFxuICAgICAgX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nKHJhdGlvLCBkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51IDogZGF0YS5iLCBkYXRhKTtcbiAgfSxcbiAgICAgIF9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJSb3VuZGVkQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICAgIHZhciB2YWx1ZSA9IGRhdGEucyArIGRhdGEuYyAqIHJhdGlvO1xuICAgIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBfih2YWx1ZSArICh2YWx1ZSA8IDAgPyAtLjUgOiAuNSkpICsgZGF0YS51LCBkYXRhKTtcbiAgfSxcbiAgICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUocmF0aW8sIGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID8gZGF0YS5lIDogZGF0YS5iLCBkYXRhKTtcbiAgfSxcbiAgICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQocmF0aW8sIGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvICE9PSAxID8gZGF0YS5iIDogZGF0YS5lLCBkYXRhKTtcbiAgfSxcbiAgICAgIF9zZXR0ZXJDU1NTdHlsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NTdHlsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gIH0sXG4gICAgICBfc2V0dGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NQcm9wKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRhcmdldC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICB9LFxuICAgICAgX3NldHRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGFyZ2V0Ll9nc2FwW3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9LFxuICAgICAgX3NldHRlclNjYWxlID0gZnVuY3Rpb24gX3NldHRlclNjYWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRhcmdldC5fZ3NhcC5zY2FsZVggPSB0YXJnZXQuX2dzYXAuc2NhbGVZID0gdmFsdWU7XG4gIH0sXG4gICAgICBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclNjYWxlV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gICAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gdmFsdWU7XG4gICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG4gIH0sXG4gICAgICBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICAgIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgICBjYWNoZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbiAgfSxcbiAgICAgIF90cmFuc2Zvcm1Qcm9wID0gXCJ0cmFuc2Zvcm1cIixcbiAgICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgICAgX3N1cHBvcnRzM0QsXG4gICAgICBfY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50KHR5cGUsIG5zKSB7XG4gICAgdmFyIGUgPSBfZG9jJDEuY3JlYXRlRWxlbWVudE5TID8gX2RvYyQxLmNyZWF0ZUVsZW1lbnROUygobnMgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jJDEuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICByZXR1cm4gZS5zdHlsZSA/IGUgOiBfZG9jJDEuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgfSxcbiAgICAgIF9nZXRDb21wdXRlZFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSB7XG4gICAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgIHJldHVybiBjc1twcm9wZXJ0eV0gfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSB8fCAhc2tpcFByZWZpeEZhbGxiYWNrICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX2NoZWNrUHJvcFByZWZpeChwcm9wZXJ0eSkgfHwgcHJvcGVydHksIDEpIHx8IFwiXCI7XG4gIH0sXG4gICAgICBfcHJlZml4ZXMgPSBcIk8sTW96LG1zLE1zLFdlYmtpdFwiLnNwbGl0KFwiLFwiKSxcbiAgICAgIF9jaGVja1Byb3BQcmVmaXggPSBmdW5jdGlvbiBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5LCBlbGVtZW50LCBwcmVmZXJQcmVmaXgpIHtcbiAgICB2YXIgZSA9IGVsZW1lbnQgfHwgX3RlbXBEaXYsXG4gICAgICAgIHMgPSBlLnN0eWxlLFxuICAgICAgICBpID0gNTtcblxuICAgIGlmIChwcm9wZXJ0eSBpbiBzICYmICFwcmVmZXJQcmVmaXgpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9XG5cbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuXG4gICAgd2hpbGUgKGktLSAmJiAhKF9wcmVmaXhlc1tpXSArIHByb3BlcnR5IGluIHMpKSB7fVxuXG4gICAgcmV0dXJuIGkgPCAwID8gbnVsbCA6IChpID09PSAzID8gXCJtc1wiIDogaSAPSAwID8gX3ByZWZpeGVzW2ldIDogXCJcIikgKyBwcm9wZXJ0eTtcbiAgfSxcbiAgICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgICBpZiAoX3dpbmRvd0V4aXN0cyQxKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgICBfd2luJDEgPSB3aW5kb3c7XG4gICAgICBfZG9jJDEgPSBfd2luJDEuZG9jdW1lbnQ7XG4gICAgICBfZG9jRWxlbWVudCA9IF9kb2MkMS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBfdGVtcERpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpIHx8IHtcbiAgICAgICAgc3R5bGU6IHt9XG4gICAgICB9O1xuICAgICAgX3RlbXBEaXZTdHlsZXIgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIjtcbiAgICAgIF90ZW1wRGl2LnN0eWxlLmNzc1RleHQgPSBcImJvcmRlci13aWR0aDowO2xpbmUtaGVpZ2h0OjA7cG9zaXRpb246YWJzb2x1dGU7cGFkZGluZzowXCI7XG4gICAgICBfc3VwcG9ydHMzRCA9ICEhX2NoZWNrUHJvcFByZWZpeChcInBlcnNwZWN0aXZlXCIpO1xuICAgICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICAgIH1cbiAgfSxcbiAgICAgIF9nZXRCQm94SGFjayA9IGZ1bmN0aW9uIF9nZXRCQm94SGFjayhzd2FwSWZQb3NzaWJsZSkge1xuICAgIHZhciBzdmcgPSBfY3JlYXRlRWxlbWVudChcInN2Z1wiLCB0aGlzLm93bmVyU1ZHRWxlbWVudCAmJiB0aGlzLm93bmVyU1ZHRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSB8fCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpLFxuICAgICAgICBvbGRQYXJlbnQgPSB0aGlzLnBhcmVudE5vZGUsXG4gICAgICAgIG9sZFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nLFxuICAgICAgICBvbGRDU1MgPSB0aGlzLnN0eWxlLmNzc1RleHQsXG4gICAgICAgIGJib3g7XG5cbiAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gICAgc3ZnLmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuICAgIGlmIChzd2FwSWZQb3NzaWJsZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgICB0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDtcbiAgICAgICAgdGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2dzYXBCQm94KSB7XG4gICAgICBiYm94ID0gdGhpcy5fZ3NhcEJCb3goKTtcbiAgICB9XG5cbiAgICBpZiAob2xkUGFyZW50KSB7XG4gICAgICBpZiAob2xkU2libGluZykge1xuICAgICAgICBvbGRQYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIG9sZFNpYmxpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgICB0aGlzLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gICAgcmV0dXJuIGJib3g7XG4gIH0sXG4gICAgICBfZ2V0QXR0cmlidXRlRmFsbGJhY2tzID0gZnVuY3Rpb24gX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIGF0dHJpYnV0ZXNBcnJheSkge1xuICAgIHZhciBpID0gYXR0cmlidXRlc0FycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZXNBcnJheVtpXSkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlc0FycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xuICAgIHZhciBib3VuZHM7XG5cbiAgICB0cnkge1xuICAgICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBib3VuZHMgJiYgKGJvdW5kcy53aWR0aCB8fCBib3VuZHMuaGVpZ2h0KSB8fCB0YXJnZXQuZ2V0QkJveCA9PT0gX2dldEJCb3hIYWNrIHx8IChib3VuZHMgPSBfZ2V0QkJveEhhY2suY2FsbCh0YXJnZXQsIHRydWUpKTtcbiAgICByZXR1cm4gYm91bmRzICYmICFib3VuZHMud2lkdGggJiYgIWJvdW5kcy54ICYmICFib3VuZHMueSA/IHtcbiAgICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgICB5OiArX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIFtcInlcIiwgXCJjeVwiLCBcInkxXCJdKSB8fCAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9IDogYm91bmRzO1xuICB9LFxuICAgICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgICByZXR1cm4gISEoZS5nZXRDVE0gJiYgKCFlLnBhcmVudE5vZGUgfHwgZS5vd25lclNWR0VsZW1lbnQpICYmIF9nZXRCQm94KGUpKTtcbiAgfSxcbiAgICAgIF9yZW1vdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG5cbiAgICAgIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3RyYW5zZm9ybVByb3A7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgICBpZiAocHJvcGVydHkuc3Vic3RyKDAsIDIpID09PSBcIm1zXCIgfHwgcHJvcGVydHkuc3Vic3RyKDAsIDYpID09PSBcIndlYmtpdFwiKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBcIi1cIiArIHByb3BlcnR5O1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgICAgIF9hZGROb25Ud2VlbmluZ1BUID0gZnVuY3Rpb24gX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBiZWdpbm5pbmcsIGVuZCwgb25seVNldEF0RW5kKSB7XG4gICAgdmFyIHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBvbmx5U2V0QXRFbmQgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKTtcbiAgICBwbHVnaW4uX3B0ID0gcHQ7XG4gICAgcHQuYiA9IGJlZ2lubmluZztcbiAgICBwdC5lID0gZW5kO1xuXG4gICAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblxuICAgIHJldHVybiBwdDtcbiAgfSxcbiAgICAgIF9ub25Db252ZXJ0aWJsZVVuaXRzID0ge1xuICAgIGRlZzogMSxcbiAgICByYWQ6IDEsXG4gICAgdHVybjogMVxuICB9LFxuICAgICAgX2NvbnZlcnRUb1VuaXQgPSBmdW5jdGlvbiBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgdW5pdCkge1xuICAgIHZhciBjdXJWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDAsXG4gICAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxuICAgICAgICBzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxuICAgICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXG4gICAgICAgIGlzUm9vdFNWRyA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIsXG4gICAgICAgIG1lYXN1cmVQcm9wZXJ0eSA9IChpc1Jvb3RTVkcgPyBcImNsaWVudFwiIDogXCJvZmZzZXRcIikgKyAoaG9yaXpvbnRhbCA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIpLFxuICAgICAgICBhbW91bnQgPSAxMDAsXG4gICAgICAgIHRvUGl4ZWxzID0gdW5pdCA9PT0gXCJweFwiLFxuICAgICAgICB0b1BlcmNlbnQgPSB1bml0ID09PSBcIiVcIixcbiAgICAgICAgcHgsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGlzU1ZHO1xuXG4gICAgaWYgKHVuaXQgPT09IGN1clVuaXQgfHwgIWN1clZhbHVlIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW3VuaXRdIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW2N1clVuaXRdKSB7XG4gICAgICByZXR1cm4gY3VyVmFsdWU7XG4gICAgfVxuXG4gICAgY3VyVW5pdCAhPT0gXCJweFwiICYmICF0b1BpeGVscyAmJiAoY3VyVmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgXCJweFwiKSk7XG4gICAgaXNTVkcgPSB0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpO1xuXG4gICAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgICBweCA9IGlzU1ZHID8gdGFyZ2V0LmdldEJCb3goKVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gOiB0YXJnZXRbbWVhc3VyZVByb3BlcnR5XTtcbiAgICAgIHJldHVybiBfcm91bmQodG9QZXJjZW50ID8gY3VyVmFsdWUgLyBweCAqIGFtb3VudCA6IGN1clZhbHVlIC8gMTAwICogcHgpO1xuICAgIH1cblxuICAgIHN0eWxlW2hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA9IGFtb3VudCArICh0b1BpeGVscyA/IGN1clVuaXQgOiB1bml0KTtcbiAgICBwYXJlbnQgPSBcHJvcGVydHkuaW5kZXhPZihcImFkaXVzXCIpIHx8IHVuaXQgPT09IFwiZW1cIiAmJiB0YXJnZXQuYXBwZW5kQ2hpbGQgJiYgIWlzUm9vdFNWRyA/IHRhcmdldCA6IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKGlzU1ZHKSB7XG4gICAgICBwYXJlbnQgPSAodGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCB8fCB7fSkucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MkMSB8fCAhcGFyZW50LmFwcGVuZENoaWxkKSB7XG4gICAgICBwYXJlbnQgPSBfZG9jJDEuYm9keTtcbiAgICB9XG5cbiAgICBjYWNoZSA9IHBhcmVudC5fZ3NhcDtcblxuICAgIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUpIHtcbiAgICAgIHJldHVybiBfcm91bmQoY3VyVmFsdWUgLyBjYWNoZS53aWR0aCAqIGFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChzdHlsZS5wb3NpdGlvbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJwb3NpdGlvblwiKSk7XG4gICAgICBwYXJlbnQgPT09IHRhcmdldCAmJiAoc3R5bGUucG9zaXRpb24gPSBcInN0YXRpY1wiKTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChfdGVtcERpdik7XG4gICAgICBweCA9IF90ZW1wRGl2W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICAgIGlmIChob3Jpem9udGFsICYmIHRvUGVyY2VudCkge1xuICAgICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgICBjYWNoZS50aW1lID0gX3RpY2tlci50aW1lO1xuICAgICAgICBjYWNoZS53aWR0aCA9IHBhcmVudFttZWFzdXJlUHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfcm91bmQodG9QaXhlbHMgPyBweCAqIGN1clZhbHVlIC8gYW1vdW50IDogcHggJiYgY3VyVmFsdWUgPyBhbW91bnQgLyBweCAqIGN1clZhbHVlIDogMCk7XG4gIH0sXG4gICAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gICAgaWYgKHByb3BlcnR5IGluIF9wcm9wZXJ0eUFsaWFzZXMgJiYgcHJvcGVydHkgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgIHByb3BlcnR5ID0gX3Byb3BlcnR5QWxpYXNlc1twcm9wZXJ0eV07XG5cbiAgICAgIGlmIChcHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5zcGxpdChcIixcIilbMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wZXJ0eV0gJiYgcHJvcGVydHkgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgIHZhbHVlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdW5jYWNoZSk7XG4gICAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogdmFsdWUuc3ZnID8gdmFsdWUub3JpZ2luIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XTtcblxuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCBKHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICAgIHZhbHVlID0gX3NwZWNpYWxQcm9wc1twcm9wZXJ0eV0gJiYgX3NwZWNpYWxQcm9wc1twcm9wZXJ0eV0odGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCkgfHwgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkgfHwgX2dldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IChwcm9wZXJ0eSA9PT0gXCJvcGFjaXR5XCIgPyAxIDogMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQgJiYgIX4odmFsdWUgKyBcIlwiKS50cmltKCkuaW5kZXhPZihcIiBcIikgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgdW5pdCkgKyB1bml0IDogdmFsdWU7XG4gIH0sXG4gICAgICBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nID0gZnVuY3Rpb24gX3R3ZWVuQ29tcGxleENTU1N0cmluZyh0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0IHx8IHN0YXJ0ID09PSBcIm5vbmVcIikge1xuICAgICAgdmFyIHAgPSBfY2hlY2tQcm9wUHJlZml4KHByb3AsIHRhcmdldCwgMSksXG4gICAgICAgICAgcyA9IHAgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwLCAxKTtcblxuICAgICAgaWYgKHMgJiYgcyAhPT0gc3RhcnQpIHtcbiAgICAgICAgcHJvcCA9IHA7XG4gICAgICAgIHN0YXJ0ID0gcztcbiAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJib3JkZXJDb2xvclwiKSB7XG4gICAgICAgIHN0YXJ0ID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcImJvcmRlclRvcENvbG9yXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxuICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgICBhLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHN0YXJ0VmFsdWVzLFxuICAgICAgICBzdGFydE51bSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICAgIGVuZFZhbHVlLFxuICAgICAgICBlbmROdW0sXG4gICAgICAgIGNodW5rLFxuICAgICAgICBlbmRVbml0LFxuICAgICAgICBzdGFydFVuaXQsXG4gICAgICAgIGVuZFZhbHVlcztcbiAgICBwdC5iID0gc3RhcnQ7XG4gICAgcHQuZSA9IGVuZDtcbiAgICBzdGFydCArPSBcIlwiO1xuICAgIGVuZCArPSBcIlwiO1xuXG4gICAgaWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIHRhcmdldC5zdHlsZVtwcm9wXSA9IGVuZDtcbiAgICAgIGVuZCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcCkgfHwgZW5kO1xuICAgICAgdGFyZ2V0LnN0eWxlW3Byb3BdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgYSA9IFtzdGFydCwgZW5kXTtcblxuICAgIF9jb2xvclN0cmluZ0ZpbHRlcihhKTtcblxuICAgIHN0YXJ0ID0gYVswXTtcbiAgICBlbmQgPSBhWzFdO1xuICAgIHN0YXJ0VmFsdWVzID0gc3RhcnQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcbiAgICBlbmRWYWx1ZXMgPSBlbmQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblxuICAgIGlmIChlbmRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICB3aGlsZSAocmVzdWx0ID0gX251bVdpdGhVbml0RXhwLmV4ZWMoZW5kKSkge1xuICAgICAgICBlbmRWYWx1ZSA9IHJlc3VsdFswXTtcbiAgICAgICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgICAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIiB8fCBjaHVuay5zdWJzdHIoLTUpID09PSBcImhzbGEoXCIpIHtcbiAgICAgICAgICBjb2xvciA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kVmFsdWUgIT09IChzdGFydFZhbHVlID0gc3RhcnRWYWx1ZXNbbWF0Y2hJbmRleCsrXSB8fCBcIlwiKSkge1xuICAgICAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydFZhbHVlKSB8fCAwO1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IHN0YXJ0VmFsdWUuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgICAgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiAmJiAoZW5kVmFsdWUgPSBfcGFyc2VSZWxhdGl2ZShzdGFydE51bSwgZW5kVmFsdWUpICsgc3RhcnRVbml0KTtcbiAgICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgICAgICBlbmRVbml0ID0gZW5kVmFsdWUuc3Vic3RyKChlbmROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICAgIGluZGV4ID0gX251bVdpdGhVbml0RXhwLmxhc3RJbmRleCAtIGVuZFVuaXQubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKCFlbmRVbml0KSB7XG4gICAgICAgICAgICBlbmRVbml0ID0gZW5kVW5pdCB8fCBfY29uZmlnLnVuaXRzW3Byb3BdIHx8IHN0YXJ0VW5pdDtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGVuZCArPSBlbmRVbml0O1xuICAgICAgICAgICAgICBwdC5lICs9IGVuZFVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCkge1xuICAgICAgICAgICAgc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHQuX3B0ID0ge1xuICAgICAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgICAgICBjOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCB8fCBwcm9wID09PSBcInpJbmRleFwiID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB0LnIgPSBwcm9wID09PSBcImRpc3BsYXlcIiAmJiBlbmQgPT09IFwibm9uZVwiID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZTtcbiAgICB9XG5cbiAgICBfcmVsRXhwLnRlc3QoZW5kKSAmJiAocHQuZSA9IDApO1xuICAgIHRoaXMuX3B0ID0gcHQ7XG4gICAgcmV0dXJuIHB0O1xuICB9LFxuICAgICAgX2tleXdvcmRUb1BlcmNlbnQgPSB7XG4gICAgdG9wOiBcIjAlXCIsXG4gICAgYm90dG9tOiBcIjEwMCVcIixcbiAgICBsZWZ0OiBcIjAlXCIsXG4gICAgcmlnaHQ6IFwiMTAwJVwiLFxuICAgIGNlbnRlcjogXCI1MCVcIlxuICB9LFxuICAgICAgX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMgPSBmdW5jdGlvbiBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyh2YWx1ZSkge1xuICAgIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgeCA9IHNwbGl0WzBdLFxuICAgICAgICB5ID0gc3BsaXRbMV0gfHwgXCI1MCVcIjtcblxuICAgIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgICB2YWx1ZSA9IHg7XG4gICAgICB4ID0geTtcbiAgICAgIHkgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBzcGxpdFswXSA9IF9rZXl3b3JkVG9QZXJjZW50W3hdIHx8IHg7XG4gICAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICAgIHJldHVybiBzcGxpdC5qb2luKFwiIFwiKTtcbiAgfSxcbiAgICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgICBpZiAoZGF0YS50d2VlbiAmJiBkYXRhLnR3ZWVuLl90aW1lID09PSBkYXRhLnR3ZWVuLl9kdXIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBkYXRhLnQsXG4gICAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgICAgcHJvcHMgPSBkYXRhLnUsXG4gICAgICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICBjbGVhclRyYW5zZm9ybXMsXG4gICAgICAgICAgaTtcblxuICAgICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICAgIHN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICBjbGVhclRyYW5zZm9ybXMgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wcy5zcGxpdChcIixcIik7XG4gICAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKC0taSAIC0xKSB7XG4gICAgICAgICAgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICAgICAgaWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wXSkge1xuICAgICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICAgIHByb3AgPSBwcm9wID09PSBcInRyYW5zZm9ybU9yaWdpblwiID8gX3RyYW5zZm9ybU9yaWdpblByb3AgOiBfdHJhbnNmb3JtUHJvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICAgIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuXG4gICAgICAgICAgY2FjaGUudW5jYWNoZSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICAgICBfc3BlY2lhbFByb3BzID0ge1xuICAgIGNsZWFyUHJvcHM6IGZ1bmN0aW9uIGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICAgIGlmICh0d2Vlbi5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIpIHtcbiAgICAgICAgdmFyIHB0ID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMCwgX3JlbmRlckNsZWFyUHJvcHMpO1xuICAgICAgICBwdC51ID0gZW5kVmFsdWU7XG4gICAgICAgIHB0LnByID0gLTEwO1xuICAgICAgICBwdC50d2VlbiA9IHR3ZWVuO1xuXG4gICAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAgICAgX2lkZW50aXR5MkRNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF0sXG4gICAgICBfcm90YXRpb25hbFByb3BlcnRpZXMgPSB7fSxcbiAgICAgIF9pc051bGxUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfaXNOdWxsVHJhbnNmb3JtKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWU7XG4gIH0sXG4gICAgICBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpIHtcbiAgICB2YXIgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICByZXR1cm4gX2lzTnVsbFRyYW5zZm9ybShtYXRyaXhTdHJpbmcpID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXhTdHJpbmcuc3Vic3RyKDcpLm1hdGNoKF9udW1FeHApLm1hcChfcm91bmQpO1xuICB9LFxuICAgICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XG4gICAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IF9nZXRDYWNoZSh0YXJnZXQpLFxuICAgICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5leHRTaWJsaW5nLFxuICAgICAgICB0ZW1wLFxuICAgICAgICBhZGRlZFRvRE9NO1xuXG4gICAgaWYgKGNhY2hlLnN2ZyAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpKSB7XG4gICAgICB0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4O1xuICAgICAgbWF0cml4ID0gW3RlbXAuYSwgdGVtcC5iLCB0ZW1wLmMsIHRlbXAuZCwgdGVtcC5lLCB0ZW1wLmZdO1xuICAgICAgcmV0dXJuIG1hdHJpeC5qb2luKFwiLFwiKSA9PT0gXCIxLDAsMCwxLDAsMFwiID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXg7XG4gICAgfSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2Zykge1xuICAgICAgdGVtcCA9IHN0eWxlLmRpc3BsYXk7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgICAgIGlmICghcGFyZW50IHx8ICF0YXJnZXQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgIGFkZGVkVG9ET00gPSAxO1xuICAgICAgICBuZXh0U2libGluZyA9IHRhcmdldC5uZXh0U2libGluZztcblxuICAgICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBtYXRyaXggPSBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCk7XG4gICAgICB0ZW1wID8gc3R5bGUuZGlzcGxheSA9IHRlbXAgOiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBcImRpc3BsYXlcIik7XG5cbiAgICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICAgIG5leHRTaWJsaW5nID8gcGFyZW50Lmluc2VydEJlZm9yZSh0YXJnZXQsIG5leHRTaWJsaW5nKSA6IHBhcmVudCA/IHBhcmVudC5hcHBlbmRDaGlsZCh0YXJnZXQpIDogX2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm9yY2UyRCAmJiBtYXRyaXgubGVuZ3RoID4gNiA/IFttYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0sIG1hdHJpeFsxMl0sIG1hdHJpeFsxM11dIDogbWF0cml4O1xuICB9LFxuICAgICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICAgIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgbWF0cml4ID0gbWF0cml4QXJyYXkgfHwgX2dldE1hdHJpeCh0YXJnZXQsIHRydWUpLFxuICAgICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgICB5T3JpZ2luT2xkID0gY2FjaGUueU9yaWdpbiB8fCAwLFxuICAgICAgICB4T2Zmc2V0T2xkID0gY2FjaGUueE9mZnNldCB8fCAwLFxuICAgICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgICBhID0gbWF0cml4WzBdLFxuICAgICAgICBiID0gbWF0cml4WzFdLFxuICAgICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgICBkID0gbWF0cml4WzNdLFxuICAgICAgICB0eCA9IG1hdHJpeFs0XSxcbiAgICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICAgIG9yaWdpblNwbGl0ID0gb3JpZ2luLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgeE9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luU3BsaXRbMF0pIHx8IDAsXG4gICAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIGRldGVybWluYW50LFxuICAgICAgICB4LFxuICAgICAgICB5O1xuXG4gICAgaWYgKCFvcmlnaW5Jc0Fic29sdXRlKSB7XG4gICAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgICAgeE9yaWdpbiA9IGJvdW5kcy54ICsgKH5vcmlnaW5TcGxpdFswXS5pbmRleE9mKFwiJVwiKSA/IHhPcmlnaW4gLyAxMDAgKiBib3VuZHMud2lkdGggOiB4T3JpZ2luKTtcbiAgICAgIHlPcmlnaW4gPSBib3VuZHMueSArIChKG9yaWdpblNwbGl0WzFdIHx8IG9yaWdpblNwbGl0WzBdKS5pbmRleE9mKFwiJVwiKSA/IHlPcmlnaW4gLyAxMDAgKiBib3VuZHMuaGVpZ2h0IDogeU9yaWdpbik7XG4gICAgfSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMpKSB7XG4gICAgICB4ID0geE9yaWdpbiAqIChkIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqICgtYyAvIGRldGVybWluYW50KSArIChjICogdHkgLSBkICogdHgpIC8gZGV0ZXJtaW5hbnQ7XG4gICAgICB5ID0geE9yaWdpbiAqICgtYiAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoYSAvIGRldGVybWluYW50KSAtIChhICogdHkgLSBiICogdHgpIC8gZGV0ZXJtaW5hbnQ7XG4gICAgICB4T3JpZ2luID0geDtcbiAgICAgIHlPcmlnaW4gPSB5O1xuICAgIH1cblxuICAgIGlmIChzbW9vdGggfHwgc21vb3RoICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGgpIHtcbiAgICAgIHR4ID0geE9yaWdpbiAtIHhPcmlnaW5PbGQ7XG4gICAgICB0eSA9IHlPcmlnaW4gLSB5T3JpZ2luT2xkO1xuICAgICAgY2FjaGUueE9mZnNldCA9IHhPZmZzZXRPbGQgKyAodHggKiBhICsgdHkgKiBjKSAtIHR4O1xuICAgICAgY2FjaGUueU9mZnNldCA9IHlPZmZzZXRPbGQgKyAodHggKiBiICsgdHkgKiBkKSAtIHR5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgY2FjaGUueE9yaWdpbiA9IHhPcmlnaW47XG4gICAgY2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XG4gICAgY2FjaGUuc21vb3RoID0gISFzbW9vdGg7XG4gICAgY2FjaGUub3JpZ2luID0gb3JpZ2luO1xuICAgIGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XG4gICAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiMHB4IDBweFwiO1xuXG4gICAgaWYgKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XG4gICAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9yaWdpblwiLCB4T3JpZ2luT2xkLCB4T3JpZ2luKTtcblxuICAgICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPcmlnaW5cIiwgeU9yaWdpbk9sZCwgeU9yaWdpbik7XG5cbiAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T2Zmc2V0XCIsIHhPZmZzZXRPbGQsIGNhY2hlLnhPZmZzZXQpO1xuXG4gICAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9mZnNldFwiLCB5T2Zmc2V0T2xkLCBjYWNoZS55T2Zmc2V0KTtcbiAgICB9XG5cbiAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHhPcmlnaW4gKyBcIiBcIiArIHlPcmlnaW4pO1xuICB9LFxuICAgICAgX3BhcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdW5jYWNoZSkge1xuICAgIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBuZXcgR1NDYWNoZSh0YXJnZXQpO1xuXG4gICAgaWYgKFwieFwiIGluIGNhY2hlICYmICF1bmNhY2hlICYmICFjYWNoZS51bmNhY2hlKSB7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBpbnZlcnRlZFNjYWxlWCA9IGNhY2hlLnNjYWxlWCA8IDAsXG4gICAgICAgIHB4ID0gXCJweFwiLFxuICAgICAgICBkZWcgPSBcImRlZ1wiLFxuICAgICAgICBvcmlnaW4gPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB8fCBcIjBcIixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgeixcbiAgICAgICAgc2NhbGVYLFxuICAgICAgICBzY2FsZVksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICByb3RhdGlvblgsXG4gICAgICAgIHJvdGF0aW9uWSxcbiAgICAgICAgc2tld1gsXG4gICAgICAgIHNrZXdZLFxuICAgICAgICBwZXJzcGVjdGl2ZSxcbiAgICAgICAgeE9yaWdpbixcbiAgICAgICAgeU9yaWdpbixcbiAgICAgICAgbWF0cml4LFxuICAgICAgICBhbmdsZSxcbiAgICAgICAgY29zLFxuICAgICAgICBzaW4sXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGQsXG4gICAgICAgIGExMixcbiAgICAgICAgYTIyLFxuICAgICAgICB0MSxcbiAgICAgICAgdDIsXG4gICAgICAgIHQzLFxuICAgICAgICBhMTMsXG4gICAgICAgIGEyMyxcbiAgICAgICAgYTMzLFxuICAgICAgICBhNDIsXG4gICAgICAgIGE0MyxcbiAgICAgICAgYTMyO1xuICAgIHggPSB5ID0geiA9IHJvdGF0aW9uID0gcm90YXRpb25YID0gcm90YXRpb25ZID0gc2tld1ggPSBza2V3WSA9IHBlcnNwZWN0aXZlID0gMDtcbiAgICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICAgIGNhY2hlLnN2ZyA9ICEhKHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCkpO1xuICAgIG1hdHJpeCA9IF9nZXRNYXRyaXgodGFyZ2V0LCBjYWNoZS5zdmcpO1xuXG4gICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgdDEgPSAoIWNhY2hlLnVuY2FjaGUgfHwgb3JpZ2luID09PSBcIjBweCAwcHhcIikgJiYgIXVuY2FjaGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcblxuICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgdDEgfHwgb3JpZ2luLCAhIXQxIHx8IGNhY2hlLm9yaWdpbklzQWJzb2x1dGUsIGNhY2hlLnNtb290aCAhPT0gZmFsc2UsIG1hdHJpeCk7XG4gICAgfVxuXG4gICAgeE9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gfHwgMDtcbiAgICB5T3JpZ2luID0gY2FjaGUueU9yaWdpbiB8fCAwO1xuXG4gICAgaWYgKG1hdHJpeCAhPT0gX2lkZW50aXR5MkRNYXRyaXgpIHtcbiAgICAgIGEgPSBtYXRyaXhbMF07XG4gICAgICBiID0gbWF0cml4WzFdO1xuICAgICAgYyA9IG1hdHJpeFsyXTtcbiAgICAgIGQgPSBtYXRyaXhbM107XG4gICAgICB4ID0gYTEyID0gbWF0cml4WzRdO1xuICAgICAgeSA9IGEyMiA9IG1hdHJpeFs1XTtcblxuICAgICAgaWYgKG1hdHJpeC5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgICBzY2FsZVkgPSBNYXRoLnNxcnQoZCAqIGQgKyBjICogYyk7XG4gICAgICAgIHJvdGF0aW9uID0gYSB8fCBiID8gX2F0YW4yKGIsIGEpICogX1JBRDJERUcgOiAwO1xuICAgICAgICBza2V3WCA9IGMgfHwgZCA/IF9hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiAwO1xuICAgICAgICBza2V3WCAmJiAoc2NhbGVZICo9IE1hdGguYWJzKE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpKSk7XG5cbiAgICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICAgIHggLT0geE9yaWdpbiAtICh4T3JpZ2luICogYSArIHlPcmlnaW4gKiBjKTtcbiAgICAgICAgICB5IC09IHlPcmlnaW4gLSAoeE9yaWdpbiAqIGIgKyB5T3JpZ2luICogZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGEzMiA9IG1hdHJpeFs2XTtcbiAgICAgICAgYTQyID0gbWF0cml4WzddO1xuICAgICAgICBhMTMgPSBtYXRyaXhbOF07XG4gICAgICAgIGEyMyA9IG1hdHJpeFs5XTtcbiAgICAgICAgYTMzID0gbWF0cml4WzEwXTtcbiAgICAgICAgYTQzID0gbWF0cml4WzExXTtcbiAgICAgICAgeCA9IG1hdHJpeFsxMl07XG4gICAgICAgIHkgPSBtYXRyaXhbMTNdO1xuICAgICAgICB6ID0gbWF0cml4WzE0XTtcbiAgICAgICAgYW5nbGUgPSBfYXRhbjIoYTMyLCBhMzMpO1xuICAgICAgICByb3RhdGlvblggPSBhbmdsZSAqIF9SQUQyREVHO1xuXG4gICAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgICAgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICAgICAgICB0MSA9IGExMiAqIGNvcyArIGExMyAqIHNpbjtcbiAgICAgICAgICB0MiA9IGEyMiAqIGNvcyArIGEyMyAqIHNpbjtcbiAgICAgICAgICB0MyA9IGEzMiAqIGNvcyArIGEzMyAqIHNpbjtcbiAgICAgICAgICBhMTMgPSBhMTIgKiAtc2luICsgYTEzICogY29zO1xuICAgICAgICAgIGEyMyA9IGEyMiAqIC1zaW4gKyBhMjMgKiBjb3M7XG4gICAgICAgICAgYTMzID0gYTMyICogLXNpbiArIGEzMyAqIGNvcztcbiAgICAgICAgICBhNDMgPSBhNDIgKiAtc2luICsgYTQzICogY29zO1xuICAgICAgICAgIGExMiA9IHQxO1xuICAgICAgICAgIGEyMiA9IHQyO1xuICAgICAgICAgIGEzMiA9IHQzO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5nbGUgPSBfYXRhbjIoLWMsIGEzMyk7XG4gICAgICAgIHJvdGF0aW9uWSA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICAgIHQxID0gYSAqIGNvcyAtIGExMyAqIHNpbjtcbiAgICAgICAgICB0MiA9IGIgKiBjb3MgLSBhMjMgKiBzaW47XG4gICAgICAgICAgdDMgPSBjICogY29zIC0gYTMzICogc2luO1xuICAgICAgICAgIGE0MyA9IGQgKiBzaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgICAgYSA9IHQxO1xuICAgICAgICAgIGIgPSB0MjtcbiAgICAgICAgICBjID0gdDM7XG4gICAgICAgIH1cblxuICAgICAgICBhbmdsZSA9IF9hdGFuMihiLCBhKTtcbiAgICAgICAgcm90YXRpb24gPSBhbmdsZSAqIF9SQUQyREVHO1xuXG4gICAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgdDEgPSBhICogY29zICsgYiAqIHNpbjtcbiAgICAgICAgICB0MiA9IGExMiAqIGNvcyArIGEyMiAqIHNpbjtcbiAgICAgICAgICBiID0gYiAqIGNvcyAtIGEgKiBzaW47XG4gICAgICAgICAgYTIyID0gYTIyICogY29zIC0gYTEyICogc2luO1xuICAgICAgICAgIGEgPSB0MTtcbiAgICAgICAgICBhMTIgPSB0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3RhdGlvblggJiYgTWF0aC5hYnMocm90YXRpb25YKSArIE1hdGguYWJzKHJvdGF0aW9uKSAIDM1OS45KSB7XG4gICAgICAgICAgcm90YXRpb25YID0gcm90YXRpb24gPSAwO1xuICAgICAgICAgIHJvdGF0aW9uWSA9IDE4MCAtIHJvdGF0aW9uWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjYWxlWCA9IF9yb3VuZChNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSk7XG4gICAgICAgIHNjYWxlWSA9IF9yb3VuZChNYXRoLnNxcnQoYTIyICogYTIyICsgYTMyICogYTMyKSk7XG4gICAgICAgIGFuZ2xlID0gX2F0YW4yKGExMiwgYTIyKTtcbiAgICAgICAgc2tld1ggPSBNYXRoLmFicyhhbmdsZSkgPiAwLjAwMDIgPyBhbmdsZSAqIF9SQUQyREVHIDogMDtcbiAgICAgICAgcGVyc3BlY3RpdmUgPSBhNDMgPyAxIC8gKGE0MyA8IDAgPyAtYTQzIDogYTQzKSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgdDEgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgICBjYWNoZS5mb3JjZUNTUyA9IHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIikgfHwgIV9pc051bGxUcmFuc2Zvcm0oX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCkpO1xuICAgICAgICB0MSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHQxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnMoc2tld1gpID4gOTAgJiYgTWF0aC5hYnMoc2tld1gpIDwgMjcwKSB7XG4gICAgICBpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcbiAgICAgICAgc2NhbGVYICo9IC0xO1xuICAgICAgICBza2V3WCArPSByb3RhdGlvbiA8PSAwID8gMTgwIDogLTE4MDtcbiAgICAgICAgcm90YXRpb24gKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZVkgKj0gLTE7XG4gICAgICAgIHNrZXdYICs9IHNrZXdYIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVuY2FjaGUgPSB1bmNhY2hlIHx8IGNhY2hlLnVuY2FjaGU7XG4gICAgY2FjaGUueCA9IHggLSAoKGNhY2hlLnhQZXJjZW50ID0geCAmJiAoIXVuY2FjaGUgJiYgY2FjaGUueFBlcmNlbnQgfHwgKE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldFdpZHRoIC8gMikgPT09IE1hdGgucm91bmQoLXgpID8gLTUwIDogMCkpKSA/IHRhcmdldC5vZmZzZXRXaWR0aCAqIGNhY2hlLnhQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcbiAgICBjYWNoZS55ID0geSAtICgoY2FjaGUueVBlcmNlbnQgPSB5ICYmICghdW5jYWNoZSAmJiBjYWNoZS55UGVyY2VudCB8fCAoTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0SGVpZ2h0IC8gMikgPT09IE1hdGgucm91bmQoLXkpID8gLTUwIDogMCkpKSA/IHRhcmdldC5vZmZzZXRIZWlnaHQgKiBjYWNoZS55UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gICAgY2FjaGUueiA9IHogKyBweDtcbiAgICBjYWNoZS5zY2FsZVggPSBfcm91bmQoc2NhbGVYKTtcbiAgICBjYWNoZS5zY2FsZVkgPSBfcm91bmQoc2NhbGVZKTtcbiAgICBjYWNoZS5yb3RhdGlvbiA9IF9yb3VuZChyb3RhdGlvbikgKyBkZWc7XG4gICAgY2FjaGUucm90YXRpb25YID0gX3JvdW5kKHJvdGF0aW9uWCkgKyBkZWc7XG4gICAgY2FjaGUucm90YXRpb25ZID0gX3JvdW5kKHJvdGF0aW9uWSkgKyBkZWc7XG4gICAgY2FjaGUuc2tld1ggPSBza2V3WCArIGRlZztcbiAgICBjYWNoZS5za2V3WSA9IHNrZXdZICsgZGVnO1xuICAgIGNhY2hlLnRyYW5zZm9ybVBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmUgKyBweDtcblxuICAgIGlmIChjYWNoZS56T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW4uc3BsaXQoXCIgXCIpWzJdKSB8fCAwKSB7XG4gICAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gICAgfVxuXG4gICAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICAgIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtID0gY2FjaGUuc3ZnID8gX3JlbmRlclNWR1RyYW5zZm9ybXMgOiBfc3VwcG9ydHMzRCA/IF9yZW5kZXJDU1NUcmFuc2Zvcm1zIDogX3JlbmRlck5vbjNEVHJhbnNmb3JtcztcbiAgICBjYWNoZS51bmNhY2hlID0gMDtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH0sXG4gICAgICBfZmlyc3RUd29Pbmx5ID0gZnVuY3Rpb24gX2ZpcnN0VHdvT25seSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbiAgfSxcbiAgICAgIF9hZGRQeFRyYW5zbGF0ZSA9IGZ1bmN0aW9uIF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHN0YXJ0LCB2YWx1ZSkge1xuICAgIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gICAgcmV0dXJuIF9yb3VuZChwYXJzZUZsb2F0KHN0YXJ0KSArIHBhcnNlRmxvYXQoX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgdmFsdWUgKyBcInB4XCIsIHVuaXQpKSkgKyB1bml0O1xuICB9LFxuICAgICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gICAgY2FjaGUueiA9IFwiMHB4XCI7XG4gICAgY2FjaGUucm90YXRpb25ZID0gY2FjaGUucm90YXRpb25YID0gXCIwZGVnXCI7XG4gICAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgICBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpO1xuICB9LFxuICAgICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICAgIF96ZXJvUHggPSBcIjBweFwiLFxuICAgICAgX2VuZFBhcmVudGhlc2lzID0gXCIpIFwiLFxuICAgICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgICB2YXIgX3JlZiA9IGNhY2hlIHx8IHRoaXMsXG4gICAgICAgIHhQZXJjZW50ID0gX3JlZi54UGVyY2VudCxcbiAgICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgICB4ID0gX3JlZi54LFxuICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICB6ID0gX3JlZi56LFxuICAgICAgICByb3RhdGlvbiA9IF9yZWYucm90YXRpb24sXG4gICAgICAgIHJvdGF0aW9uWSA9IF9yZWYucm90YXRpb25ZLFxuICAgICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgICAgc2tld1ggPSBfcmVmLnNrZXdYLFxuICAgICAgICBza2V3WSA9IF9yZWYuc2tld1ksXG4gICAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgICBzY2FsZVkgPSBfcmVmLnNjYWxlWSxcbiAgICAgICAgdHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBfcmVmLnRyYW5zZm9ybVBlcnNwZWN0aXZlLFxuICAgICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgICAgek9yaWdpbiA9IF9yZWYuek9yaWdpbixcbiAgICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICAgIHVzZTNEID0gZm9yY2UzRCA9PT0gXCJhdXRvXCIgJiYgcmF0aW8gJiYgcmF0aW8gIT09IDEgfHwgZm9yY2UzRCA9PT0gdHJ1ZTtcblxuICAgIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgICB2YXIgYW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWSkgKiBfREVHMlJBRCxcbiAgICAgICAgICBhMTMgPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIGNvcztcblxuICAgICAgYW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWCkgKiBfREVHMlJBRDtcbiAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHggPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB4LCBhMTMgKiBjb3MgKiAtek9yaWdpbik7XG4gICAgICB5ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeSwgLU1hdGguc2luKGFuZ2xlKSAqIC16T3JpZ2luKTtcbiAgICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm1QZXJzcGVjdGl2ZSAhPT0gX3plcm9QeCkge1xuICAgICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gICAgfVxuXG4gICAgaWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG4gICAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICAgIH1cblxuICAgIGlmICh1c2UzRCB8fCB4ICE9PSBfemVyb1B4IHx8IHkgIT09IF96ZXJvUHggfHwgeiAhPT0gX3plcm9QeCkge1xuICAgICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gICAgfVxuXG4gICAgaWYgKHJvdGF0aW9uICE9PSBfemVyb0RlZykge1xuICAgICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICAgIH1cblxuICAgIGlmIChyb3RhdGlvblkgIT09IF96ZXJvRGVnKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgICB9XG5cbiAgICBpZiAocm90YXRpb25YICE9PSBfemVyb0RlZykge1xuICAgICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gICAgfVxuXG4gICAgaWYgKHNrZXdYICE9PSBfemVyb0RlZyB8fCBza2V3WSAhPT0gX3plcm9EZWcpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgICB9XG5cbiAgICBpZiAoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuICAgICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICAgIH1cblxuICAgIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zIHx8IFwidHJhbnNsYXRlKDAsIDApXCI7XG4gIH0sXG4gICAgICBfcmVuZGVyU1ZHVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJTVkdUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xuICAgIHZhciBfcmVmMiA9IGNhY2hlIHx8IHRoaXMsXG4gICAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICAgIHlQZXJjZW50ID0gX3JlZjIueVBlcmNlbnQsXG4gICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICB5ID0gX3JlZjIueSxcbiAgICAgICAgcm90YXRpb24gPSBfcmVmMi5yb3RhdGlvbixcbiAgICAgICAgc2tld1ggPSBfcmVmMi5za2V3WCxcbiAgICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgICBzY2FsZVkgPSBfcmVmMi5zY2FsZVksXG4gICAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgICAgeE9yaWdpbiA9IF9yZWYyLnhPcmlnaW4sXG4gICAgICAgIHlPcmlnaW4gPSBfcmVmMi55T3JpZ2luLFxuICAgICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgICAgeU9mZnNldCA9IF9yZWYyLnlPZmZzZXQsXG4gICAgICAgIGZvcmNlQ1NTID0gX3JlZjIuZm9yY2VDU1MsXG4gICAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgICAgdHkgPSBwYXJzZUZsb2F0KHkpLFxuICAgICAgICBhMTEsXG4gICAgICAgIGEyMSxcbiAgICAgICAgYTEyLFxuICAgICAgICBhMjIsXG4gICAgICAgIHRlbXA7XG5cbiAgICByb3RhdGlvbiA9IHBhcnNlRmxvYXQocm90YXRpb24pO1xuICAgIHNrZXdYID0gcGFyc2VGbG9hdChza2V3WCk7XG4gICAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICAgIGlmIChza2V3WSkge1xuICAgICAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcbiAgICAgIHNrZXdYICs9IHNrZXdZO1xuICAgICAgcm90YXRpb24gKz0gc2tld1k7XG4gICAgfVxuXG4gICAgaWYgKHJvdGF0aW9uIHx8IHNrZXdYKSB7XG4gICAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICAgIHNrZXdYICo9IF9ERUcyUkFEO1xuICAgICAgYTExID0gTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYO1xuICAgICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgICAgYTEyID0gTWF0aC5zaW4ocm90YXRpb24gLSBza2V3WCkgKiAtc2NhbGVZO1xuICAgICAgYTIyID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVk7XG5cbiAgICAgIGlmIChza2V3WCkge1xuICAgICAgICBza2V3WSAqPSBfREVHMlJBRDtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdYIC0gc2tld1kpO1xuICAgICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICAgIGExMiAqPSB0ZW1wO1xuICAgICAgICBhMjIgKj0gdGVtcDtcblxuICAgICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1kpO1xuICAgICAgICAgIHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcbiAgICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgICBhMjEgKj0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhMTEgPSBfcm91bmQoYTExKTtcbiAgICAgIGEyMSA9IF9yb3VuZChhMjEpO1xuICAgICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgICBhMjIgPSBfcm91bmQoYTIyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYTExID0gc2NhbGVYO1xuICAgICAgYTIyID0gc2NhbGVZO1xuICAgICAgYTIxID0gYTEyID0gMDtcbiAgICB9XG5cbiAgICBpZiAodHggJiYgIX4oeCArIFwiXCIpLmluZGV4T2YoXCJweFwiKSB8fCB0eSAmJiAhfih5ICsgXCJcIikuaW5kZXhPZihcInB4XCIpKSB7XG4gICAgICB0eCA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHgsIFwicHhcIik7XG4gICAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gICAgfVxuXG4gICAgaWYgKHhPcmlnaW4gfHwgeU9yaWdpbiB8fCB4T2Zmc2V0IHx8IHlPZmZzZXQpIHtcbiAgICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICAgIHR5ID0gX3JvdW5kKHR5ICsgeU9yaWdpbiAtICh4T3JpZ2luICogYTIxICsgeU9yaWdpbiAqIGEyMikgKyB5T2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgICAgdHggPSBfcm91bmQodHggKyB4UGVyY2VudCAvIDEwMCAqIHRlbXAud2lkdGgpO1xuICAgICAgdHkgPSBfcm91bmQodHkgKyB5UGVyY2VudCAvIDEwMCAqIHRlbXAuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB0ZW1wID0gXCJtYXRyaXgoXCIgKyBhMTEgKyBcIixcIiArIGEyMSArIFwiLFwiICsgYTEyICsgXCIsXCIgKyBhMjIgKyBcIixcIiArIHR4ICsgXCIsXCIgKyB0eSArIFwiKVwiO1xuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGVtcCk7XG4gICAgZm9yY2VDU1MgJiYgKHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0ZW1wKTtcbiAgfSxcbiAgICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgZW5kVmFsdWUpIHtcbiAgICB2YXIgY2FwID0gMzYwLFxuICAgICAgICBpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpICogKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpID8gX1JBRDJERUcgOiAxKSxcbiAgICAgICAgY2hhbmdlID0gZW5kTnVtIC0gc3RhcnROdW0sXG4gICAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSArIFwiZGVnXCIsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgcHQ7XG5cbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJzaG9ydFwiKSB7XG4gICAgICAgIGNoYW5nZSAlPSBjYXA7XG5cbiAgICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG4gICAgICAgICAgY2hhbmdlICs9IGNoYW5nZSA8IDAgPyBjYXAgOiAtY2FwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiY3dcIiAmJiBjaGFuZ2UgPCAwKSB7XG4gICAgICAgIGNoYW5nZSA9IChjaGFuZ2UgKyBjYXAgKiBfYmlnTnVtJDEpICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImNjd1wiICYmIGNoYW5nZSAIDApIHtcbiAgICAgICAgY2hhbmdlID0gKGNoYW5nZSAtIGNhcCAqIF9iaWdOdW0kMSkgJSBjYXAgLSBfihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcbiAgICBwdC5lID0gZmluYWxWYWx1ZTtcbiAgICBwdC51ID0gXCJkZWdcIjtcblxuICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICByZXR1cm4gcHQ7XG4gIH0sXG4gICAgICBfYXNzaWduID0gZnVuY3Rpb24gX2Fzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRbcF0gPSBzb3VyY2VbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHMgPSBmdW5jdGlvbiBfYWRkUmF3VHJhbnNmb3JtUFRzKHBsdWdpbiwgdHJhbnNmb3JtcywgdGFyZ2V0KSB7XG4gICAgdmFyIHN0YXJ0Q2FjaGUgPSBfYXNzaWduKHt9LCB0YXJnZXQuX2dzYXApLFxuICAgICAgICBleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIGVuZENhY2hlLFxuICAgICAgICBwLFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgc3RhcnROdW0sXG4gICAgICAgIGVuZE51bSxcbiAgICAgICAgc3RhcnRVbml0LFxuICAgICAgICBlbmRVbml0O1xuXG4gICAgaWYgKHN0YXJ0Q2FjaGUuc3ZnKSB7XG4gICAgICBzdGFydFZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIik7XG4gICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuICAgICAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcblxuICAgICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHN0YXJ0VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1Qcm9wXTtcbiAgICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG4gICAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuICAgICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gc3RhcnRWYWx1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHAgaW4gX3RyYW5zZm9ybVByb3BzKSB7XG4gICAgICBzdGFydFZhbHVlID0gc3RhcnRDYWNoZVtwXTtcbiAgICAgIGVuZFZhbHVlID0gZW5kQ2FjaGVbcF07XG5cbiAgICAgIGlmIChzdGFydFZhbHVlICE9PSBlbmRWYWx1ZSAmJiBleGNsdWRlLmluZGV4T2YocCkgPCAwKSB7XG4gICAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcbiAgICAgICAgc3RhcnROdW0gPSBzdGFydFVuaXQgIT09IGVuZFVuaXQgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIDogcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIGVuZENhY2hlLCBwLCBzdGFydE51bSwgZW5kTnVtIC0gc3RhcnROdW0sIF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgICAgcGx1Z2luLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXNzaWduKGVuZENhY2hlLCBzdGFydENhY2hlKTtcbiAgfTtcblxuICBfZm9yRWFjaE5hbWUoXCJwYWRkaW5nLG1hcmdpbixXaWR0aCxSYWRpdXNcIiwgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XG4gICAgdmFyIHQgPSBcIlRvcFwiLFxuICAgICAgICByID0gXCJSaWdodFwiLFxuICAgICAgICBiID0gXCJCb3R0b21cIixcbiAgICAgICAgbCA9IFwiTGVmdFwiLFxuICAgICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgIHJldHVybiBpbmRleCA8IDIgPyBuYW1lICsgc2lkZSA6IFwiYm9yZGVyXCIgKyBzaWRlICsgbmFtZTtcbiAgICB9KTtcblxuICAgIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgICAgdmFyIGEsIHZhcnM7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkge1xuICAgICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIF9nZXQocGx1Z2luLCBwcm9wLCBwcm9wZXJ0eSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIHZhcnMuc3BsaXQoYVswXSkubGVuZ3RoID09PSA1ID8gYVswXSA6IHZhcnM7XG4gICAgICB9XG5cbiAgICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgICB2YXJzID0ge307XG4gICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wLCBpKSB7XG4gICAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgICAgfSk7XG4gICAgICBwbHVnaW4uaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKTtcbiAgICB9O1xuICB9KTtcblxuICB2YXIgQ1NTUGx1Z2luID0ge1xuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgcmVnaXN0ZXI6IF9pbml0Q29yZSxcbiAgICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5zdHlsZSAmJiB0YXJnZXQubm9kZVR5cGU7XG4gICAgfSxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLl9wcm9wcyxcbiAgICAgICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgICAgICBzdGFydEF0ID0gdHdlZW4udmFycy5zdGFydEF0LFxuICAgICAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICAgICAgZW5kVmFsdWUsXG4gICAgICAgICAgZW5kTnVtLFxuICAgICAgICAgIHN0YXJ0TnVtLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgICAgcCxcbiAgICAgICAgICBzdGFydFVuaXQsXG4gICAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQsXG4gICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIHNtb290aCxcbiAgICAgICAgICBoYXNQcmlvcml0eTtcbiAgICAgIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICBpZiAocCA9PT0gXCJhdXRvUm91bmRcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kVmFsdWUgPSB2YXJzW3BdO1xuXG4gICAgICAgIGlmIChfcGx1Z2luc1twXSAmJiBfY2hlY2tQbHVnaW4ocCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gdHlwZW9mIGVuZFZhbHVlO1xuICAgICAgICBzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gICAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWNpYWxQcm9wKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3AodGhpcywgdGFyZ2V0LCBwLCBlbmRWYWx1ZSwgdHdlZW4pICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHAuc3Vic3RyKDAsIDIpID09PSBcIi0tXCIpIHtcbiAgICAgICAgICBzdGFydFZhbHVlID0gKGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5nZXRQcm9wZXJ0eVZhbHVlKHApICsgXCJcIikudHJpbSgpO1xuICAgICAgICAgIGVuZFZhbHVlICs9IFwiXCI7XG4gICAgICAgICAgX2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgICAgICBpZiAoIV9jb2xvckV4cC50ZXN0KHN0YXJ0VmFsdWUpKSB7XG4gICAgICAgICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVuZFVuaXQgPyBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0VmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpICsgZW5kVW5pdCkgOiBzdGFydFVuaXQgJiYgKGVuZFZhbHVlICs9IHN0YXJ0VW5pdCk7XG4gICAgICAgICAgdGhpcy5hZGQoc3R5bGUsIFwic2V0UHJvcGVydHlcIiwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcbiAgICAgICAgICBwcm9wcy5wdXNoKHApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpZiAoc3RhcnRBdCAmJiBwIGluIHN0YXJ0QXQpIHtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWUgPSB0eXBlb2Ygc3RhcnRBdFtwXSA9PT0gXCJmdW5jdGlvblwiID8gc3RhcnRBdFtwXS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHN0YXJ0QXRbcF07XG4gICAgICAgICAgICBfaXNTdHJpbmcoc3RhcnRWYWx1ZSkgJiYgfnN0YXJ0VmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikgJiYgKHN0YXJ0VmFsdWUgPSBfcmVwbGFjZVJhbmRvbShzdGFydFZhbHVlKSk7XG4gICAgICAgICAgICBnZXRVbml0KHN0YXJ0VmFsdWUgKyBcIlwiKSB8fCAoc3RhcnRWYWx1ZSArPSBfY29uZmlnLnVuaXRzW3BdIHx8IGdldFVuaXQoX2dldCh0YXJnZXQsIHApKSB8fCBcIlwiKTtcbiAgICAgICAgICAgIChzdGFydFZhbHVlICsgXCJcIikuY2hhckF0KDEpID09PSBcIj1cIiAmJiAoc3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgICAgIHJlbGF0aXZlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIGVuZFZhbHVlLnN1YnN0cigwLCAyKTtcbiAgICAgICAgICByZWxhdGl2ZSAmJiAoZW5kVmFsdWUgPSBlbmRWYWx1ZS5zdWJzdHIoMikpO1xuICAgICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHAgaW4gX3Byb3BlcnR5QWxpYXNlcykge1xuICAgICAgICAgICAgaWYgKHAgPT09IFwiYXV0b0FscGhhXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0TnVtID09PSAxICYmIF9nZXQodGFyZ2V0LCBcInZpc2liaWxpdHlcIikgPT09IFwiaGlkZGVuXCIgJiYgZW5kTnVtKSB7XG4gICAgICAgICAgICAgICAgc3RhcnROdW0gPSAwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIFwidmlzaWJpbGl0eVwiLCBzdGFydE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgZW5kTnVtID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLCAhZW5kTnVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAgIT09IFwic2NhbGVcIiAmJiBwICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICAgIHAgPSBfcHJvcGVydHlBbGlhc2VzW3BdO1xuICAgICAgICAgICAgICBcC5pbmRleE9mKFwiLFwiKSAmJiAocCA9IHAuc3BsaXQoXCIsXCIpWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQgPSBwIGluIF90cmFuc2Zvcm1Qcm9wcztcblxuICAgICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQpIHtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtUHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICAgICAgICAgICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gJiYgIXZhcnMucGFyc2VUcmFuc2Zvcm0gfHwgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdmFycy5wYXJzZVRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgIHNtb290aCA9IHZhcnMuc21vb3RoT3JpZ2luICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGg7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2VlbiA9IHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgc3R5bGUsIF90cmFuc2Zvcm1Qcm9wLCAwLCAxLCBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0sIGNhY2hlLCAwLCAtMSk7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybVByb3BUd2Vlbi5kZXAgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgY2FjaGUsIFwic2NhbGVZXCIsIGNhY2hlLnNjYWxlWSwgKHJlbGF0aXZlID8gX3BhcnNlUmVsYXRpdmUoY2FjaGUuc2NhbGVZLCByZWxhdGl2ZSArIGVuZE51bSkgOiBlbmROdW0pIC0gY2FjaGUuc2NhbGVZIHx8IDApO1xuICAgICAgICAgICAgICBwcm9wcy5wdXNoKFwic2NhbGVZXCIsIHApO1xuICAgICAgICAgICAgICBwICs9IFwiWFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInRyYW5zZm9ybU9yaWdpblwiKSB7XG4gICAgICAgICAgICAgIGVuZFZhbHVlID0gX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMoZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMCwgc21vb3RoLCAwLCB0aGlzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmRVbml0ID0gcGFyc2VGbG9hdChlbmRWYWx1ZS5zcGxpdChcIiBcIilbMl0pIHx8IDA7XG4gICAgICAgICAgICAgICAgZW5kVW5pdCAhPT0gY2FjaGUuek9yaWdpbiAmJiBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJ6T3JpZ2luXCIsIGNhY2hlLnpPcmlnaW4sIGVuZFVuaXQpO1xuXG4gICAgICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIHAsIF9maXJzdFR3b09ubHkoc3RhcnRWYWx1ZSksIF9maXJzdFR3b09ubHkoZW5kVmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInN2Z09yaWdpblwiKSB7XG4gICAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAxLCBzbW9vdGgsIDAsIHRoaXMpO1xuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwIGluIF9yb3RhdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgICBfYWRkUm90YXRpb25hbFByb3BUd2Vlbih0aGlzLCBjYWNoZSwgcCwgc3RhcnROdW0sIHJlbGF0aXZlID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIHJlbGF0aXZlICsgZW5kVmFsdWUpIDogZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInNtb290aE9yaWdpblwiKSB7XG4gICAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInNtb290aFwiLCBjYWNoZS5zbW9vdGgsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJmb3JjZTNEXCIpIHtcbiAgICAgICAgICAgICAgY2FjaGVbcF0gPSBlbmRWYWx1ZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgICAgX2FkZFJhd1RyYW5zZm9ybVBUcyh0aGlzLCBlbmRWYWx1ZSwgdGFyZ2V0KTtcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICAgIHAgPSBfY2hlY2tQcm9wUHJlZml4KHApIHx8IHA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzVHJhbnNmb3JtUmVsYXRlZCB8fCAoZW5kTnVtIHx8IGVuZE51bSA9PT0gMCkgJiYgKHN0YXJ0TnVtIHx8IHN0YXJ0TnVtID09PSAwKSAmJiAhX2NvbXBsZXhFeHAudGVzdChlbmRWYWx1ZSkgJiYgcCBpbiBzdHlsZSkge1xuICAgICAgICAgICAgc3RhcnRVbml0ID0gKHN0YXJ0VmFsdWUgKyBcIlwiKS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgICAgIGVuZE51bSB8fCAoZW5kTnVtID0gMCk7XG4gICAgICAgICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSkgfHwgKHAgaW4gX2NvbmZpZy51bml0cyA/IF9jb25maWcudW5pdHNbcF0gOiBzdGFydFVuaXQpO1xuICAgICAgICAgICAgc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIChzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkpO1xuICAgICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBpc1RyYW5zZm9ybVJlbGF0ZWQgPyBjYWNoZSA6IHN0eWxlLCBwLCBzdGFydE51bSwgKHJlbGF0aXZlID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIHJlbGF0aXZlICsgZW5kTnVtKSA6IGVuZE51bSkgLSBzdGFydE51bSwgIWlzVHJhbnNmb3JtUmVsYXRlZCAmJiAoZW5kVW5pdCA9PT0gXCJweFwiIHx8IHAgPT09IFwiekluZGV4XCIpICYmIHZhcnMuYXV0b1JvdW5kICE9PSBmYWxzZSA/IF9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA6IF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgICAgICAgIHRoaXMuX3B0LnUgPSBlbmRVbml0IHx8IDA7XG5cbiAgICAgICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgZW5kVW5pdCAhPT0gXCIlXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcHQuYiA9IHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICAgIHRoaXMuX3B0LnIgPSBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgICBpZiAocCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBwLCBzdGFydFZhbHVlIHx8IHRhcmdldFtwXSwgcmVsYXRpdmUgPyByZWxhdGl2ZSArIGVuZFZhbHVlIDogZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9taXNzaW5nUGx1Z2luKHAsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHRoaXMsIHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgcmVsYXRpdmUgPyByZWxhdGl2ZSArIGVuZFZhbHVlIDogZW5kVmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb3BzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0aGlzKTtcbiAgICB9LFxuICAgIGdldDogX2dldCxcbiAgICBhbGlhc2VzOiBfcHJvcGVydHlBbGlhc2VzLFxuICAgIGdldFNldHRlcjogZnVuY3Rpb24gZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHBsdWdpbikge1xuICAgICAgdmFyIHAgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcbiAgICAgIHAgJiYgcC5pbmRleE9mKFwiLFwiKSA8IDAgJiYgKHByb3BlcnR5ID0gcCk7XG4gICAgICByZXR1cm4gcHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGFyZ2V0Ll9nc2FwLnggfHwgX2dldCh0YXJnZXQsIFwieFwiKSkgPyBwbHVnaW4gJiYgX3JlY2VudFNldHRlclBsdWdpbiA9PT0gcGx1Z2luID8gcHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZSA6IF9zZXR0ZXJUcmFuc2Zvcm0gOiAoX3JlY2VudFNldHRlclBsdWdpbiA9IHBsdWdpbiB8fCB7fSkgJiYgKHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIDogX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIpIDogdGFyZ2V0LnN0eWxlICYmICFfaXNVbmRlZmluZWQodGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSkgPyBfc2V0dGVyQ1NTU3R5bGUgOiBcHJvcGVydHkuaW5kZXhPZihcIi1cIikgPyBfc2V0dGVyQ1NTUHJvcCA6IF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgfSxcbiAgICBjb3JlOiB7XG4gICAgICBfcmVtb3ZlUHJvcGVydHk6IF9yZW1vdmVQcm9wZXJ0eSxcbiAgICAgIF9nZXRNYXRyaXg6IF9nZXRNYXRyaXhcbiAgICB9XG4gIH07XG4gIGdzYXAudXRpbHMuY2hlY2tQcmVmaXggPSBfY2hlY2tQcm9wUHJlZml4O1xuXG4gIChmdW5jdGlvbiAocG9zaXRpb25BbmRTY2FsZSwgcm90YXRpb24sIG90aGVycywgYWxpYXNlcykge1xuICAgIHZhciBhbGwgPSBfZm9yRWFjaE5hbWUocG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb24gKyBcIixcIiArIG90aGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90cmFuc2Zvcm1Qcm9wc1tuYW1lXSA9IDE7XG4gICAgfSk7XG5cbiAgICBfZm9yRWFjaE5hbWUocm90YXRpb24sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJkZWdcIjtcbiAgICAgIF9yb3RhdGlvbmFsUHJvcGVydGllc1tuYW1lXSA9IDE7XG4gICAgfSk7XG5cbiAgICBfcHJvcGVydHlBbGlhc2VzW2FsbFsxM11dID0gcG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb247XG5cbiAgICBfZm9yRWFjaE5hbWUoYWxpYXNlcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBzcGxpdCA9IG5hbWUuc3BsaXQoXCI6XCIpO1xuICAgICAgX3Byb3BlcnR5QWxpYXNlc1tzcGxpdFsxXV0gPSBhbGxbc3BsaXRbMF1dO1xuICAgIH0pO1xuICB9KShcIngseSx6LHNjYWxlLHNjYWxlWCxzY2FsZVkseFBlcmNlbnQseVBlcmNlbnRcIiwgXCJyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHNrZXdYLHNrZXdZXCIsIFwidHJhbnNmb3JtLHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW4sZm9yY2UzRCxzbW9vdGhPcmlnaW4sdHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCIwOnRyYW5zbGF0ZVgsMTp0cmFuc2xhdGVZLDI6dHJhbnNsYXRlWiw4OnJvdGF0ZSw4OnJvdGF0aW9uWiw4OnJvdGF0ZVosOTpyb3RhdGVYLDEwOnJvdGF0ZVlcIik7XG5cbiAgX2ZvckVhY2hOYW1lKFwieCx5LHosdG9wLHJpZ2h0LGJvdHRvbSxsZWZ0LHdpZHRoLGhlaWdodCxmb250U2l6ZSxwYWRkaW5nLG1hcmdpbixwZXJzcGVjdGl2ZVwiLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF9jb25maWcudW5pdHNbbmFtZV0gPSBcInB4XCI7XG4gIH0pO1xuXG4gIGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKTtcblxuICB2YXIgZ3NhcFdpdGhDU1MgPSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbikgfHwgZ3NhcCxcbiAgICAgIFR3ZWVuTWF4V2l0aENTUyA9IGdzYXBXaXRoQ1NTLmNvcmUuVHdlZW47XG5cbiAgZXhwb3J0cy5CYWNrID0gQmFjaztcbiAgZXhwb3J0cy5Cb3VuY2UgPSBCb3VuY2U7XG4gIGV4cG9ydHMuQ1NTUGx1Z2luID0gQ1NTUGx1Z2luO1xuICBleHBvcnRzLkNpcmMgPSBDaXJjO1xuICBleHBvcnRzLkN1YmljID0gQ3ViaWM7XG4gIGV4cG9ydHMuRWxhc3RpYyA9IEVsYXN0aWM7XG4gIGV4cG9ydHMuRXhwbyA9IEV4cG87XG4gIGV4cG9ydHMuTGluZWFyID0gTGluZWFyO1xuICBleHBvcnRzLlBvd2VyMCA9IFBvd2VyMDtcbiAgZXhwb3J0cy5Qb3dlcjEgPSBQb3dlcjE7XG4gIGV4cG9ydHMuUG93ZXIyID0gUG93ZXIyO1xuICBleHBvcnRzLlBvd2VyMyA9IFBvd2VyMztcbiAgZXhwb3J0cy5Qb3dlcjQgPSBQb3dlcjQ7XG4gIGV4cG9ydHMuUXVhZCA9IFF1YWQ7XG4gIGV4cG9ydHMuUXVhcnQgPSBRdWFydDtcbiAgZXhwb3J0cy5RdWludCA9IFF1aW50O1xuICBleHBvcnRzLlNpbmUgPSBTaW5lO1xuICBleHBvcnRzLlN0ZXBwZWRFYXNlID0gU3RlcHBlZEVhc2U7XG4gIGV4cG9ydHMuU3Ryb25nID0gU3Ryb25nO1xuICBleHBvcnRzLlRpbWVsaW5lTGl0ZSA9IFRpbWVsaW5lO1xuICBleHBvcnRzLlRpbWVsaW5lTWF4ID0gVGltZWxpbmU7XG4gIGV4cG9ydHMuVHdlZW5MaXRlID0gVHdlZW47XG4gIGV4cG9ydHMuVHdlZW5NYXggPSBUd2Vlbk1heFdpdGhDU1M7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IGdzYXBXaXRoQ1NTO1xuICBleHBvcnRzLmdzYXAgPSBnc2FwV2l0aENTUztcblxuICBpZiAodHlwZW9mKHdpbmRvdykgPT09ICd1bmRlZmluZWQnIHx8IHdpbmRvdyAhPT0gZXhwb3J0cykge09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7fSBlbHNlIHtkZWxldGUgd2luZG93LmRlZmF1bHQ7fVxuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/dist/gsap.js\n");

/***/ }),

/***/ "./node_modules/gsap/utils/VelocityTracker.js":
/*!****************************************************!*\
  !*** ./node_modules/gsap/utils/VelocityTracker.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VelocityTracker: () => (/* binding */ VelocityTracker),\n/* harmony export */   \"default\": () => (/* binding */ VelocityTracker)\n/* harmony export */ });\n/*!\n * VelocityTracker: 3.10.4\n * https://greensock.com\n *\n * Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _toArray,\n    _getUnit,\n    _first,\n    _ticker,\n    _time1,\n    _time2,\n    _getCache,\n    _getGSAP = function _getGSAP() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap);\n},\n    _lookup = {},\n    _round = function _round(value) {\n  return Math.round(value * 10000) / 10000;\n},\n    _getID = function _getID(target) {\n  return _getCache(target).id;\n},\n    _getByTarget = function _getByTarget(target) {\n  return _lookup[_getID(typeof target === \"string\" ? _toArray(target)[0] : target)];\n},\n    _onTick = function _onTick(time) {\n  var pt = _first,\n      val; //if the frame rate is too high, we won't be able to track the velocity as well, so only update the values about 20 times per second\n\n  if (time - _time1 >= 0.05) {\n    _time2 = _time1;\n    _time1 = time;\n\n    while (pt) {\n      val = pt.g(pt.t, pt.p);\n\n      if (val !== pt.v1 || time - pt.t1 > 0.2) {\n        //use a threshold of 0.2 seconds for zeroing-out velocity. If we only use 0.05 and things update slightly slower, like some Android devices dispatch \"touchmove\" events sluggishly so 2 or 3 ticks of the gsap.ticker may elapse inbetween, thus it may appear like the object is not moving but it actually is but it's not updating as frequently. A threshold of 0.2 seconds seems to be a good balance. We want to update things frequently (0.05 seconds) when they're moving so that we can respond to fast motions accurately, but we want to be more resistant to go back to a zero velocity.\n        pt.v2 = pt.v1;\n        pt.v1 = val;\n        pt.t2 = pt.t1;\n        pt.t1 = time;\n      }\n\n      pt = pt._next;\n    }\n  }\n},\n    _types = {\n  deg: 360,\n  rad: Math.PI * 2\n},\n    _initCore = function _initCore() {\n  gsap = _getGSAP();\n\n  if (gsap) {\n    _toArray = gsap.utils.toArray;\n    _getUnit = gsap.utils.getUnit;\n    _getCache = gsap.core.getCache;\n    _ticker = gsap.ticker;\n    _coreInitted = 1;\n  }\n};\n\nvar PropTracker = function PropTracker(target, property, type, next) {\n  this.t = target;\n  this.p = property;\n  this.g = target._gsap.get;\n  this.rCap = _types[type || _getUnit(this.g(target, property))]; //rotational cap (for degrees, \"deg\", it's 360 and for radians, \"rad\", it's Math.PI * 2)\n\n  this.v1 = this.v2 = 0;\n  this.t1 = this.t2 = _ticker.time;\n\n  if (next) {\n    this._next = next;\n    next._prev = this;\n  }\n};\n\nvar VelocityTracker = /*#__PURE__*/function () {\n  function VelocityTracker(target, property) {\n    if (!_coreInitted) {\n      _initCore();\n    }\n\n    this.target = _toArray(target)[0];\n    _lookup[_getID(this.target)] = this;\n    this._props = {};\n    property && this.add(property);\n  }\n\n  VelocityTracker.register = function register(core) {\n    gsap = core;\n\n    _initCore();\n  };\n\n  var _proto = VelocityTracker.prototype;\n\n  _proto.get = function get(property, skipRecentTick) {\n    var pt = this._props[property] || console.warn(\"Not tracking \"  property  \" velocity.\"),\n        val,\n        dif,\n        rotationCap;\n    val = parseFloat(skipRecentTick ? pt.v1 : pt.g(pt.t, pt.p));\n    dif = val - parseFloat(pt.v2);\n    rotationCap = pt.rCap;\n\n    if (rotationCap) {\n      //rotational values need special interpretation so that if, for example, they go from 179 to -178 degrees it is interpreted as a change of 3 instead of -357.\n      dif = dif % rotationCap;\n\n      if (dif !== dif % (rotationCap / 2)) {\n        dif = dif < 0 ? dif  rotationCap : dif - rotationCap;\n      }\n    }\n\n    return _round(dif / ((skipRecentTick ? pt.t1 : _ticker.time) - pt.t2));\n  };\n\n  _proto.getAll = function getAll() {\n    var result = {},\n        props = this._props,\n        p;\n\n    for (p in props) {\n      result[p] = this.get(p);\n    }\n\n    return result;\n  };\n\n  _proto.isTracking = function isTracking(property) {\n    return property in this._props;\n  };\n\n  _proto.add = function add(property, type) {\n    if (!(property in this._props)) {\n      if (!_first) {\n        _ticker.add(_onTick);\n\n        _time1 = _time2 = _ticker.time;\n      }\n\n      _first = this._props[property] = new PropTracker(this.target, property, type, _first);\n    }\n  };\n\n  _proto.remove = function remove(property) {\n    var pt = this._props[property],\n        prev,\n        next;\n\n    if (pt) {\n      prev = pt._prev;\n      next = pt._next;\n\n      if (prev) {\n        prev._next = next;\n      }\n\n      if (next) {\n        next._prev = prev;\n      } else if (_first === pt) {\n        _ticker.remove(_onTick);\n\n        _first = 0;\n      }\n\n      delete this._props[property];\n    }\n  };\n\n  _proto.kill = function kill(shallow) {\n    for (var p in this._props) {\n      this.remove(p);\n    }\n\n    if (!shallow) {\n      delete _lookup[_getID(this.target)];\n    }\n  };\n\n  VelocityTracker.track = function track(targets, properties, types) {\n    if (!_coreInitted) {\n      _initCore();\n    }\n\n    var result = [],\n        targs = _toArray(targets),\n        a = properties.split(\",\"),\n        t = (types || \"\").split(\",\"),\n        i = targs.length,\n        tracker,\n        j;\n\n    while (i--) {\n      tracker = _getByTarget(targs[i]) || new VelocityTracker(targs[i]);\n      j = a.length;\n\n      while (j--) {\n        tracker.add(a[j], t[j] || t[0]);\n      }\n\n      result.push(tracker);\n    }\n\n    return result;\n  };\n\n  VelocityTracker.untrack = function untrack(targets, properties) {\n    var props = (properties || \"\").split(\",\");\n\n    _toArray(targets).forEach(function (target) {\n      var tracker = _getByTarget(target);\n\n      if (tracker) {\n        if (!props.length) {\n          tracker.kill(1);\n        } else {\n          props.forEach(function (p) {\n            return tracker.remove(p);\n          });\n        }\n      }\n    });\n  };\n\n  VelocityTracker.isTracking = function isTracking(target, property) {\n    var tracker = _getByTarget(target);\n\n    return tracker && tracker.isTracking(property);\n  };\n\n  VelocityTracker.getVelocity = function getVelocity(target, property) {\n    var tracker = _getByTarget(target);\n\n    return !tracker || !tracker.isTracking(property) ? console.warn(\"Not tracking velocity of \"  property) : tracker.get(property);\n  };\n\n  return VelocityTracker;\n}();\nVelocityTracker.getByTarget = _getByTarget;\n_getGSAP() && gsap.registerPlugin(VelocityTracker);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9WZWxvY2l0eVRyYWNrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTs7QUFFbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvVmVsb2NpdHlUcmFja2VyLmpzP2U4Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWZWxvY2l0eVRyYWNrZXI6IDMuMTAuNFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfdG9BcnJheSxcbiAgICBfZ2V0VW5pdCxcbiAgICBfZmlyc3QsXG4gICAgX3RpY2tlcixcbiAgICBfdGltZTEsXG4gICAgX3RpbWUyLFxuICAgIF9nZXRDYWNoZSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApO1xufSxcbiAgICBfbG9va3VwID0ge30sXG4gICAgX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDApIC8gMTAwMDA7XG59LFxuICAgIF9nZXRJRCA9IGZ1bmN0aW9uIF9nZXRJRCh0YXJnZXQpIHtcbiAgcmV0dXJuIF9nZXRDYWNoZSh0YXJnZXQpLmlkO1xufSxcbiAgICBfZ2V0QnlUYXJnZXQgPSBmdW5jdGlvbiBfZ2V0QnlUYXJnZXQodGFyZ2V0KSB7XG4gIHJldHVybiBfbG9va3VwW19nZXRJRCh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiID8gX3RvQXJyYXkodGFyZ2V0KVswXSA6IHRhcmdldCldO1xufSxcbiAgICBfb25UaWNrID0gZnVuY3Rpb24gX29uVGljayh0aW1lKSB7XG4gIHZhciBwdCA9IF9maXJzdCxcbiAgICAgIHZhbDsgLy9pZiB0aGUgZnJhbWUgcmF0ZSBpcyB0b28gaGlnaCwgd2Ugd29uJ3QgYmUgYWJsZSB0byB0cmFjayB0aGUgdmVsb2NpdHkgYXMgd2VsbCwgc28gb25seSB1cGRhdGUgdGhlIHZhbHVlcyBhYm91dCAyMCB0aW1lcyBwZXIgc2Vjb25kXG5cbiAgaWYgKHRpbWUgLSBfdGltZTEgPj0gMC4wNSkge1xuICAgIF90aW1lMiA9IF90aW1lMTtcbiAgICBfdGltZTEgPSB0aW1lO1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICB2YWwgPSBwdC5nKHB0LnQsIHB0LnApO1xuXG4gICAgICBpZiAodmFsICE9PSBwdC52MSB8fCB0aW1lIC0gcHQudDEgPiAwLjIpIHtcbiAgICAgICAgLy91c2UgYSB0aHJlc2hvbGQgb2YgMC4yIHNlY29uZHMgZm9yIHplcm9pbmctb3V0IHZlbG9jaXR5LiBJZiB3ZSBvbmx5IHVzZSAwLjA1IGFuZCB0aGluZ3MgdXBkYXRlIHNsaWdodGx5IHNsb3dlciwgbGlrZSBzb21lIEFuZHJvaWQgZGV2aWNlcyBkaXNwYXRjaCBcInRvdWNobW92ZVwiIGV2ZW50cyBzbHVnZ2lzaGx5IHNvIDIgb3IgMyB0aWNrcyBvZiB0aGUgZ3NhcC50aWNrZXIgbWF5IGVsYXBzZSBpbmJldHdlZW4sIHRodXMgaXQgbWF5IGFwcGVhciBsaWtlIHRoZSBvYmplY3QgaXMgbm90IG1vdmluZyBidXQgaXQgYWN0dWFsbHkgaXMgYnV0IGl0J3Mgbm90IHVwZGF0aW5nIGFzIGZyZXF1ZW50bHkuIEEgdGhyZXNob2xkIG9mIDAuMiBzZWNvbmRzIHNlZW1zIHRvIGJlIGEgZ29vZCBiYWxhbmNlLiBXZSB3YW50IHRvIHVwZGF0ZSB0aGluZ3MgZnJlcXVlbnRseSAoMC4wNSBzZWNvbmRzKSB3aGVuIHRoZXkncmUgbW92aW5nIHNvIHRoYXQgd2UgY2FuIHJlc3BvbmQgdG8gZmFzdCBtb3Rpb25zIGFjY3VyYXRlbHksIGJ1dCB3ZSB3YW50IHRvIGJlIG1vcmUgcmVzaXN0YW50IHRvIGdvIGJhY2sgdG8gYSB6ZXJvIHZlbG9jaXR5LlxuICAgICAgICBwdC52MiA9IHB0LnYxO1xuICAgICAgICBwdC52MSA9IHZhbDtcbiAgICAgICAgcHQudDIgPSBwdC50MTtcbiAgICAgICAgcHQudDEgPSB0aW1lO1xuICAgICAgfVxuXG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cbiAgfVxufSxcbiAgICBfdHlwZXMgPSB7XG4gIGRlZzogMzYwLFxuICByYWQ6IE1hdGguUEkgKiAyXG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgZ3NhcCA9IF9nZXRHU0FQKCk7XG5cbiAgaWYgKGdzYXApIHtcbiAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcbiAgICBfZ2V0VW5pdCA9IGdzYXAudXRpbHMuZ2V0VW5pdDtcbiAgICBfZ2V0Q2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGU7XG4gICAgX3RpY2tlciA9IGdzYXAudGlja2VyO1xuICAgIF9jb3JlSW5pdHRlZCA9IDE7XG4gIH1cbn07XG5cbnZhciBQcm9wVHJhY2tlciA9IGZ1bmN0aW9uIFByb3BUcmFja2VyKHRhcmdldCwgcHJvcGVydHksIHR5cGUsIG5leHQpIHtcbiAgdGhpcy50ID0gdGFyZ2V0O1xuICB0aGlzLnAgPSBwcm9wZXJ0eTtcbiAgdGhpcy5nID0gdGFyZ2V0Ll9nc2FwLmdldDtcbiAgdGhpcy5yQ2FwID0gX3R5cGVzW3R5cGUgfHwgX2dldFVuaXQodGhpcy5nKHRhcmdldCwgcHJvcGVydHkpKV07IC8vcm90YXRpb25hbCBjYXAgKGZvciBkZWdyZWVzLCBcImRlZ1wiLCBpdCdzIDM2MCBhbmQgZm9yIHJhZGlhbnMsIFwicmFkXCIsIGl0J3MgTWF0aC5QSSAqIDIpXG5cbiAgdGhpcy52MSA9IHRoaXMudjIgPSAwO1xuICB0aGlzLnQxID0gdGhpcy50MiA9IF90aWNrZXIudGltZTtcblxuICBpZiAobmV4dCkge1xuICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgIG5leHQuX3ByZXYgPSB0aGlzO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIFZlbG9jaXR5VHJhY2tlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlbG9jaXR5VHJhY2tlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgIF9pbml0Q29yZSgpO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0ID0gX3RvQXJyYXkodGFyZ2V0KVswXTtcbiAgICBfbG9va3VwW19nZXRJRCh0aGlzLnRhcmdldCldID0gdGhpcztcbiAgICB0aGlzLl9wcm9wcyA9IHt9O1xuICAgIHByb3BlcnR5ICYmIHRoaXMuYWRkKHByb3BlcnR5KTtcbiAgfVxuXG4gIFZlbG9jaXR5VHJhY2tlci5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBnc2FwID0gY29yZTtcblxuICAgIF9pbml0Q29yZSgpO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBWZWxvY2l0eVRyYWNrZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQocHJvcGVydHksIHNraXBSZWNlbnRUaWNrKSB7XG4gICAgdmFyIHB0ID0gdGhpcy5fcHJvcHNbcHJvcGVydHldIHx8IGNvbnNvbGUud2FybihcIk5vdCB0cmFja2luZyBcIiArIHByb3BlcnR5ICsgXCIgdmVsb2NpdHkuXCIpLFxuICAgICAgICB2YWwsXG4gICAgICAgIGRpZixcbiAgICAgICAgcm90YXRpb25DYXA7XG4gICAgdmFsID0gcGFyc2VGbG9hdChza2lwUmVjZW50VGljayA/IHB0LnYxIDogcHQuZyhwdC50LCBwdC5wKSk7XG4gICAgZGlmID0gdmFsIC0gcGFyc2VGbG9hdChwdC52Mik7XG4gICAgcm90YXRpb25DYXAgPSBwdC5yQ2FwO1xuXG4gICAgaWYgKHJvdGF0aW9uQ2FwKSB7XG4gICAgICAvL3JvdGF0aW9uYWwgdmFsdWVzIG5lZWQgc3BlY2lhbCBpbnRlcnByZXRhdGlvbiBzbyB0aGF0IGlmLCBmb3IgZXhhbXBsZSwgdGhleSBnbyBmcm9tIDE3OSB0byAtMTc4IGRlZ3JlZXMgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBjaGFuZ2Ugb2YgMyBpbnN0ZWFkIG9mIC0zNTcuXG4gICAgICBkaWYgPSBkaWYgJSByb3RhdGlvbkNhcDtcblxuICAgICAgaWYgKGRpZiAhPT0gZGlmICUgKHJvdGF0aW9uQ2FwIC8gMikpIHtcbiAgICAgICAgZGlmID0gZGlmIDwgMCA/IGRpZiArIHJvdGF0aW9uQ2FwIDogZGlmIC0gcm90YXRpb25DYXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yb3VuZChkaWYgLyAoKHNraXBSZWNlbnRUaWNrID8gcHQudDEgOiBfdGlja2VyLnRpbWUpIC0gcHQudDIpKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0QWxsID0gZnVuY3Rpb24gZ2V0QWxsKCkge1xuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgcHJvcHMgPSB0aGlzLl9wcm9wcyxcbiAgICAgICAgcDtcblxuICAgIGZvciAocCBpbiBwcm9wcykge1xuICAgICAgcmVzdWx0W3BdID0gdGhpcy5nZXQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8uaXNUcmFja2luZyA9IGZ1bmN0aW9uIGlzVHJhY2tpbmcocHJvcGVydHkpIHtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcy5fcHJvcHM7XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChwcm9wZXJ0eSwgdHlwZSkge1xuICAgIGlmICghKHByb3BlcnR5IGluIHRoaXMuX3Byb3BzKSkge1xuICAgICAgaWYgKCFfZmlyc3QpIHtcbiAgICAgICAgX3RpY2tlci5hZGQoX29uVGljayk7XG5cbiAgICAgICAgX3RpbWUxID0gX3RpbWUyID0gX3RpY2tlci50aW1lO1xuICAgICAgfVxuXG4gICAgICBfZmlyc3QgPSB0aGlzLl9wcm9wc1twcm9wZXJ0eV0gPSBuZXcgUHJvcFRyYWNrZXIodGhpcy50YXJnZXQsIHByb3BlcnR5LCB0eXBlLCBfZmlyc3QpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHByb3BlcnR5KSB7XG4gICAgdmFyIHB0ID0gdGhpcy5fcHJvcHNbcHJvcGVydHldLFxuICAgICAgICBwcmV2LFxuICAgICAgICBuZXh0O1xuXG4gICAgaWYgKHB0KSB7XG4gICAgICBwcmV2ID0gcHQuX3ByZXY7XG4gICAgICBuZXh0ID0gcHQuX25leHQ7XG5cbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHByZXYuX25leHQgPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgICAgIH0gZWxzZSBpZiAoX2ZpcnN0ID09PSBwdCkge1xuICAgICAgICBfdGlja2VyLnJlbW92ZShfb25UaWNrKTtcblxuICAgICAgICBfZmlyc3QgPSAwO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgdGhpcy5fcHJvcHNbcHJvcGVydHldO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ua2lsbCA9IGZ1bmN0aW9uIGtpbGwoc2hhbGxvdykge1xuICAgIGZvciAodmFyIHAgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICAgIHRoaXMucmVtb3ZlKHApO1xuICAgIH1cblxuICAgIGlmICghc2hhbGxvdykge1xuICAgICAgZGVsZXRlIF9sb29rdXBbX2dldElEKHRoaXMudGFyZ2V0KV07XG4gICAgfVxuICB9O1xuXG4gIFZlbG9jaXR5VHJhY2tlci50cmFjayA9IGZ1bmN0aW9uIHRyYWNrKHRhcmdldHMsIHByb3BlcnRpZXMsIHR5cGVzKSB7XG4gICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgIF9pbml0Q29yZSgpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgdGFyZ3MgPSBfdG9BcnJheSh0YXJnZXRzKSxcbiAgICAgICAgYSA9IHByb3BlcnRpZXMuc3BsaXQoXCIsXCIpLFxuICAgICAgICB0ID0gKHR5cGVzIHx8IFwiXCIpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgaSA9IHRhcmdzLmxlbmd0aCxcbiAgICAgICAgdHJhY2tlcixcbiAgICAgICAgajtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRyYWNrZXIgPSBfZ2V0QnlUYXJnZXQodGFyZ3NbaV0pIHx8IG5ldyBWZWxvY2l0eVRyYWNrZXIodGFyZ3NbaV0pO1xuICAgICAgaiA9IGEubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIHRyYWNrZXIuYWRkKGFbal0sIHRbal0gfHwgdFswXSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKHRyYWNrZXIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgVmVsb2NpdHlUcmFja2VyLnVudHJhY2sgPSBmdW5jdGlvbiB1bnRyYWNrKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgcHJvcHMgPSAocHJvcGVydGllcyB8fCBcIlwiKS5zcGxpdChcIixcIik7XG5cbiAgICBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHZhciB0cmFja2VyID0gX2dldEJ5VGFyZ2V0KHRhcmdldCk7XG5cbiAgICAgIGlmICh0cmFja2VyKSB7XG4gICAgICAgIGlmICghcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhY2tlci5raWxsKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFja2VyLnJlbW92ZShwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFZlbG9jaXR5VHJhY2tlci5pc1RyYWNraW5nID0gZnVuY3Rpb24gaXNUcmFja2luZyh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgdmFyIHRyYWNrZXIgPSBfZ2V0QnlUYXJnZXQodGFyZ2V0KTtcblxuICAgIHJldHVybiB0cmFja2VyICYmIHRyYWNrZXIuaXNUcmFja2luZyhwcm9wZXJ0eSk7XG4gIH07XG5cbiAgVmVsb2NpdHlUcmFja2VyLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gZ2V0VmVsb2NpdHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgIHZhciB0cmFja2VyID0gX2dldEJ5VGFyZ2V0KHRhcmdldCk7XG5cbiAgICByZXR1cm4gIXRyYWNrZXIgfHwgIXRyYWNrZXIuaXNUcmFja2luZyhwcm9wZXJ0eSkgPyBjb25zb2xlLndhcm4oXCJOb3QgdHJhY2tpbmcgdmVsb2NpdHkgb2YgXCIgKyBwcm9wZXJ0eSkgOiB0cmFja2VyLmdldChwcm9wZXJ0eSk7XG4gIH07XG5cbiAgcmV0dXJuIFZlbG9jaXR5VHJhY2tlcjtcbn0oKTtcblZlbG9jaXR5VHJhY2tlci5nZXRCeVRhcmdldCA9IF9nZXRCeVRhcmdldDtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihWZWxvY2l0eVRyYWNrZXIpO1xuZXhwb3J0IHsgVmVsb2NpdHlUcmFja2VyIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/utils/VelocityTracker.js\n");

/***/ }),

/***/ "./node_modules/gsap/utils/matrix.js":
/*!*******************************************!*\
  !*** ./node_modules/gsap/utils/matrix.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Matrix2D: () => (/* binding */ Matrix2D),\n/* harmony export */   _getCTM: () => (/* binding */ _getCTM),\n/* harmony export */   _getDocScrollLeft: () => (/* binding */ _getDocScrollLeft),\n/* harmony export */   _getDocScrollTop: () => (/* binding */ _getDocScrollTop),\n/* harmony export */   _isFixed: () => (/* binding */ _isFixed),\n/* harmony export */   _setDoc: () => (/* binding */ _setDoc),\n/* harmony export */   getGlobalMatrix: () => (/* binding */ getGlobalMatrix)\n/* harmony export */ });\n/*!\n * matrix 3.10.4\n * https://greensock.com\n *\n * Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _doc,\n    _win,\n    _docElement,\n    _body,\n    _divContainer,\n    _svgContainer,\n    _identityMatrix,\n    _gEl,\n    _transformProp = \"transform\",\n    _transformOriginProp = _transformProp  \"Origin\",\n    _hasOffsetBug,\n    _setDoc = function _setDoc(element) {\n  var doc = element.ownerDocument || element;\n\n  if (!(_transformProp in element.style) && \"msTransform\" in element.style) {\n    //to improve compatibility with old Microsoft browsers\n    _transformProp = \"msTransform\";\n    _transformOriginProp = _transformProp  \"Origin\";\n  }\n\n  while (doc.parentNode && (doc = doc.parentNode)) {}\n\n  _win = window;\n  _identityMatrix = new Matrix2D();\n\n  if (doc) {\n    _doc = doc;\n    _docElement = doc.documentElement;\n    _body = doc.body;\n    _gEl = _doc.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"); // prevent any existing CSS from transforming it\n\n    _gEl.style.transform = \"none\"; // now test for the offset reporting bug. Use feature detection instead of browser sniffing to make things more bulletproof and future-proof. Hopefully Safari will fix their bug soon but it's 2020 and it's still not fixed.\n\n    var d1 = doc.createElement(\"div\"),\n        d2 = doc.createElement(\"div\");\n\n    _body.appendChild(d1);\n\n    d1.appendChild(d2);\n    d1.style.position = \"static\";\n    d1.style[_transformProp] = \"translate3d(0,0,1px)\";\n    _hasOffsetBug = d2.offsetParent !== d1;\n\n    _body.removeChild(d1);\n  }\n\n  return doc;\n},\n    _forceNonZeroScale = function _forceNonZeroScale(e) {\n  // walks up the element's ancestors and finds any that had their scale set to 0 via GSAP, and changes them to 0.0001 to ensure that measurements work. Firefox has a bug that causes it to incorrectly report getBoundingClientRect() when scale is 0.\n  var a, cache;\n\n  while (e && e !== _body) {\n    cache = e._gsap;\n    cache && cache.uncache && cache.get(e, \"x\"); // force re-parsing of transforms if necessary\n\n    if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {\n      cache.scaleX = cache.scaleY = 1e-4;\n      cache.renderTransform(1, cache);\n      a ? a.push(cache) : a = [cache];\n    }\n\n    e = e.parentNode;\n  }\n\n  return a;\n},\n    // possible future addition: pass an element to _forceDisplay() and it'll walk up all its ancestors and make sure anything with display: none is set to display: block, and if there's no parentNode, it'll add it to the body. It returns an Array that you can then feed to _revertDisplay() to have it revert all the changes it made.\n// _forceDisplay = e => {\n// \tlet a = [],\n// \t\tparent;\n// \twhile (e && e !== _body) {\n// \t\tparent = e.parentNode;\n// \t\t(_win.getComputedStyle(e).display === \"none\" || !parent) && a.push(e, e.style.display, parent) && (e.style.display = \"block\");\n// \t\tparent || _body.appendChild(e);\n// \t\te = parent;\n// \t}\n// \treturn a;\n// },\n// _revertDisplay = a => {\n// \tfor (let i = 0; i < a.length; i=3) {\n// \t\ta[i1] ? (a[i].style.display = a[i1]) : a[i].style.removeProperty(\"display\");\n// \t\ta[i2] || a[i].parentNode.removeChild(a[i]);\n// \t}\n// },\n_svgTemps = [],\n    //we create 3 elements for SVG, and 3 for other DOM elements and cache them for performance reasons. They get nested in _divContainer and _svgContainer so that just one element is added to the DOM on each successive attempt. Again, performance is key.\n_divTemps = [],\n    _getDocScrollTop = function _getDocScrollTop() {\n  return _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0;\n},\n    _getDocScrollLeft = function _getDocScrollLeft() {\n  return _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0;\n},\n    _svgOwner = function _svgOwner(element) {\n  return element.ownerSVGElement || ((element.tagName  \"\").toLowerCase() === \"svg\" ? element : null);\n},\n    _isFixed = function _isFixed(element) {\n  if (_win.getComputedStyle(element).position === \"fixed\") {\n    return true;\n  }\n\n  element = element.parentNode;\n\n  if (element && element.nodeType === 1) {\n    // avoid document fragments which will throw an error.\n    return _isFixed(element);\n  }\n},\n    _createSibling = function _createSibling(element, i) {\n  if (element.parentNode && (_doc || _setDoc(element))) {\n    var svg = _svgOwner(element),\n        ns = svg ? svg.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\" : \"http://www.w3.org/1999/xhtml\",\n        type = svg ? i ? \"rect\" : \"g\" : \"div\",\n        x = i !== 2 ? 0 : 100,\n        y = i === 3 ? 100 : 0,\n        css = \"position:absolute;display:block;pointer-events:none;margin:0;padding:0;\",\n        e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, \"http\"), type) : _doc.createElement(type);\n\n    if (i) {\n      if (!svg) {\n        if (!_divContainer) {\n          _divContainer = _createSibling(element);\n          _divContainer.style.cssText = css;\n        }\n\n        e.style.cssText = css  \"width:0.1px;height:0.1px;top:\"  y  \"px;left:\"  x  \"px\";\n\n        _divContainer.appendChild(e);\n      } else {\n        _svgContainer || (_svgContainer = _createSibling(element));\n        e.setAttribute(\"width\", 0.01);\n        e.setAttribute(\"height\", 0.01);\n        e.setAttribute(\"transform\", \"translate(\"  x  \",\"  y  \")\");\n\n        _svgContainer.appendChild(e);\n      }\n    }\n\n    return e;\n  }\n\n  throw \"Need document and parent.\";\n},\n    _consolidate = function _consolidate(m) {\n  // replaces SVGTransformList.consolidate() because a bug in Firefox causes it to break pointer events. See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n  var c = new Matrix2D(),\n      i = 0;\n\n  for (; i < m.numberOfItems; i) {\n    c.multiply(m.getItem(i).matrix);\n  }\n\n  return c;\n},\n    _getCTM = function _getCTM(svg) {\n  var m = svg.getCTM(),\n      transform;\n\n  if (!m) {\n    // Firefox returns null for getCTM() on root <svg> elements, so this is a workaround using a <g> that we temporarily append.\n    transform = svg.style[_transformProp];\n    svg.style[_transformProp] = \"none\"; // a bug in Firefox causes css transforms to contaminate the getCTM()\n\n    svg.appendChild(_gEl);\n    m = _gEl.getCTM();\n    svg.removeChild(_gEl);\n    transform ? svg.style[_transformProp] = transform : svg.style.removeProperty(_transformProp.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n  }\n\n  return m || _identityMatrix.clone(); // Firefox will still return null if the <svg> has a width/height of 0 in the browser.\n},\n    _placeSiblings = function _placeSiblings(element, adjustGOffset) {\n  var svg = _svgOwner(element),\n      isRootSVG = element === svg,\n      siblings = svg ? _svgTemps : _divTemps,\n      parent = element.parentNode,\n      container,\n      m,\n      b,\n      x,\n      y,\n      cs;\n\n  if (element === _win) {\n    return element;\n  }\n\n  siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));\n  container = svg ? _svgContainer : _divContainer;\n\n  if (svg) {\n    if (isRootSVG) {\n      b = _getCTM(element);\n      x = -b.e / b.a;\n      y = -b.f / b.d;\n      m = _identityMatrix;\n    } else if (element.getBBox) {\n      b = element.getBBox();\n      m = element.transform ? element.transform.baseVal : {}; // IE11 doesn't follow the spec.\n\n      m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix; // don't call m.consolidate().matrix because a bug in Firefox makes pointer events not work when consolidate() is called on the same tick as getBoundingClientRect()! See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n\n      x = m.a * b.x  m.c * b.y;\n      y = m.b * b.x  m.d * b.y;\n    } else {\n      // may be a <mask> which has no getBBox() so just use defaults instead of throwing errors.\n      m = new Matrix2D();\n      x = y = 0;\n    }\n\n    if (adjustGOffset && element.tagName.toLowerCase() === \"g\") {\n      x = y = 0;\n    }\n\n    (isRootSVG ? svg : parent).appendChild(container);\n    container.setAttribute(\"transform\", \"matrix(\"  m.a  \",\"  m.b  \",\"  m.c  \",\"  m.d  \",\"  (m.e  x)  \",\"  (m.f  y)  \")\");\n  } else {\n    x = y = 0;\n\n    if (_hasOffsetBug) {\n      // some browsers (like Safari) have a bug that causes them to misreport offset values. When an ancestor element has a transform applied, it's supposed to treat it as if it's position: relative (new context). Safari botches this, so we need to find the closest ancestor (between the element and its offsetParent) that has a transform applied and if one is found, grab its offsetTop/Left and subtract them to compensate.\n      m = element.offsetParent;\n      b = element;\n\n      while (b && (b = b.parentNode) && b !== m && b.parentNode) {\n        if ((_win.getComputedStyle(b)[_transformProp]  \"\").length > 4) {\n          x = b.offsetLeft;\n          y = b.offsetTop;\n          b = 0;\n        }\n      }\n    }\n\n    cs = _win.getComputedStyle(element);\n\n    if (cs.position !== \"absolute\" && cs.position !== \"fixed\") {\n      m = element.offsetParent;\n\n      while (parent && parent !== m) {\n        // if there's an ancestor element between the element and its offsetParent that's scrolled, we must factor that in.\n        x = parent.scrollLeft || 0;\n        y = parent.scrollTop || 0;\n        parent = parent.parentNode;\n      }\n    }\n\n    b = container.style;\n    b.top = element.offsetTop - y  \"px\";\n    b.left = element.offsetLeft - x  \"px\";\n    b[_transformProp] = cs[_transformProp];\n    b[_transformOriginProp] = cs[_transformOriginProp]; // b.border = m.border;\n    // b.borderLeftStyle = m.borderLeftStyle;\n    // b.borderTopStyle = m.borderTopStyle;\n    // b.borderLeftWidth = m.borderLeftWidth;\n    // b.borderTopWidth = m.borderTopWidth;\n\n    b.position = cs.position === \"fixed\" ? \"fixed\" : \"absolute\";\n    element.parentNode.appendChild(container);\n  }\n\n  return container;\n},\n    _setMatrix = function _setMatrix(m, a, b, c, d, e, f) {\n  m.a = a;\n  m.b = b;\n  m.c = c;\n  m.d = d;\n  m.e = e;\n  m.f = f;\n  return m;\n};\n\nvar Matrix2D = /*#__PURE__*/function () {\n  function Matrix2D(a, b, c, d, e, f) {\n    if (a === void 0) {\n      a = 1;\n    }\n\n    if (b === void 0) {\n      b = 0;\n    }\n\n    if (c === void 0) {\n      c = 0;\n    }\n\n    if (d === void 0) {\n      d = 1;\n    }\n\n    if (e === void 0) {\n      e = 0;\n    }\n\n    if (f === void 0) {\n      f = 0;\n    }\n\n    _setMatrix(this, a, b, c, d, e, f);\n  }\n\n  var _proto = Matrix2D.prototype;\n\n  _proto.inverse = function inverse() {\n    var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f,\n        determinant = a * d - b * c || 1e-10;\n    return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);\n  };\n\n  _proto.multiply = function multiply(matrix) {\n    var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f,\n        a2 = matrix.a,\n        b2 = matrix.c,\n        c2 = matrix.b,\n        d2 = matrix.d,\n        e2 = matrix.e,\n        f2 = matrix.f;\n    return _setMatrix(this, a2 * a  c2 * c, a2 * b  c2 * d, b2 * a  d2 * c, b2 * b  d2 * d, e  e2 * a  f2 * c, f  e2 * b  f2 * d);\n  };\n\n  _proto.clone = function clone() {\n    return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);\n  };\n\n  _proto.equals = function equals(matrix) {\n    var a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f;\n    return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;\n  };\n\n  _proto.apply = function apply(point, decoratee) {\n    if (decoratee === void 0) {\n      decoratee = {};\n    }\n\n    var x = point.x,\n        y = point.y,\n        a = this.a,\n        b = this.b,\n        c = this.c,\n        d = this.d,\n        e = this.e,\n        f = this.f;\n    decoratee.x = x * a  y * c  e || 0;\n    decoratee.y = x * b  y * d  f || 0;\n    return decoratee;\n  };\n\n  return Matrix2D;\n}(); // Feed in an element and it'll return a 2D matrix (optionally inverted) so that you can translate between coordinate spaces.\n// Inverting lets you translate a global point into a local coordinate space. No inverting lets you go the other way.\n// We needed this to work around various browser bugs, like Firefox doesn't accurately report getScreenCTM() when there\n// are transforms applied to ancestor elements.\n// The matrix math to convert any x/y coordinate is as follows, which is wrapped in a convenient apply() method of Matrix2D above:\n//     tx = m.a * x  m.c * y  m.e\n//     ty = m.b * x  m.d * y  m.f\n\nfunction getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {\n  // adjustGOffset is typically used only when grabbing an element's PARENT's global matrix, and it ignores the x/y offset of any SVG <g> elements because they behave in a special way.\n  if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {\n    return new Matrix2D();\n  }\n\n  var zeroScales = _forceNonZeroScale(element),\n      svg = _svgOwner(element),\n      temps = svg ? _svgTemps : _divTemps,\n      container = _placeSiblings(element, adjustGOffset),\n      b1 = temps[0].getBoundingClientRect(),\n      b2 = temps[1].getBoundingClientRect(),\n      b3 = temps[2].getBoundingClientRect(),\n      parent = container.parentNode,\n      isFixed = !includeScrollInFixed && _isFixed(element),\n      m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left  (isFixed ? 0 : _getDocScrollLeft()), b1.top  (isFixed ? 0 : _getDocScrollTop()));\n\n  parent.removeChild(container);\n\n  if (zeroScales) {\n    b1 = zeroScales.length;\n\n    while (b1--) {\n      b2 = zeroScales[b1];\n      b2.scaleX = b2.scaleY = 0;\n      b2.renderTransform(1, b2);\n    }\n  }\n\n  return inverse ? m.inverse() : m;\n}\n // export function getMatrix(element) {\n// \t_doc || _setDoc(element);\n// \tlet m = (_win.getComputedStyle(element)[_transformProp]  \"\").substr(7).match(/[-.]*\\d[.e\\-]*\\d*[e\\-\\]*\\d*/g),\n// \t\tis2D = m && m.length === 6;\n// \treturn !m || m.length < 6 ? new Matrix2D() : new Matrix2D(m[0], m[1], m[is2D ? 2 : 4], m[is2D ? 3 : 5], m[is2D ? 4 : 12], m[is2D ? 5 : 13]);\n// }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9tYXRyaXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTs7QUFFcEUsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWMsb0JBQW9CLFNBQVMsVUFBVTtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLGFBQWEsZ0JBQWdCOztBQUUxRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDhEQUE4RDs7QUFFOUQsNEdBQTRHOztBQUU1RztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDMkUsQ0FBQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvbWF0cml4LmpzP2VjNWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBtYXRyaXggMy4xMC40XG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDIyLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9kb2MsXG4gICAgX3dpbixcbiAgICBfZG9jRWxlbWVudCxcbiAgICBfYm9keSxcbiAgICBfZGl2Q29udGFpbmVyLFxuICAgIF9zdmdDb250YWluZXIsXG4gICAgX2lkZW50aXR5TWF0cml4LFxuICAgIF9nRWwsXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgIF9oYXNPZmZzZXRCdWcsXG4gICAgX3NldERvYyA9IGZ1bmN0aW9uIF9zZXREb2MoZWxlbWVudCkge1xuICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG5cbiAgaWYgKCEoX3RyYW5zZm9ybVByb3AgaW4gZWxlbWVudC5zdHlsZSkgJiYgXCJtc1RyYW5zZm9ybVwiIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAvL3RvIGltcHJvdmUgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBNaWNyb3NvZnQgYnJvd3NlcnNcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwibXNUcmFuc2Zvcm1cIjtcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIjtcbiAgfVxuXG4gIHdoaWxlIChkb2MucGFyZW50Tm9kZSAmJiAoZG9jID0gZG9jLnBhcmVudE5vZGUpKSB7fVxuXG4gIF93aW4gPSB3aW5kb3c7XG4gIF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgyRCgpO1xuXG4gIGlmIChkb2MpIHtcbiAgICBfZG9jID0gZG9jO1xuICAgIF9kb2NFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfYm9keSA9IGRvYy5ib2R5O1xuICAgIF9nRWwgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTsgLy8gcHJldmVudCBhbnkgZXhpc3RpbmcgQ1NTIGZyb20gdHJhbnNmb3JtaW5nIGl0XG5cbiAgICBfZ0VsLnN0eWxlLnRyYW5zZm9ybSA9IFwibm9uZVwiOyAvLyBub3cgdGVzdCBmb3IgdGhlIG9mZnNldCByZXBvcnRpbmcgYnVnLiBVc2UgZmVhdHVyZSBkZXRlY3Rpb24gaW5zdGVhZCBvZiBicm93c2VyIHNuaWZmaW5nIHRvIG1ha2UgdGhpbmdzIG1vcmUgYnVsbGV0cHJvb2YgYW5kIGZ1dHVyZS1wcm9vZi4gSG9wZWZ1bGx5IFNhZmFyaSB3aWxsIGZpeCB0aGVpciBidWcgc29vbiBidXQgaXQncyAyMDIwIGFuZCBpdCdzIHN0aWxsIG5vdCBmaXhlZC5cblxuICAgIHZhciBkMSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBkMiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgX2JvZHkuYXBwZW5kQ2hpbGQoZDEpO1xuXG4gICAgZDEuYXBwZW5kQ2hpbGQoZDIpO1xuICAgIGQxLnN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIjtcbiAgICBkMS5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcInRyYW5zbGF0ZTNkKDAsMCwxcHgpXCI7XG4gICAgX2hhc09mZnNldEJ1ZyA9IGQyLm9mZnNldFBhcmVudCAhPT0gZDE7XG5cbiAgICBfYm9keS5yZW1vdmVDaGlsZChkMSk7XG4gIH1cblxuICByZXR1cm4gZG9jO1xufSxcbiAgICBfZm9yY2VOb25aZXJvU2NhbGUgPSBmdW5jdGlvbiBfZm9yY2VOb25aZXJvU2NhbGUoZSkge1xuICAvLyB3YWxrcyB1cCB0aGUgZWxlbWVudCdzIGFuY2VzdG9ycyBhbmQgZmluZHMgYW55IHRoYXQgaGFkIHRoZWlyIHNjYWxlIHNldCB0byAwIHZpYSBHU0FQLCBhbmQgY2hhbmdlcyB0aGVtIHRvIDAuMDAwMSB0byBlbnN1cmUgdGhhdCBtZWFzdXJlbWVudHMgd29yay4gRmlyZWZveCBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgdG8gaW5jb3JyZWN0bHkgcmVwb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHdoZW4gc2NhbGUgaXMgMC5cbiAgdmFyIGEsIGNhY2hlO1xuXG4gIHdoaWxlIChlICYmIGUgIT09IF9ib2R5KSB7XG4gICAgY2FjaGUgPSBlLl9nc2FwO1xuICAgIGNhY2hlICYmIGNhY2hlLnVuY2FjaGUgJiYgY2FjaGUuZ2V0KGUsIFwieFwiKTsgLy8gZm9yY2UgcmUtcGFyc2luZyBvZiB0cmFuc2Zvcm1zIGlmIG5lY2Vzc2FyeVxuXG4gICAgaWYgKGNhY2hlICYmICFjYWNoZS5zY2FsZVggJiYgIWNhY2hlLnNjYWxlWSAmJiBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0pIHtcbiAgICAgIGNhY2hlLnNjYWxlWCA9IGNhY2hlLnNjYWxlWSA9IDFlLTQ7XG4gICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuICAgICAgYSA/IGEucHVzaChjYWNoZSkgOiBhID0gW2NhY2hlXTtcbiAgICB9XG5cbiAgICBlID0gZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59LFxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBhZGRpdGlvbjogcGFzcyBhbiBlbGVtZW50IHRvIF9mb3JjZURpc3BsYXkoKSBhbmQgaXQnbGwgd2FsayB1cCBhbGwgaXRzIGFuY2VzdG9ycyBhbmQgbWFrZSBzdXJlIGFueXRoaW5nIHdpdGggZGlzcGxheTogbm9uZSBpcyBzZXQgdG8gZGlzcGxheTogYmxvY2ssIGFuZCBpZiB0aGVyZSdzIG5vIHBhcmVudE5vZGUsIGl0J2xsIGFkZCBpdCB0byB0aGUgYm9keS4gSXQgcmV0dXJucyBhbiBBcnJheSB0aGF0IHlvdSBjYW4gdGhlbiBmZWVkIHRvIF9yZXZlcnREaXNwbGF5KCkgdG8gaGF2ZSBpdCByZXZlcnQgYWxsIHRoZSBjaGFuZ2VzIGl0IG1hZGUuXG4vLyBfZm9yY2VEaXNwbGF5ID0gZSA9PiB7XG4vLyBcdGxldCBhID0gW10sXG4vLyBcdFx0cGFyZW50O1xuLy8gXHR3aGlsZSAoZSAmJiBlICE9PSBfYm9keSkge1xuLy8gXHRcdHBhcmVudCA9IGUucGFyZW50Tm9kZTtcbi8vIFx0XHQoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGUpLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFwYXJlbnQpICYmIGEucHVzaChlLCBlLnN0eWxlLmRpc3BsYXksIHBhcmVudCkgJiYgKGUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIik7XG4vLyBcdFx0cGFyZW50IHx8IF9ib2R5LmFwcGVuZENoaWxkKGUpO1xuLy8gXHRcdGUgPSBwYXJlbnQ7XG4vLyBcdH1cbi8vIFx0cmV0dXJuIGE7XG4vLyB9LFxuLy8gX3JldmVydERpc3BsYXkgPSBhID0IHtcbi8vIFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSs9Mykge1xuLy8gXHRcdGFbaSsxXSA/IChhW2ldLnN0eWxlLmRpc3BsYXkgPSBhW2krMV0pIDogYVtpXS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4vLyBcdFx0YVtpKzJdIHx8IGFbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhW2ldKTtcbi8vIFx0fVxuLy8gfSxcbl9zdmdUZW1wcyA9IFtdLFxuICAgIC8vd2UgY3JlYXRlIDMgZWxlbWVudHMgZm9yIFNWRywgYW5kIDMgZm9yIG90aGVyIERPTSBlbGVtZW50cyBhbmQgY2FjaGUgdGhlbSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gVGhleSBnZXQgbmVzdGVkIGluIF9kaXZDb250YWluZXIgYW5kIF9zdmdDb250YWluZXIgc28gdGhhdCBqdXN0IG9uZSBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET00gb24gZWFjaCBzdWNjZXNzaXZlIGF0dGVtcHQuIEFnYWluLCBwZXJmb3JtYW5jZSBpcyBrZXkuXG5fZGl2VGVtcHMgPSBbXSxcbiAgICBfZ2V0RG9jU2Nyb2xsVG9wID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbFRvcCgpIHtcbiAgcmV0dXJuIF93aW4ucGFnZVlPZmZzZXQgfHwgX2RvYy5zY3JvbGxUb3AgfHwgX2RvY0VsZW1lbnQuc2Nyb2xsVG9wIHx8IF9ib2R5LnNjcm9sbFRvcCB8fCAwO1xufSxcbiAgICBfZ2V0RG9jU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIF9nZXREb2NTY3JvbGxMZWZ0KCkge1xuICByZXR1cm4gX3dpbi5wYWdlWE9mZnNldCB8fCBfZG9jLnNjcm9sbExlZnQgfHwgX2RvY0VsZW1lbnQuc2Nyb2xsTGVmdCB8fCBfYm9keS5zY3JvbGxMZWZ0IHx8IDA7XG59LFxuICAgIF9zdmdPd25lciA9IGZ1bmN0aW9uIF9zdmdPd25lcihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCB8fCAoKGVsZW1lbnQudGFnTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIgPyBlbGVtZW50IDogbnVsbCk7XG59LFxuICAgIF9pc0ZpeGVkID0gZnVuY3Rpb24gX2lzRml4ZWQoZWxlbWVudCkge1xuICBpZiAoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIC8vIGF2b2lkIGRvY3VtZW50IGZyYWdtZW50cyB3aGljaCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIHJldHVybiBfaXNGaXhlZChlbGVtZW50KTtcbiAgfVxufSxcbiAgICBfY3JlYXRlU2libGluZyA9IGZ1bmN0aW9uIF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIGkpIHtcbiAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiAoX2RvYyB8fCBfc2V0RG9jKGVsZW1lbnQpKSkge1xuICAgIHZhciBzdmcgPSBfc3ZnT3duZXIoZWxlbWVudCksXG4gICAgICAgIG5zID0gc3ZnID8gc3ZnLmdldEF0dHJpYnV0ZShcInhtbG5zXCIpIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiA6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFxuICAgICAgICB0eXBlID0gc3ZnID8gaSA/IFwicmVjdFwiIDogXCJnXCIgOiBcImRpdlwiLFxuICAgICAgICB4ID0gaSAhPT0gMiA/IDAgOiAxMDAsXG4gICAgICAgIHkgPSBpID09PSAzID8gMTAwIDogMCxcbiAgICAgICAgY3NzID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3BvaW50ZXItZXZlbnRzOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO1wiLFxuICAgICAgICBlID0gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUyhucy5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXG4gICAgaWYgKGkpIHtcbiAgICAgIGlmICghc3ZnKSB7XG4gICAgICAgIGlmICghX2RpdkNvbnRhaW5lcikge1xuICAgICAgICAgIF9kaXZDb250YWluZXIgPSBfY3JlYXRlU2libGluZyhlbGVtZW50KTtcbiAgICAgICAgICBfZGl2Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBjc3M7XG4gICAgICAgIH1cblxuICAgICAgICBlLnN0eWxlLmNzc1RleHQgPSBjc3MgKyBcIndpZHRoOjAuMXB4O2hlaWdodDowLjFweDt0b3A6XCIgKyB5ICsgXCJweDtsZWZ0OlwiICsgeCArIFwicHhcIjtcblxuICAgICAgICBfZGl2Q29udGFpbmVyLmFwcGVuZENoaWxkKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3N2Z0NvbnRhaW5lciB8fCAoX3N2Z0NvbnRhaW5lciA9IF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQpKTtcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwLjAxKTtcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMC4wMSk7XG4gICAgICAgIGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiKTtcblxuICAgICAgICBfc3ZnQ29udGFpbmVyLmFwcGVuZENoaWxkKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlO1xuICB9XG5cbiAgdGhyb3cgXCJOZWVkIGRvY3VtZW50IGFuZCBwYXJlbnQuXCI7XG59LFxuICAgIF9jb25zb2xpZGF0ZSA9IGZ1bmN0aW9uIF9jb25zb2xpZGF0ZShtKSB7XG4gIC8vIHJlcGxhY2VzIFNWR1RyYW5zZm9ybUxpc3QuY29uc29saWRhdGUoKSBiZWNhdXNlIGEgYnVnIGluIEZpcmVmb3ggY2F1c2VzIGl0IHRvIGJyZWFrIHBvaW50ZXIgZXZlbnRzLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMzI0OC10b3VjaC1pcy1ub3Qtd29ya2luZy1vbi1kcmFnZ2FibGUtaW4tZmlyZWZveC13aW5kb3dzLXYzMjQvP3RhYj1jb21tZW50cyNjb21tZW50LTEwOTgwMFxuICB2YXIgYyA9IG5ldyBNYXRyaXgyRCgpLFxuICAgICAgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBtLm51bWJlck9mSXRlbXM7IGkrKykge1xuICAgIGMubXVsdGlwbHkobS5nZXRJdGVtKGkpLm1hdHJpeCk7XG4gIH1cblxuICByZXR1cm4gYztcbn0sXG4gICAgX2dldENUTSA9IGZ1bmN0aW9uIF9nZXRDVE0oc3ZnKSB7XG4gIHZhciBtID0gc3ZnLmdldENUTSgpLFxuICAgICAgdHJhbnNmb3JtO1xuXG4gIGlmICghbSkge1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDVE0oKSBvbiByb290IDxzdmcIGVsZW1lbnRzLCBzbyB0aGlzIGlzIGEgd29ya2Fyb3VuZCB1c2luZyBhIDxnPiB0aGF0IHdlIHRlbXBvcmFyaWx5IGFwcGVuZC5cbiAgICB0cmFuc2Zvcm0gPSBzdmcuc3R5bGVbX3RyYW5zZm9ybVByb3BdO1xuICAgIHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcIm5vbmVcIjsgLy8gYSBidWcgaW4gRmlyZWZveCBjYXVzZXMgY3NzIHRyYW5zZm9ybXMgdG8gY29udGFtaW5hdGUgdGhlIGdldENUTSgpXG5cbiAgICBzdmcuYXBwZW5kQ2hpbGQoX2dFbCk7XG4gICAgbSA9IF9nRWwuZ2V0Q1RNKCk7XG4gICAgc3ZnLnJlbW92ZUNoaWxkKF9nRWwpO1xuICAgIHRyYW5zZm9ybSA/IHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm0gOiBzdmcuc3R5bGUucmVtb3ZlUHJvcGVydHkoX3RyYW5zZm9ybVByb3AucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBtIHx8IF9pZGVudGl0eU1hdHJpeC5jbG9uZSgpOyAvLyBGaXJlZm94IHdpbGwgc3RpbGwgcmV0dXJuIG51bGwgaWYgdGhlIDxzdmcIGhhcyBhIHdpZHRoL2hlaWdodCBvZiAwIGluIHRoZSBicm93c2VyLlxufSxcbiAgICBfcGxhY2VTaWJsaW5ncyA9IGZ1bmN0aW9uIF9wbGFjZVNpYmxpbmdzKGVsZW1lbnQsIGFkanVzdEdPZmZzZXQpIHtcbiAgdmFyIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgIGlzUm9vdFNWRyA9IGVsZW1lbnQgPT09IHN2ZyxcbiAgICAgIHNpYmxpbmdzID0gc3ZnID8gX3N2Z1RlbXBzIDogX2RpdlRlbXBzLFxuICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbSxcbiAgICAgIGIsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNzO1xuXG4gIGlmIChlbGVtZW50ID09PSBfd2luKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBzaWJsaW5ncy5sZW5ndGggfHwgc2libGluZ3MucHVzaChfY3JlYXRlU2libGluZyhlbGVtZW50LCAxKSwgX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgMiksIF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIDMpKTtcbiAgY29udGFpbmVyID0gc3ZnID8gX3N2Z0NvbnRhaW5lciA6IF9kaXZDb250YWluZXI7XG5cbiAgaWYgKHN2Zykge1xuICAgIGlmIChpc1Jvb3RTVkcpIHtcbiAgICAgIGIgPSBfZ2V0Q1RNKGVsZW1lbnQpO1xuICAgICAgeCA9IC1iLmUgLyBiLmE7XG4gICAgICB5ID0gLWIuZiAvIGIuZDtcbiAgICAgIG0gPSBfaWRlbnRpdHlNYXRyaXg7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmdldEJCb3gpIHtcbiAgICAgIGIgPSBlbGVtZW50LmdldEJCb3goKTtcbiAgICAgIG0gPSBlbGVtZW50LnRyYW5zZm9ybSA/IGVsZW1lbnQudHJhbnNmb3JtLmJhc2VWYWwgOiB7fTsgLy8gSUUxMSBkb2Vzbid0IGZvbGxvdyB0aGUgc3BlYy5cblxuICAgICAgbSA9ICFtLm51bWJlck9mSXRlbXMgPyBfaWRlbnRpdHlNYXRyaXggOiBtLm51bWJlck9mSXRlbXMgPiAxID8gX2NvbnNvbGlkYXRlKG0pIDogbS5nZXRJdGVtKDApLm1hdHJpeDsgLy8gZG9uJ3QgY2FsbCBtLmNvbnNvbGlkYXRlKCkubWF0cml4IGJlY2F1c2UgYSBidWcgaW4gRmlyZWZveCBtYWtlcyBwb2ludGVyIGV2ZW50cyBub3Qgd29yayB3aGVuIGNvbnNvbGlkYXRlKCkgaXMgY2FsbGVkIG9uIHRoZSBzYW1lIHRpY2sgYXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkhIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIzMjQ4LXRvdWNoLWlzLW5vdC13b3JraW5nLW9uLWRyYWdnYWJsZS1pbi1maXJlZm94LXdpbmRvd3MtdjMyNC8/dGFiPWNvbW1lbnRzI2NvbW1lbnQtMTA5ODAwXG5cbiAgICAgIHggPSBtLmEgKiBiLnggKyBtLmMgKiBiLnk7XG4gICAgICB5ID0gbS5iICogYi54ICsgbS5kICogYi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYXkgYmUgYSA8bWFzaz4gd2hpY2ggaGFzIG5vIGdldEJCb3goKSBzbyBqdXN0IHVzZSBkZWZhdWx0cyBpbnN0ZWFkIG9mIHRocm93aW5nIGVycm9ycy5cbiAgICAgIG0gPSBuZXcgTWF0cml4MkQoKTtcbiAgICAgIHggPSB5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYWRqdXN0R09mZnNldCAmJiBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJnXCIpIHtcbiAgICAgIHggPSB5ID0gMDtcbiAgICB9XG5cbiAgICAoaXNSb290U1ZHID8gc3ZnIDogcGFyZW50KS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJtYXRyaXgoXCIgKyBtLmEgKyBcIixcIiArIG0uYiArIFwiLFwiICsgbS5jICsgXCIsXCIgKyBtLmQgKyBcIixcIiArIChtLmUgKyB4KSArIFwiLFwiICsgKG0uZiArIHkpICsgXCIpXCIpO1xuICB9IGVsc2Uge1xuICAgIHggPSB5ID0gMDtcblxuICAgIGlmIChfaGFzT2Zmc2V0QnVnKSB7XG4gICAgICAvLyBzb21lIGJyb3dzZXJzIChsaWtlIFNhZmFyaSkgaGF2ZSBhIGJ1ZyB0aGF0IGNhdXNlcyB0aGVtIHRvIG1pc3JlcG9ydCBvZmZzZXQgdmFsdWVzLiBXaGVuIGFuIGFuY2VzdG9yIGVsZW1lbnQgaGFzIGEgdHJhbnNmb3JtIGFwcGxpZWQsIGl0J3Mgc3VwcG9zZWQgdG8gdHJlYXQgaXQgYXMgaWYgaXQncyBwb3NpdGlvbjogcmVsYXRpdmUgKG5ldyBjb250ZXh0KS4gU2FmYXJpIGJvdGNoZXMgdGhpcywgc28gd2UgbmVlZCB0byBmaW5kIHRoZSBjbG9zZXN0IGFuY2VzdG9yIChiZXR3ZWVuIHRoZSBlbGVtZW50IGFuZCBpdHMgb2Zmc2V0UGFyZW50KSB0aGF0IGhhcyBhIHRyYW5zZm9ybSBhcHBsaWVkIGFuZCBpZiBvbmUgaXMgZm91bmQsIGdyYWIgaXRzIG9mZnNldFRvcC9MZWZ0IGFuZCBzdWJ0cmFjdCB0aGVtIHRvIGNvbXBlbnNhdGUuXG4gICAgICBtID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICBiID0gZWxlbWVudDtcblxuICAgICAgd2hpbGUgKGIgJiYgKGIgPSBiLnBhcmVudE5vZGUpICYmIGIgIT09IG0gJiYgYi5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICgoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGIpW190cmFuc2Zvcm1Qcm9wXSArIFwiXCIpLmxlbmd0aCAIDQpIHtcbiAgICAgICAgICB4ID0gYi5vZmZzZXRMZWZ0O1xuICAgICAgICAgIHkgPSBiLm9mZnNldFRvcDtcbiAgICAgICAgICBiID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNzID0gX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGNzLnBvc2l0aW9uICE9PSBcImFic29sdXRlXCIgJiYgY3MucG9zaXRpb24gIT09IFwiZml4ZWRcIikge1xuICAgICAgbSA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG4gICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPT0gbSkge1xuICAgICAgICAvLyBpZiB0aGVyZSdzIGFuIGFuY2VzdG9yIGVsZW1lbnQgYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgaXRzIG9mZnNldFBhcmVudCB0aGF0J3Mgc2Nyb2xsZWQsIHdlIG11c3QgZmFjdG9yIHRoYXQgaW4uXG4gICAgICAgIHggKz0gcGFyZW50LnNjcm9sbExlZnQgfHwgMDtcbiAgICAgICAgeSArPSBwYXJlbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGIgPSBjb250YWluZXIuc3R5bGU7XG4gICAgYi50b3AgPSBlbGVtZW50Lm9mZnNldFRvcCAtIHkgKyBcInB4XCI7XG4gICAgYi5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0IC0geCArIFwicHhcIjtcbiAgICBiW190cmFuc2Zvcm1Qcm9wXSA9IGNzW190cmFuc2Zvcm1Qcm9wXTtcbiAgICBiW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IGNzW190cmFuc2Zvcm1PcmlnaW5Qcm9wXTsgLy8gYi5ib3JkZXIgPSBtLmJvcmRlcjtcbiAgICAvLyBiLmJvcmRlckxlZnRTdHlsZSA9IG0uYm9yZGVyTGVmdFN0eWxlO1xuICAgIC8vIGIuYm9yZGVyVG9wU3R5bGUgPSBtLmJvcmRlclRvcFN0eWxlO1xuICAgIC8vIGIuYm9yZGVyTGVmdFdpZHRoID0gbS5ib3JkZXJMZWZ0V2lkdGg7XG4gICAgLy8gYi5ib3JkZXJUb3BXaWR0aCA9IG0uYm9yZGVyVG9wV2lkdGg7XG5cbiAgICBiLnBvc2l0aW9uID0gY3MucG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIjtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXI7XG59LFxuICAgIF9zZXRNYXRyaXggPSBmdW5jdGlvbiBfc2V0TWF0cml4KG0sIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgbS5hID0gYTtcbiAgbS5iID0gYjtcbiAgbS5jID0gYztcbiAgbS5kID0gZDtcbiAgbS5lID0gZTtcbiAgbS5mID0gZjtcbiAgcmV0dXJuIG07XG59O1xuXG5leHBvcnQgdmFyIE1hdHJpeDJEID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWF0cml4MkQoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIGlmIChiID09PSB2b2lkIDApIHtcbiAgICAgIGIgPSAwO1xuICAgIH1cblxuICAgIGlmIChjID09PSB2b2lkIDApIHtcbiAgICAgIGMgPSAwO1xuICAgIH1cblxuICAgIGlmIChkID09PSB2b2lkIDApIHtcbiAgICAgIGQgPSAxO1xuICAgIH1cblxuICAgIGlmIChlID09PSB2b2lkIDApIHtcbiAgICAgIGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChmID09PSB2b2lkIDApIHtcbiAgICAgIGYgPSAwO1xuICAgIH1cblxuICAgIF9zZXRNYXRyaXgodGhpcywgYSwgYiwgYywgZCwgZSwgZik7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTWF0cml4MkQucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbnZlcnNlID0gZnVuY3Rpb24gaW52ZXJzZSgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYyA9IHRoaXMuYyxcbiAgICAgICAgZCA9IHRoaXMuZCxcbiAgICAgICAgZSA9IHRoaXMuZSxcbiAgICAgICAgZiA9IHRoaXMuZixcbiAgICAgICAgZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjIHx8IDFlLTEwO1xuICAgIHJldHVybiBfc2V0TWF0cml4KHRoaXMsIGQgLyBkZXRlcm1pbmFudCwgLWIgLyBkZXRlcm1pbmFudCwgLWMgLyBkZXRlcm1pbmFudCwgYSAvIGRldGVybWluYW50LCAoYyAqIGYgLSBkICogZSkgLyBkZXRlcm1pbmFudCwgLShhICogZiAtIGIgKiBlKSAvIGRldGVybWluYW50KTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtYXRyaXgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYyA9IHRoaXMuYyxcbiAgICAgICAgZCA9IHRoaXMuZCxcbiAgICAgICAgZSA9IHRoaXMuZSxcbiAgICAgICAgZiA9IHRoaXMuZixcbiAgICAgICAgYTIgPSBtYXRyaXguYSxcbiAgICAgICAgYjIgPSBtYXRyaXguYyxcbiAgICAgICAgYzIgPSBtYXRyaXguYixcbiAgICAgICAgZDIgPSBtYXRyaXguZCxcbiAgICAgICAgZTIgPSBtYXRyaXguZSxcbiAgICAgICAgZjIgPSBtYXRyaXguZjtcbiAgICByZXR1cm4gX3NldE1hdHJpeCh0aGlzLCBhMiAqIGEgKyBjMiAqIGMsIGEyICogYiArIGMyICogZCwgYjIgKiBhICsgZDIgKiBjLCBiMiAqIGIgKyBkMiAqIGQsIGUgKyBlMiAqIGEgKyBmMiAqIGMsIGYgKyBlMiAqIGIgKyBmMiAqIGQpO1xuICB9O1xuXG4gIF9wcm90by5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgTWF0cml4MkQodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLmUsIHRoaXMuZik7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhtYXRyaXgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYyA9IHRoaXMuYyxcbiAgICAgICAgZCA9IHRoaXMuZCxcbiAgICAgICAgZSA9IHRoaXMuZSxcbiAgICAgICAgZiA9IHRoaXMuZjtcbiAgICByZXR1cm4gYSA9PT0gbWF0cml4LmEgJiYgYiA9PT0gbWF0cml4LmIgJiYgYyA9PT0gbWF0cml4LmMgJiYgZCA9PT0gbWF0cml4LmQgJiYgZSA9PT0gbWF0cml4LmUgJiYgZiA9PT0gbWF0cml4LmY7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkocG9pbnQsIGRlY29yYXRlZSkge1xuICAgIGlmIChkZWNvcmF0ZWUgPT09IHZvaWQgMCkge1xuICAgICAgZGVjb3JhdGVlID0ge307XG4gICAgfVxuXG4gICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYyA9IHRoaXMuYyxcbiAgICAgICAgZCA9IHRoaXMuZCxcbiAgICAgICAgZSA9IHRoaXMuZSxcbiAgICAgICAgZiA9IHRoaXMuZjtcbiAgICBkZWNvcmF0ZWUueCA9IHggKiBhICsgeSAqIGMgKyBlIHx8IDA7XG4gICAgZGVjb3JhdGVlLnkgPSB4ICogYiArIHkgKiBkICsgZiB8fCAwO1xuICAgIHJldHVybiBkZWNvcmF0ZWU7XG4gIH07XG5cbiAgcmV0dXJuIE1hdHJpeDJEO1xufSgpOyAvLyBGZWVkIGluIGFuIGVsZW1lbnQgYW5kIGl0J2xsIHJldHVybiBhIDJEIG1hdHJpeCAob3B0aW9uYWxseSBpbnZlcnRlZCkgc28gdGhhdCB5b3UgY2FuIHRyYW5zbGF0ZSBiZXR3ZWVuIGNvb3JkaW5hdGUgc3BhY2VzLlxuLy8gSW52ZXJ0aW5nIGxldHMgeW91IHRyYW5zbGF0ZSBhIGdsb2JhbCBwb2ludCBpbnRvIGEgbG9jYWwgY29vcmRpbmF0ZSBzcGFjZS4gTm8gaW52ZXJ0aW5nIGxldHMgeW91IGdvIHRoZSBvdGhlciB3YXkuXG4vLyBXZSBuZWVkZWQgdGhpcyB0byB3b3JrIGFyb3VuZCB2YXJpb3VzIGJyb3dzZXIgYnVncywgbGlrZSBGaXJlZm94IGRvZXNuJ3QgYWNjdXJhdGVseSByZXBvcnQgZ2V0U2NyZWVuQ1RNKCkgd2hlbiB0aGVyZVxuLy8gYXJlIHRyYW5zZm9ybXMgYXBwbGllZCB0byBhbmNlc3RvciBlbGVtZW50cy5cbi8vIFRoZSBtYXRyaXggbWF0aCB0byBjb252ZXJ0IGFueSB4L3kgY29vcmRpbmF0ZSBpcyBhcyBmb2xsb3dzLCB3aGljaCBpcyB3cmFwcGVkIGluIGEgY29udmVuaWVudCBhcHBseSgpIG1ldGhvZCBvZiBNYXRyaXgyRCBhYm92ZTpcbi8vICAgICB0eCA9IG0uYSAqIHggKyBtLmMgKiB5ICsgbS5lXG4vLyAgICAgdHkgPSBtLmIgKiB4ICsgbS5kICogeSArIG0uZlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGludmVyc2UsIGFkanVzdEdPZmZzZXQsIGluY2x1ZGVTY3JvbGxJbkZpeGVkKSB7XG4gIC8vIGFkanVzdEdPZmZzZXQgaXMgdHlwaWNhbGx5IHVzZWQgb25seSB3aGVuIGdyYWJiaW5nIGFuIGVsZW1lbnQncyBQQVJFTlQncyBnbG9iYWwgbWF0cml4LCBhbmQgaXQgaWdub3JlcyB0aGUgeC95IG9mZnNldCBvZiBhbnkgU1ZHIDxnPiBlbGVtZW50cyBiZWNhdXNlIHRoZXkgYmVoYXZlIGluIGEgc3BlY2lhbCB3YXkuXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnROb2RlIHx8IChfZG9jIHx8IF9zZXREb2MoZWxlbWVudCkpLmRvY3VtZW50RWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgTWF0cml4MkQoKTtcbiAgfVxuXG4gIHZhciB6ZXJvU2NhbGVzID0gX2ZvcmNlTm9uWmVyb1NjYWxlKGVsZW1lbnQpLFxuICAgICAgc3ZnID0gX3N2Z093bmVyKGVsZW1lbnQpLFxuICAgICAgdGVtcHMgPSBzdmcgPyBfc3ZnVGVtcHMgOiBfZGl2VGVtcHMsXG4gICAgICBjb250YWluZXIgPSBfcGxhY2VTaWJsaW5ncyhlbGVtZW50LCBhZGp1c3RHT2Zmc2V0KSxcbiAgICAgIGIxID0gdGVtcHNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBiMiA9IHRlbXBzWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgYjMgPSB0ZW1wc1syXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlLFxuICAgICAgaXNGaXhlZCA9ICFpbmNsdWRlU2Nyb2xsSW5GaXhlZCAmJiBfaXNGaXhlZChlbGVtZW50KSxcbiAgICAgIG0gPSBuZXcgTWF0cml4MkQoKGIyLmxlZnQgLSBiMS5sZWZ0KSAvIDEwMCwgKGIyLnRvcCAtIGIxLnRvcCkgLyAxMDAsIChiMy5sZWZ0IC0gYjEubGVmdCkgLyAxMDAsIChiMy50b3AgLSBiMS50b3ApIC8gMTAwLCBiMS5sZWZ0ICsgKGlzRml4ZWQgPyAwIDogX2dldERvY1Njcm9sbExlZnQoKSksIGIxLnRvcCArIChpc0ZpeGVkID8gMCA6IF9nZXREb2NTY3JvbGxUb3AoKSkpO1xuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXG4gIGlmICh6ZXJvU2NhbGVzKSB7XG4gICAgYjEgPSB6ZXJvU2NhbGVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChiMS0tKSB7XG4gICAgICBiMiA9IHplcm9TY2FsZXNbYjFdO1xuICAgICAgYjIuc2NhbGVYID0gYjIuc2NhbGVZID0gMDtcbiAgICAgIGIyLnJlbmRlclRyYW5zZm9ybSgxLCBiMik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGludmVyc2UgPyBtLmludmVyc2UoKSA6IG07XG59XG5leHBvcnQgeyBfZ2V0RG9jU2Nyb2xsVG9wLCBfZ2V0RG9jU2Nyb2xsTGVmdCwgX3NldERvYywgX2lzRml4ZWQsIF9nZXRDVE0gfTsgLy8gZXhwb3J0IGZ1bmN0aW9uIGdldE1hdHJpeChlbGVtZW50KSB7XG4vLyBcdF9kb2MgfHwgX3NldERvYyhlbGVtZW50KTtcbi8vIFx0bGV0IG0gPSAoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW190cmFuc2Zvcm1Qcm9wXSArIFwiXCIpLnN1YnN0cig3KS5tYXRjaCgvWy0uXSpcXGQrWy5lXFwtK10qXFxkKltlXFwtXFwrXSpcXGQqL2cpLFxuLy8gXHRcdGlzMkQgPSBtICYmIG0ubGVuZ3RoID09PSA2O1xuLy8gXHRyZXR1cm4gIW0gfHwgbS5sZW5ndGggPCA2ID8gbmV3IE1hdHJpeDJEKCkgOiBuZXcgTWF0cml4MkQoK21bMF0sICttWzFdLCArbVtpczJEID8gMiA6IDRdLCArbVtpczJEID8gMyA6IDVdLCArbVtpczJEID8gNCA6IDEyXSwgK21baXMyRCA/IDUgOiAxM10pO1xuLy8gfSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/utils/matrix.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _assertThisInitialized)\n/* harmony export */ });\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzP2Q3NmUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _classCallCheck)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanM/YjQ4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _createClass)\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0M7QUFDL0M7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZEQUFhO0FBQy9DO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanM/YWMyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdG9Qcm9wZXJ0eUtleSBmcm9tIFwiLi90b1Byb3BlcnR5S2V5LmpzXCI7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCB0b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/createClass.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _getPrototypeOf)\n/* harmony export */ });\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZi5qcz9mMTMwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _inherits)\n/* harmony export */ });\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(subClass, superClass);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDbEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsOERBQWM7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanM/NWE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vc2V0UHJvdG90eXBlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/inherits.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _possibleConstructorReturn)\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(self);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDNkI7QUFDaEQ7QUFDZixlQUFlLHNEQUFPO0FBQ3RCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLHFFQUFxQjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzP2U5NGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5pbXBvcnQgYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _setPrototypeOf)\n/* harmony export */ });\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzP2EyM2YiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _toPrimitive)\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\nfunction _toPrimitive(input, hint) {\n  if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9QcmltaXRpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7QUFDbkI7QUFDZixNQUFNLHNEQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vUG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvUHJpbWl0aXZlLmpzP2I4MWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _toPropertyKey)\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\");\n\n\nfunction _toPropertyKey(arg) {\n  var key = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arg, \"string\");\n  return (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key) === \"symbol\" ? key : String(key);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Qcm9wZXJ0eUtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDUztBQUM1QjtBQUNmLFlBQVksMkRBQVc7QUFDdkIsU0FBUyxzREFBTztBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL1BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzP2UzM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5pbXBvcnQgdG9QcmltaXRpdmUgZnJvbSBcIi4vdG9QcmltaXRpdmUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _typeof)\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzPzZjZDIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIF90eXBlb2Yob2JqKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/typeof.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./source/js/app.js");
/******/ 	
/******/ })()
;